
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Entreprise
 * 
 */
export type Entreprise = $Result.DefaultSelection<Prisma.$EntreprisePayload>
/**
 * Model Utilisateur
 * 
 */
export type Utilisateur = $Result.DefaultSelection<Prisma.$UtilisateurPayload>
/**
 * Model Adresse
 * 
 */
export type Adresse = $Result.DefaultSelection<Prisma.$AdressePayload>
/**
 * Model Contact
 * 
 */
export type Contact = $Result.DefaultSelection<Prisma.$ContactPayload>
/**
 * Model Fournisseur
 * 
 */
export type Fournisseur = $Result.DefaultSelection<Prisma.$FournisseurPayload>
/**
 * Model Teneur
 * 
 */
export type Teneur = $Result.DefaultSelection<Prisma.$TeneurPayload>
/**
 * Model Devise
 * 
 */
export type Devise = $Result.DefaultSelection<Prisma.$DevisePayload>
/**
 * Model Produit
 * 
 */
export type Produit = $Result.DefaultSelection<Prisma.$ProduitPayload>
/**
 * Model Paiement
 * 
 */
export type Paiement = $Result.DefaultSelection<Prisma.$PaiementPayload>
/**
 * Model Caisse
 * 
 */
export type Caisse = $Result.DefaultSelection<Prisma.$CaissePayload>
/**
 * Model Vente
 * 
 */
export type Vente = $Result.DefaultSelection<Prisma.$VentePayload>
/**
 * Model Panier
 * 
 */
export type Panier = $Result.DefaultSelection<Prisma.$PanierPayload>
/**
 * Model DetailPanier
 * 
 */
export type DetailPanier = $Result.DefaultSelection<Prisma.$DetailPanierPayload>
/**
 * Model Achat
 * 
 */
export type Achat = $Result.DefaultSelection<Prisma.$AchatPayload>
/**
 * Model Reservation
 * 
 */
export type Reservation = $Result.DefaultSelection<Prisma.$ReservationPayload>
/**
 * Model Commande
 * 
 */
export type Commande = $Result.DefaultSelection<Prisma.$CommandePayload>
/**
 * Model MouvementCaisse
 * 
 */
export type MouvementCaisse = $Result.DefaultSelection<Prisma.$MouvementCaissePayload>
/**
 * Model DetailClotureCaisse
 * 
 */
export type DetailClotureCaisse = $Result.DefaultSelection<Prisma.$DetailClotureCaissePayload>
/**
 * Model ClotureCaisse
 * 
 */
export type ClotureCaisse = $Result.DefaultSelection<Prisma.$ClotureCaissePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  admin: 'admin',
  client: 'client',
  agent: 'agent'
};

export type Role = (typeof Role)[keyof typeof Role]


export const Poste: {
  directeur: 'directeur',
  secretaire: 'secretaire',
  caissier: 'caissier',
  gerant: 'gerant'
};

export type Poste = (typeof Poste)[keyof typeof Poste]


export const Sexe: {
  homme: 'homme',
  femme: 'femme'
};

export type Sexe = (typeof Sexe)[keyof typeof Sexe]


export const MoyenPaiment: {
  cache: 'cache',
  banque: 'banque',
  mobile: 'mobile',
  cheque: 'cheque',
  autres: 'autres'
};

export type MoyenPaiment = (typeof MoyenPaiment)[keyof typeof MoyenPaiment]


export const StatutAchat: {
  EN_COURS: 'EN_COURS',
  TERMINE: 'TERMINE',
  ANNULE: 'ANNULE'
};

export type StatutAchat = (typeof StatutAchat)[keyof typeof StatutAchat]


export const StatutVente: {
  EN_ATTENTE: 'EN_ATTENTE',
  CONFIRME: 'CONFIRME',
  REMBOURSE: 'REMBOURSE',
  ANNULE: 'ANNULE'
};

export type StatutVente = (typeof StatutVente)[keyof typeof StatutVente]


export const TypeClient: {
  ordinaire: 'ordinaire',
  nouveau: 'nouveau',
  client: 'client',
  fournisseur: 'fournisseur',
  agent: 'agent'
};

export type TypeClient = (typeof TypeClient)[keyof typeof TypeClient]


export const StatutReservation: {
  EN_ATTENTE: 'EN_ATTENTE',
  CONFIRMEE: 'CONFIRMEE',
  ANNULEE: 'ANNULEE',
  REJETEE: 'REJETEE',
  CONVERTIE: 'CONVERTIE'
};

export type StatutReservation = (typeof StatutReservation)[keyof typeof StatutReservation]


export const StatutCommande: {
  EN_ATTENTE_PAIEMENT: 'EN_ATTENTE_PAIEMENT',
  PAIDEE: 'PAIDEE',
  EN_PREPARATION: 'EN_PREPARATION',
  EN_LIVRAISON: 'EN_LIVRAISON',
  LIVREE: 'LIVREE',
  ANNULEE: 'ANNULEE',
  REMBOURSEE: 'REMBOURSEE',
  ECHEC_PAIEMENT: 'ECHEC_PAIEMENT'
};

export type StatutCommande = (typeof StatutCommande)[keyof typeof StatutCommande]


export const TypeMouvementCaisse: {
  ENTREE: 'ENTREE',
  SORTIE: 'SORTIE'
};

export type TypeMouvementCaisse = (typeof TypeMouvementCaisse)[keyof typeof TypeMouvementCaisse]


export const StatutCaisse: {
  OUVERTE: 'OUVERTE',
  FERMEE: 'FERMEE',
  EN_ATTENTE: 'EN_ATTENTE'
};

export type StatutCaisse = (typeof StatutCaisse)[keyof typeof StatutCaisse]


export const CategorieMouvement: {
  ACHAT: 'ACHAT',
  VENTE: 'VENTE',
  FOURNISSEUR: 'FOURNISSEUR',
  SALAIRE: 'SALAIRE',
  LOYER: 'LOYER',
  EMPRUNT: 'EMPRUNT',
  TAXE: 'TAXE',
  AUTRES: 'AUTRES'
};

export type CategorieMouvement = (typeof CategorieMouvement)[keyof typeof CategorieMouvement]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type Poste = $Enums.Poste

export const Poste: typeof $Enums.Poste

export type Sexe = $Enums.Sexe

export const Sexe: typeof $Enums.Sexe

export type MoyenPaiment = $Enums.MoyenPaiment

export const MoyenPaiment: typeof $Enums.MoyenPaiment

export type StatutAchat = $Enums.StatutAchat

export const StatutAchat: typeof $Enums.StatutAchat

export type StatutVente = $Enums.StatutVente

export const StatutVente: typeof $Enums.StatutVente

export type TypeClient = $Enums.TypeClient

export const TypeClient: typeof $Enums.TypeClient

export type StatutReservation = $Enums.StatutReservation

export const StatutReservation: typeof $Enums.StatutReservation

export type StatutCommande = $Enums.StatutCommande

export const StatutCommande: typeof $Enums.StatutCommande

export type TypeMouvementCaisse = $Enums.TypeMouvementCaisse

export const TypeMouvementCaisse: typeof $Enums.TypeMouvementCaisse

export type StatutCaisse = $Enums.StatutCaisse

export const StatutCaisse: typeof $Enums.StatutCaisse

export type CategorieMouvement = $Enums.CategorieMouvement

export const CategorieMouvement: typeof $Enums.CategorieMouvement

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Entreprises
 * const entreprises = await prisma.entreprise.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Entreprises
   * const entreprises = await prisma.entreprise.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.entreprise`: Exposes CRUD operations for the **Entreprise** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Entreprises
    * const entreprises = await prisma.entreprise.findMany()
    * ```
    */
  get entreprise(): Prisma.EntrepriseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.utilisateur`: Exposes CRUD operations for the **Utilisateur** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Utilisateurs
    * const utilisateurs = await prisma.utilisateur.findMany()
    * ```
    */
  get utilisateur(): Prisma.UtilisateurDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.adresse`: Exposes CRUD operations for the **Adresse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Adresses
    * const adresses = await prisma.adresse.findMany()
    * ```
    */
  get adresse(): Prisma.AdresseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contact`: Exposes CRUD operations for the **Contact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contacts
    * const contacts = await prisma.contact.findMany()
    * ```
    */
  get contact(): Prisma.ContactDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fournisseur`: Exposes CRUD operations for the **Fournisseur** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Fournisseurs
    * const fournisseurs = await prisma.fournisseur.findMany()
    * ```
    */
  get fournisseur(): Prisma.FournisseurDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.teneur`: Exposes CRUD operations for the **Teneur** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teneurs
    * const teneurs = await prisma.teneur.findMany()
    * ```
    */
  get teneur(): Prisma.TeneurDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.devise`: Exposes CRUD operations for the **Devise** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Devises
    * const devises = await prisma.devise.findMany()
    * ```
    */
  get devise(): Prisma.DeviseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.produit`: Exposes CRUD operations for the **Produit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Produits
    * const produits = await prisma.produit.findMany()
    * ```
    */
  get produit(): Prisma.ProduitDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.paiement`: Exposes CRUD operations for the **Paiement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Paiements
    * const paiements = await prisma.paiement.findMany()
    * ```
    */
  get paiement(): Prisma.PaiementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.caisse`: Exposes CRUD operations for the **Caisse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Caisses
    * const caisses = await prisma.caisse.findMany()
    * ```
    */
  get caisse(): Prisma.CaisseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vente`: Exposes CRUD operations for the **Vente** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ventes
    * const ventes = await prisma.vente.findMany()
    * ```
    */
  get vente(): Prisma.VenteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.panier`: Exposes CRUD operations for the **Panier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Paniers
    * const paniers = await prisma.panier.findMany()
    * ```
    */
  get panier(): Prisma.PanierDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.detailPanier`: Exposes CRUD operations for the **DetailPanier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DetailPaniers
    * const detailPaniers = await prisma.detailPanier.findMany()
    * ```
    */
  get detailPanier(): Prisma.DetailPanierDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.achat`: Exposes CRUD operations for the **Achat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Achats
    * const achats = await prisma.achat.findMany()
    * ```
    */
  get achat(): Prisma.AchatDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reservation`: Exposes CRUD operations for the **Reservation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reservations
    * const reservations = await prisma.reservation.findMany()
    * ```
    */
  get reservation(): Prisma.ReservationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.commande`: Exposes CRUD operations for the **Commande** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Commandes
    * const commandes = await prisma.commande.findMany()
    * ```
    */
  get commande(): Prisma.CommandeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mouvementCaisse`: Exposes CRUD operations for the **MouvementCaisse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MouvementCaisses
    * const mouvementCaisses = await prisma.mouvementCaisse.findMany()
    * ```
    */
  get mouvementCaisse(): Prisma.MouvementCaisseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.detailClotureCaisse`: Exposes CRUD operations for the **DetailClotureCaisse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DetailClotureCaisses
    * const detailClotureCaisses = await prisma.detailClotureCaisse.findMany()
    * ```
    */
  get detailClotureCaisse(): Prisma.DetailClotureCaisseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.clotureCaisse`: Exposes CRUD operations for the **ClotureCaisse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClotureCaisses
    * const clotureCaisses = await prisma.clotureCaisse.findMany()
    * ```
    */
  get clotureCaisse(): Prisma.ClotureCaisseDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.8.2
   * Query Engine version: 2060c79ba17c6bb9f5823312b6f6b7f4a845738e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Entreprise: 'Entreprise',
    Utilisateur: 'Utilisateur',
    Adresse: 'Adresse',
    Contact: 'Contact',
    Fournisseur: 'Fournisseur',
    Teneur: 'Teneur',
    Devise: 'Devise',
    Produit: 'Produit',
    Paiement: 'Paiement',
    Caisse: 'Caisse',
    Vente: 'Vente',
    Panier: 'Panier',
    DetailPanier: 'DetailPanier',
    Achat: 'Achat',
    Reservation: 'Reservation',
    Commande: 'Commande',
    MouvementCaisse: 'MouvementCaisse',
    DetailClotureCaisse: 'DetailClotureCaisse',
    ClotureCaisse: 'ClotureCaisse'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "entreprise" | "utilisateur" | "adresse" | "contact" | "fournisseur" | "teneur" | "devise" | "produit" | "paiement" | "caisse" | "vente" | "panier" | "detailPanier" | "achat" | "reservation" | "commande" | "mouvementCaisse" | "detailClotureCaisse" | "clotureCaisse"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Entreprise: {
        payload: Prisma.$EntreprisePayload<ExtArgs>
        fields: Prisma.EntrepriseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EntrepriseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntreprisePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EntrepriseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntreprisePayload>
          }
          findFirst: {
            args: Prisma.EntrepriseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntreprisePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EntrepriseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntreprisePayload>
          }
          findMany: {
            args: Prisma.EntrepriseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntreprisePayload>[]
          }
          create: {
            args: Prisma.EntrepriseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntreprisePayload>
          }
          createMany: {
            args: Prisma.EntrepriseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EntrepriseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntreprisePayload>[]
          }
          delete: {
            args: Prisma.EntrepriseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntreprisePayload>
          }
          update: {
            args: Prisma.EntrepriseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntreprisePayload>
          }
          deleteMany: {
            args: Prisma.EntrepriseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EntrepriseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EntrepriseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntreprisePayload>[]
          }
          upsert: {
            args: Prisma.EntrepriseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntreprisePayload>
          }
          aggregate: {
            args: Prisma.EntrepriseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEntreprise>
          }
          groupBy: {
            args: Prisma.EntrepriseGroupByArgs<ExtArgs>
            result: $Utils.Optional<EntrepriseGroupByOutputType>[]
          }
          count: {
            args: Prisma.EntrepriseCountArgs<ExtArgs>
            result: $Utils.Optional<EntrepriseCountAggregateOutputType> | number
          }
        }
      }
      Utilisateur: {
        payload: Prisma.$UtilisateurPayload<ExtArgs>
        fields: Prisma.UtilisateurFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UtilisateurFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UtilisateurPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UtilisateurFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UtilisateurPayload>
          }
          findFirst: {
            args: Prisma.UtilisateurFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UtilisateurPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UtilisateurFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UtilisateurPayload>
          }
          findMany: {
            args: Prisma.UtilisateurFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UtilisateurPayload>[]
          }
          create: {
            args: Prisma.UtilisateurCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UtilisateurPayload>
          }
          createMany: {
            args: Prisma.UtilisateurCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UtilisateurCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UtilisateurPayload>[]
          }
          delete: {
            args: Prisma.UtilisateurDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UtilisateurPayload>
          }
          update: {
            args: Prisma.UtilisateurUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UtilisateurPayload>
          }
          deleteMany: {
            args: Prisma.UtilisateurDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UtilisateurUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UtilisateurUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UtilisateurPayload>[]
          }
          upsert: {
            args: Prisma.UtilisateurUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UtilisateurPayload>
          }
          aggregate: {
            args: Prisma.UtilisateurAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUtilisateur>
          }
          groupBy: {
            args: Prisma.UtilisateurGroupByArgs<ExtArgs>
            result: $Utils.Optional<UtilisateurGroupByOutputType>[]
          }
          count: {
            args: Prisma.UtilisateurCountArgs<ExtArgs>
            result: $Utils.Optional<UtilisateurCountAggregateOutputType> | number
          }
        }
      }
      Adresse: {
        payload: Prisma.$AdressePayload<ExtArgs>
        fields: Prisma.AdresseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdresseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdressePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdresseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdressePayload>
          }
          findFirst: {
            args: Prisma.AdresseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdressePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdresseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdressePayload>
          }
          findMany: {
            args: Prisma.AdresseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdressePayload>[]
          }
          create: {
            args: Prisma.AdresseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdressePayload>
          }
          createMany: {
            args: Prisma.AdresseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdresseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdressePayload>[]
          }
          delete: {
            args: Prisma.AdresseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdressePayload>
          }
          update: {
            args: Prisma.AdresseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdressePayload>
          }
          deleteMany: {
            args: Prisma.AdresseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdresseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdresseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdressePayload>[]
          }
          upsert: {
            args: Prisma.AdresseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdressePayload>
          }
          aggregate: {
            args: Prisma.AdresseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdresse>
          }
          groupBy: {
            args: Prisma.AdresseGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdresseGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdresseCountArgs<ExtArgs>
            result: $Utils.Optional<AdresseCountAggregateOutputType> | number
          }
        }
      }
      Contact: {
        payload: Prisma.$ContactPayload<ExtArgs>
        fields: Prisma.ContactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          findFirst: {
            args: Prisma.ContactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          findMany: {
            args: Prisma.ContactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          create: {
            args: Prisma.ContactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          createMany: {
            args: Prisma.ContactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContactCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          delete: {
            args: Prisma.ContactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          update: {
            args: Prisma.ContactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          deleteMany: {
            args: Prisma.ContactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContactUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          upsert: {
            args: Prisma.ContactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          aggregate: {
            args: Prisma.ContactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContact>
          }
          groupBy: {
            args: Prisma.ContactGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactCountArgs<ExtArgs>
            result: $Utils.Optional<ContactCountAggregateOutputType> | number
          }
        }
      }
      Fournisseur: {
        payload: Prisma.$FournisseurPayload<ExtArgs>
        fields: Prisma.FournisseurFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FournisseurFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FournisseurPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FournisseurFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FournisseurPayload>
          }
          findFirst: {
            args: Prisma.FournisseurFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FournisseurPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FournisseurFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FournisseurPayload>
          }
          findMany: {
            args: Prisma.FournisseurFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FournisseurPayload>[]
          }
          create: {
            args: Prisma.FournisseurCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FournisseurPayload>
          }
          createMany: {
            args: Prisma.FournisseurCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FournisseurCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FournisseurPayload>[]
          }
          delete: {
            args: Prisma.FournisseurDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FournisseurPayload>
          }
          update: {
            args: Prisma.FournisseurUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FournisseurPayload>
          }
          deleteMany: {
            args: Prisma.FournisseurDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FournisseurUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FournisseurUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FournisseurPayload>[]
          }
          upsert: {
            args: Prisma.FournisseurUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FournisseurPayload>
          }
          aggregate: {
            args: Prisma.FournisseurAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFournisseur>
          }
          groupBy: {
            args: Prisma.FournisseurGroupByArgs<ExtArgs>
            result: $Utils.Optional<FournisseurGroupByOutputType>[]
          }
          count: {
            args: Prisma.FournisseurCountArgs<ExtArgs>
            result: $Utils.Optional<FournisseurCountAggregateOutputType> | number
          }
        }
      }
      Teneur: {
        payload: Prisma.$TeneurPayload<ExtArgs>
        fields: Prisma.TeneurFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeneurFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeneurPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeneurFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeneurPayload>
          }
          findFirst: {
            args: Prisma.TeneurFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeneurPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeneurFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeneurPayload>
          }
          findMany: {
            args: Prisma.TeneurFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeneurPayload>[]
          }
          create: {
            args: Prisma.TeneurCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeneurPayload>
          }
          createMany: {
            args: Prisma.TeneurCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeneurCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeneurPayload>[]
          }
          delete: {
            args: Prisma.TeneurDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeneurPayload>
          }
          update: {
            args: Prisma.TeneurUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeneurPayload>
          }
          deleteMany: {
            args: Prisma.TeneurDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeneurUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TeneurUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeneurPayload>[]
          }
          upsert: {
            args: Prisma.TeneurUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeneurPayload>
          }
          aggregate: {
            args: Prisma.TeneurAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeneur>
          }
          groupBy: {
            args: Prisma.TeneurGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeneurGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeneurCountArgs<ExtArgs>
            result: $Utils.Optional<TeneurCountAggregateOutputType> | number
          }
        }
      }
      Devise: {
        payload: Prisma.$DevisePayload<ExtArgs>
        fields: Prisma.DeviseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeviseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevisePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeviseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevisePayload>
          }
          findFirst: {
            args: Prisma.DeviseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevisePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeviseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevisePayload>
          }
          findMany: {
            args: Prisma.DeviseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevisePayload>[]
          }
          create: {
            args: Prisma.DeviseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevisePayload>
          }
          createMany: {
            args: Prisma.DeviseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeviseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevisePayload>[]
          }
          delete: {
            args: Prisma.DeviseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevisePayload>
          }
          update: {
            args: Prisma.DeviseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevisePayload>
          }
          deleteMany: {
            args: Prisma.DeviseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeviseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DeviseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevisePayload>[]
          }
          upsert: {
            args: Prisma.DeviseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevisePayload>
          }
          aggregate: {
            args: Prisma.DeviseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDevise>
          }
          groupBy: {
            args: Prisma.DeviseGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeviseGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeviseCountArgs<ExtArgs>
            result: $Utils.Optional<DeviseCountAggregateOutputType> | number
          }
        }
      }
      Produit: {
        payload: Prisma.$ProduitPayload<ExtArgs>
        fields: Prisma.ProduitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProduitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProduitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProduitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProduitPayload>
          }
          findFirst: {
            args: Prisma.ProduitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProduitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProduitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProduitPayload>
          }
          findMany: {
            args: Prisma.ProduitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProduitPayload>[]
          }
          create: {
            args: Prisma.ProduitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProduitPayload>
          }
          createMany: {
            args: Prisma.ProduitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProduitCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProduitPayload>[]
          }
          delete: {
            args: Prisma.ProduitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProduitPayload>
          }
          update: {
            args: Prisma.ProduitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProduitPayload>
          }
          deleteMany: {
            args: Prisma.ProduitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProduitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProduitUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProduitPayload>[]
          }
          upsert: {
            args: Prisma.ProduitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProduitPayload>
          }
          aggregate: {
            args: Prisma.ProduitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduit>
          }
          groupBy: {
            args: Prisma.ProduitGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProduitGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProduitCountArgs<ExtArgs>
            result: $Utils.Optional<ProduitCountAggregateOutputType> | number
          }
        }
      }
      Paiement: {
        payload: Prisma.$PaiementPayload<ExtArgs>
        fields: Prisma.PaiementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaiementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaiementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaiementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaiementPayload>
          }
          findFirst: {
            args: Prisma.PaiementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaiementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaiementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaiementPayload>
          }
          findMany: {
            args: Prisma.PaiementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaiementPayload>[]
          }
          create: {
            args: Prisma.PaiementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaiementPayload>
          }
          createMany: {
            args: Prisma.PaiementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaiementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaiementPayload>[]
          }
          delete: {
            args: Prisma.PaiementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaiementPayload>
          }
          update: {
            args: Prisma.PaiementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaiementPayload>
          }
          deleteMany: {
            args: Prisma.PaiementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaiementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaiementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaiementPayload>[]
          }
          upsert: {
            args: Prisma.PaiementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaiementPayload>
          }
          aggregate: {
            args: Prisma.PaiementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaiement>
          }
          groupBy: {
            args: Prisma.PaiementGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaiementGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaiementCountArgs<ExtArgs>
            result: $Utils.Optional<PaiementCountAggregateOutputType> | number
          }
        }
      }
      Caisse: {
        payload: Prisma.$CaissePayload<ExtArgs>
        fields: Prisma.CaisseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CaisseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaissePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CaisseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaissePayload>
          }
          findFirst: {
            args: Prisma.CaisseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaissePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CaisseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaissePayload>
          }
          findMany: {
            args: Prisma.CaisseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaissePayload>[]
          }
          create: {
            args: Prisma.CaisseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaissePayload>
          }
          createMany: {
            args: Prisma.CaisseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CaisseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaissePayload>[]
          }
          delete: {
            args: Prisma.CaisseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaissePayload>
          }
          update: {
            args: Prisma.CaisseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaissePayload>
          }
          deleteMany: {
            args: Prisma.CaisseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CaisseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CaisseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaissePayload>[]
          }
          upsert: {
            args: Prisma.CaisseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaissePayload>
          }
          aggregate: {
            args: Prisma.CaisseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCaisse>
          }
          groupBy: {
            args: Prisma.CaisseGroupByArgs<ExtArgs>
            result: $Utils.Optional<CaisseGroupByOutputType>[]
          }
          count: {
            args: Prisma.CaisseCountArgs<ExtArgs>
            result: $Utils.Optional<CaisseCountAggregateOutputType> | number
          }
        }
      }
      Vente: {
        payload: Prisma.$VentePayload<ExtArgs>
        fields: Prisma.VenteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VenteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VenteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentePayload>
          }
          findFirst: {
            args: Prisma.VenteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VenteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentePayload>
          }
          findMany: {
            args: Prisma.VenteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentePayload>[]
          }
          create: {
            args: Prisma.VenteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentePayload>
          }
          createMany: {
            args: Prisma.VenteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VenteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentePayload>[]
          }
          delete: {
            args: Prisma.VenteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentePayload>
          }
          update: {
            args: Prisma.VenteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentePayload>
          }
          deleteMany: {
            args: Prisma.VenteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VenteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VenteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentePayload>[]
          }
          upsert: {
            args: Prisma.VenteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentePayload>
          }
          aggregate: {
            args: Prisma.VenteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVente>
          }
          groupBy: {
            args: Prisma.VenteGroupByArgs<ExtArgs>
            result: $Utils.Optional<VenteGroupByOutputType>[]
          }
          count: {
            args: Prisma.VenteCountArgs<ExtArgs>
            result: $Utils.Optional<VenteCountAggregateOutputType> | number
          }
        }
      }
      Panier: {
        payload: Prisma.$PanierPayload<ExtArgs>
        fields: Prisma.PanierFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PanierFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PanierPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PanierFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PanierPayload>
          }
          findFirst: {
            args: Prisma.PanierFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PanierPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PanierFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PanierPayload>
          }
          findMany: {
            args: Prisma.PanierFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PanierPayload>[]
          }
          create: {
            args: Prisma.PanierCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PanierPayload>
          }
          createMany: {
            args: Prisma.PanierCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PanierCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PanierPayload>[]
          }
          delete: {
            args: Prisma.PanierDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PanierPayload>
          }
          update: {
            args: Prisma.PanierUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PanierPayload>
          }
          deleteMany: {
            args: Prisma.PanierDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PanierUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PanierUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PanierPayload>[]
          }
          upsert: {
            args: Prisma.PanierUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PanierPayload>
          }
          aggregate: {
            args: Prisma.PanierAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePanier>
          }
          groupBy: {
            args: Prisma.PanierGroupByArgs<ExtArgs>
            result: $Utils.Optional<PanierGroupByOutputType>[]
          }
          count: {
            args: Prisma.PanierCountArgs<ExtArgs>
            result: $Utils.Optional<PanierCountAggregateOutputType> | number
          }
        }
      }
      DetailPanier: {
        payload: Prisma.$DetailPanierPayload<ExtArgs>
        fields: Prisma.DetailPanierFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DetailPanierFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetailPanierPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DetailPanierFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetailPanierPayload>
          }
          findFirst: {
            args: Prisma.DetailPanierFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetailPanierPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DetailPanierFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetailPanierPayload>
          }
          findMany: {
            args: Prisma.DetailPanierFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetailPanierPayload>[]
          }
          create: {
            args: Prisma.DetailPanierCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetailPanierPayload>
          }
          createMany: {
            args: Prisma.DetailPanierCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DetailPanierCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetailPanierPayload>[]
          }
          delete: {
            args: Prisma.DetailPanierDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetailPanierPayload>
          }
          update: {
            args: Prisma.DetailPanierUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetailPanierPayload>
          }
          deleteMany: {
            args: Prisma.DetailPanierDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DetailPanierUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DetailPanierUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetailPanierPayload>[]
          }
          upsert: {
            args: Prisma.DetailPanierUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetailPanierPayload>
          }
          aggregate: {
            args: Prisma.DetailPanierAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDetailPanier>
          }
          groupBy: {
            args: Prisma.DetailPanierGroupByArgs<ExtArgs>
            result: $Utils.Optional<DetailPanierGroupByOutputType>[]
          }
          count: {
            args: Prisma.DetailPanierCountArgs<ExtArgs>
            result: $Utils.Optional<DetailPanierCountAggregateOutputType> | number
          }
        }
      }
      Achat: {
        payload: Prisma.$AchatPayload<ExtArgs>
        fields: Prisma.AchatFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AchatFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchatPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AchatFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchatPayload>
          }
          findFirst: {
            args: Prisma.AchatFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchatPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AchatFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchatPayload>
          }
          findMany: {
            args: Prisma.AchatFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchatPayload>[]
          }
          create: {
            args: Prisma.AchatCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchatPayload>
          }
          createMany: {
            args: Prisma.AchatCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AchatCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchatPayload>[]
          }
          delete: {
            args: Prisma.AchatDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchatPayload>
          }
          update: {
            args: Prisma.AchatUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchatPayload>
          }
          deleteMany: {
            args: Prisma.AchatDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AchatUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AchatUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchatPayload>[]
          }
          upsert: {
            args: Prisma.AchatUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchatPayload>
          }
          aggregate: {
            args: Prisma.AchatAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAchat>
          }
          groupBy: {
            args: Prisma.AchatGroupByArgs<ExtArgs>
            result: $Utils.Optional<AchatGroupByOutputType>[]
          }
          count: {
            args: Prisma.AchatCountArgs<ExtArgs>
            result: $Utils.Optional<AchatCountAggregateOutputType> | number
          }
        }
      }
      Reservation: {
        payload: Prisma.$ReservationPayload<ExtArgs>
        fields: Prisma.ReservationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReservationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReservationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>
          }
          findFirst: {
            args: Prisma.ReservationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReservationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>
          }
          findMany: {
            args: Prisma.ReservationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>[]
          }
          create: {
            args: Prisma.ReservationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>
          }
          createMany: {
            args: Prisma.ReservationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReservationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>[]
          }
          delete: {
            args: Prisma.ReservationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>
          }
          update: {
            args: Prisma.ReservationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>
          }
          deleteMany: {
            args: Prisma.ReservationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReservationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReservationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>[]
          }
          upsert: {
            args: Prisma.ReservationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>
          }
          aggregate: {
            args: Prisma.ReservationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReservation>
          }
          groupBy: {
            args: Prisma.ReservationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReservationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReservationCountArgs<ExtArgs>
            result: $Utils.Optional<ReservationCountAggregateOutputType> | number
          }
        }
      }
      Commande: {
        payload: Prisma.$CommandePayload<ExtArgs>
        fields: Prisma.CommandeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommandeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommandeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandePayload>
          }
          findFirst: {
            args: Prisma.CommandeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommandeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandePayload>
          }
          findMany: {
            args: Prisma.CommandeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandePayload>[]
          }
          create: {
            args: Prisma.CommandeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandePayload>
          }
          createMany: {
            args: Prisma.CommandeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommandeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandePayload>[]
          }
          delete: {
            args: Prisma.CommandeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandePayload>
          }
          update: {
            args: Prisma.CommandeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandePayload>
          }
          deleteMany: {
            args: Prisma.CommandeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommandeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CommandeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandePayload>[]
          }
          upsert: {
            args: Prisma.CommandeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandePayload>
          }
          aggregate: {
            args: Prisma.CommandeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCommande>
          }
          groupBy: {
            args: Prisma.CommandeGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommandeGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommandeCountArgs<ExtArgs>
            result: $Utils.Optional<CommandeCountAggregateOutputType> | number
          }
        }
      }
      MouvementCaisse: {
        payload: Prisma.$MouvementCaissePayload<ExtArgs>
        fields: Prisma.MouvementCaisseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MouvementCaisseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MouvementCaissePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MouvementCaisseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MouvementCaissePayload>
          }
          findFirst: {
            args: Prisma.MouvementCaisseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MouvementCaissePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MouvementCaisseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MouvementCaissePayload>
          }
          findMany: {
            args: Prisma.MouvementCaisseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MouvementCaissePayload>[]
          }
          create: {
            args: Prisma.MouvementCaisseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MouvementCaissePayload>
          }
          createMany: {
            args: Prisma.MouvementCaisseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MouvementCaisseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MouvementCaissePayload>[]
          }
          delete: {
            args: Prisma.MouvementCaisseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MouvementCaissePayload>
          }
          update: {
            args: Prisma.MouvementCaisseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MouvementCaissePayload>
          }
          deleteMany: {
            args: Prisma.MouvementCaisseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MouvementCaisseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MouvementCaisseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MouvementCaissePayload>[]
          }
          upsert: {
            args: Prisma.MouvementCaisseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MouvementCaissePayload>
          }
          aggregate: {
            args: Prisma.MouvementCaisseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMouvementCaisse>
          }
          groupBy: {
            args: Prisma.MouvementCaisseGroupByArgs<ExtArgs>
            result: $Utils.Optional<MouvementCaisseGroupByOutputType>[]
          }
          count: {
            args: Prisma.MouvementCaisseCountArgs<ExtArgs>
            result: $Utils.Optional<MouvementCaisseCountAggregateOutputType> | number
          }
        }
      }
      DetailClotureCaisse: {
        payload: Prisma.$DetailClotureCaissePayload<ExtArgs>
        fields: Prisma.DetailClotureCaisseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DetailClotureCaisseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetailClotureCaissePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DetailClotureCaisseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetailClotureCaissePayload>
          }
          findFirst: {
            args: Prisma.DetailClotureCaisseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetailClotureCaissePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DetailClotureCaisseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetailClotureCaissePayload>
          }
          findMany: {
            args: Prisma.DetailClotureCaisseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetailClotureCaissePayload>[]
          }
          create: {
            args: Prisma.DetailClotureCaisseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetailClotureCaissePayload>
          }
          createMany: {
            args: Prisma.DetailClotureCaisseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DetailClotureCaisseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetailClotureCaissePayload>[]
          }
          delete: {
            args: Prisma.DetailClotureCaisseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetailClotureCaissePayload>
          }
          update: {
            args: Prisma.DetailClotureCaisseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetailClotureCaissePayload>
          }
          deleteMany: {
            args: Prisma.DetailClotureCaisseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DetailClotureCaisseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DetailClotureCaisseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetailClotureCaissePayload>[]
          }
          upsert: {
            args: Prisma.DetailClotureCaisseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetailClotureCaissePayload>
          }
          aggregate: {
            args: Prisma.DetailClotureCaisseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDetailClotureCaisse>
          }
          groupBy: {
            args: Prisma.DetailClotureCaisseGroupByArgs<ExtArgs>
            result: $Utils.Optional<DetailClotureCaisseGroupByOutputType>[]
          }
          count: {
            args: Prisma.DetailClotureCaisseCountArgs<ExtArgs>
            result: $Utils.Optional<DetailClotureCaisseCountAggregateOutputType> | number
          }
        }
      }
      ClotureCaisse: {
        payload: Prisma.$ClotureCaissePayload<ExtArgs>
        fields: Prisma.ClotureCaisseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClotureCaisseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClotureCaissePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClotureCaisseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClotureCaissePayload>
          }
          findFirst: {
            args: Prisma.ClotureCaisseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClotureCaissePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClotureCaisseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClotureCaissePayload>
          }
          findMany: {
            args: Prisma.ClotureCaisseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClotureCaissePayload>[]
          }
          create: {
            args: Prisma.ClotureCaisseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClotureCaissePayload>
          }
          createMany: {
            args: Prisma.ClotureCaisseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClotureCaisseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClotureCaissePayload>[]
          }
          delete: {
            args: Prisma.ClotureCaisseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClotureCaissePayload>
          }
          update: {
            args: Prisma.ClotureCaisseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClotureCaissePayload>
          }
          deleteMany: {
            args: Prisma.ClotureCaisseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClotureCaisseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClotureCaisseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClotureCaissePayload>[]
          }
          upsert: {
            args: Prisma.ClotureCaisseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClotureCaissePayload>
          }
          aggregate: {
            args: Prisma.ClotureCaisseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClotureCaisse>
          }
          groupBy: {
            args: Prisma.ClotureCaisseGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClotureCaisseGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClotureCaisseCountArgs<ExtArgs>
            result: $Utils.Optional<ClotureCaisseCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    entreprise?: EntrepriseOmit
    utilisateur?: UtilisateurOmit
    adresse?: AdresseOmit
    contact?: ContactOmit
    fournisseur?: FournisseurOmit
    teneur?: TeneurOmit
    devise?: DeviseOmit
    produit?: ProduitOmit
    paiement?: PaiementOmit
    caisse?: CaisseOmit
    vente?: VenteOmit
    panier?: PanierOmit
    detailPanier?: DetailPanierOmit
    achat?: AchatOmit
    reservation?: ReservationOmit
    commande?: CommandeOmit
    mouvementCaisse?: MouvementCaisseOmit
    detailClotureCaisse?: DetailClotureCaisseOmit
    clotureCaisse?: ClotureCaisseOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UtilisateurCountOutputType
   */

  export type UtilisateurCountOutputType = {
    Adresse: number
    Contact: number
    Produit: number
    Vente: number
    Achat: number
    Teneur: number
    Devise: number
    Panier: number
    Reservation: number
    Commande: number
    Caisse: number
    MouvementCaisse: number
    ClotureCaisse: number
  }

  export type UtilisateurCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Adresse?: boolean | UtilisateurCountOutputTypeCountAdresseArgs
    Contact?: boolean | UtilisateurCountOutputTypeCountContactArgs
    Produit?: boolean | UtilisateurCountOutputTypeCountProduitArgs
    Vente?: boolean | UtilisateurCountOutputTypeCountVenteArgs
    Achat?: boolean | UtilisateurCountOutputTypeCountAchatArgs
    Teneur?: boolean | UtilisateurCountOutputTypeCountTeneurArgs
    Devise?: boolean | UtilisateurCountOutputTypeCountDeviseArgs
    Panier?: boolean | UtilisateurCountOutputTypeCountPanierArgs
    Reservation?: boolean | UtilisateurCountOutputTypeCountReservationArgs
    Commande?: boolean | UtilisateurCountOutputTypeCountCommandeArgs
    Caisse?: boolean | UtilisateurCountOutputTypeCountCaisseArgs
    MouvementCaisse?: boolean | UtilisateurCountOutputTypeCountMouvementCaisseArgs
    ClotureCaisse?: boolean | UtilisateurCountOutputTypeCountClotureCaisseArgs
  }

  // Custom InputTypes
  /**
   * UtilisateurCountOutputType without action
   */
  export type UtilisateurCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UtilisateurCountOutputType
     */
    select?: UtilisateurCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UtilisateurCountOutputType without action
   */
  export type UtilisateurCountOutputTypeCountAdresseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdresseWhereInput
  }

  /**
   * UtilisateurCountOutputType without action
   */
  export type UtilisateurCountOutputTypeCountContactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
  }

  /**
   * UtilisateurCountOutputType without action
   */
  export type UtilisateurCountOutputTypeCountProduitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProduitWhereInput
  }

  /**
   * UtilisateurCountOutputType without action
   */
  export type UtilisateurCountOutputTypeCountVenteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VenteWhereInput
  }

  /**
   * UtilisateurCountOutputType without action
   */
  export type UtilisateurCountOutputTypeCountAchatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AchatWhereInput
  }

  /**
   * UtilisateurCountOutputType without action
   */
  export type UtilisateurCountOutputTypeCountTeneurArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeneurWhereInput
  }

  /**
   * UtilisateurCountOutputType without action
   */
  export type UtilisateurCountOutputTypeCountDeviseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviseWhereInput
  }

  /**
   * UtilisateurCountOutputType without action
   */
  export type UtilisateurCountOutputTypeCountPanierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PanierWhereInput
  }

  /**
   * UtilisateurCountOutputType without action
   */
  export type UtilisateurCountOutputTypeCountReservationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReservationWhereInput
  }

  /**
   * UtilisateurCountOutputType without action
   */
  export type UtilisateurCountOutputTypeCountCommandeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommandeWhereInput
  }

  /**
   * UtilisateurCountOutputType without action
   */
  export type UtilisateurCountOutputTypeCountCaisseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CaisseWhereInput
  }

  /**
   * UtilisateurCountOutputType without action
   */
  export type UtilisateurCountOutputTypeCountMouvementCaisseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MouvementCaisseWhereInput
  }

  /**
   * UtilisateurCountOutputType without action
   */
  export type UtilisateurCountOutputTypeCountClotureCaisseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClotureCaisseWhereInput
  }


  /**
   * Count Type AdresseCountOutputType
   */

  export type AdresseCountOutputType = {
    Reservation: number
    Commande: number
  }

  export type AdresseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Reservation?: boolean | AdresseCountOutputTypeCountReservationArgs
    Commande?: boolean | AdresseCountOutputTypeCountCommandeArgs
  }

  // Custom InputTypes
  /**
   * AdresseCountOutputType without action
   */
  export type AdresseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdresseCountOutputType
     */
    select?: AdresseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AdresseCountOutputType without action
   */
  export type AdresseCountOutputTypeCountReservationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReservationWhereInput
  }

  /**
   * AdresseCountOutputType without action
   */
  export type AdresseCountOutputTypeCountCommandeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommandeWhereInput
  }


  /**
   * Count Type ContactCountOutputType
   */

  export type ContactCountOutputType = {
    Reservation: number
    Commande: number
  }

  export type ContactCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Reservation?: boolean | ContactCountOutputTypeCountReservationArgs
    Commande?: boolean | ContactCountOutputTypeCountCommandeArgs
  }

  // Custom InputTypes
  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactCountOutputType
     */
    select?: ContactCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeCountReservationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReservationWhereInput
  }

  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeCountCommandeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommandeWhereInput
  }


  /**
   * Count Type FournisseurCountOutputType
   */

  export type FournisseurCountOutputType = {
    Vente: number
    Achat: number
    Adresse: number
    Contact: number
    Reservation: number
    Commande: number
  }

  export type FournisseurCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Vente?: boolean | FournisseurCountOutputTypeCountVenteArgs
    Achat?: boolean | FournisseurCountOutputTypeCountAchatArgs
    Adresse?: boolean | FournisseurCountOutputTypeCountAdresseArgs
    Contact?: boolean | FournisseurCountOutputTypeCountContactArgs
    Reservation?: boolean | FournisseurCountOutputTypeCountReservationArgs
    Commande?: boolean | FournisseurCountOutputTypeCountCommandeArgs
  }

  // Custom InputTypes
  /**
   * FournisseurCountOutputType without action
   */
  export type FournisseurCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FournisseurCountOutputType
     */
    select?: FournisseurCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FournisseurCountOutputType without action
   */
  export type FournisseurCountOutputTypeCountVenteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VenteWhereInput
  }

  /**
   * FournisseurCountOutputType without action
   */
  export type FournisseurCountOutputTypeCountAchatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AchatWhereInput
  }

  /**
   * FournisseurCountOutputType without action
   */
  export type FournisseurCountOutputTypeCountAdresseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdresseWhereInput
  }

  /**
   * FournisseurCountOutputType without action
   */
  export type FournisseurCountOutputTypeCountContactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
  }

  /**
   * FournisseurCountOutputType without action
   */
  export type FournisseurCountOutputTypeCountReservationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReservationWhereInput
  }

  /**
   * FournisseurCountOutputType without action
   */
  export type FournisseurCountOutputTypeCountCommandeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommandeWhereInput
  }


  /**
   * Count Type TeneurCountOutputType
   */

  export type TeneurCountOutputType = {
    Produit: number
    DetailClotureCaisse: number
  }

  export type TeneurCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Produit?: boolean | TeneurCountOutputTypeCountProduitArgs
    DetailClotureCaisse?: boolean | TeneurCountOutputTypeCountDetailClotureCaisseArgs
  }

  // Custom InputTypes
  /**
   * TeneurCountOutputType without action
   */
  export type TeneurCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeneurCountOutputType
     */
    select?: TeneurCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TeneurCountOutputType without action
   */
  export type TeneurCountOutputTypeCountProduitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProduitWhereInput
  }

  /**
   * TeneurCountOutputType without action
   */
  export type TeneurCountOutputTypeCountDetailClotureCaisseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DetailClotureCaisseWhereInput
  }


  /**
   * Count Type DeviseCountOutputType
   */

  export type DeviseCountOutputType = {
    Produit: number
    Paiement: number
    Caisse: number
  }

  export type DeviseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Produit?: boolean | DeviseCountOutputTypeCountProduitArgs
    Paiement?: boolean | DeviseCountOutputTypeCountPaiementArgs
    Caisse?: boolean | DeviseCountOutputTypeCountCaisseArgs
  }

  // Custom InputTypes
  /**
   * DeviseCountOutputType without action
   */
  export type DeviseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviseCountOutputType
     */
    select?: DeviseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DeviseCountOutputType without action
   */
  export type DeviseCountOutputTypeCountProduitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProduitWhereInput
  }

  /**
   * DeviseCountOutputType without action
   */
  export type DeviseCountOutputTypeCountPaiementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaiementWhereInput
  }

  /**
   * DeviseCountOutputType without action
   */
  export type DeviseCountOutputTypeCountCaisseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CaisseWhereInput
  }


  /**
   * Count Type ProduitCountOutputType
   */

  export type ProduitCountOutputType = {
    DetailPanier: number
    DetailClotureCaisse: number
  }

  export type ProduitCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    DetailPanier?: boolean | ProduitCountOutputTypeCountDetailPanierArgs
    DetailClotureCaisse?: boolean | ProduitCountOutputTypeCountDetailClotureCaisseArgs
  }

  // Custom InputTypes
  /**
   * ProduitCountOutputType without action
   */
  export type ProduitCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProduitCountOutputType
     */
    select?: ProduitCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProduitCountOutputType without action
   */
  export type ProduitCountOutputTypeCountDetailPanierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DetailPanierWhereInput
  }

  /**
   * ProduitCountOutputType without action
   */
  export type ProduitCountOutputTypeCountDetailClotureCaisseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DetailClotureCaisseWhereInput
  }


  /**
   * Count Type PaiementCountOutputType
   */

  export type PaiementCountOutputType = {
    Achat: number
    Commande: number
    Vente: number
  }

  export type PaiementCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Achat?: boolean | PaiementCountOutputTypeCountAchatArgs
    Commande?: boolean | PaiementCountOutputTypeCountCommandeArgs
    Vente?: boolean | PaiementCountOutputTypeCountVenteArgs
  }

  // Custom InputTypes
  /**
   * PaiementCountOutputType without action
   */
  export type PaiementCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaiementCountOutputType
     */
    select?: PaiementCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PaiementCountOutputType without action
   */
  export type PaiementCountOutputTypeCountAchatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AchatWhereInput
  }

  /**
   * PaiementCountOutputType without action
   */
  export type PaiementCountOutputTypeCountCommandeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommandeWhereInput
  }

  /**
   * PaiementCountOutputType without action
   */
  export type PaiementCountOutputTypeCountVenteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VenteWhereInput
  }


  /**
   * Count Type CaisseCountOutputType
   */

  export type CaisseCountOutputType = {
    MouvementCaisse: number
    clotures: number
    Paiement: number
  }

  export type CaisseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    MouvementCaisse?: boolean | CaisseCountOutputTypeCountMouvementCaisseArgs
    clotures?: boolean | CaisseCountOutputTypeCountCloturesArgs
    Paiement?: boolean | CaisseCountOutputTypeCountPaiementArgs
  }

  // Custom InputTypes
  /**
   * CaisseCountOutputType without action
   */
  export type CaisseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaisseCountOutputType
     */
    select?: CaisseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CaisseCountOutputType without action
   */
  export type CaisseCountOutputTypeCountMouvementCaisseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MouvementCaisseWhereInput
  }

  /**
   * CaisseCountOutputType without action
   */
  export type CaisseCountOutputTypeCountCloturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClotureCaisseWhereInput
  }

  /**
   * CaisseCountOutputType without action
   */
  export type CaisseCountOutputTypeCountPaiementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaiementWhereInput
  }


  /**
   * Count Type PanierCountOutputType
   */

  export type PanierCountOutputType = {
    DetailPanier: number
    Achat: number
    Vente: number
    Reservation: number
    Commande: number
  }

  export type PanierCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    DetailPanier?: boolean | PanierCountOutputTypeCountDetailPanierArgs
    Achat?: boolean | PanierCountOutputTypeCountAchatArgs
    Vente?: boolean | PanierCountOutputTypeCountVenteArgs
    Reservation?: boolean | PanierCountOutputTypeCountReservationArgs
    Commande?: boolean | PanierCountOutputTypeCountCommandeArgs
  }

  // Custom InputTypes
  /**
   * PanierCountOutputType without action
   */
  export type PanierCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PanierCountOutputType
     */
    select?: PanierCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PanierCountOutputType without action
   */
  export type PanierCountOutputTypeCountDetailPanierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DetailPanierWhereInput
  }

  /**
   * PanierCountOutputType without action
   */
  export type PanierCountOutputTypeCountAchatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AchatWhereInput
  }

  /**
   * PanierCountOutputType without action
   */
  export type PanierCountOutputTypeCountVenteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VenteWhereInput
  }

  /**
   * PanierCountOutputType without action
   */
  export type PanierCountOutputTypeCountReservationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReservationWhereInput
  }

  /**
   * PanierCountOutputType without action
   */
  export type PanierCountOutputTypeCountCommandeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommandeWhereInput
  }


  /**
   * Count Type ClotureCaisseCountOutputType
   */

  export type ClotureCaisseCountOutputType = {
    DetailClotureCaisse: number
  }

  export type ClotureCaisseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    DetailClotureCaisse?: boolean | ClotureCaisseCountOutputTypeCountDetailClotureCaisseArgs
  }

  // Custom InputTypes
  /**
   * ClotureCaisseCountOutputType without action
   */
  export type ClotureCaisseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClotureCaisseCountOutputType
     */
    select?: ClotureCaisseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClotureCaisseCountOutputType without action
   */
  export type ClotureCaisseCountOutputTypeCountDetailClotureCaisseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DetailClotureCaisseWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Entreprise
   */

  export type AggregateEntreprise = {
    _count: EntrepriseCountAggregateOutputType | null
    _avg: EntrepriseAvgAggregateOutputType | null
    _sum: EntrepriseSumAggregateOutputType | null
    _min: EntrepriseMinAggregateOutputType | null
    _max: EntrepriseMaxAggregateOutputType | null
  }

  export type EntrepriseAvgAggregateOutputType = {
    id: number | null
  }

  export type EntrepriseSumAggregateOutputType = {
    id: number | null
  }

  export type EntrepriseMinAggregateOutputType = {
    id: number | null
    nom: string | null
    encronyme: string | null
    code_postale: string | null
    adresse: string | null
    tel: string | null
    site: string | null
    email: string | null
    description: string | null
    logo: string | null
  }

  export type EntrepriseMaxAggregateOutputType = {
    id: number | null
    nom: string | null
    encronyme: string | null
    code_postale: string | null
    adresse: string | null
    tel: string | null
    site: string | null
    email: string | null
    description: string | null
    logo: string | null
  }

  export type EntrepriseCountAggregateOutputType = {
    id: number
    nom: number
    encronyme: number
    code_postale: number
    adresse: number
    tel: number
    site: number
    email: number
    description: number
    logo: number
    _all: number
  }


  export type EntrepriseAvgAggregateInputType = {
    id?: true
  }

  export type EntrepriseSumAggregateInputType = {
    id?: true
  }

  export type EntrepriseMinAggregateInputType = {
    id?: true
    nom?: true
    encronyme?: true
    code_postale?: true
    adresse?: true
    tel?: true
    site?: true
    email?: true
    description?: true
    logo?: true
  }

  export type EntrepriseMaxAggregateInputType = {
    id?: true
    nom?: true
    encronyme?: true
    code_postale?: true
    adresse?: true
    tel?: true
    site?: true
    email?: true
    description?: true
    logo?: true
  }

  export type EntrepriseCountAggregateInputType = {
    id?: true
    nom?: true
    encronyme?: true
    code_postale?: true
    adresse?: true
    tel?: true
    site?: true
    email?: true
    description?: true
    logo?: true
    _all?: true
  }

  export type EntrepriseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Entreprise to aggregate.
     */
    where?: EntrepriseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Entreprises to fetch.
     */
    orderBy?: EntrepriseOrderByWithRelationInput | EntrepriseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EntrepriseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Entreprises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Entreprises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Entreprises
    **/
    _count?: true | EntrepriseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EntrepriseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EntrepriseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EntrepriseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EntrepriseMaxAggregateInputType
  }

  export type GetEntrepriseAggregateType<T extends EntrepriseAggregateArgs> = {
        [P in keyof T & keyof AggregateEntreprise]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEntreprise[P]>
      : GetScalarType<T[P], AggregateEntreprise[P]>
  }




  export type EntrepriseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EntrepriseWhereInput
    orderBy?: EntrepriseOrderByWithAggregationInput | EntrepriseOrderByWithAggregationInput[]
    by: EntrepriseScalarFieldEnum[] | EntrepriseScalarFieldEnum
    having?: EntrepriseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EntrepriseCountAggregateInputType | true
    _avg?: EntrepriseAvgAggregateInputType
    _sum?: EntrepriseSumAggregateInputType
    _min?: EntrepriseMinAggregateInputType
    _max?: EntrepriseMaxAggregateInputType
  }

  export type EntrepriseGroupByOutputType = {
    id: number
    nom: string
    encronyme: string
    code_postale: string
    adresse: string
    tel: string
    site: string | null
    email: string
    description: string | null
    logo: string | null
    _count: EntrepriseCountAggregateOutputType | null
    _avg: EntrepriseAvgAggregateOutputType | null
    _sum: EntrepriseSumAggregateOutputType | null
    _min: EntrepriseMinAggregateOutputType | null
    _max: EntrepriseMaxAggregateOutputType | null
  }

  type GetEntrepriseGroupByPayload<T extends EntrepriseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EntrepriseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EntrepriseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EntrepriseGroupByOutputType[P]>
            : GetScalarType<T[P], EntrepriseGroupByOutputType[P]>
        }
      >
    >


  export type EntrepriseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    encronyme?: boolean
    code_postale?: boolean
    adresse?: boolean
    tel?: boolean
    site?: boolean
    email?: boolean
    description?: boolean
    logo?: boolean
  }, ExtArgs["result"]["entreprise"]>

  export type EntrepriseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    encronyme?: boolean
    code_postale?: boolean
    adresse?: boolean
    tel?: boolean
    site?: boolean
    email?: boolean
    description?: boolean
    logo?: boolean
  }, ExtArgs["result"]["entreprise"]>

  export type EntrepriseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    encronyme?: boolean
    code_postale?: boolean
    adresse?: boolean
    tel?: boolean
    site?: boolean
    email?: boolean
    description?: boolean
    logo?: boolean
  }, ExtArgs["result"]["entreprise"]>

  export type EntrepriseSelectScalar = {
    id?: boolean
    nom?: boolean
    encronyme?: boolean
    code_postale?: boolean
    adresse?: boolean
    tel?: boolean
    site?: boolean
    email?: boolean
    description?: boolean
    logo?: boolean
  }

  export type EntrepriseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nom" | "encronyme" | "code_postale" | "adresse" | "tel" | "site" | "email" | "description" | "logo", ExtArgs["result"]["entreprise"]>

  export type $EntreprisePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Entreprise"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nom: string
      encronyme: string
      code_postale: string
      adresse: string
      tel: string
      site: string | null
      email: string
      description: string | null
      logo: string | null
    }, ExtArgs["result"]["entreprise"]>
    composites: {}
  }

  type EntrepriseGetPayload<S extends boolean | null | undefined | EntrepriseDefaultArgs> = $Result.GetResult<Prisma.$EntreprisePayload, S>

  type EntrepriseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EntrepriseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EntrepriseCountAggregateInputType | true
    }

  export interface EntrepriseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Entreprise'], meta: { name: 'Entreprise' } }
    /**
     * Find zero or one Entreprise that matches the filter.
     * @param {EntrepriseFindUniqueArgs} args - Arguments to find a Entreprise
     * @example
     * // Get one Entreprise
     * const entreprise = await prisma.entreprise.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EntrepriseFindUniqueArgs>(args: SelectSubset<T, EntrepriseFindUniqueArgs<ExtArgs>>): Prisma__EntrepriseClient<$Result.GetResult<Prisma.$EntreprisePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Entreprise that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EntrepriseFindUniqueOrThrowArgs} args - Arguments to find a Entreprise
     * @example
     * // Get one Entreprise
     * const entreprise = await prisma.entreprise.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EntrepriseFindUniqueOrThrowArgs>(args: SelectSubset<T, EntrepriseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EntrepriseClient<$Result.GetResult<Prisma.$EntreprisePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Entreprise that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntrepriseFindFirstArgs} args - Arguments to find a Entreprise
     * @example
     * // Get one Entreprise
     * const entreprise = await prisma.entreprise.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EntrepriseFindFirstArgs>(args?: SelectSubset<T, EntrepriseFindFirstArgs<ExtArgs>>): Prisma__EntrepriseClient<$Result.GetResult<Prisma.$EntreprisePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Entreprise that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntrepriseFindFirstOrThrowArgs} args - Arguments to find a Entreprise
     * @example
     * // Get one Entreprise
     * const entreprise = await prisma.entreprise.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EntrepriseFindFirstOrThrowArgs>(args?: SelectSubset<T, EntrepriseFindFirstOrThrowArgs<ExtArgs>>): Prisma__EntrepriseClient<$Result.GetResult<Prisma.$EntreprisePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Entreprises that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntrepriseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Entreprises
     * const entreprises = await prisma.entreprise.findMany()
     * 
     * // Get first 10 Entreprises
     * const entreprises = await prisma.entreprise.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const entrepriseWithIdOnly = await prisma.entreprise.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EntrepriseFindManyArgs>(args?: SelectSubset<T, EntrepriseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EntreprisePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Entreprise.
     * @param {EntrepriseCreateArgs} args - Arguments to create a Entreprise.
     * @example
     * // Create one Entreprise
     * const Entreprise = await prisma.entreprise.create({
     *   data: {
     *     // ... data to create a Entreprise
     *   }
     * })
     * 
     */
    create<T extends EntrepriseCreateArgs>(args: SelectSubset<T, EntrepriseCreateArgs<ExtArgs>>): Prisma__EntrepriseClient<$Result.GetResult<Prisma.$EntreprisePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Entreprises.
     * @param {EntrepriseCreateManyArgs} args - Arguments to create many Entreprises.
     * @example
     * // Create many Entreprises
     * const entreprise = await prisma.entreprise.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EntrepriseCreateManyArgs>(args?: SelectSubset<T, EntrepriseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Entreprises and returns the data saved in the database.
     * @param {EntrepriseCreateManyAndReturnArgs} args - Arguments to create many Entreprises.
     * @example
     * // Create many Entreprises
     * const entreprise = await prisma.entreprise.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Entreprises and only return the `id`
     * const entrepriseWithIdOnly = await prisma.entreprise.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EntrepriseCreateManyAndReturnArgs>(args?: SelectSubset<T, EntrepriseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EntreprisePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Entreprise.
     * @param {EntrepriseDeleteArgs} args - Arguments to delete one Entreprise.
     * @example
     * // Delete one Entreprise
     * const Entreprise = await prisma.entreprise.delete({
     *   where: {
     *     // ... filter to delete one Entreprise
     *   }
     * })
     * 
     */
    delete<T extends EntrepriseDeleteArgs>(args: SelectSubset<T, EntrepriseDeleteArgs<ExtArgs>>): Prisma__EntrepriseClient<$Result.GetResult<Prisma.$EntreprisePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Entreprise.
     * @param {EntrepriseUpdateArgs} args - Arguments to update one Entreprise.
     * @example
     * // Update one Entreprise
     * const entreprise = await prisma.entreprise.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EntrepriseUpdateArgs>(args: SelectSubset<T, EntrepriseUpdateArgs<ExtArgs>>): Prisma__EntrepriseClient<$Result.GetResult<Prisma.$EntreprisePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Entreprises.
     * @param {EntrepriseDeleteManyArgs} args - Arguments to filter Entreprises to delete.
     * @example
     * // Delete a few Entreprises
     * const { count } = await prisma.entreprise.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EntrepriseDeleteManyArgs>(args?: SelectSubset<T, EntrepriseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Entreprises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntrepriseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Entreprises
     * const entreprise = await prisma.entreprise.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EntrepriseUpdateManyArgs>(args: SelectSubset<T, EntrepriseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Entreprises and returns the data updated in the database.
     * @param {EntrepriseUpdateManyAndReturnArgs} args - Arguments to update many Entreprises.
     * @example
     * // Update many Entreprises
     * const entreprise = await prisma.entreprise.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Entreprises and only return the `id`
     * const entrepriseWithIdOnly = await prisma.entreprise.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EntrepriseUpdateManyAndReturnArgs>(args: SelectSubset<T, EntrepriseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EntreprisePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Entreprise.
     * @param {EntrepriseUpsertArgs} args - Arguments to update or create a Entreprise.
     * @example
     * // Update or create a Entreprise
     * const entreprise = await prisma.entreprise.upsert({
     *   create: {
     *     // ... data to create a Entreprise
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Entreprise we want to update
     *   }
     * })
     */
    upsert<T extends EntrepriseUpsertArgs>(args: SelectSubset<T, EntrepriseUpsertArgs<ExtArgs>>): Prisma__EntrepriseClient<$Result.GetResult<Prisma.$EntreprisePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Entreprises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntrepriseCountArgs} args - Arguments to filter Entreprises to count.
     * @example
     * // Count the number of Entreprises
     * const count = await prisma.entreprise.count({
     *   where: {
     *     // ... the filter for the Entreprises we want to count
     *   }
     * })
    **/
    count<T extends EntrepriseCountArgs>(
      args?: Subset<T, EntrepriseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EntrepriseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Entreprise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntrepriseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EntrepriseAggregateArgs>(args: Subset<T, EntrepriseAggregateArgs>): Prisma.PrismaPromise<GetEntrepriseAggregateType<T>>

    /**
     * Group by Entreprise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntrepriseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EntrepriseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EntrepriseGroupByArgs['orderBy'] }
        : { orderBy?: EntrepriseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EntrepriseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEntrepriseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Entreprise model
   */
  readonly fields: EntrepriseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Entreprise.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EntrepriseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Entreprise model
   */
  interface EntrepriseFieldRefs {
    readonly id: FieldRef<"Entreprise", 'Int'>
    readonly nom: FieldRef<"Entreprise", 'String'>
    readonly encronyme: FieldRef<"Entreprise", 'String'>
    readonly code_postale: FieldRef<"Entreprise", 'String'>
    readonly adresse: FieldRef<"Entreprise", 'String'>
    readonly tel: FieldRef<"Entreprise", 'String'>
    readonly site: FieldRef<"Entreprise", 'String'>
    readonly email: FieldRef<"Entreprise", 'String'>
    readonly description: FieldRef<"Entreprise", 'String'>
    readonly logo: FieldRef<"Entreprise", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Entreprise findUnique
   */
  export type EntrepriseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entreprise
     */
    select?: EntrepriseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Entreprise
     */
    omit?: EntrepriseOmit<ExtArgs> | null
    /**
     * Filter, which Entreprise to fetch.
     */
    where: EntrepriseWhereUniqueInput
  }

  /**
   * Entreprise findUniqueOrThrow
   */
  export type EntrepriseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entreprise
     */
    select?: EntrepriseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Entreprise
     */
    omit?: EntrepriseOmit<ExtArgs> | null
    /**
     * Filter, which Entreprise to fetch.
     */
    where: EntrepriseWhereUniqueInput
  }

  /**
   * Entreprise findFirst
   */
  export type EntrepriseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entreprise
     */
    select?: EntrepriseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Entreprise
     */
    omit?: EntrepriseOmit<ExtArgs> | null
    /**
     * Filter, which Entreprise to fetch.
     */
    where?: EntrepriseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Entreprises to fetch.
     */
    orderBy?: EntrepriseOrderByWithRelationInput | EntrepriseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Entreprises.
     */
    cursor?: EntrepriseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Entreprises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Entreprises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Entreprises.
     */
    distinct?: EntrepriseScalarFieldEnum | EntrepriseScalarFieldEnum[]
  }

  /**
   * Entreprise findFirstOrThrow
   */
  export type EntrepriseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entreprise
     */
    select?: EntrepriseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Entreprise
     */
    omit?: EntrepriseOmit<ExtArgs> | null
    /**
     * Filter, which Entreprise to fetch.
     */
    where?: EntrepriseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Entreprises to fetch.
     */
    orderBy?: EntrepriseOrderByWithRelationInput | EntrepriseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Entreprises.
     */
    cursor?: EntrepriseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Entreprises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Entreprises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Entreprises.
     */
    distinct?: EntrepriseScalarFieldEnum | EntrepriseScalarFieldEnum[]
  }

  /**
   * Entreprise findMany
   */
  export type EntrepriseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entreprise
     */
    select?: EntrepriseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Entreprise
     */
    omit?: EntrepriseOmit<ExtArgs> | null
    /**
     * Filter, which Entreprises to fetch.
     */
    where?: EntrepriseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Entreprises to fetch.
     */
    orderBy?: EntrepriseOrderByWithRelationInput | EntrepriseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Entreprises.
     */
    cursor?: EntrepriseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Entreprises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Entreprises.
     */
    skip?: number
    distinct?: EntrepriseScalarFieldEnum | EntrepriseScalarFieldEnum[]
  }

  /**
   * Entreprise create
   */
  export type EntrepriseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entreprise
     */
    select?: EntrepriseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Entreprise
     */
    omit?: EntrepriseOmit<ExtArgs> | null
    /**
     * The data needed to create a Entreprise.
     */
    data: XOR<EntrepriseCreateInput, EntrepriseUncheckedCreateInput>
  }

  /**
   * Entreprise createMany
   */
  export type EntrepriseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Entreprises.
     */
    data: EntrepriseCreateManyInput | EntrepriseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Entreprise createManyAndReturn
   */
  export type EntrepriseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entreprise
     */
    select?: EntrepriseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Entreprise
     */
    omit?: EntrepriseOmit<ExtArgs> | null
    /**
     * The data used to create many Entreprises.
     */
    data: EntrepriseCreateManyInput | EntrepriseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Entreprise update
   */
  export type EntrepriseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entreprise
     */
    select?: EntrepriseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Entreprise
     */
    omit?: EntrepriseOmit<ExtArgs> | null
    /**
     * The data needed to update a Entreprise.
     */
    data: XOR<EntrepriseUpdateInput, EntrepriseUncheckedUpdateInput>
    /**
     * Choose, which Entreprise to update.
     */
    where: EntrepriseWhereUniqueInput
  }

  /**
   * Entreprise updateMany
   */
  export type EntrepriseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Entreprises.
     */
    data: XOR<EntrepriseUpdateManyMutationInput, EntrepriseUncheckedUpdateManyInput>
    /**
     * Filter which Entreprises to update
     */
    where?: EntrepriseWhereInput
    /**
     * Limit how many Entreprises to update.
     */
    limit?: number
  }

  /**
   * Entreprise updateManyAndReturn
   */
  export type EntrepriseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entreprise
     */
    select?: EntrepriseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Entreprise
     */
    omit?: EntrepriseOmit<ExtArgs> | null
    /**
     * The data used to update Entreprises.
     */
    data: XOR<EntrepriseUpdateManyMutationInput, EntrepriseUncheckedUpdateManyInput>
    /**
     * Filter which Entreprises to update
     */
    where?: EntrepriseWhereInput
    /**
     * Limit how many Entreprises to update.
     */
    limit?: number
  }

  /**
   * Entreprise upsert
   */
  export type EntrepriseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entreprise
     */
    select?: EntrepriseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Entreprise
     */
    omit?: EntrepriseOmit<ExtArgs> | null
    /**
     * The filter to search for the Entreprise to update in case it exists.
     */
    where: EntrepriseWhereUniqueInput
    /**
     * In case the Entreprise found by the `where` argument doesn't exist, create a new Entreprise with this data.
     */
    create: XOR<EntrepriseCreateInput, EntrepriseUncheckedCreateInput>
    /**
     * In case the Entreprise was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EntrepriseUpdateInput, EntrepriseUncheckedUpdateInput>
  }

  /**
   * Entreprise delete
   */
  export type EntrepriseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entreprise
     */
    select?: EntrepriseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Entreprise
     */
    omit?: EntrepriseOmit<ExtArgs> | null
    /**
     * Filter which Entreprise to delete.
     */
    where: EntrepriseWhereUniqueInput
  }

  /**
   * Entreprise deleteMany
   */
  export type EntrepriseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Entreprises to delete
     */
    where?: EntrepriseWhereInput
    /**
     * Limit how many Entreprises to delete.
     */
    limit?: number
  }

  /**
   * Entreprise without action
   */
  export type EntrepriseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entreprise
     */
    select?: EntrepriseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Entreprise
     */
    omit?: EntrepriseOmit<ExtArgs> | null
  }


  /**
   * Model Utilisateur
   */

  export type AggregateUtilisateur = {
    _count: UtilisateurCountAggregateOutputType | null
    _avg: UtilisateurAvgAggregateOutputType | null
    _sum: UtilisateurSumAggregateOutputType | null
    _min: UtilisateurMinAggregateOutputType | null
    _max: UtilisateurMaxAggregateOutputType | null
  }

  export type UtilisateurAvgAggregateOutputType = {
    id: number | null
  }

  export type UtilisateurSumAggregateOutputType = {
    id: number | null
  }

  export type UtilisateurMinAggregateOutputType = {
    id: number | null
    email: string | null
    nom: string | null
    postnom: string | null
    nom_complet: string | null
    sexe: $Enums.Sexe | null
    role: $Enums.Role | null
    poste: $Enums.Poste | null
    picture: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UtilisateurMaxAggregateOutputType = {
    id: number | null
    email: string | null
    nom: string | null
    postnom: string | null
    nom_complet: string | null
    sexe: $Enums.Sexe | null
    role: $Enums.Role | null
    poste: $Enums.Poste | null
    picture: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UtilisateurCountAggregateOutputType = {
    id: number
    email: number
    nom: number
    postnom: number
    nom_complet: number
    sexe: number
    role: number
    poste: number
    picture: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UtilisateurAvgAggregateInputType = {
    id?: true
  }

  export type UtilisateurSumAggregateInputType = {
    id?: true
  }

  export type UtilisateurMinAggregateInputType = {
    id?: true
    email?: true
    nom?: true
    postnom?: true
    nom_complet?: true
    sexe?: true
    role?: true
    poste?: true
    picture?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UtilisateurMaxAggregateInputType = {
    id?: true
    email?: true
    nom?: true
    postnom?: true
    nom_complet?: true
    sexe?: true
    role?: true
    poste?: true
    picture?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UtilisateurCountAggregateInputType = {
    id?: true
    email?: true
    nom?: true
    postnom?: true
    nom_complet?: true
    sexe?: true
    role?: true
    poste?: true
    picture?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UtilisateurAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Utilisateur to aggregate.
     */
    where?: UtilisateurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Utilisateurs to fetch.
     */
    orderBy?: UtilisateurOrderByWithRelationInput | UtilisateurOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UtilisateurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Utilisateurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Utilisateurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Utilisateurs
    **/
    _count?: true | UtilisateurCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UtilisateurAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UtilisateurSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UtilisateurMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UtilisateurMaxAggregateInputType
  }

  export type GetUtilisateurAggregateType<T extends UtilisateurAggregateArgs> = {
        [P in keyof T & keyof AggregateUtilisateur]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUtilisateur[P]>
      : GetScalarType<T[P], AggregateUtilisateur[P]>
  }




  export type UtilisateurGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UtilisateurWhereInput
    orderBy?: UtilisateurOrderByWithAggregationInput | UtilisateurOrderByWithAggregationInput[]
    by: UtilisateurScalarFieldEnum[] | UtilisateurScalarFieldEnum
    having?: UtilisateurScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UtilisateurCountAggregateInputType | true
    _avg?: UtilisateurAvgAggregateInputType
    _sum?: UtilisateurSumAggregateInputType
    _min?: UtilisateurMinAggregateInputType
    _max?: UtilisateurMaxAggregateInputType
  }

  export type UtilisateurGroupByOutputType = {
    id: number
    email: string
    nom: string
    postnom: string
    nom_complet: string | null
    sexe: $Enums.Sexe | null
    role: $Enums.Role
    poste: $Enums.Poste | null
    picture: string | null
    createdAt: Date
    updatedAt: Date
    _count: UtilisateurCountAggregateOutputType | null
    _avg: UtilisateurAvgAggregateOutputType | null
    _sum: UtilisateurSumAggregateOutputType | null
    _min: UtilisateurMinAggregateOutputType | null
    _max: UtilisateurMaxAggregateOutputType | null
  }

  type GetUtilisateurGroupByPayload<T extends UtilisateurGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UtilisateurGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UtilisateurGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UtilisateurGroupByOutputType[P]>
            : GetScalarType<T[P], UtilisateurGroupByOutputType[P]>
        }
      >
    >


  export type UtilisateurSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    nom?: boolean
    postnom?: boolean
    nom_complet?: boolean
    sexe?: boolean
    role?: boolean
    poste?: boolean
    picture?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Adresse?: boolean | Utilisateur$AdresseArgs<ExtArgs>
    Contact?: boolean | Utilisateur$ContactArgs<ExtArgs>
    Produit?: boolean | Utilisateur$ProduitArgs<ExtArgs>
    Vente?: boolean | Utilisateur$VenteArgs<ExtArgs>
    Achat?: boolean | Utilisateur$AchatArgs<ExtArgs>
    Teneur?: boolean | Utilisateur$TeneurArgs<ExtArgs>
    Devise?: boolean | Utilisateur$DeviseArgs<ExtArgs>
    Panier?: boolean | Utilisateur$PanierArgs<ExtArgs>
    Reservation?: boolean | Utilisateur$ReservationArgs<ExtArgs>
    Commande?: boolean | Utilisateur$CommandeArgs<ExtArgs>
    Caisse?: boolean | Utilisateur$CaisseArgs<ExtArgs>
    MouvementCaisse?: boolean | Utilisateur$MouvementCaisseArgs<ExtArgs>
    ClotureCaisse?: boolean | Utilisateur$ClotureCaisseArgs<ExtArgs>
    _count?: boolean | UtilisateurCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["utilisateur"]>

  export type UtilisateurSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    nom?: boolean
    postnom?: boolean
    nom_complet?: boolean
    sexe?: boolean
    role?: boolean
    poste?: boolean
    picture?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["utilisateur"]>

  export type UtilisateurSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    nom?: boolean
    postnom?: boolean
    nom_complet?: boolean
    sexe?: boolean
    role?: boolean
    poste?: boolean
    picture?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["utilisateur"]>

  export type UtilisateurSelectScalar = {
    id?: boolean
    email?: boolean
    nom?: boolean
    postnom?: boolean
    nom_complet?: boolean
    sexe?: boolean
    role?: boolean
    poste?: boolean
    picture?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UtilisateurOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "nom" | "postnom" | "nom_complet" | "sexe" | "role" | "poste" | "picture" | "createdAt" | "updatedAt", ExtArgs["result"]["utilisateur"]>
  export type UtilisateurInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Adresse?: boolean | Utilisateur$AdresseArgs<ExtArgs>
    Contact?: boolean | Utilisateur$ContactArgs<ExtArgs>
    Produit?: boolean | Utilisateur$ProduitArgs<ExtArgs>
    Vente?: boolean | Utilisateur$VenteArgs<ExtArgs>
    Achat?: boolean | Utilisateur$AchatArgs<ExtArgs>
    Teneur?: boolean | Utilisateur$TeneurArgs<ExtArgs>
    Devise?: boolean | Utilisateur$DeviseArgs<ExtArgs>
    Panier?: boolean | Utilisateur$PanierArgs<ExtArgs>
    Reservation?: boolean | Utilisateur$ReservationArgs<ExtArgs>
    Commande?: boolean | Utilisateur$CommandeArgs<ExtArgs>
    Caisse?: boolean | Utilisateur$CaisseArgs<ExtArgs>
    MouvementCaisse?: boolean | Utilisateur$MouvementCaisseArgs<ExtArgs>
    ClotureCaisse?: boolean | Utilisateur$ClotureCaisseArgs<ExtArgs>
    _count?: boolean | UtilisateurCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UtilisateurIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UtilisateurIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UtilisateurPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Utilisateur"
    objects: {
      Adresse: Prisma.$AdressePayload<ExtArgs>[]
      Contact: Prisma.$ContactPayload<ExtArgs>[]
      Produit: Prisma.$ProduitPayload<ExtArgs>[]
      Vente: Prisma.$VentePayload<ExtArgs>[]
      Achat: Prisma.$AchatPayload<ExtArgs>[]
      Teneur: Prisma.$TeneurPayload<ExtArgs>[]
      Devise: Prisma.$DevisePayload<ExtArgs>[]
      Panier: Prisma.$PanierPayload<ExtArgs>[]
      Reservation: Prisma.$ReservationPayload<ExtArgs>[]
      Commande: Prisma.$CommandePayload<ExtArgs>[]
      Caisse: Prisma.$CaissePayload<ExtArgs>[]
      MouvementCaisse: Prisma.$MouvementCaissePayload<ExtArgs>[]
      ClotureCaisse: Prisma.$ClotureCaissePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      nom: string
      postnom: string
      nom_complet: string | null
      sexe: $Enums.Sexe | null
      role: $Enums.Role
      poste: $Enums.Poste | null
      picture: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["utilisateur"]>
    composites: {}
  }

  type UtilisateurGetPayload<S extends boolean | null | undefined | UtilisateurDefaultArgs> = $Result.GetResult<Prisma.$UtilisateurPayload, S>

  type UtilisateurCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UtilisateurFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UtilisateurCountAggregateInputType | true
    }

  export interface UtilisateurDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Utilisateur'], meta: { name: 'Utilisateur' } }
    /**
     * Find zero or one Utilisateur that matches the filter.
     * @param {UtilisateurFindUniqueArgs} args - Arguments to find a Utilisateur
     * @example
     * // Get one Utilisateur
     * const utilisateur = await prisma.utilisateur.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UtilisateurFindUniqueArgs>(args: SelectSubset<T, UtilisateurFindUniqueArgs<ExtArgs>>): Prisma__UtilisateurClient<$Result.GetResult<Prisma.$UtilisateurPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Utilisateur that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UtilisateurFindUniqueOrThrowArgs} args - Arguments to find a Utilisateur
     * @example
     * // Get one Utilisateur
     * const utilisateur = await prisma.utilisateur.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UtilisateurFindUniqueOrThrowArgs>(args: SelectSubset<T, UtilisateurFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UtilisateurClient<$Result.GetResult<Prisma.$UtilisateurPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Utilisateur that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UtilisateurFindFirstArgs} args - Arguments to find a Utilisateur
     * @example
     * // Get one Utilisateur
     * const utilisateur = await prisma.utilisateur.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UtilisateurFindFirstArgs>(args?: SelectSubset<T, UtilisateurFindFirstArgs<ExtArgs>>): Prisma__UtilisateurClient<$Result.GetResult<Prisma.$UtilisateurPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Utilisateur that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UtilisateurFindFirstOrThrowArgs} args - Arguments to find a Utilisateur
     * @example
     * // Get one Utilisateur
     * const utilisateur = await prisma.utilisateur.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UtilisateurFindFirstOrThrowArgs>(args?: SelectSubset<T, UtilisateurFindFirstOrThrowArgs<ExtArgs>>): Prisma__UtilisateurClient<$Result.GetResult<Prisma.$UtilisateurPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Utilisateurs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UtilisateurFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Utilisateurs
     * const utilisateurs = await prisma.utilisateur.findMany()
     * 
     * // Get first 10 Utilisateurs
     * const utilisateurs = await prisma.utilisateur.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const utilisateurWithIdOnly = await prisma.utilisateur.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UtilisateurFindManyArgs>(args?: SelectSubset<T, UtilisateurFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UtilisateurPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Utilisateur.
     * @param {UtilisateurCreateArgs} args - Arguments to create a Utilisateur.
     * @example
     * // Create one Utilisateur
     * const Utilisateur = await prisma.utilisateur.create({
     *   data: {
     *     // ... data to create a Utilisateur
     *   }
     * })
     * 
     */
    create<T extends UtilisateurCreateArgs>(args: SelectSubset<T, UtilisateurCreateArgs<ExtArgs>>): Prisma__UtilisateurClient<$Result.GetResult<Prisma.$UtilisateurPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Utilisateurs.
     * @param {UtilisateurCreateManyArgs} args - Arguments to create many Utilisateurs.
     * @example
     * // Create many Utilisateurs
     * const utilisateur = await prisma.utilisateur.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UtilisateurCreateManyArgs>(args?: SelectSubset<T, UtilisateurCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Utilisateurs and returns the data saved in the database.
     * @param {UtilisateurCreateManyAndReturnArgs} args - Arguments to create many Utilisateurs.
     * @example
     * // Create many Utilisateurs
     * const utilisateur = await prisma.utilisateur.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Utilisateurs and only return the `id`
     * const utilisateurWithIdOnly = await prisma.utilisateur.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UtilisateurCreateManyAndReturnArgs>(args?: SelectSubset<T, UtilisateurCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UtilisateurPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Utilisateur.
     * @param {UtilisateurDeleteArgs} args - Arguments to delete one Utilisateur.
     * @example
     * // Delete one Utilisateur
     * const Utilisateur = await prisma.utilisateur.delete({
     *   where: {
     *     // ... filter to delete one Utilisateur
     *   }
     * })
     * 
     */
    delete<T extends UtilisateurDeleteArgs>(args: SelectSubset<T, UtilisateurDeleteArgs<ExtArgs>>): Prisma__UtilisateurClient<$Result.GetResult<Prisma.$UtilisateurPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Utilisateur.
     * @param {UtilisateurUpdateArgs} args - Arguments to update one Utilisateur.
     * @example
     * // Update one Utilisateur
     * const utilisateur = await prisma.utilisateur.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UtilisateurUpdateArgs>(args: SelectSubset<T, UtilisateurUpdateArgs<ExtArgs>>): Prisma__UtilisateurClient<$Result.GetResult<Prisma.$UtilisateurPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Utilisateurs.
     * @param {UtilisateurDeleteManyArgs} args - Arguments to filter Utilisateurs to delete.
     * @example
     * // Delete a few Utilisateurs
     * const { count } = await prisma.utilisateur.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UtilisateurDeleteManyArgs>(args?: SelectSubset<T, UtilisateurDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Utilisateurs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UtilisateurUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Utilisateurs
     * const utilisateur = await prisma.utilisateur.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UtilisateurUpdateManyArgs>(args: SelectSubset<T, UtilisateurUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Utilisateurs and returns the data updated in the database.
     * @param {UtilisateurUpdateManyAndReturnArgs} args - Arguments to update many Utilisateurs.
     * @example
     * // Update many Utilisateurs
     * const utilisateur = await prisma.utilisateur.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Utilisateurs and only return the `id`
     * const utilisateurWithIdOnly = await prisma.utilisateur.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UtilisateurUpdateManyAndReturnArgs>(args: SelectSubset<T, UtilisateurUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UtilisateurPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Utilisateur.
     * @param {UtilisateurUpsertArgs} args - Arguments to update or create a Utilisateur.
     * @example
     * // Update or create a Utilisateur
     * const utilisateur = await prisma.utilisateur.upsert({
     *   create: {
     *     // ... data to create a Utilisateur
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Utilisateur we want to update
     *   }
     * })
     */
    upsert<T extends UtilisateurUpsertArgs>(args: SelectSubset<T, UtilisateurUpsertArgs<ExtArgs>>): Prisma__UtilisateurClient<$Result.GetResult<Prisma.$UtilisateurPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Utilisateurs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UtilisateurCountArgs} args - Arguments to filter Utilisateurs to count.
     * @example
     * // Count the number of Utilisateurs
     * const count = await prisma.utilisateur.count({
     *   where: {
     *     // ... the filter for the Utilisateurs we want to count
     *   }
     * })
    **/
    count<T extends UtilisateurCountArgs>(
      args?: Subset<T, UtilisateurCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UtilisateurCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Utilisateur.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UtilisateurAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UtilisateurAggregateArgs>(args: Subset<T, UtilisateurAggregateArgs>): Prisma.PrismaPromise<GetUtilisateurAggregateType<T>>

    /**
     * Group by Utilisateur.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UtilisateurGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UtilisateurGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UtilisateurGroupByArgs['orderBy'] }
        : { orderBy?: UtilisateurGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UtilisateurGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUtilisateurGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Utilisateur model
   */
  readonly fields: UtilisateurFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Utilisateur.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UtilisateurClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Adresse<T extends Utilisateur$AdresseArgs<ExtArgs> = {}>(args?: Subset<T, Utilisateur$AdresseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdressePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Contact<T extends Utilisateur$ContactArgs<ExtArgs> = {}>(args?: Subset<T, Utilisateur$ContactArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Produit<T extends Utilisateur$ProduitArgs<ExtArgs> = {}>(args?: Subset<T, Utilisateur$ProduitArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProduitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Vente<T extends Utilisateur$VenteArgs<ExtArgs> = {}>(args?: Subset<T, Utilisateur$VenteArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VentePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Achat<T extends Utilisateur$AchatArgs<ExtArgs> = {}>(args?: Subset<T, Utilisateur$AchatArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Teneur<T extends Utilisateur$TeneurArgs<ExtArgs> = {}>(args?: Subset<T, Utilisateur$TeneurArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeneurPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Devise<T extends Utilisateur$DeviseArgs<ExtArgs> = {}>(args?: Subset<T, Utilisateur$DeviseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DevisePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Panier<T extends Utilisateur$PanierArgs<ExtArgs> = {}>(args?: Subset<T, Utilisateur$PanierArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PanierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Reservation<T extends Utilisateur$ReservationArgs<ExtArgs> = {}>(args?: Subset<T, Utilisateur$ReservationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Commande<T extends Utilisateur$CommandeArgs<ExtArgs> = {}>(args?: Subset<T, Utilisateur$CommandeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommandePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Caisse<T extends Utilisateur$CaisseArgs<ExtArgs> = {}>(args?: Subset<T, Utilisateur$CaisseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CaissePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    MouvementCaisse<T extends Utilisateur$MouvementCaisseArgs<ExtArgs> = {}>(args?: Subset<T, Utilisateur$MouvementCaisseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MouvementCaissePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ClotureCaisse<T extends Utilisateur$ClotureCaisseArgs<ExtArgs> = {}>(args?: Subset<T, Utilisateur$ClotureCaisseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClotureCaissePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Utilisateur model
   */
  interface UtilisateurFieldRefs {
    readonly id: FieldRef<"Utilisateur", 'Int'>
    readonly email: FieldRef<"Utilisateur", 'String'>
    readonly nom: FieldRef<"Utilisateur", 'String'>
    readonly postnom: FieldRef<"Utilisateur", 'String'>
    readonly nom_complet: FieldRef<"Utilisateur", 'String'>
    readonly sexe: FieldRef<"Utilisateur", 'Sexe'>
    readonly role: FieldRef<"Utilisateur", 'Role'>
    readonly poste: FieldRef<"Utilisateur", 'Poste'>
    readonly picture: FieldRef<"Utilisateur", 'String'>
    readonly createdAt: FieldRef<"Utilisateur", 'DateTime'>
    readonly updatedAt: FieldRef<"Utilisateur", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Utilisateur findUnique
   */
  export type UtilisateurFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Utilisateur
     */
    select?: UtilisateurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Utilisateur
     */
    omit?: UtilisateurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UtilisateurInclude<ExtArgs> | null
    /**
     * Filter, which Utilisateur to fetch.
     */
    where: UtilisateurWhereUniqueInput
  }

  /**
   * Utilisateur findUniqueOrThrow
   */
  export type UtilisateurFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Utilisateur
     */
    select?: UtilisateurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Utilisateur
     */
    omit?: UtilisateurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UtilisateurInclude<ExtArgs> | null
    /**
     * Filter, which Utilisateur to fetch.
     */
    where: UtilisateurWhereUniqueInput
  }

  /**
   * Utilisateur findFirst
   */
  export type UtilisateurFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Utilisateur
     */
    select?: UtilisateurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Utilisateur
     */
    omit?: UtilisateurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UtilisateurInclude<ExtArgs> | null
    /**
     * Filter, which Utilisateur to fetch.
     */
    where?: UtilisateurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Utilisateurs to fetch.
     */
    orderBy?: UtilisateurOrderByWithRelationInput | UtilisateurOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Utilisateurs.
     */
    cursor?: UtilisateurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Utilisateurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Utilisateurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Utilisateurs.
     */
    distinct?: UtilisateurScalarFieldEnum | UtilisateurScalarFieldEnum[]
  }

  /**
   * Utilisateur findFirstOrThrow
   */
  export type UtilisateurFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Utilisateur
     */
    select?: UtilisateurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Utilisateur
     */
    omit?: UtilisateurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UtilisateurInclude<ExtArgs> | null
    /**
     * Filter, which Utilisateur to fetch.
     */
    where?: UtilisateurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Utilisateurs to fetch.
     */
    orderBy?: UtilisateurOrderByWithRelationInput | UtilisateurOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Utilisateurs.
     */
    cursor?: UtilisateurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Utilisateurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Utilisateurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Utilisateurs.
     */
    distinct?: UtilisateurScalarFieldEnum | UtilisateurScalarFieldEnum[]
  }

  /**
   * Utilisateur findMany
   */
  export type UtilisateurFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Utilisateur
     */
    select?: UtilisateurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Utilisateur
     */
    omit?: UtilisateurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UtilisateurInclude<ExtArgs> | null
    /**
     * Filter, which Utilisateurs to fetch.
     */
    where?: UtilisateurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Utilisateurs to fetch.
     */
    orderBy?: UtilisateurOrderByWithRelationInput | UtilisateurOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Utilisateurs.
     */
    cursor?: UtilisateurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Utilisateurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Utilisateurs.
     */
    skip?: number
    distinct?: UtilisateurScalarFieldEnum | UtilisateurScalarFieldEnum[]
  }

  /**
   * Utilisateur create
   */
  export type UtilisateurCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Utilisateur
     */
    select?: UtilisateurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Utilisateur
     */
    omit?: UtilisateurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UtilisateurInclude<ExtArgs> | null
    /**
     * The data needed to create a Utilisateur.
     */
    data: XOR<UtilisateurCreateInput, UtilisateurUncheckedCreateInput>
  }

  /**
   * Utilisateur createMany
   */
  export type UtilisateurCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Utilisateurs.
     */
    data: UtilisateurCreateManyInput | UtilisateurCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Utilisateur createManyAndReturn
   */
  export type UtilisateurCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Utilisateur
     */
    select?: UtilisateurSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Utilisateur
     */
    omit?: UtilisateurOmit<ExtArgs> | null
    /**
     * The data used to create many Utilisateurs.
     */
    data: UtilisateurCreateManyInput | UtilisateurCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Utilisateur update
   */
  export type UtilisateurUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Utilisateur
     */
    select?: UtilisateurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Utilisateur
     */
    omit?: UtilisateurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UtilisateurInclude<ExtArgs> | null
    /**
     * The data needed to update a Utilisateur.
     */
    data: XOR<UtilisateurUpdateInput, UtilisateurUncheckedUpdateInput>
    /**
     * Choose, which Utilisateur to update.
     */
    where: UtilisateurWhereUniqueInput
  }

  /**
   * Utilisateur updateMany
   */
  export type UtilisateurUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Utilisateurs.
     */
    data: XOR<UtilisateurUpdateManyMutationInput, UtilisateurUncheckedUpdateManyInput>
    /**
     * Filter which Utilisateurs to update
     */
    where?: UtilisateurWhereInput
    /**
     * Limit how many Utilisateurs to update.
     */
    limit?: number
  }

  /**
   * Utilisateur updateManyAndReturn
   */
  export type UtilisateurUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Utilisateur
     */
    select?: UtilisateurSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Utilisateur
     */
    omit?: UtilisateurOmit<ExtArgs> | null
    /**
     * The data used to update Utilisateurs.
     */
    data: XOR<UtilisateurUpdateManyMutationInput, UtilisateurUncheckedUpdateManyInput>
    /**
     * Filter which Utilisateurs to update
     */
    where?: UtilisateurWhereInput
    /**
     * Limit how many Utilisateurs to update.
     */
    limit?: number
  }

  /**
   * Utilisateur upsert
   */
  export type UtilisateurUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Utilisateur
     */
    select?: UtilisateurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Utilisateur
     */
    omit?: UtilisateurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UtilisateurInclude<ExtArgs> | null
    /**
     * The filter to search for the Utilisateur to update in case it exists.
     */
    where: UtilisateurWhereUniqueInput
    /**
     * In case the Utilisateur found by the `where` argument doesn't exist, create a new Utilisateur with this data.
     */
    create: XOR<UtilisateurCreateInput, UtilisateurUncheckedCreateInput>
    /**
     * In case the Utilisateur was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UtilisateurUpdateInput, UtilisateurUncheckedUpdateInput>
  }

  /**
   * Utilisateur delete
   */
  export type UtilisateurDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Utilisateur
     */
    select?: UtilisateurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Utilisateur
     */
    omit?: UtilisateurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UtilisateurInclude<ExtArgs> | null
    /**
     * Filter which Utilisateur to delete.
     */
    where: UtilisateurWhereUniqueInput
  }

  /**
   * Utilisateur deleteMany
   */
  export type UtilisateurDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Utilisateurs to delete
     */
    where?: UtilisateurWhereInput
    /**
     * Limit how many Utilisateurs to delete.
     */
    limit?: number
  }

  /**
   * Utilisateur.Adresse
   */
  export type Utilisateur$AdresseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adresse
     */
    select?: AdresseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Adresse
     */
    omit?: AdresseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdresseInclude<ExtArgs> | null
    where?: AdresseWhereInput
    orderBy?: AdresseOrderByWithRelationInput | AdresseOrderByWithRelationInput[]
    cursor?: AdresseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdresseScalarFieldEnum | AdresseScalarFieldEnum[]
  }

  /**
   * Utilisateur.Contact
   */
  export type Utilisateur$ContactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    cursor?: ContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Utilisateur.Produit
   */
  export type Utilisateur$ProduitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Produit
     */
    select?: ProduitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Produit
     */
    omit?: ProduitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProduitInclude<ExtArgs> | null
    where?: ProduitWhereInput
    orderBy?: ProduitOrderByWithRelationInput | ProduitOrderByWithRelationInput[]
    cursor?: ProduitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProduitScalarFieldEnum | ProduitScalarFieldEnum[]
  }

  /**
   * Utilisateur.Vente
   */
  export type Utilisateur$VenteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vente
     */
    select?: VenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vente
     */
    omit?: VenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenteInclude<ExtArgs> | null
    where?: VenteWhereInput
    orderBy?: VenteOrderByWithRelationInput | VenteOrderByWithRelationInput[]
    cursor?: VenteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VenteScalarFieldEnum | VenteScalarFieldEnum[]
  }

  /**
   * Utilisateur.Achat
   */
  export type Utilisateur$AchatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achat
     */
    select?: AchatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achat
     */
    omit?: AchatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchatInclude<ExtArgs> | null
    where?: AchatWhereInput
    orderBy?: AchatOrderByWithRelationInput | AchatOrderByWithRelationInput[]
    cursor?: AchatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AchatScalarFieldEnum | AchatScalarFieldEnum[]
  }

  /**
   * Utilisateur.Teneur
   */
  export type Utilisateur$TeneurArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teneur
     */
    select?: TeneurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teneur
     */
    omit?: TeneurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeneurInclude<ExtArgs> | null
    where?: TeneurWhereInput
    orderBy?: TeneurOrderByWithRelationInput | TeneurOrderByWithRelationInput[]
    cursor?: TeneurWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeneurScalarFieldEnum | TeneurScalarFieldEnum[]
  }

  /**
   * Utilisateur.Devise
   */
  export type Utilisateur$DeviseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Devise
     */
    select?: DeviseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Devise
     */
    omit?: DeviseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviseInclude<ExtArgs> | null
    where?: DeviseWhereInput
    orderBy?: DeviseOrderByWithRelationInput | DeviseOrderByWithRelationInput[]
    cursor?: DeviseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeviseScalarFieldEnum | DeviseScalarFieldEnum[]
  }

  /**
   * Utilisateur.Panier
   */
  export type Utilisateur$PanierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Panier
     */
    select?: PanierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Panier
     */
    omit?: PanierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PanierInclude<ExtArgs> | null
    where?: PanierWhereInput
    orderBy?: PanierOrderByWithRelationInput | PanierOrderByWithRelationInput[]
    cursor?: PanierWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PanierScalarFieldEnum | PanierScalarFieldEnum[]
  }

  /**
   * Utilisateur.Reservation
   */
  export type Utilisateur$ReservationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    where?: ReservationWhereInput
    orderBy?: ReservationOrderByWithRelationInput | ReservationOrderByWithRelationInput[]
    cursor?: ReservationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReservationScalarFieldEnum | ReservationScalarFieldEnum[]
  }

  /**
   * Utilisateur.Commande
   */
  export type Utilisateur$CommandeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commande
     */
    select?: CommandeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Commande
     */
    omit?: CommandeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandeInclude<ExtArgs> | null
    where?: CommandeWhereInput
    orderBy?: CommandeOrderByWithRelationInput | CommandeOrderByWithRelationInput[]
    cursor?: CommandeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommandeScalarFieldEnum | CommandeScalarFieldEnum[]
  }

  /**
   * Utilisateur.Caisse
   */
  export type Utilisateur$CaisseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Caisse
     */
    select?: CaisseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Caisse
     */
    omit?: CaisseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaisseInclude<ExtArgs> | null
    where?: CaisseWhereInput
    orderBy?: CaisseOrderByWithRelationInput | CaisseOrderByWithRelationInput[]
    cursor?: CaisseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CaisseScalarFieldEnum | CaisseScalarFieldEnum[]
  }

  /**
   * Utilisateur.MouvementCaisse
   */
  export type Utilisateur$MouvementCaisseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MouvementCaisse
     */
    select?: MouvementCaisseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MouvementCaisse
     */
    omit?: MouvementCaisseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MouvementCaisseInclude<ExtArgs> | null
    where?: MouvementCaisseWhereInput
    orderBy?: MouvementCaisseOrderByWithRelationInput | MouvementCaisseOrderByWithRelationInput[]
    cursor?: MouvementCaisseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MouvementCaisseScalarFieldEnum | MouvementCaisseScalarFieldEnum[]
  }

  /**
   * Utilisateur.ClotureCaisse
   */
  export type Utilisateur$ClotureCaisseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClotureCaisse
     */
    select?: ClotureCaisseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClotureCaisse
     */
    omit?: ClotureCaisseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClotureCaisseInclude<ExtArgs> | null
    where?: ClotureCaisseWhereInput
    orderBy?: ClotureCaisseOrderByWithRelationInput | ClotureCaisseOrderByWithRelationInput[]
    cursor?: ClotureCaisseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClotureCaisseScalarFieldEnum | ClotureCaisseScalarFieldEnum[]
  }

  /**
   * Utilisateur without action
   */
  export type UtilisateurDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Utilisateur
     */
    select?: UtilisateurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Utilisateur
     */
    omit?: UtilisateurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UtilisateurInclude<ExtArgs> | null
  }


  /**
   * Model Adresse
   */

  export type AggregateAdresse = {
    _count: AdresseCountAggregateOutputType | null
    _avg: AdresseAvgAggregateOutputType | null
    _sum: AdresseSumAggregateOutputType | null
    _min: AdresseMinAggregateOutputType | null
    _max: AdresseMaxAggregateOutputType | null
  }

  export type AdresseAvgAggregateOutputType = {
    id: number | null
    utilisateurId: number | null
    fournisseurId: number | null
  }

  export type AdresseSumAggregateOutputType = {
    id: number | null
    utilisateurId: number | null
    fournisseurId: number | null
  }

  export type AdresseMinAggregateOutputType = {
    id: number | null
    ville: string | null
    commune: string | null
    adresse: string | null
    utilisateurId: number | null
    fournisseurId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdresseMaxAggregateOutputType = {
    id: number | null
    ville: string | null
    commune: string | null
    adresse: string | null
    utilisateurId: number | null
    fournisseurId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdresseCountAggregateOutputType = {
    id: number
    ville: number
    commune: number
    adresse: number
    utilisateurId: number
    fournisseurId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AdresseAvgAggregateInputType = {
    id?: true
    utilisateurId?: true
    fournisseurId?: true
  }

  export type AdresseSumAggregateInputType = {
    id?: true
    utilisateurId?: true
    fournisseurId?: true
  }

  export type AdresseMinAggregateInputType = {
    id?: true
    ville?: true
    commune?: true
    adresse?: true
    utilisateurId?: true
    fournisseurId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdresseMaxAggregateInputType = {
    id?: true
    ville?: true
    commune?: true
    adresse?: true
    utilisateurId?: true
    fournisseurId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdresseCountAggregateInputType = {
    id?: true
    ville?: true
    commune?: true
    adresse?: true
    utilisateurId?: true
    fournisseurId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AdresseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Adresse to aggregate.
     */
    where?: AdresseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Adresses to fetch.
     */
    orderBy?: AdresseOrderByWithRelationInput | AdresseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdresseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Adresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Adresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Adresses
    **/
    _count?: true | AdresseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdresseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdresseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdresseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdresseMaxAggregateInputType
  }

  export type GetAdresseAggregateType<T extends AdresseAggregateArgs> = {
        [P in keyof T & keyof AggregateAdresse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdresse[P]>
      : GetScalarType<T[P], AggregateAdresse[P]>
  }




  export type AdresseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdresseWhereInput
    orderBy?: AdresseOrderByWithAggregationInput | AdresseOrderByWithAggregationInput[]
    by: AdresseScalarFieldEnum[] | AdresseScalarFieldEnum
    having?: AdresseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdresseCountAggregateInputType | true
    _avg?: AdresseAvgAggregateInputType
    _sum?: AdresseSumAggregateInputType
    _min?: AdresseMinAggregateInputType
    _max?: AdresseMaxAggregateInputType
  }

  export type AdresseGroupByOutputType = {
    id: number
    ville: string
    commune: string
    adresse: string
    utilisateurId: number | null
    fournisseurId: number | null
    createdAt: Date
    updatedAt: Date
    _count: AdresseCountAggregateOutputType | null
    _avg: AdresseAvgAggregateOutputType | null
    _sum: AdresseSumAggregateOutputType | null
    _min: AdresseMinAggregateOutputType | null
    _max: AdresseMaxAggregateOutputType | null
  }

  type GetAdresseGroupByPayload<T extends AdresseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdresseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdresseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdresseGroupByOutputType[P]>
            : GetScalarType<T[P], AdresseGroupByOutputType[P]>
        }
      >
    >


  export type AdresseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ville?: boolean
    commune?: boolean
    adresse?: boolean
    utilisateurId?: boolean
    fournisseurId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    utilisateur?: boolean | Adresse$utilisateurArgs<ExtArgs>
    fournisseur?: boolean | Adresse$fournisseurArgs<ExtArgs>
    Reservation?: boolean | Adresse$ReservationArgs<ExtArgs>
    Commande?: boolean | Adresse$CommandeArgs<ExtArgs>
    _count?: boolean | AdresseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adresse"]>

  export type AdresseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ville?: boolean
    commune?: boolean
    adresse?: boolean
    utilisateurId?: boolean
    fournisseurId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    utilisateur?: boolean | Adresse$utilisateurArgs<ExtArgs>
    fournisseur?: boolean | Adresse$fournisseurArgs<ExtArgs>
  }, ExtArgs["result"]["adresse"]>

  export type AdresseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ville?: boolean
    commune?: boolean
    adresse?: boolean
    utilisateurId?: boolean
    fournisseurId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    utilisateur?: boolean | Adresse$utilisateurArgs<ExtArgs>
    fournisseur?: boolean | Adresse$fournisseurArgs<ExtArgs>
  }, ExtArgs["result"]["adresse"]>

  export type AdresseSelectScalar = {
    id?: boolean
    ville?: boolean
    commune?: boolean
    adresse?: boolean
    utilisateurId?: boolean
    fournisseurId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AdresseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ville" | "commune" | "adresse" | "utilisateurId" | "fournisseurId" | "createdAt" | "updatedAt", ExtArgs["result"]["adresse"]>
  export type AdresseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    utilisateur?: boolean | Adresse$utilisateurArgs<ExtArgs>
    fournisseur?: boolean | Adresse$fournisseurArgs<ExtArgs>
    Reservation?: boolean | Adresse$ReservationArgs<ExtArgs>
    Commande?: boolean | Adresse$CommandeArgs<ExtArgs>
    _count?: boolean | AdresseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AdresseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    utilisateur?: boolean | Adresse$utilisateurArgs<ExtArgs>
    fournisseur?: boolean | Adresse$fournisseurArgs<ExtArgs>
  }
  export type AdresseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    utilisateur?: boolean | Adresse$utilisateurArgs<ExtArgs>
    fournisseur?: boolean | Adresse$fournisseurArgs<ExtArgs>
  }

  export type $AdressePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Adresse"
    objects: {
      utilisateur: Prisma.$UtilisateurPayload<ExtArgs> | null
      fournisseur: Prisma.$FournisseurPayload<ExtArgs> | null
      Reservation: Prisma.$ReservationPayload<ExtArgs>[]
      Commande: Prisma.$CommandePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      ville: string
      commune: string
      adresse: string
      utilisateurId: number | null
      fournisseurId: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["adresse"]>
    composites: {}
  }

  type AdresseGetPayload<S extends boolean | null | undefined | AdresseDefaultArgs> = $Result.GetResult<Prisma.$AdressePayload, S>

  type AdresseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdresseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdresseCountAggregateInputType | true
    }

  export interface AdresseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Adresse'], meta: { name: 'Adresse' } }
    /**
     * Find zero or one Adresse that matches the filter.
     * @param {AdresseFindUniqueArgs} args - Arguments to find a Adresse
     * @example
     * // Get one Adresse
     * const adresse = await prisma.adresse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdresseFindUniqueArgs>(args: SelectSubset<T, AdresseFindUniqueArgs<ExtArgs>>): Prisma__AdresseClient<$Result.GetResult<Prisma.$AdressePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Adresse that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdresseFindUniqueOrThrowArgs} args - Arguments to find a Adresse
     * @example
     * // Get one Adresse
     * const adresse = await prisma.adresse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdresseFindUniqueOrThrowArgs>(args: SelectSubset<T, AdresseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdresseClient<$Result.GetResult<Prisma.$AdressePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Adresse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdresseFindFirstArgs} args - Arguments to find a Adresse
     * @example
     * // Get one Adresse
     * const adresse = await prisma.adresse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdresseFindFirstArgs>(args?: SelectSubset<T, AdresseFindFirstArgs<ExtArgs>>): Prisma__AdresseClient<$Result.GetResult<Prisma.$AdressePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Adresse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdresseFindFirstOrThrowArgs} args - Arguments to find a Adresse
     * @example
     * // Get one Adresse
     * const adresse = await prisma.adresse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdresseFindFirstOrThrowArgs>(args?: SelectSubset<T, AdresseFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdresseClient<$Result.GetResult<Prisma.$AdressePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Adresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdresseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Adresses
     * const adresses = await prisma.adresse.findMany()
     * 
     * // Get first 10 Adresses
     * const adresses = await prisma.adresse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adresseWithIdOnly = await prisma.adresse.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdresseFindManyArgs>(args?: SelectSubset<T, AdresseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdressePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Adresse.
     * @param {AdresseCreateArgs} args - Arguments to create a Adresse.
     * @example
     * // Create one Adresse
     * const Adresse = await prisma.adresse.create({
     *   data: {
     *     // ... data to create a Adresse
     *   }
     * })
     * 
     */
    create<T extends AdresseCreateArgs>(args: SelectSubset<T, AdresseCreateArgs<ExtArgs>>): Prisma__AdresseClient<$Result.GetResult<Prisma.$AdressePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Adresses.
     * @param {AdresseCreateManyArgs} args - Arguments to create many Adresses.
     * @example
     * // Create many Adresses
     * const adresse = await prisma.adresse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdresseCreateManyArgs>(args?: SelectSubset<T, AdresseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Adresses and returns the data saved in the database.
     * @param {AdresseCreateManyAndReturnArgs} args - Arguments to create many Adresses.
     * @example
     * // Create many Adresses
     * const adresse = await prisma.adresse.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Adresses and only return the `id`
     * const adresseWithIdOnly = await prisma.adresse.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdresseCreateManyAndReturnArgs>(args?: SelectSubset<T, AdresseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdressePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Adresse.
     * @param {AdresseDeleteArgs} args - Arguments to delete one Adresse.
     * @example
     * // Delete one Adresse
     * const Adresse = await prisma.adresse.delete({
     *   where: {
     *     // ... filter to delete one Adresse
     *   }
     * })
     * 
     */
    delete<T extends AdresseDeleteArgs>(args: SelectSubset<T, AdresseDeleteArgs<ExtArgs>>): Prisma__AdresseClient<$Result.GetResult<Prisma.$AdressePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Adresse.
     * @param {AdresseUpdateArgs} args - Arguments to update one Adresse.
     * @example
     * // Update one Adresse
     * const adresse = await prisma.adresse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdresseUpdateArgs>(args: SelectSubset<T, AdresseUpdateArgs<ExtArgs>>): Prisma__AdresseClient<$Result.GetResult<Prisma.$AdressePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Adresses.
     * @param {AdresseDeleteManyArgs} args - Arguments to filter Adresses to delete.
     * @example
     * // Delete a few Adresses
     * const { count } = await prisma.adresse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdresseDeleteManyArgs>(args?: SelectSubset<T, AdresseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Adresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdresseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Adresses
     * const adresse = await prisma.adresse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdresseUpdateManyArgs>(args: SelectSubset<T, AdresseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Adresses and returns the data updated in the database.
     * @param {AdresseUpdateManyAndReturnArgs} args - Arguments to update many Adresses.
     * @example
     * // Update many Adresses
     * const adresse = await prisma.adresse.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Adresses and only return the `id`
     * const adresseWithIdOnly = await prisma.adresse.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdresseUpdateManyAndReturnArgs>(args: SelectSubset<T, AdresseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdressePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Adresse.
     * @param {AdresseUpsertArgs} args - Arguments to update or create a Adresse.
     * @example
     * // Update or create a Adresse
     * const adresse = await prisma.adresse.upsert({
     *   create: {
     *     // ... data to create a Adresse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Adresse we want to update
     *   }
     * })
     */
    upsert<T extends AdresseUpsertArgs>(args: SelectSubset<T, AdresseUpsertArgs<ExtArgs>>): Prisma__AdresseClient<$Result.GetResult<Prisma.$AdressePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Adresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdresseCountArgs} args - Arguments to filter Adresses to count.
     * @example
     * // Count the number of Adresses
     * const count = await prisma.adresse.count({
     *   where: {
     *     // ... the filter for the Adresses we want to count
     *   }
     * })
    **/
    count<T extends AdresseCountArgs>(
      args?: Subset<T, AdresseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdresseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Adresse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdresseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdresseAggregateArgs>(args: Subset<T, AdresseAggregateArgs>): Prisma.PrismaPromise<GetAdresseAggregateType<T>>

    /**
     * Group by Adresse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdresseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdresseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdresseGroupByArgs['orderBy'] }
        : { orderBy?: AdresseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdresseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdresseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Adresse model
   */
  readonly fields: AdresseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Adresse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdresseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    utilisateur<T extends Adresse$utilisateurArgs<ExtArgs> = {}>(args?: Subset<T, Adresse$utilisateurArgs<ExtArgs>>): Prisma__UtilisateurClient<$Result.GetResult<Prisma.$UtilisateurPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    fournisseur<T extends Adresse$fournisseurArgs<ExtArgs> = {}>(args?: Subset<T, Adresse$fournisseurArgs<ExtArgs>>): Prisma__FournisseurClient<$Result.GetResult<Prisma.$FournisseurPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Reservation<T extends Adresse$ReservationArgs<ExtArgs> = {}>(args?: Subset<T, Adresse$ReservationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Commande<T extends Adresse$CommandeArgs<ExtArgs> = {}>(args?: Subset<T, Adresse$CommandeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommandePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Adresse model
   */
  interface AdresseFieldRefs {
    readonly id: FieldRef<"Adresse", 'Int'>
    readonly ville: FieldRef<"Adresse", 'String'>
    readonly commune: FieldRef<"Adresse", 'String'>
    readonly adresse: FieldRef<"Adresse", 'String'>
    readonly utilisateurId: FieldRef<"Adresse", 'Int'>
    readonly fournisseurId: FieldRef<"Adresse", 'Int'>
    readonly createdAt: FieldRef<"Adresse", 'DateTime'>
    readonly updatedAt: FieldRef<"Adresse", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Adresse findUnique
   */
  export type AdresseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adresse
     */
    select?: AdresseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Adresse
     */
    omit?: AdresseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdresseInclude<ExtArgs> | null
    /**
     * Filter, which Adresse to fetch.
     */
    where: AdresseWhereUniqueInput
  }

  /**
   * Adresse findUniqueOrThrow
   */
  export type AdresseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adresse
     */
    select?: AdresseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Adresse
     */
    omit?: AdresseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdresseInclude<ExtArgs> | null
    /**
     * Filter, which Adresse to fetch.
     */
    where: AdresseWhereUniqueInput
  }

  /**
   * Adresse findFirst
   */
  export type AdresseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adresse
     */
    select?: AdresseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Adresse
     */
    omit?: AdresseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdresseInclude<ExtArgs> | null
    /**
     * Filter, which Adresse to fetch.
     */
    where?: AdresseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Adresses to fetch.
     */
    orderBy?: AdresseOrderByWithRelationInput | AdresseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Adresses.
     */
    cursor?: AdresseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Adresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Adresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Adresses.
     */
    distinct?: AdresseScalarFieldEnum | AdresseScalarFieldEnum[]
  }

  /**
   * Adresse findFirstOrThrow
   */
  export type AdresseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adresse
     */
    select?: AdresseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Adresse
     */
    omit?: AdresseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdresseInclude<ExtArgs> | null
    /**
     * Filter, which Adresse to fetch.
     */
    where?: AdresseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Adresses to fetch.
     */
    orderBy?: AdresseOrderByWithRelationInput | AdresseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Adresses.
     */
    cursor?: AdresseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Adresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Adresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Adresses.
     */
    distinct?: AdresseScalarFieldEnum | AdresseScalarFieldEnum[]
  }

  /**
   * Adresse findMany
   */
  export type AdresseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adresse
     */
    select?: AdresseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Adresse
     */
    omit?: AdresseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdresseInclude<ExtArgs> | null
    /**
     * Filter, which Adresses to fetch.
     */
    where?: AdresseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Adresses to fetch.
     */
    orderBy?: AdresseOrderByWithRelationInput | AdresseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Adresses.
     */
    cursor?: AdresseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Adresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Adresses.
     */
    skip?: number
    distinct?: AdresseScalarFieldEnum | AdresseScalarFieldEnum[]
  }

  /**
   * Adresse create
   */
  export type AdresseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adresse
     */
    select?: AdresseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Adresse
     */
    omit?: AdresseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdresseInclude<ExtArgs> | null
    /**
     * The data needed to create a Adresse.
     */
    data: XOR<AdresseCreateInput, AdresseUncheckedCreateInput>
  }

  /**
   * Adresse createMany
   */
  export type AdresseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Adresses.
     */
    data: AdresseCreateManyInput | AdresseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Adresse createManyAndReturn
   */
  export type AdresseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adresse
     */
    select?: AdresseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Adresse
     */
    omit?: AdresseOmit<ExtArgs> | null
    /**
     * The data used to create many Adresses.
     */
    data: AdresseCreateManyInput | AdresseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdresseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Adresse update
   */
  export type AdresseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adresse
     */
    select?: AdresseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Adresse
     */
    omit?: AdresseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdresseInclude<ExtArgs> | null
    /**
     * The data needed to update a Adresse.
     */
    data: XOR<AdresseUpdateInput, AdresseUncheckedUpdateInput>
    /**
     * Choose, which Adresse to update.
     */
    where: AdresseWhereUniqueInput
  }

  /**
   * Adresse updateMany
   */
  export type AdresseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Adresses.
     */
    data: XOR<AdresseUpdateManyMutationInput, AdresseUncheckedUpdateManyInput>
    /**
     * Filter which Adresses to update
     */
    where?: AdresseWhereInput
    /**
     * Limit how many Adresses to update.
     */
    limit?: number
  }

  /**
   * Adresse updateManyAndReturn
   */
  export type AdresseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adresse
     */
    select?: AdresseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Adresse
     */
    omit?: AdresseOmit<ExtArgs> | null
    /**
     * The data used to update Adresses.
     */
    data: XOR<AdresseUpdateManyMutationInput, AdresseUncheckedUpdateManyInput>
    /**
     * Filter which Adresses to update
     */
    where?: AdresseWhereInput
    /**
     * Limit how many Adresses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdresseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Adresse upsert
   */
  export type AdresseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adresse
     */
    select?: AdresseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Adresse
     */
    omit?: AdresseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdresseInclude<ExtArgs> | null
    /**
     * The filter to search for the Adresse to update in case it exists.
     */
    where: AdresseWhereUniqueInput
    /**
     * In case the Adresse found by the `where` argument doesn't exist, create a new Adresse with this data.
     */
    create: XOR<AdresseCreateInput, AdresseUncheckedCreateInput>
    /**
     * In case the Adresse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdresseUpdateInput, AdresseUncheckedUpdateInput>
  }

  /**
   * Adresse delete
   */
  export type AdresseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adresse
     */
    select?: AdresseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Adresse
     */
    omit?: AdresseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdresseInclude<ExtArgs> | null
    /**
     * Filter which Adresse to delete.
     */
    where: AdresseWhereUniqueInput
  }

  /**
   * Adresse deleteMany
   */
  export type AdresseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Adresses to delete
     */
    where?: AdresseWhereInput
    /**
     * Limit how many Adresses to delete.
     */
    limit?: number
  }

  /**
   * Adresse.utilisateur
   */
  export type Adresse$utilisateurArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Utilisateur
     */
    select?: UtilisateurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Utilisateur
     */
    omit?: UtilisateurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UtilisateurInclude<ExtArgs> | null
    where?: UtilisateurWhereInput
  }

  /**
   * Adresse.fournisseur
   */
  export type Adresse$fournisseurArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fournisseur
     */
    select?: FournisseurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fournisseur
     */
    omit?: FournisseurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FournisseurInclude<ExtArgs> | null
    where?: FournisseurWhereInput
  }

  /**
   * Adresse.Reservation
   */
  export type Adresse$ReservationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    where?: ReservationWhereInput
    orderBy?: ReservationOrderByWithRelationInput | ReservationOrderByWithRelationInput[]
    cursor?: ReservationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReservationScalarFieldEnum | ReservationScalarFieldEnum[]
  }

  /**
   * Adresse.Commande
   */
  export type Adresse$CommandeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commande
     */
    select?: CommandeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Commande
     */
    omit?: CommandeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandeInclude<ExtArgs> | null
    where?: CommandeWhereInput
    orderBy?: CommandeOrderByWithRelationInput | CommandeOrderByWithRelationInput[]
    cursor?: CommandeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommandeScalarFieldEnum | CommandeScalarFieldEnum[]
  }

  /**
   * Adresse without action
   */
  export type AdresseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adresse
     */
    select?: AdresseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Adresse
     */
    omit?: AdresseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdresseInclude<ExtArgs> | null
  }


  /**
   * Model Contact
   */

  export type AggregateContact = {
    _count: ContactCountAggregateOutputType | null
    _avg: ContactAvgAggregateOutputType | null
    _sum: ContactSumAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  export type ContactAvgAggregateOutputType = {
    id: number | null
    utilisateurId: number | null
    fournisseurId: number | null
  }

  export type ContactSumAggregateOutputType = {
    id: number | null
    utilisateurId: number | null
    fournisseurId: number | null
  }

  export type ContactMinAggregateOutputType = {
    id: number | null
    tel: string | null
    utilisateurId: number | null
    fournisseurId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactMaxAggregateOutputType = {
    id: number | null
    tel: string | null
    utilisateurId: number | null
    fournisseurId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactCountAggregateOutputType = {
    id: number
    tel: number
    utilisateurId: number
    fournisseurId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContactAvgAggregateInputType = {
    id?: true
    utilisateurId?: true
    fournisseurId?: true
  }

  export type ContactSumAggregateInputType = {
    id?: true
    utilisateurId?: true
    fournisseurId?: true
  }

  export type ContactMinAggregateInputType = {
    id?: true
    tel?: true
    utilisateurId?: true
    fournisseurId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactMaxAggregateInputType = {
    id?: true
    tel?: true
    utilisateurId?: true
    fournisseurId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactCountAggregateInputType = {
    id?: true
    tel?: true
    utilisateurId?: true
    fournisseurId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contact to aggregate.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contacts
    **/
    _count?: true | ContactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContactAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContactSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactMaxAggregateInputType
  }

  export type GetContactAggregateType<T extends ContactAggregateArgs> = {
        [P in keyof T & keyof AggregateContact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContact[P]>
      : GetScalarType<T[P], AggregateContact[P]>
  }




  export type ContactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithAggregationInput | ContactOrderByWithAggregationInput[]
    by: ContactScalarFieldEnum[] | ContactScalarFieldEnum
    having?: ContactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactCountAggregateInputType | true
    _avg?: ContactAvgAggregateInputType
    _sum?: ContactSumAggregateInputType
    _min?: ContactMinAggregateInputType
    _max?: ContactMaxAggregateInputType
  }

  export type ContactGroupByOutputType = {
    id: number
    tel: string
    utilisateurId: number | null
    fournisseurId: number | null
    createdAt: Date
    updatedAt: Date
    _count: ContactCountAggregateOutputType | null
    _avg: ContactAvgAggregateOutputType | null
    _sum: ContactSumAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  type GetContactGroupByPayload<T extends ContactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactGroupByOutputType[P]>
            : GetScalarType<T[P], ContactGroupByOutputType[P]>
        }
      >
    >


  export type ContactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tel?: boolean
    utilisateurId?: boolean
    fournisseurId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    utilisateur?: boolean | Contact$utilisateurArgs<ExtArgs>
    fournisseur?: boolean | Contact$fournisseurArgs<ExtArgs>
    Reservation?: boolean | Contact$ReservationArgs<ExtArgs>
    Commande?: boolean | Contact$CommandeArgs<ExtArgs>
    _count?: boolean | ContactCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contact"]>

  export type ContactSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tel?: boolean
    utilisateurId?: boolean
    fournisseurId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    utilisateur?: boolean | Contact$utilisateurArgs<ExtArgs>
    fournisseur?: boolean | Contact$fournisseurArgs<ExtArgs>
  }, ExtArgs["result"]["contact"]>

  export type ContactSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tel?: boolean
    utilisateurId?: boolean
    fournisseurId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    utilisateur?: boolean | Contact$utilisateurArgs<ExtArgs>
    fournisseur?: boolean | Contact$fournisseurArgs<ExtArgs>
  }, ExtArgs["result"]["contact"]>

  export type ContactSelectScalar = {
    id?: boolean
    tel?: boolean
    utilisateurId?: boolean
    fournisseurId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContactOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tel" | "utilisateurId" | "fournisseurId" | "createdAt" | "updatedAt", ExtArgs["result"]["contact"]>
  export type ContactInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    utilisateur?: boolean | Contact$utilisateurArgs<ExtArgs>
    fournisseur?: boolean | Contact$fournisseurArgs<ExtArgs>
    Reservation?: boolean | Contact$ReservationArgs<ExtArgs>
    Commande?: boolean | Contact$CommandeArgs<ExtArgs>
    _count?: boolean | ContactCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ContactIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    utilisateur?: boolean | Contact$utilisateurArgs<ExtArgs>
    fournisseur?: boolean | Contact$fournisseurArgs<ExtArgs>
  }
  export type ContactIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    utilisateur?: boolean | Contact$utilisateurArgs<ExtArgs>
    fournisseur?: boolean | Contact$fournisseurArgs<ExtArgs>
  }

  export type $ContactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Contact"
    objects: {
      utilisateur: Prisma.$UtilisateurPayload<ExtArgs> | null
      fournisseur: Prisma.$FournisseurPayload<ExtArgs> | null
      Reservation: Prisma.$ReservationPayload<ExtArgs>[]
      Commande: Prisma.$CommandePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      tel: string
      utilisateurId: number | null
      fournisseurId: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["contact"]>
    composites: {}
  }

  type ContactGetPayload<S extends boolean | null | undefined | ContactDefaultArgs> = $Result.GetResult<Prisma.$ContactPayload, S>

  type ContactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContactFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContactCountAggregateInputType | true
    }

  export interface ContactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Contact'], meta: { name: 'Contact' } }
    /**
     * Find zero or one Contact that matches the filter.
     * @param {ContactFindUniqueArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactFindUniqueArgs>(args: SelectSubset<T, ContactFindUniqueArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Contact that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContactFindUniqueOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindFirstArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactFindFirstArgs>(args?: SelectSubset<T, ContactFindFirstArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindFirstOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Contacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contacts
     * const contacts = await prisma.contact.findMany()
     * 
     * // Get first 10 Contacts
     * const contacts = await prisma.contact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactWithIdOnly = await prisma.contact.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContactFindManyArgs>(args?: SelectSubset<T, ContactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Contact.
     * @param {ContactCreateArgs} args - Arguments to create a Contact.
     * @example
     * // Create one Contact
     * const Contact = await prisma.contact.create({
     *   data: {
     *     // ... data to create a Contact
     *   }
     * })
     * 
     */
    create<T extends ContactCreateArgs>(args: SelectSubset<T, ContactCreateArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Contacts.
     * @param {ContactCreateManyArgs} args - Arguments to create many Contacts.
     * @example
     * // Create many Contacts
     * const contact = await prisma.contact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactCreateManyArgs>(args?: SelectSubset<T, ContactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Contacts and returns the data saved in the database.
     * @param {ContactCreateManyAndReturnArgs} args - Arguments to create many Contacts.
     * @example
     * // Create many Contacts
     * const contact = await prisma.contact.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Contacts and only return the `id`
     * const contactWithIdOnly = await prisma.contact.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContactCreateManyAndReturnArgs>(args?: SelectSubset<T, ContactCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Contact.
     * @param {ContactDeleteArgs} args - Arguments to delete one Contact.
     * @example
     * // Delete one Contact
     * const Contact = await prisma.contact.delete({
     *   where: {
     *     // ... filter to delete one Contact
     *   }
     * })
     * 
     */
    delete<T extends ContactDeleteArgs>(args: SelectSubset<T, ContactDeleteArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Contact.
     * @param {ContactUpdateArgs} args - Arguments to update one Contact.
     * @example
     * // Update one Contact
     * const contact = await prisma.contact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactUpdateArgs>(args: SelectSubset<T, ContactUpdateArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Contacts.
     * @param {ContactDeleteManyArgs} args - Arguments to filter Contacts to delete.
     * @example
     * // Delete a few Contacts
     * const { count } = await prisma.contact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactDeleteManyArgs>(args?: SelectSubset<T, ContactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contacts
     * const contact = await prisma.contact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactUpdateManyArgs>(args: SelectSubset<T, ContactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contacts and returns the data updated in the database.
     * @param {ContactUpdateManyAndReturnArgs} args - Arguments to update many Contacts.
     * @example
     * // Update many Contacts
     * const contact = await prisma.contact.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Contacts and only return the `id`
     * const contactWithIdOnly = await prisma.contact.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContactUpdateManyAndReturnArgs>(args: SelectSubset<T, ContactUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Contact.
     * @param {ContactUpsertArgs} args - Arguments to update or create a Contact.
     * @example
     * // Update or create a Contact
     * const contact = await prisma.contact.upsert({
     *   create: {
     *     // ... data to create a Contact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contact we want to update
     *   }
     * })
     */
    upsert<T extends ContactUpsertArgs>(args: SelectSubset<T, ContactUpsertArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactCountArgs} args - Arguments to filter Contacts to count.
     * @example
     * // Count the number of Contacts
     * const count = await prisma.contact.count({
     *   where: {
     *     // ... the filter for the Contacts we want to count
     *   }
     * })
    **/
    count<T extends ContactCountArgs>(
      args?: Subset<T, ContactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactAggregateArgs>(args: Subset<T, ContactAggregateArgs>): Prisma.PrismaPromise<GetContactAggregateType<T>>

    /**
     * Group by Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactGroupByArgs['orderBy'] }
        : { orderBy?: ContactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Contact model
   */
  readonly fields: ContactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Contact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    utilisateur<T extends Contact$utilisateurArgs<ExtArgs> = {}>(args?: Subset<T, Contact$utilisateurArgs<ExtArgs>>): Prisma__UtilisateurClient<$Result.GetResult<Prisma.$UtilisateurPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    fournisseur<T extends Contact$fournisseurArgs<ExtArgs> = {}>(args?: Subset<T, Contact$fournisseurArgs<ExtArgs>>): Prisma__FournisseurClient<$Result.GetResult<Prisma.$FournisseurPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Reservation<T extends Contact$ReservationArgs<ExtArgs> = {}>(args?: Subset<T, Contact$ReservationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Commande<T extends Contact$CommandeArgs<ExtArgs> = {}>(args?: Subset<T, Contact$CommandeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommandePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Contact model
   */
  interface ContactFieldRefs {
    readonly id: FieldRef<"Contact", 'Int'>
    readonly tel: FieldRef<"Contact", 'String'>
    readonly utilisateurId: FieldRef<"Contact", 'Int'>
    readonly fournisseurId: FieldRef<"Contact", 'Int'>
    readonly createdAt: FieldRef<"Contact", 'DateTime'>
    readonly updatedAt: FieldRef<"Contact", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Contact findUnique
   */
  export type ContactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact findUniqueOrThrow
   */
  export type ContactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact findFirst
   */
  export type ContactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact findFirstOrThrow
   */
  export type ContactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact findMany
   */
  export type ContactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contacts to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact create
   */
  export type ContactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The data needed to create a Contact.
     */
    data: XOR<ContactCreateInput, ContactUncheckedCreateInput>
  }

  /**
   * Contact createMany
   */
  export type ContactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contacts.
     */
    data: ContactCreateManyInput | ContactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contact createManyAndReturn
   */
  export type ContactCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * The data used to create many Contacts.
     */
    data: ContactCreateManyInput | ContactCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Contact update
   */
  export type ContactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The data needed to update a Contact.
     */
    data: XOR<ContactUpdateInput, ContactUncheckedUpdateInput>
    /**
     * Choose, which Contact to update.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact updateMany
   */
  export type ContactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contacts.
     */
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyInput>
    /**
     * Filter which Contacts to update
     */
    where?: ContactWhereInput
    /**
     * Limit how many Contacts to update.
     */
    limit?: number
  }

  /**
   * Contact updateManyAndReturn
   */
  export type ContactUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * The data used to update Contacts.
     */
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyInput>
    /**
     * Filter which Contacts to update
     */
    where?: ContactWhereInput
    /**
     * Limit how many Contacts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Contact upsert
   */
  export type ContactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The filter to search for the Contact to update in case it exists.
     */
    where: ContactWhereUniqueInput
    /**
     * In case the Contact found by the `where` argument doesn't exist, create a new Contact with this data.
     */
    create: XOR<ContactCreateInput, ContactUncheckedCreateInput>
    /**
     * In case the Contact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactUpdateInput, ContactUncheckedUpdateInput>
  }

  /**
   * Contact delete
   */
  export type ContactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter which Contact to delete.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact deleteMany
   */
  export type ContactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contacts to delete
     */
    where?: ContactWhereInput
    /**
     * Limit how many Contacts to delete.
     */
    limit?: number
  }

  /**
   * Contact.utilisateur
   */
  export type Contact$utilisateurArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Utilisateur
     */
    select?: UtilisateurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Utilisateur
     */
    omit?: UtilisateurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UtilisateurInclude<ExtArgs> | null
    where?: UtilisateurWhereInput
  }

  /**
   * Contact.fournisseur
   */
  export type Contact$fournisseurArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fournisseur
     */
    select?: FournisseurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fournisseur
     */
    omit?: FournisseurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FournisseurInclude<ExtArgs> | null
    where?: FournisseurWhereInput
  }

  /**
   * Contact.Reservation
   */
  export type Contact$ReservationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    where?: ReservationWhereInput
    orderBy?: ReservationOrderByWithRelationInput | ReservationOrderByWithRelationInput[]
    cursor?: ReservationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReservationScalarFieldEnum | ReservationScalarFieldEnum[]
  }

  /**
   * Contact.Commande
   */
  export type Contact$CommandeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commande
     */
    select?: CommandeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Commande
     */
    omit?: CommandeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandeInclude<ExtArgs> | null
    where?: CommandeWhereInput
    orderBy?: CommandeOrderByWithRelationInput | CommandeOrderByWithRelationInput[]
    cursor?: CommandeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommandeScalarFieldEnum | CommandeScalarFieldEnum[]
  }

  /**
   * Contact without action
   */
  export type ContactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
  }


  /**
   * Model Fournisseur
   */

  export type AggregateFournisseur = {
    _count: FournisseurCountAggregateOutputType | null
    _avg: FournisseurAvgAggregateOutputType | null
    _sum: FournisseurSumAggregateOutputType | null
    _min: FournisseurMinAggregateOutputType | null
    _max: FournisseurMaxAggregateOutputType | null
  }

  export type FournisseurAvgAggregateOutputType = {
    id: number | null
  }

  export type FournisseurSumAggregateOutputType = {
    id: number | null
  }

  export type FournisseurMinAggregateOutputType = {
    id: number | null
    nom: string | null
    email: string | null
    code_postal: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FournisseurMaxAggregateOutputType = {
    id: number | null
    nom: string | null
    email: string | null
    code_postal: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FournisseurCountAggregateOutputType = {
    id: number
    nom: number
    email: number
    code_postal: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FournisseurAvgAggregateInputType = {
    id?: true
  }

  export type FournisseurSumAggregateInputType = {
    id?: true
  }

  export type FournisseurMinAggregateInputType = {
    id?: true
    nom?: true
    email?: true
    code_postal?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FournisseurMaxAggregateInputType = {
    id?: true
    nom?: true
    email?: true
    code_postal?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FournisseurCountAggregateInputType = {
    id?: true
    nom?: true
    email?: true
    code_postal?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FournisseurAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Fournisseur to aggregate.
     */
    where?: FournisseurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fournisseurs to fetch.
     */
    orderBy?: FournisseurOrderByWithRelationInput | FournisseurOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FournisseurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fournisseurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fournisseurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Fournisseurs
    **/
    _count?: true | FournisseurCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FournisseurAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FournisseurSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FournisseurMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FournisseurMaxAggregateInputType
  }

  export type GetFournisseurAggregateType<T extends FournisseurAggregateArgs> = {
        [P in keyof T & keyof AggregateFournisseur]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFournisseur[P]>
      : GetScalarType<T[P], AggregateFournisseur[P]>
  }




  export type FournisseurGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FournisseurWhereInput
    orderBy?: FournisseurOrderByWithAggregationInput | FournisseurOrderByWithAggregationInput[]
    by: FournisseurScalarFieldEnum[] | FournisseurScalarFieldEnum
    having?: FournisseurScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FournisseurCountAggregateInputType | true
    _avg?: FournisseurAvgAggregateInputType
    _sum?: FournisseurSumAggregateInputType
    _min?: FournisseurMinAggregateInputType
    _max?: FournisseurMaxAggregateInputType
  }

  export type FournisseurGroupByOutputType = {
    id: number
    nom: string
    email: string
    code_postal: string | null
    createdAt: Date
    updatedAt: Date
    _count: FournisseurCountAggregateOutputType | null
    _avg: FournisseurAvgAggregateOutputType | null
    _sum: FournisseurSumAggregateOutputType | null
    _min: FournisseurMinAggregateOutputType | null
    _max: FournisseurMaxAggregateOutputType | null
  }

  type GetFournisseurGroupByPayload<T extends FournisseurGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FournisseurGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FournisseurGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FournisseurGroupByOutputType[P]>
            : GetScalarType<T[P], FournisseurGroupByOutputType[P]>
        }
      >
    >


  export type FournisseurSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    email?: boolean
    code_postal?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Vente?: boolean | Fournisseur$VenteArgs<ExtArgs>
    Achat?: boolean | Fournisseur$AchatArgs<ExtArgs>
    Adresse?: boolean | Fournisseur$AdresseArgs<ExtArgs>
    Contact?: boolean | Fournisseur$ContactArgs<ExtArgs>
    Reservation?: boolean | Fournisseur$ReservationArgs<ExtArgs>
    Commande?: boolean | Fournisseur$CommandeArgs<ExtArgs>
    _count?: boolean | FournisseurCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fournisseur"]>

  export type FournisseurSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    email?: boolean
    code_postal?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["fournisseur"]>

  export type FournisseurSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    email?: boolean
    code_postal?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["fournisseur"]>

  export type FournisseurSelectScalar = {
    id?: boolean
    nom?: boolean
    email?: boolean
    code_postal?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FournisseurOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nom" | "email" | "code_postal" | "createdAt" | "updatedAt", ExtArgs["result"]["fournisseur"]>
  export type FournisseurInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Vente?: boolean | Fournisseur$VenteArgs<ExtArgs>
    Achat?: boolean | Fournisseur$AchatArgs<ExtArgs>
    Adresse?: boolean | Fournisseur$AdresseArgs<ExtArgs>
    Contact?: boolean | Fournisseur$ContactArgs<ExtArgs>
    Reservation?: boolean | Fournisseur$ReservationArgs<ExtArgs>
    Commande?: boolean | Fournisseur$CommandeArgs<ExtArgs>
    _count?: boolean | FournisseurCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FournisseurIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type FournisseurIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $FournisseurPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Fournisseur"
    objects: {
      Vente: Prisma.$VentePayload<ExtArgs>[]
      Achat: Prisma.$AchatPayload<ExtArgs>[]
      Adresse: Prisma.$AdressePayload<ExtArgs>[]
      Contact: Prisma.$ContactPayload<ExtArgs>[]
      Reservation: Prisma.$ReservationPayload<ExtArgs>[]
      Commande: Prisma.$CommandePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nom: string
      email: string
      code_postal: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["fournisseur"]>
    composites: {}
  }

  type FournisseurGetPayload<S extends boolean | null | undefined | FournisseurDefaultArgs> = $Result.GetResult<Prisma.$FournisseurPayload, S>

  type FournisseurCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FournisseurFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FournisseurCountAggregateInputType | true
    }

  export interface FournisseurDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Fournisseur'], meta: { name: 'Fournisseur' } }
    /**
     * Find zero or one Fournisseur that matches the filter.
     * @param {FournisseurFindUniqueArgs} args - Arguments to find a Fournisseur
     * @example
     * // Get one Fournisseur
     * const fournisseur = await prisma.fournisseur.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FournisseurFindUniqueArgs>(args: SelectSubset<T, FournisseurFindUniqueArgs<ExtArgs>>): Prisma__FournisseurClient<$Result.GetResult<Prisma.$FournisseurPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Fournisseur that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FournisseurFindUniqueOrThrowArgs} args - Arguments to find a Fournisseur
     * @example
     * // Get one Fournisseur
     * const fournisseur = await prisma.fournisseur.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FournisseurFindUniqueOrThrowArgs>(args: SelectSubset<T, FournisseurFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FournisseurClient<$Result.GetResult<Prisma.$FournisseurPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Fournisseur that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FournisseurFindFirstArgs} args - Arguments to find a Fournisseur
     * @example
     * // Get one Fournisseur
     * const fournisseur = await prisma.fournisseur.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FournisseurFindFirstArgs>(args?: SelectSubset<T, FournisseurFindFirstArgs<ExtArgs>>): Prisma__FournisseurClient<$Result.GetResult<Prisma.$FournisseurPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Fournisseur that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FournisseurFindFirstOrThrowArgs} args - Arguments to find a Fournisseur
     * @example
     * // Get one Fournisseur
     * const fournisseur = await prisma.fournisseur.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FournisseurFindFirstOrThrowArgs>(args?: SelectSubset<T, FournisseurFindFirstOrThrowArgs<ExtArgs>>): Prisma__FournisseurClient<$Result.GetResult<Prisma.$FournisseurPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Fournisseurs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FournisseurFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Fournisseurs
     * const fournisseurs = await prisma.fournisseur.findMany()
     * 
     * // Get first 10 Fournisseurs
     * const fournisseurs = await prisma.fournisseur.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fournisseurWithIdOnly = await prisma.fournisseur.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FournisseurFindManyArgs>(args?: SelectSubset<T, FournisseurFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FournisseurPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Fournisseur.
     * @param {FournisseurCreateArgs} args - Arguments to create a Fournisseur.
     * @example
     * // Create one Fournisseur
     * const Fournisseur = await prisma.fournisseur.create({
     *   data: {
     *     // ... data to create a Fournisseur
     *   }
     * })
     * 
     */
    create<T extends FournisseurCreateArgs>(args: SelectSubset<T, FournisseurCreateArgs<ExtArgs>>): Prisma__FournisseurClient<$Result.GetResult<Prisma.$FournisseurPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Fournisseurs.
     * @param {FournisseurCreateManyArgs} args - Arguments to create many Fournisseurs.
     * @example
     * // Create many Fournisseurs
     * const fournisseur = await prisma.fournisseur.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FournisseurCreateManyArgs>(args?: SelectSubset<T, FournisseurCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Fournisseurs and returns the data saved in the database.
     * @param {FournisseurCreateManyAndReturnArgs} args - Arguments to create many Fournisseurs.
     * @example
     * // Create many Fournisseurs
     * const fournisseur = await prisma.fournisseur.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Fournisseurs and only return the `id`
     * const fournisseurWithIdOnly = await prisma.fournisseur.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FournisseurCreateManyAndReturnArgs>(args?: SelectSubset<T, FournisseurCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FournisseurPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Fournisseur.
     * @param {FournisseurDeleteArgs} args - Arguments to delete one Fournisseur.
     * @example
     * // Delete one Fournisseur
     * const Fournisseur = await prisma.fournisseur.delete({
     *   where: {
     *     // ... filter to delete one Fournisseur
     *   }
     * })
     * 
     */
    delete<T extends FournisseurDeleteArgs>(args: SelectSubset<T, FournisseurDeleteArgs<ExtArgs>>): Prisma__FournisseurClient<$Result.GetResult<Prisma.$FournisseurPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Fournisseur.
     * @param {FournisseurUpdateArgs} args - Arguments to update one Fournisseur.
     * @example
     * // Update one Fournisseur
     * const fournisseur = await prisma.fournisseur.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FournisseurUpdateArgs>(args: SelectSubset<T, FournisseurUpdateArgs<ExtArgs>>): Prisma__FournisseurClient<$Result.GetResult<Prisma.$FournisseurPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Fournisseurs.
     * @param {FournisseurDeleteManyArgs} args - Arguments to filter Fournisseurs to delete.
     * @example
     * // Delete a few Fournisseurs
     * const { count } = await prisma.fournisseur.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FournisseurDeleteManyArgs>(args?: SelectSubset<T, FournisseurDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fournisseurs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FournisseurUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Fournisseurs
     * const fournisseur = await prisma.fournisseur.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FournisseurUpdateManyArgs>(args: SelectSubset<T, FournisseurUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fournisseurs and returns the data updated in the database.
     * @param {FournisseurUpdateManyAndReturnArgs} args - Arguments to update many Fournisseurs.
     * @example
     * // Update many Fournisseurs
     * const fournisseur = await prisma.fournisseur.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Fournisseurs and only return the `id`
     * const fournisseurWithIdOnly = await prisma.fournisseur.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FournisseurUpdateManyAndReturnArgs>(args: SelectSubset<T, FournisseurUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FournisseurPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Fournisseur.
     * @param {FournisseurUpsertArgs} args - Arguments to update or create a Fournisseur.
     * @example
     * // Update or create a Fournisseur
     * const fournisseur = await prisma.fournisseur.upsert({
     *   create: {
     *     // ... data to create a Fournisseur
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Fournisseur we want to update
     *   }
     * })
     */
    upsert<T extends FournisseurUpsertArgs>(args: SelectSubset<T, FournisseurUpsertArgs<ExtArgs>>): Prisma__FournisseurClient<$Result.GetResult<Prisma.$FournisseurPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Fournisseurs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FournisseurCountArgs} args - Arguments to filter Fournisseurs to count.
     * @example
     * // Count the number of Fournisseurs
     * const count = await prisma.fournisseur.count({
     *   where: {
     *     // ... the filter for the Fournisseurs we want to count
     *   }
     * })
    **/
    count<T extends FournisseurCountArgs>(
      args?: Subset<T, FournisseurCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FournisseurCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Fournisseur.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FournisseurAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FournisseurAggregateArgs>(args: Subset<T, FournisseurAggregateArgs>): Prisma.PrismaPromise<GetFournisseurAggregateType<T>>

    /**
     * Group by Fournisseur.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FournisseurGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FournisseurGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FournisseurGroupByArgs['orderBy'] }
        : { orderBy?: FournisseurGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FournisseurGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFournisseurGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Fournisseur model
   */
  readonly fields: FournisseurFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Fournisseur.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FournisseurClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Vente<T extends Fournisseur$VenteArgs<ExtArgs> = {}>(args?: Subset<T, Fournisseur$VenteArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VentePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Achat<T extends Fournisseur$AchatArgs<ExtArgs> = {}>(args?: Subset<T, Fournisseur$AchatArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Adresse<T extends Fournisseur$AdresseArgs<ExtArgs> = {}>(args?: Subset<T, Fournisseur$AdresseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdressePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Contact<T extends Fournisseur$ContactArgs<ExtArgs> = {}>(args?: Subset<T, Fournisseur$ContactArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Reservation<T extends Fournisseur$ReservationArgs<ExtArgs> = {}>(args?: Subset<T, Fournisseur$ReservationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Commande<T extends Fournisseur$CommandeArgs<ExtArgs> = {}>(args?: Subset<T, Fournisseur$CommandeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommandePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Fournisseur model
   */
  interface FournisseurFieldRefs {
    readonly id: FieldRef<"Fournisseur", 'Int'>
    readonly nom: FieldRef<"Fournisseur", 'String'>
    readonly email: FieldRef<"Fournisseur", 'String'>
    readonly code_postal: FieldRef<"Fournisseur", 'String'>
    readonly createdAt: FieldRef<"Fournisseur", 'DateTime'>
    readonly updatedAt: FieldRef<"Fournisseur", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Fournisseur findUnique
   */
  export type FournisseurFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fournisseur
     */
    select?: FournisseurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fournisseur
     */
    omit?: FournisseurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FournisseurInclude<ExtArgs> | null
    /**
     * Filter, which Fournisseur to fetch.
     */
    where: FournisseurWhereUniqueInput
  }

  /**
   * Fournisseur findUniqueOrThrow
   */
  export type FournisseurFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fournisseur
     */
    select?: FournisseurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fournisseur
     */
    omit?: FournisseurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FournisseurInclude<ExtArgs> | null
    /**
     * Filter, which Fournisseur to fetch.
     */
    where: FournisseurWhereUniqueInput
  }

  /**
   * Fournisseur findFirst
   */
  export type FournisseurFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fournisseur
     */
    select?: FournisseurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fournisseur
     */
    omit?: FournisseurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FournisseurInclude<ExtArgs> | null
    /**
     * Filter, which Fournisseur to fetch.
     */
    where?: FournisseurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fournisseurs to fetch.
     */
    orderBy?: FournisseurOrderByWithRelationInput | FournisseurOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Fournisseurs.
     */
    cursor?: FournisseurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fournisseurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fournisseurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Fournisseurs.
     */
    distinct?: FournisseurScalarFieldEnum | FournisseurScalarFieldEnum[]
  }

  /**
   * Fournisseur findFirstOrThrow
   */
  export type FournisseurFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fournisseur
     */
    select?: FournisseurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fournisseur
     */
    omit?: FournisseurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FournisseurInclude<ExtArgs> | null
    /**
     * Filter, which Fournisseur to fetch.
     */
    where?: FournisseurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fournisseurs to fetch.
     */
    orderBy?: FournisseurOrderByWithRelationInput | FournisseurOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Fournisseurs.
     */
    cursor?: FournisseurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fournisseurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fournisseurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Fournisseurs.
     */
    distinct?: FournisseurScalarFieldEnum | FournisseurScalarFieldEnum[]
  }

  /**
   * Fournisseur findMany
   */
  export type FournisseurFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fournisseur
     */
    select?: FournisseurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fournisseur
     */
    omit?: FournisseurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FournisseurInclude<ExtArgs> | null
    /**
     * Filter, which Fournisseurs to fetch.
     */
    where?: FournisseurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fournisseurs to fetch.
     */
    orderBy?: FournisseurOrderByWithRelationInput | FournisseurOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Fournisseurs.
     */
    cursor?: FournisseurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fournisseurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fournisseurs.
     */
    skip?: number
    distinct?: FournisseurScalarFieldEnum | FournisseurScalarFieldEnum[]
  }

  /**
   * Fournisseur create
   */
  export type FournisseurCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fournisseur
     */
    select?: FournisseurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fournisseur
     */
    omit?: FournisseurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FournisseurInclude<ExtArgs> | null
    /**
     * The data needed to create a Fournisseur.
     */
    data: XOR<FournisseurCreateInput, FournisseurUncheckedCreateInput>
  }

  /**
   * Fournisseur createMany
   */
  export type FournisseurCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Fournisseurs.
     */
    data: FournisseurCreateManyInput | FournisseurCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Fournisseur createManyAndReturn
   */
  export type FournisseurCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fournisseur
     */
    select?: FournisseurSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Fournisseur
     */
    omit?: FournisseurOmit<ExtArgs> | null
    /**
     * The data used to create many Fournisseurs.
     */
    data: FournisseurCreateManyInput | FournisseurCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Fournisseur update
   */
  export type FournisseurUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fournisseur
     */
    select?: FournisseurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fournisseur
     */
    omit?: FournisseurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FournisseurInclude<ExtArgs> | null
    /**
     * The data needed to update a Fournisseur.
     */
    data: XOR<FournisseurUpdateInput, FournisseurUncheckedUpdateInput>
    /**
     * Choose, which Fournisseur to update.
     */
    where: FournisseurWhereUniqueInput
  }

  /**
   * Fournisseur updateMany
   */
  export type FournisseurUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Fournisseurs.
     */
    data: XOR<FournisseurUpdateManyMutationInput, FournisseurUncheckedUpdateManyInput>
    /**
     * Filter which Fournisseurs to update
     */
    where?: FournisseurWhereInput
    /**
     * Limit how many Fournisseurs to update.
     */
    limit?: number
  }

  /**
   * Fournisseur updateManyAndReturn
   */
  export type FournisseurUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fournisseur
     */
    select?: FournisseurSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Fournisseur
     */
    omit?: FournisseurOmit<ExtArgs> | null
    /**
     * The data used to update Fournisseurs.
     */
    data: XOR<FournisseurUpdateManyMutationInput, FournisseurUncheckedUpdateManyInput>
    /**
     * Filter which Fournisseurs to update
     */
    where?: FournisseurWhereInput
    /**
     * Limit how many Fournisseurs to update.
     */
    limit?: number
  }

  /**
   * Fournisseur upsert
   */
  export type FournisseurUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fournisseur
     */
    select?: FournisseurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fournisseur
     */
    omit?: FournisseurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FournisseurInclude<ExtArgs> | null
    /**
     * The filter to search for the Fournisseur to update in case it exists.
     */
    where: FournisseurWhereUniqueInput
    /**
     * In case the Fournisseur found by the `where` argument doesn't exist, create a new Fournisseur with this data.
     */
    create: XOR<FournisseurCreateInput, FournisseurUncheckedCreateInput>
    /**
     * In case the Fournisseur was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FournisseurUpdateInput, FournisseurUncheckedUpdateInput>
  }

  /**
   * Fournisseur delete
   */
  export type FournisseurDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fournisseur
     */
    select?: FournisseurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fournisseur
     */
    omit?: FournisseurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FournisseurInclude<ExtArgs> | null
    /**
     * Filter which Fournisseur to delete.
     */
    where: FournisseurWhereUniqueInput
  }

  /**
   * Fournisseur deleteMany
   */
  export type FournisseurDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Fournisseurs to delete
     */
    where?: FournisseurWhereInput
    /**
     * Limit how many Fournisseurs to delete.
     */
    limit?: number
  }

  /**
   * Fournisseur.Vente
   */
  export type Fournisseur$VenteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vente
     */
    select?: VenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vente
     */
    omit?: VenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenteInclude<ExtArgs> | null
    where?: VenteWhereInput
    orderBy?: VenteOrderByWithRelationInput | VenteOrderByWithRelationInput[]
    cursor?: VenteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VenteScalarFieldEnum | VenteScalarFieldEnum[]
  }

  /**
   * Fournisseur.Achat
   */
  export type Fournisseur$AchatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achat
     */
    select?: AchatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achat
     */
    omit?: AchatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchatInclude<ExtArgs> | null
    where?: AchatWhereInput
    orderBy?: AchatOrderByWithRelationInput | AchatOrderByWithRelationInput[]
    cursor?: AchatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AchatScalarFieldEnum | AchatScalarFieldEnum[]
  }

  /**
   * Fournisseur.Adresse
   */
  export type Fournisseur$AdresseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adresse
     */
    select?: AdresseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Adresse
     */
    omit?: AdresseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdresseInclude<ExtArgs> | null
    where?: AdresseWhereInput
    orderBy?: AdresseOrderByWithRelationInput | AdresseOrderByWithRelationInput[]
    cursor?: AdresseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdresseScalarFieldEnum | AdresseScalarFieldEnum[]
  }

  /**
   * Fournisseur.Contact
   */
  export type Fournisseur$ContactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    cursor?: ContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Fournisseur.Reservation
   */
  export type Fournisseur$ReservationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    where?: ReservationWhereInput
    orderBy?: ReservationOrderByWithRelationInput | ReservationOrderByWithRelationInput[]
    cursor?: ReservationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReservationScalarFieldEnum | ReservationScalarFieldEnum[]
  }

  /**
   * Fournisseur.Commande
   */
  export type Fournisseur$CommandeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commande
     */
    select?: CommandeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Commande
     */
    omit?: CommandeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandeInclude<ExtArgs> | null
    where?: CommandeWhereInput
    orderBy?: CommandeOrderByWithRelationInput | CommandeOrderByWithRelationInput[]
    cursor?: CommandeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommandeScalarFieldEnum | CommandeScalarFieldEnum[]
  }

  /**
   * Fournisseur without action
   */
  export type FournisseurDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fournisseur
     */
    select?: FournisseurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fournisseur
     */
    omit?: FournisseurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FournisseurInclude<ExtArgs> | null
  }


  /**
   * Model Teneur
   */

  export type AggregateTeneur = {
    _count: TeneurCountAggregateOutputType | null
    _avg: TeneurAvgAggregateOutputType | null
    _sum: TeneurSumAggregateOutputType | null
    _min: TeneurMinAggregateOutputType | null
    _max: TeneurMaxAggregateOutputType | null
  }

  export type TeneurAvgAggregateOutputType = {
    id: number | null
    valeur: number | null
    utilisateurId: number | null
  }

  export type TeneurSumAggregateOutputType = {
    id: number | null
    valeur: number | null
    utilisateurId: number | null
  }

  export type TeneurMinAggregateOutputType = {
    id: number | null
    valeur: number | null
    utilisateurId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeneurMaxAggregateOutputType = {
    id: number | null
    valeur: number | null
    utilisateurId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeneurCountAggregateOutputType = {
    id: number
    valeur: number
    utilisateurId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TeneurAvgAggregateInputType = {
    id?: true
    valeur?: true
    utilisateurId?: true
  }

  export type TeneurSumAggregateInputType = {
    id?: true
    valeur?: true
    utilisateurId?: true
  }

  export type TeneurMinAggregateInputType = {
    id?: true
    valeur?: true
    utilisateurId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeneurMaxAggregateInputType = {
    id?: true
    valeur?: true
    utilisateurId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeneurCountAggregateInputType = {
    id?: true
    valeur?: true
    utilisateurId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TeneurAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Teneur to aggregate.
     */
    where?: TeneurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teneurs to fetch.
     */
    orderBy?: TeneurOrderByWithRelationInput | TeneurOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeneurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teneurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teneurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Teneurs
    **/
    _count?: true | TeneurCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TeneurAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TeneurSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeneurMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeneurMaxAggregateInputType
  }

  export type GetTeneurAggregateType<T extends TeneurAggregateArgs> = {
        [P in keyof T & keyof AggregateTeneur]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeneur[P]>
      : GetScalarType<T[P], AggregateTeneur[P]>
  }




  export type TeneurGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeneurWhereInput
    orderBy?: TeneurOrderByWithAggregationInput | TeneurOrderByWithAggregationInput[]
    by: TeneurScalarFieldEnum[] | TeneurScalarFieldEnum
    having?: TeneurScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeneurCountAggregateInputType | true
    _avg?: TeneurAvgAggregateInputType
    _sum?: TeneurSumAggregateInputType
    _min?: TeneurMinAggregateInputType
    _max?: TeneurMaxAggregateInputType
  }

  export type TeneurGroupByOutputType = {
    id: number
    valeur: number
    utilisateurId: number
    createdAt: Date
    updatedAt: Date
    _count: TeneurCountAggregateOutputType | null
    _avg: TeneurAvgAggregateOutputType | null
    _sum: TeneurSumAggregateOutputType | null
    _min: TeneurMinAggregateOutputType | null
    _max: TeneurMaxAggregateOutputType | null
  }

  type GetTeneurGroupByPayload<T extends TeneurGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeneurGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeneurGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeneurGroupByOutputType[P]>
            : GetScalarType<T[P], TeneurGroupByOutputType[P]>
        }
      >
    >


  export type TeneurSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    valeur?: boolean
    utilisateurId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    utilisateur?: boolean | UtilisateurDefaultArgs<ExtArgs>
    Produit?: boolean | Teneur$ProduitArgs<ExtArgs>
    DetailClotureCaisse?: boolean | Teneur$DetailClotureCaisseArgs<ExtArgs>
    _count?: boolean | TeneurCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teneur"]>

  export type TeneurSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    valeur?: boolean
    utilisateurId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    utilisateur?: boolean | UtilisateurDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teneur"]>

  export type TeneurSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    valeur?: boolean
    utilisateurId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    utilisateur?: boolean | UtilisateurDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teneur"]>

  export type TeneurSelectScalar = {
    id?: boolean
    valeur?: boolean
    utilisateurId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TeneurOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "valeur" | "utilisateurId" | "createdAt" | "updatedAt", ExtArgs["result"]["teneur"]>
  export type TeneurInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    utilisateur?: boolean | UtilisateurDefaultArgs<ExtArgs>
    Produit?: boolean | Teneur$ProduitArgs<ExtArgs>
    DetailClotureCaisse?: boolean | Teneur$DetailClotureCaisseArgs<ExtArgs>
    _count?: boolean | TeneurCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TeneurIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    utilisateur?: boolean | UtilisateurDefaultArgs<ExtArgs>
  }
  export type TeneurIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    utilisateur?: boolean | UtilisateurDefaultArgs<ExtArgs>
  }

  export type $TeneurPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Teneur"
    objects: {
      utilisateur: Prisma.$UtilisateurPayload<ExtArgs>
      Produit: Prisma.$ProduitPayload<ExtArgs>[]
      DetailClotureCaisse: Prisma.$DetailClotureCaissePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      valeur: number
      utilisateurId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["teneur"]>
    composites: {}
  }

  type TeneurGetPayload<S extends boolean | null | undefined | TeneurDefaultArgs> = $Result.GetResult<Prisma.$TeneurPayload, S>

  type TeneurCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TeneurFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeneurCountAggregateInputType | true
    }

  export interface TeneurDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Teneur'], meta: { name: 'Teneur' } }
    /**
     * Find zero or one Teneur that matches the filter.
     * @param {TeneurFindUniqueArgs} args - Arguments to find a Teneur
     * @example
     * // Get one Teneur
     * const teneur = await prisma.teneur.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeneurFindUniqueArgs>(args: SelectSubset<T, TeneurFindUniqueArgs<ExtArgs>>): Prisma__TeneurClient<$Result.GetResult<Prisma.$TeneurPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Teneur that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeneurFindUniqueOrThrowArgs} args - Arguments to find a Teneur
     * @example
     * // Get one Teneur
     * const teneur = await prisma.teneur.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeneurFindUniqueOrThrowArgs>(args: SelectSubset<T, TeneurFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeneurClient<$Result.GetResult<Prisma.$TeneurPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Teneur that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeneurFindFirstArgs} args - Arguments to find a Teneur
     * @example
     * // Get one Teneur
     * const teneur = await prisma.teneur.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeneurFindFirstArgs>(args?: SelectSubset<T, TeneurFindFirstArgs<ExtArgs>>): Prisma__TeneurClient<$Result.GetResult<Prisma.$TeneurPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Teneur that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeneurFindFirstOrThrowArgs} args - Arguments to find a Teneur
     * @example
     * // Get one Teneur
     * const teneur = await prisma.teneur.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeneurFindFirstOrThrowArgs>(args?: SelectSubset<T, TeneurFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeneurClient<$Result.GetResult<Prisma.$TeneurPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Teneurs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeneurFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teneurs
     * const teneurs = await prisma.teneur.findMany()
     * 
     * // Get first 10 Teneurs
     * const teneurs = await prisma.teneur.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teneurWithIdOnly = await prisma.teneur.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeneurFindManyArgs>(args?: SelectSubset<T, TeneurFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeneurPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Teneur.
     * @param {TeneurCreateArgs} args - Arguments to create a Teneur.
     * @example
     * // Create one Teneur
     * const Teneur = await prisma.teneur.create({
     *   data: {
     *     // ... data to create a Teneur
     *   }
     * })
     * 
     */
    create<T extends TeneurCreateArgs>(args: SelectSubset<T, TeneurCreateArgs<ExtArgs>>): Prisma__TeneurClient<$Result.GetResult<Prisma.$TeneurPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Teneurs.
     * @param {TeneurCreateManyArgs} args - Arguments to create many Teneurs.
     * @example
     * // Create many Teneurs
     * const teneur = await prisma.teneur.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeneurCreateManyArgs>(args?: SelectSubset<T, TeneurCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Teneurs and returns the data saved in the database.
     * @param {TeneurCreateManyAndReturnArgs} args - Arguments to create many Teneurs.
     * @example
     * // Create many Teneurs
     * const teneur = await prisma.teneur.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Teneurs and only return the `id`
     * const teneurWithIdOnly = await prisma.teneur.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeneurCreateManyAndReturnArgs>(args?: SelectSubset<T, TeneurCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeneurPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Teneur.
     * @param {TeneurDeleteArgs} args - Arguments to delete one Teneur.
     * @example
     * // Delete one Teneur
     * const Teneur = await prisma.teneur.delete({
     *   where: {
     *     // ... filter to delete one Teneur
     *   }
     * })
     * 
     */
    delete<T extends TeneurDeleteArgs>(args: SelectSubset<T, TeneurDeleteArgs<ExtArgs>>): Prisma__TeneurClient<$Result.GetResult<Prisma.$TeneurPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Teneur.
     * @param {TeneurUpdateArgs} args - Arguments to update one Teneur.
     * @example
     * // Update one Teneur
     * const teneur = await prisma.teneur.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeneurUpdateArgs>(args: SelectSubset<T, TeneurUpdateArgs<ExtArgs>>): Prisma__TeneurClient<$Result.GetResult<Prisma.$TeneurPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Teneurs.
     * @param {TeneurDeleteManyArgs} args - Arguments to filter Teneurs to delete.
     * @example
     * // Delete a few Teneurs
     * const { count } = await prisma.teneur.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeneurDeleteManyArgs>(args?: SelectSubset<T, TeneurDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teneurs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeneurUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teneurs
     * const teneur = await prisma.teneur.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeneurUpdateManyArgs>(args: SelectSubset<T, TeneurUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teneurs and returns the data updated in the database.
     * @param {TeneurUpdateManyAndReturnArgs} args - Arguments to update many Teneurs.
     * @example
     * // Update many Teneurs
     * const teneur = await prisma.teneur.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Teneurs and only return the `id`
     * const teneurWithIdOnly = await prisma.teneur.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TeneurUpdateManyAndReturnArgs>(args: SelectSubset<T, TeneurUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeneurPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Teneur.
     * @param {TeneurUpsertArgs} args - Arguments to update or create a Teneur.
     * @example
     * // Update or create a Teneur
     * const teneur = await prisma.teneur.upsert({
     *   create: {
     *     // ... data to create a Teneur
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Teneur we want to update
     *   }
     * })
     */
    upsert<T extends TeneurUpsertArgs>(args: SelectSubset<T, TeneurUpsertArgs<ExtArgs>>): Prisma__TeneurClient<$Result.GetResult<Prisma.$TeneurPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Teneurs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeneurCountArgs} args - Arguments to filter Teneurs to count.
     * @example
     * // Count the number of Teneurs
     * const count = await prisma.teneur.count({
     *   where: {
     *     // ... the filter for the Teneurs we want to count
     *   }
     * })
    **/
    count<T extends TeneurCountArgs>(
      args?: Subset<T, TeneurCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeneurCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Teneur.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeneurAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeneurAggregateArgs>(args: Subset<T, TeneurAggregateArgs>): Prisma.PrismaPromise<GetTeneurAggregateType<T>>

    /**
     * Group by Teneur.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeneurGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeneurGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeneurGroupByArgs['orderBy'] }
        : { orderBy?: TeneurGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeneurGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeneurGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Teneur model
   */
  readonly fields: TeneurFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Teneur.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeneurClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    utilisateur<T extends UtilisateurDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UtilisateurDefaultArgs<ExtArgs>>): Prisma__UtilisateurClient<$Result.GetResult<Prisma.$UtilisateurPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Produit<T extends Teneur$ProduitArgs<ExtArgs> = {}>(args?: Subset<T, Teneur$ProduitArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProduitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    DetailClotureCaisse<T extends Teneur$DetailClotureCaisseArgs<ExtArgs> = {}>(args?: Subset<T, Teneur$DetailClotureCaisseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DetailClotureCaissePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Teneur model
   */
  interface TeneurFieldRefs {
    readonly id: FieldRef<"Teneur", 'Int'>
    readonly valeur: FieldRef<"Teneur", 'Float'>
    readonly utilisateurId: FieldRef<"Teneur", 'Int'>
    readonly createdAt: FieldRef<"Teneur", 'DateTime'>
    readonly updatedAt: FieldRef<"Teneur", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Teneur findUnique
   */
  export type TeneurFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teneur
     */
    select?: TeneurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teneur
     */
    omit?: TeneurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeneurInclude<ExtArgs> | null
    /**
     * Filter, which Teneur to fetch.
     */
    where: TeneurWhereUniqueInput
  }

  /**
   * Teneur findUniqueOrThrow
   */
  export type TeneurFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teneur
     */
    select?: TeneurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teneur
     */
    omit?: TeneurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeneurInclude<ExtArgs> | null
    /**
     * Filter, which Teneur to fetch.
     */
    where: TeneurWhereUniqueInput
  }

  /**
   * Teneur findFirst
   */
  export type TeneurFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teneur
     */
    select?: TeneurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teneur
     */
    omit?: TeneurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeneurInclude<ExtArgs> | null
    /**
     * Filter, which Teneur to fetch.
     */
    where?: TeneurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teneurs to fetch.
     */
    orderBy?: TeneurOrderByWithRelationInput | TeneurOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teneurs.
     */
    cursor?: TeneurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teneurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teneurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teneurs.
     */
    distinct?: TeneurScalarFieldEnum | TeneurScalarFieldEnum[]
  }

  /**
   * Teneur findFirstOrThrow
   */
  export type TeneurFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teneur
     */
    select?: TeneurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teneur
     */
    omit?: TeneurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeneurInclude<ExtArgs> | null
    /**
     * Filter, which Teneur to fetch.
     */
    where?: TeneurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teneurs to fetch.
     */
    orderBy?: TeneurOrderByWithRelationInput | TeneurOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teneurs.
     */
    cursor?: TeneurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teneurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teneurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teneurs.
     */
    distinct?: TeneurScalarFieldEnum | TeneurScalarFieldEnum[]
  }

  /**
   * Teneur findMany
   */
  export type TeneurFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teneur
     */
    select?: TeneurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teneur
     */
    omit?: TeneurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeneurInclude<ExtArgs> | null
    /**
     * Filter, which Teneurs to fetch.
     */
    where?: TeneurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teneurs to fetch.
     */
    orderBy?: TeneurOrderByWithRelationInput | TeneurOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Teneurs.
     */
    cursor?: TeneurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teneurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teneurs.
     */
    skip?: number
    distinct?: TeneurScalarFieldEnum | TeneurScalarFieldEnum[]
  }

  /**
   * Teneur create
   */
  export type TeneurCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teneur
     */
    select?: TeneurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teneur
     */
    omit?: TeneurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeneurInclude<ExtArgs> | null
    /**
     * The data needed to create a Teneur.
     */
    data: XOR<TeneurCreateInput, TeneurUncheckedCreateInput>
  }

  /**
   * Teneur createMany
   */
  export type TeneurCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Teneurs.
     */
    data: TeneurCreateManyInput | TeneurCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Teneur createManyAndReturn
   */
  export type TeneurCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teneur
     */
    select?: TeneurSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Teneur
     */
    omit?: TeneurOmit<ExtArgs> | null
    /**
     * The data used to create many Teneurs.
     */
    data: TeneurCreateManyInput | TeneurCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeneurIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Teneur update
   */
  export type TeneurUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teneur
     */
    select?: TeneurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teneur
     */
    omit?: TeneurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeneurInclude<ExtArgs> | null
    /**
     * The data needed to update a Teneur.
     */
    data: XOR<TeneurUpdateInput, TeneurUncheckedUpdateInput>
    /**
     * Choose, which Teneur to update.
     */
    where: TeneurWhereUniqueInput
  }

  /**
   * Teneur updateMany
   */
  export type TeneurUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Teneurs.
     */
    data: XOR<TeneurUpdateManyMutationInput, TeneurUncheckedUpdateManyInput>
    /**
     * Filter which Teneurs to update
     */
    where?: TeneurWhereInput
    /**
     * Limit how many Teneurs to update.
     */
    limit?: number
  }

  /**
   * Teneur updateManyAndReturn
   */
  export type TeneurUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teneur
     */
    select?: TeneurSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Teneur
     */
    omit?: TeneurOmit<ExtArgs> | null
    /**
     * The data used to update Teneurs.
     */
    data: XOR<TeneurUpdateManyMutationInput, TeneurUncheckedUpdateManyInput>
    /**
     * Filter which Teneurs to update
     */
    where?: TeneurWhereInput
    /**
     * Limit how many Teneurs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeneurIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Teneur upsert
   */
  export type TeneurUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teneur
     */
    select?: TeneurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teneur
     */
    omit?: TeneurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeneurInclude<ExtArgs> | null
    /**
     * The filter to search for the Teneur to update in case it exists.
     */
    where: TeneurWhereUniqueInput
    /**
     * In case the Teneur found by the `where` argument doesn't exist, create a new Teneur with this data.
     */
    create: XOR<TeneurCreateInput, TeneurUncheckedCreateInput>
    /**
     * In case the Teneur was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeneurUpdateInput, TeneurUncheckedUpdateInput>
  }

  /**
   * Teneur delete
   */
  export type TeneurDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teneur
     */
    select?: TeneurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teneur
     */
    omit?: TeneurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeneurInclude<ExtArgs> | null
    /**
     * Filter which Teneur to delete.
     */
    where: TeneurWhereUniqueInput
  }

  /**
   * Teneur deleteMany
   */
  export type TeneurDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Teneurs to delete
     */
    where?: TeneurWhereInput
    /**
     * Limit how many Teneurs to delete.
     */
    limit?: number
  }

  /**
   * Teneur.Produit
   */
  export type Teneur$ProduitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Produit
     */
    select?: ProduitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Produit
     */
    omit?: ProduitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProduitInclude<ExtArgs> | null
    where?: ProduitWhereInput
    orderBy?: ProduitOrderByWithRelationInput | ProduitOrderByWithRelationInput[]
    cursor?: ProduitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProduitScalarFieldEnum | ProduitScalarFieldEnum[]
  }

  /**
   * Teneur.DetailClotureCaisse
   */
  export type Teneur$DetailClotureCaisseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetailClotureCaisse
     */
    select?: DetailClotureCaisseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DetailClotureCaisse
     */
    omit?: DetailClotureCaisseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetailClotureCaisseInclude<ExtArgs> | null
    where?: DetailClotureCaisseWhereInput
    orderBy?: DetailClotureCaisseOrderByWithRelationInput | DetailClotureCaisseOrderByWithRelationInput[]
    cursor?: DetailClotureCaisseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DetailClotureCaisseScalarFieldEnum | DetailClotureCaisseScalarFieldEnum[]
  }

  /**
   * Teneur without action
   */
  export type TeneurDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teneur
     */
    select?: TeneurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teneur
     */
    omit?: TeneurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeneurInclude<ExtArgs> | null
  }


  /**
   * Model Devise
   */

  export type AggregateDevise = {
    _count: DeviseCountAggregateOutputType | null
    _avg: DeviseAvgAggregateOutputType | null
    _sum: DeviseSumAggregateOutputType | null
    _min: DeviseMinAggregateOutputType | null
    _max: DeviseMaxAggregateOutputType | null
  }

  export type DeviseAvgAggregateOutputType = {
    id: number | null
    utilisateurId: number | null
  }

  export type DeviseSumAggregateOutputType = {
    id: number | null
    utilisateurId: number | null
  }

  export type DeviseMinAggregateOutputType = {
    id: number | null
    nom: string | null
    code: string | null
    symbole: string | null
    utilisateurId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DeviseMaxAggregateOutputType = {
    id: number | null
    nom: string | null
    code: string | null
    symbole: string | null
    utilisateurId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DeviseCountAggregateOutputType = {
    id: number
    nom: number
    code: number
    symbole: number
    utilisateurId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DeviseAvgAggregateInputType = {
    id?: true
    utilisateurId?: true
  }

  export type DeviseSumAggregateInputType = {
    id?: true
    utilisateurId?: true
  }

  export type DeviseMinAggregateInputType = {
    id?: true
    nom?: true
    code?: true
    symbole?: true
    utilisateurId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DeviseMaxAggregateInputType = {
    id?: true
    nom?: true
    code?: true
    symbole?: true
    utilisateurId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DeviseCountAggregateInputType = {
    id?: true
    nom?: true
    code?: true
    symbole?: true
    utilisateurId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DeviseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Devise to aggregate.
     */
    where?: DeviseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Devises to fetch.
     */
    orderBy?: DeviseOrderByWithRelationInput | DeviseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeviseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Devises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Devises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Devises
    **/
    _count?: true | DeviseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeviseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeviseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeviseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeviseMaxAggregateInputType
  }

  export type GetDeviseAggregateType<T extends DeviseAggregateArgs> = {
        [P in keyof T & keyof AggregateDevise]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDevise[P]>
      : GetScalarType<T[P], AggregateDevise[P]>
  }




  export type DeviseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviseWhereInput
    orderBy?: DeviseOrderByWithAggregationInput | DeviseOrderByWithAggregationInput[]
    by: DeviseScalarFieldEnum[] | DeviseScalarFieldEnum
    having?: DeviseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeviseCountAggregateInputType | true
    _avg?: DeviseAvgAggregateInputType
    _sum?: DeviseSumAggregateInputType
    _min?: DeviseMinAggregateInputType
    _max?: DeviseMaxAggregateInputType
  }

  export type DeviseGroupByOutputType = {
    id: number
    nom: string
    code: string
    symbole: string
    utilisateurId: number
    createdAt: Date
    updatedAt: Date
    _count: DeviseCountAggregateOutputType | null
    _avg: DeviseAvgAggregateOutputType | null
    _sum: DeviseSumAggregateOutputType | null
    _min: DeviseMinAggregateOutputType | null
    _max: DeviseMaxAggregateOutputType | null
  }

  type GetDeviseGroupByPayload<T extends DeviseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeviseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeviseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeviseGroupByOutputType[P]>
            : GetScalarType<T[P], DeviseGroupByOutputType[P]>
        }
      >
    >


  export type DeviseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    code?: boolean
    symbole?: boolean
    utilisateurId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    utilisateur?: boolean | UtilisateurDefaultArgs<ExtArgs>
    Produit?: boolean | Devise$ProduitArgs<ExtArgs>
    Paiement?: boolean | Devise$PaiementArgs<ExtArgs>
    Caisse?: boolean | Devise$CaisseArgs<ExtArgs>
    _count?: boolean | DeviseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["devise"]>

  export type DeviseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    code?: boolean
    symbole?: boolean
    utilisateurId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    utilisateur?: boolean | UtilisateurDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["devise"]>

  export type DeviseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    code?: boolean
    symbole?: boolean
    utilisateurId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    utilisateur?: boolean | UtilisateurDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["devise"]>

  export type DeviseSelectScalar = {
    id?: boolean
    nom?: boolean
    code?: boolean
    symbole?: boolean
    utilisateurId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DeviseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nom" | "code" | "symbole" | "utilisateurId" | "createdAt" | "updatedAt", ExtArgs["result"]["devise"]>
  export type DeviseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    utilisateur?: boolean | UtilisateurDefaultArgs<ExtArgs>
    Produit?: boolean | Devise$ProduitArgs<ExtArgs>
    Paiement?: boolean | Devise$PaiementArgs<ExtArgs>
    Caisse?: boolean | Devise$CaisseArgs<ExtArgs>
    _count?: boolean | DeviseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DeviseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    utilisateur?: boolean | UtilisateurDefaultArgs<ExtArgs>
  }
  export type DeviseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    utilisateur?: boolean | UtilisateurDefaultArgs<ExtArgs>
  }

  export type $DevisePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Devise"
    objects: {
      utilisateur: Prisma.$UtilisateurPayload<ExtArgs>
      Produit: Prisma.$ProduitPayload<ExtArgs>[]
      Paiement: Prisma.$PaiementPayload<ExtArgs>[]
      Caisse: Prisma.$CaissePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nom: string
      code: string
      symbole: string
      utilisateurId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["devise"]>
    composites: {}
  }

  type DeviseGetPayload<S extends boolean | null | undefined | DeviseDefaultArgs> = $Result.GetResult<Prisma.$DevisePayload, S>

  type DeviseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeviseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeviseCountAggregateInputType | true
    }

  export interface DeviseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Devise'], meta: { name: 'Devise' } }
    /**
     * Find zero or one Devise that matches the filter.
     * @param {DeviseFindUniqueArgs} args - Arguments to find a Devise
     * @example
     * // Get one Devise
     * const devise = await prisma.devise.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeviseFindUniqueArgs>(args: SelectSubset<T, DeviseFindUniqueArgs<ExtArgs>>): Prisma__DeviseClient<$Result.GetResult<Prisma.$DevisePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Devise that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeviseFindUniqueOrThrowArgs} args - Arguments to find a Devise
     * @example
     * // Get one Devise
     * const devise = await prisma.devise.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeviseFindUniqueOrThrowArgs>(args: SelectSubset<T, DeviseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeviseClient<$Result.GetResult<Prisma.$DevisePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Devise that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviseFindFirstArgs} args - Arguments to find a Devise
     * @example
     * // Get one Devise
     * const devise = await prisma.devise.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeviseFindFirstArgs>(args?: SelectSubset<T, DeviseFindFirstArgs<ExtArgs>>): Prisma__DeviseClient<$Result.GetResult<Prisma.$DevisePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Devise that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviseFindFirstOrThrowArgs} args - Arguments to find a Devise
     * @example
     * // Get one Devise
     * const devise = await prisma.devise.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeviseFindFirstOrThrowArgs>(args?: SelectSubset<T, DeviseFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeviseClient<$Result.GetResult<Prisma.$DevisePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Devises that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Devises
     * const devises = await prisma.devise.findMany()
     * 
     * // Get first 10 Devises
     * const devises = await prisma.devise.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deviseWithIdOnly = await prisma.devise.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeviseFindManyArgs>(args?: SelectSubset<T, DeviseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DevisePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Devise.
     * @param {DeviseCreateArgs} args - Arguments to create a Devise.
     * @example
     * // Create one Devise
     * const Devise = await prisma.devise.create({
     *   data: {
     *     // ... data to create a Devise
     *   }
     * })
     * 
     */
    create<T extends DeviseCreateArgs>(args: SelectSubset<T, DeviseCreateArgs<ExtArgs>>): Prisma__DeviseClient<$Result.GetResult<Prisma.$DevisePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Devises.
     * @param {DeviseCreateManyArgs} args - Arguments to create many Devises.
     * @example
     * // Create many Devises
     * const devise = await prisma.devise.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeviseCreateManyArgs>(args?: SelectSubset<T, DeviseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Devises and returns the data saved in the database.
     * @param {DeviseCreateManyAndReturnArgs} args - Arguments to create many Devises.
     * @example
     * // Create many Devises
     * const devise = await prisma.devise.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Devises and only return the `id`
     * const deviseWithIdOnly = await prisma.devise.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeviseCreateManyAndReturnArgs>(args?: SelectSubset<T, DeviseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DevisePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Devise.
     * @param {DeviseDeleteArgs} args - Arguments to delete one Devise.
     * @example
     * // Delete one Devise
     * const Devise = await prisma.devise.delete({
     *   where: {
     *     // ... filter to delete one Devise
     *   }
     * })
     * 
     */
    delete<T extends DeviseDeleteArgs>(args: SelectSubset<T, DeviseDeleteArgs<ExtArgs>>): Prisma__DeviseClient<$Result.GetResult<Prisma.$DevisePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Devise.
     * @param {DeviseUpdateArgs} args - Arguments to update one Devise.
     * @example
     * // Update one Devise
     * const devise = await prisma.devise.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeviseUpdateArgs>(args: SelectSubset<T, DeviseUpdateArgs<ExtArgs>>): Prisma__DeviseClient<$Result.GetResult<Prisma.$DevisePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Devises.
     * @param {DeviseDeleteManyArgs} args - Arguments to filter Devises to delete.
     * @example
     * // Delete a few Devises
     * const { count } = await prisma.devise.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeviseDeleteManyArgs>(args?: SelectSubset<T, DeviseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Devises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Devises
     * const devise = await prisma.devise.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeviseUpdateManyArgs>(args: SelectSubset<T, DeviseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Devises and returns the data updated in the database.
     * @param {DeviseUpdateManyAndReturnArgs} args - Arguments to update many Devises.
     * @example
     * // Update many Devises
     * const devise = await prisma.devise.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Devises and only return the `id`
     * const deviseWithIdOnly = await prisma.devise.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DeviseUpdateManyAndReturnArgs>(args: SelectSubset<T, DeviseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DevisePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Devise.
     * @param {DeviseUpsertArgs} args - Arguments to update or create a Devise.
     * @example
     * // Update or create a Devise
     * const devise = await prisma.devise.upsert({
     *   create: {
     *     // ... data to create a Devise
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Devise we want to update
     *   }
     * })
     */
    upsert<T extends DeviseUpsertArgs>(args: SelectSubset<T, DeviseUpsertArgs<ExtArgs>>): Prisma__DeviseClient<$Result.GetResult<Prisma.$DevisePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Devises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviseCountArgs} args - Arguments to filter Devises to count.
     * @example
     * // Count the number of Devises
     * const count = await prisma.devise.count({
     *   where: {
     *     // ... the filter for the Devises we want to count
     *   }
     * })
    **/
    count<T extends DeviseCountArgs>(
      args?: Subset<T, DeviseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeviseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Devise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeviseAggregateArgs>(args: Subset<T, DeviseAggregateArgs>): Prisma.PrismaPromise<GetDeviseAggregateType<T>>

    /**
     * Group by Devise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeviseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeviseGroupByArgs['orderBy'] }
        : { orderBy?: DeviseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeviseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeviseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Devise model
   */
  readonly fields: DeviseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Devise.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeviseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    utilisateur<T extends UtilisateurDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UtilisateurDefaultArgs<ExtArgs>>): Prisma__UtilisateurClient<$Result.GetResult<Prisma.$UtilisateurPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Produit<T extends Devise$ProduitArgs<ExtArgs> = {}>(args?: Subset<T, Devise$ProduitArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProduitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Paiement<T extends Devise$PaiementArgs<ExtArgs> = {}>(args?: Subset<T, Devise$PaiementArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaiementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Caisse<T extends Devise$CaisseArgs<ExtArgs> = {}>(args?: Subset<T, Devise$CaisseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CaissePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Devise model
   */
  interface DeviseFieldRefs {
    readonly id: FieldRef<"Devise", 'Int'>
    readonly nom: FieldRef<"Devise", 'String'>
    readonly code: FieldRef<"Devise", 'String'>
    readonly symbole: FieldRef<"Devise", 'String'>
    readonly utilisateurId: FieldRef<"Devise", 'Int'>
    readonly createdAt: FieldRef<"Devise", 'DateTime'>
    readonly updatedAt: FieldRef<"Devise", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Devise findUnique
   */
  export type DeviseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Devise
     */
    select?: DeviseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Devise
     */
    omit?: DeviseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviseInclude<ExtArgs> | null
    /**
     * Filter, which Devise to fetch.
     */
    where: DeviseWhereUniqueInput
  }

  /**
   * Devise findUniqueOrThrow
   */
  export type DeviseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Devise
     */
    select?: DeviseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Devise
     */
    omit?: DeviseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviseInclude<ExtArgs> | null
    /**
     * Filter, which Devise to fetch.
     */
    where: DeviseWhereUniqueInput
  }

  /**
   * Devise findFirst
   */
  export type DeviseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Devise
     */
    select?: DeviseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Devise
     */
    omit?: DeviseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviseInclude<ExtArgs> | null
    /**
     * Filter, which Devise to fetch.
     */
    where?: DeviseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Devises to fetch.
     */
    orderBy?: DeviseOrderByWithRelationInput | DeviseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Devises.
     */
    cursor?: DeviseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Devises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Devises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Devises.
     */
    distinct?: DeviseScalarFieldEnum | DeviseScalarFieldEnum[]
  }

  /**
   * Devise findFirstOrThrow
   */
  export type DeviseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Devise
     */
    select?: DeviseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Devise
     */
    omit?: DeviseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviseInclude<ExtArgs> | null
    /**
     * Filter, which Devise to fetch.
     */
    where?: DeviseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Devises to fetch.
     */
    orderBy?: DeviseOrderByWithRelationInput | DeviseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Devises.
     */
    cursor?: DeviseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Devises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Devises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Devises.
     */
    distinct?: DeviseScalarFieldEnum | DeviseScalarFieldEnum[]
  }

  /**
   * Devise findMany
   */
  export type DeviseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Devise
     */
    select?: DeviseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Devise
     */
    omit?: DeviseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviseInclude<ExtArgs> | null
    /**
     * Filter, which Devises to fetch.
     */
    where?: DeviseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Devises to fetch.
     */
    orderBy?: DeviseOrderByWithRelationInput | DeviseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Devises.
     */
    cursor?: DeviseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Devises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Devises.
     */
    skip?: number
    distinct?: DeviseScalarFieldEnum | DeviseScalarFieldEnum[]
  }

  /**
   * Devise create
   */
  export type DeviseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Devise
     */
    select?: DeviseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Devise
     */
    omit?: DeviseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviseInclude<ExtArgs> | null
    /**
     * The data needed to create a Devise.
     */
    data: XOR<DeviseCreateInput, DeviseUncheckedCreateInput>
  }

  /**
   * Devise createMany
   */
  export type DeviseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Devises.
     */
    data: DeviseCreateManyInput | DeviseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Devise createManyAndReturn
   */
  export type DeviseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Devise
     */
    select?: DeviseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Devise
     */
    omit?: DeviseOmit<ExtArgs> | null
    /**
     * The data used to create many Devises.
     */
    data: DeviseCreateManyInput | DeviseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Devise update
   */
  export type DeviseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Devise
     */
    select?: DeviseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Devise
     */
    omit?: DeviseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviseInclude<ExtArgs> | null
    /**
     * The data needed to update a Devise.
     */
    data: XOR<DeviseUpdateInput, DeviseUncheckedUpdateInput>
    /**
     * Choose, which Devise to update.
     */
    where: DeviseWhereUniqueInput
  }

  /**
   * Devise updateMany
   */
  export type DeviseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Devises.
     */
    data: XOR<DeviseUpdateManyMutationInput, DeviseUncheckedUpdateManyInput>
    /**
     * Filter which Devises to update
     */
    where?: DeviseWhereInput
    /**
     * Limit how many Devises to update.
     */
    limit?: number
  }

  /**
   * Devise updateManyAndReturn
   */
  export type DeviseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Devise
     */
    select?: DeviseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Devise
     */
    omit?: DeviseOmit<ExtArgs> | null
    /**
     * The data used to update Devises.
     */
    data: XOR<DeviseUpdateManyMutationInput, DeviseUncheckedUpdateManyInput>
    /**
     * Filter which Devises to update
     */
    where?: DeviseWhereInput
    /**
     * Limit how many Devises to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Devise upsert
   */
  export type DeviseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Devise
     */
    select?: DeviseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Devise
     */
    omit?: DeviseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviseInclude<ExtArgs> | null
    /**
     * The filter to search for the Devise to update in case it exists.
     */
    where: DeviseWhereUniqueInput
    /**
     * In case the Devise found by the `where` argument doesn't exist, create a new Devise with this data.
     */
    create: XOR<DeviseCreateInput, DeviseUncheckedCreateInput>
    /**
     * In case the Devise was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeviseUpdateInput, DeviseUncheckedUpdateInput>
  }

  /**
   * Devise delete
   */
  export type DeviseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Devise
     */
    select?: DeviseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Devise
     */
    omit?: DeviseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviseInclude<ExtArgs> | null
    /**
     * Filter which Devise to delete.
     */
    where: DeviseWhereUniqueInput
  }

  /**
   * Devise deleteMany
   */
  export type DeviseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Devises to delete
     */
    where?: DeviseWhereInput
    /**
     * Limit how many Devises to delete.
     */
    limit?: number
  }

  /**
   * Devise.Produit
   */
  export type Devise$ProduitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Produit
     */
    select?: ProduitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Produit
     */
    omit?: ProduitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProduitInclude<ExtArgs> | null
    where?: ProduitWhereInput
    orderBy?: ProduitOrderByWithRelationInput | ProduitOrderByWithRelationInput[]
    cursor?: ProduitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProduitScalarFieldEnum | ProduitScalarFieldEnum[]
  }

  /**
   * Devise.Paiement
   */
  export type Devise$PaiementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paiement
     */
    select?: PaiementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Paiement
     */
    omit?: PaiementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaiementInclude<ExtArgs> | null
    where?: PaiementWhereInput
    orderBy?: PaiementOrderByWithRelationInput | PaiementOrderByWithRelationInput[]
    cursor?: PaiementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaiementScalarFieldEnum | PaiementScalarFieldEnum[]
  }

  /**
   * Devise.Caisse
   */
  export type Devise$CaisseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Caisse
     */
    select?: CaisseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Caisse
     */
    omit?: CaisseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaisseInclude<ExtArgs> | null
    where?: CaisseWhereInput
    orderBy?: CaisseOrderByWithRelationInput | CaisseOrderByWithRelationInput[]
    cursor?: CaisseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CaisseScalarFieldEnum | CaisseScalarFieldEnum[]
  }

  /**
   * Devise without action
   */
  export type DeviseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Devise
     */
    select?: DeviseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Devise
     */
    omit?: DeviseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviseInclude<ExtArgs> | null
  }


  /**
   * Model Produit
   */

  export type AggregateProduit = {
    _count: ProduitCountAggregateOutputType | null
    _avg: ProduitAvgAggregateOutputType | null
    _sum: ProduitSumAggregateOutputType | null
    _min: ProduitMinAggregateOutputType | null
    _max: ProduitMaxAggregateOutputType | null
  }

  export type ProduitAvgAggregateOutputType = {
    id: number | null
    prix: number | null
    qtte: number | null
    deviseId: number | null
    teneurId: number | null
    utilisateurId: number | null
  }

  export type ProduitSumAggregateOutputType = {
    id: number | null
    prix: number | null
    qtte: number | null
    deviseId: number | null
    teneurId: number | null
    utilisateurId: number | null
  }

  export type ProduitMinAggregateOutputType = {
    id: number | null
    designation: string | null
    prix: number | null
    qtte: number | null
    description: string | null
    deviseId: number | null
    teneurId: number | null
    utilisateurId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProduitMaxAggregateOutputType = {
    id: number | null
    designation: string | null
    prix: number | null
    qtte: number | null
    description: string | null
    deviseId: number | null
    teneurId: number | null
    utilisateurId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProduitCountAggregateOutputType = {
    id: number
    designation: number
    prix: number
    qtte: number
    description: number
    deviseId: number
    teneurId: number
    utilisateurId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProduitAvgAggregateInputType = {
    id?: true
    prix?: true
    qtte?: true
    deviseId?: true
    teneurId?: true
    utilisateurId?: true
  }

  export type ProduitSumAggregateInputType = {
    id?: true
    prix?: true
    qtte?: true
    deviseId?: true
    teneurId?: true
    utilisateurId?: true
  }

  export type ProduitMinAggregateInputType = {
    id?: true
    designation?: true
    prix?: true
    qtte?: true
    description?: true
    deviseId?: true
    teneurId?: true
    utilisateurId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProduitMaxAggregateInputType = {
    id?: true
    designation?: true
    prix?: true
    qtte?: true
    description?: true
    deviseId?: true
    teneurId?: true
    utilisateurId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProduitCountAggregateInputType = {
    id?: true
    designation?: true
    prix?: true
    qtte?: true
    description?: true
    deviseId?: true
    teneurId?: true
    utilisateurId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProduitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Produit to aggregate.
     */
    where?: ProduitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Produits to fetch.
     */
    orderBy?: ProduitOrderByWithRelationInput | ProduitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProduitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Produits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Produits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Produits
    **/
    _count?: true | ProduitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProduitAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProduitSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProduitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProduitMaxAggregateInputType
  }

  export type GetProduitAggregateType<T extends ProduitAggregateArgs> = {
        [P in keyof T & keyof AggregateProduit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduit[P]>
      : GetScalarType<T[P], AggregateProduit[P]>
  }




  export type ProduitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProduitWhereInput
    orderBy?: ProduitOrderByWithAggregationInput | ProduitOrderByWithAggregationInput[]
    by: ProduitScalarFieldEnum[] | ProduitScalarFieldEnum
    having?: ProduitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProduitCountAggregateInputType | true
    _avg?: ProduitAvgAggregateInputType
    _sum?: ProduitSumAggregateInputType
    _min?: ProduitMinAggregateInputType
    _max?: ProduitMaxAggregateInputType
  }

  export type ProduitGroupByOutputType = {
    id: number
    designation: string
    prix: number
    qtte: number
    description: string
    deviseId: number
    teneurId: number
    utilisateurId: number
    createdAt: Date
    updatedAt: Date
    _count: ProduitCountAggregateOutputType | null
    _avg: ProduitAvgAggregateOutputType | null
    _sum: ProduitSumAggregateOutputType | null
    _min: ProduitMinAggregateOutputType | null
    _max: ProduitMaxAggregateOutputType | null
  }

  type GetProduitGroupByPayload<T extends ProduitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProduitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProduitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProduitGroupByOutputType[P]>
            : GetScalarType<T[P], ProduitGroupByOutputType[P]>
        }
      >
    >


  export type ProduitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    designation?: boolean
    prix?: boolean
    qtte?: boolean
    description?: boolean
    deviseId?: boolean
    teneurId?: boolean
    utilisateurId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    devise?: boolean | DeviseDefaultArgs<ExtArgs>
    teneur?: boolean | TeneurDefaultArgs<ExtArgs>
    utilisateur?: boolean | UtilisateurDefaultArgs<ExtArgs>
    DetailPanier?: boolean | Produit$DetailPanierArgs<ExtArgs>
    DetailClotureCaisse?: boolean | Produit$DetailClotureCaisseArgs<ExtArgs>
    _count?: boolean | ProduitCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["produit"]>

  export type ProduitSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    designation?: boolean
    prix?: boolean
    qtte?: boolean
    description?: boolean
    deviseId?: boolean
    teneurId?: boolean
    utilisateurId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    devise?: boolean | DeviseDefaultArgs<ExtArgs>
    teneur?: boolean | TeneurDefaultArgs<ExtArgs>
    utilisateur?: boolean | UtilisateurDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["produit"]>

  export type ProduitSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    designation?: boolean
    prix?: boolean
    qtte?: boolean
    description?: boolean
    deviseId?: boolean
    teneurId?: boolean
    utilisateurId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    devise?: boolean | DeviseDefaultArgs<ExtArgs>
    teneur?: boolean | TeneurDefaultArgs<ExtArgs>
    utilisateur?: boolean | UtilisateurDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["produit"]>

  export type ProduitSelectScalar = {
    id?: boolean
    designation?: boolean
    prix?: boolean
    qtte?: boolean
    description?: boolean
    deviseId?: boolean
    teneurId?: boolean
    utilisateurId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProduitOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "designation" | "prix" | "qtte" | "description" | "deviseId" | "teneurId" | "utilisateurId" | "createdAt" | "updatedAt", ExtArgs["result"]["produit"]>
  export type ProduitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    devise?: boolean | DeviseDefaultArgs<ExtArgs>
    teneur?: boolean | TeneurDefaultArgs<ExtArgs>
    utilisateur?: boolean | UtilisateurDefaultArgs<ExtArgs>
    DetailPanier?: boolean | Produit$DetailPanierArgs<ExtArgs>
    DetailClotureCaisse?: boolean | Produit$DetailClotureCaisseArgs<ExtArgs>
    _count?: boolean | ProduitCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProduitIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    devise?: boolean | DeviseDefaultArgs<ExtArgs>
    teneur?: boolean | TeneurDefaultArgs<ExtArgs>
    utilisateur?: boolean | UtilisateurDefaultArgs<ExtArgs>
  }
  export type ProduitIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    devise?: boolean | DeviseDefaultArgs<ExtArgs>
    teneur?: boolean | TeneurDefaultArgs<ExtArgs>
    utilisateur?: boolean | UtilisateurDefaultArgs<ExtArgs>
  }

  export type $ProduitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Produit"
    objects: {
      devise: Prisma.$DevisePayload<ExtArgs>
      teneur: Prisma.$TeneurPayload<ExtArgs>
      utilisateur: Prisma.$UtilisateurPayload<ExtArgs>
      DetailPanier: Prisma.$DetailPanierPayload<ExtArgs>[]
      DetailClotureCaisse: Prisma.$DetailClotureCaissePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      designation: string
      prix: number
      qtte: number
      description: string
      deviseId: number
      teneurId: number
      utilisateurId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["produit"]>
    composites: {}
  }

  type ProduitGetPayload<S extends boolean | null | undefined | ProduitDefaultArgs> = $Result.GetResult<Prisma.$ProduitPayload, S>

  type ProduitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProduitFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProduitCountAggregateInputType | true
    }

  export interface ProduitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Produit'], meta: { name: 'Produit' } }
    /**
     * Find zero or one Produit that matches the filter.
     * @param {ProduitFindUniqueArgs} args - Arguments to find a Produit
     * @example
     * // Get one Produit
     * const produit = await prisma.produit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProduitFindUniqueArgs>(args: SelectSubset<T, ProduitFindUniqueArgs<ExtArgs>>): Prisma__ProduitClient<$Result.GetResult<Prisma.$ProduitPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Produit that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProduitFindUniqueOrThrowArgs} args - Arguments to find a Produit
     * @example
     * // Get one Produit
     * const produit = await prisma.produit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProduitFindUniqueOrThrowArgs>(args: SelectSubset<T, ProduitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProduitClient<$Result.GetResult<Prisma.$ProduitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Produit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProduitFindFirstArgs} args - Arguments to find a Produit
     * @example
     * // Get one Produit
     * const produit = await prisma.produit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProduitFindFirstArgs>(args?: SelectSubset<T, ProduitFindFirstArgs<ExtArgs>>): Prisma__ProduitClient<$Result.GetResult<Prisma.$ProduitPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Produit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProduitFindFirstOrThrowArgs} args - Arguments to find a Produit
     * @example
     * // Get one Produit
     * const produit = await prisma.produit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProduitFindFirstOrThrowArgs>(args?: SelectSubset<T, ProduitFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProduitClient<$Result.GetResult<Prisma.$ProduitPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Produits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProduitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Produits
     * const produits = await prisma.produit.findMany()
     * 
     * // Get first 10 Produits
     * const produits = await prisma.produit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const produitWithIdOnly = await prisma.produit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProduitFindManyArgs>(args?: SelectSubset<T, ProduitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProduitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Produit.
     * @param {ProduitCreateArgs} args - Arguments to create a Produit.
     * @example
     * // Create one Produit
     * const Produit = await prisma.produit.create({
     *   data: {
     *     // ... data to create a Produit
     *   }
     * })
     * 
     */
    create<T extends ProduitCreateArgs>(args: SelectSubset<T, ProduitCreateArgs<ExtArgs>>): Prisma__ProduitClient<$Result.GetResult<Prisma.$ProduitPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Produits.
     * @param {ProduitCreateManyArgs} args - Arguments to create many Produits.
     * @example
     * // Create many Produits
     * const produit = await prisma.produit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProduitCreateManyArgs>(args?: SelectSubset<T, ProduitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Produits and returns the data saved in the database.
     * @param {ProduitCreateManyAndReturnArgs} args - Arguments to create many Produits.
     * @example
     * // Create many Produits
     * const produit = await prisma.produit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Produits and only return the `id`
     * const produitWithIdOnly = await prisma.produit.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProduitCreateManyAndReturnArgs>(args?: SelectSubset<T, ProduitCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProduitPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Produit.
     * @param {ProduitDeleteArgs} args - Arguments to delete one Produit.
     * @example
     * // Delete one Produit
     * const Produit = await prisma.produit.delete({
     *   where: {
     *     // ... filter to delete one Produit
     *   }
     * })
     * 
     */
    delete<T extends ProduitDeleteArgs>(args: SelectSubset<T, ProduitDeleteArgs<ExtArgs>>): Prisma__ProduitClient<$Result.GetResult<Prisma.$ProduitPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Produit.
     * @param {ProduitUpdateArgs} args - Arguments to update one Produit.
     * @example
     * // Update one Produit
     * const produit = await prisma.produit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProduitUpdateArgs>(args: SelectSubset<T, ProduitUpdateArgs<ExtArgs>>): Prisma__ProduitClient<$Result.GetResult<Prisma.$ProduitPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Produits.
     * @param {ProduitDeleteManyArgs} args - Arguments to filter Produits to delete.
     * @example
     * // Delete a few Produits
     * const { count } = await prisma.produit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProduitDeleteManyArgs>(args?: SelectSubset<T, ProduitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Produits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProduitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Produits
     * const produit = await prisma.produit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProduitUpdateManyArgs>(args: SelectSubset<T, ProduitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Produits and returns the data updated in the database.
     * @param {ProduitUpdateManyAndReturnArgs} args - Arguments to update many Produits.
     * @example
     * // Update many Produits
     * const produit = await prisma.produit.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Produits and only return the `id`
     * const produitWithIdOnly = await prisma.produit.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProduitUpdateManyAndReturnArgs>(args: SelectSubset<T, ProduitUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProduitPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Produit.
     * @param {ProduitUpsertArgs} args - Arguments to update or create a Produit.
     * @example
     * // Update or create a Produit
     * const produit = await prisma.produit.upsert({
     *   create: {
     *     // ... data to create a Produit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Produit we want to update
     *   }
     * })
     */
    upsert<T extends ProduitUpsertArgs>(args: SelectSubset<T, ProduitUpsertArgs<ExtArgs>>): Prisma__ProduitClient<$Result.GetResult<Prisma.$ProduitPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Produits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProduitCountArgs} args - Arguments to filter Produits to count.
     * @example
     * // Count the number of Produits
     * const count = await prisma.produit.count({
     *   where: {
     *     // ... the filter for the Produits we want to count
     *   }
     * })
    **/
    count<T extends ProduitCountArgs>(
      args?: Subset<T, ProduitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProduitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Produit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProduitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProduitAggregateArgs>(args: Subset<T, ProduitAggregateArgs>): Prisma.PrismaPromise<GetProduitAggregateType<T>>

    /**
     * Group by Produit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProduitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProduitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProduitGroupByArgs['orderBy'] }
        : { orderBy?: ProduitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProduitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProduitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Produit model
   */
  readonly fields: ProduitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Produit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProduitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    devise<T extends DeviseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DeviseDefaultArgs<ExtArgs>>): Prisma__DeviseClient<$Result.GetResult<Prisma.$DevisePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    teneur<T extends TeneurDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeneurDefaultArgs<ExtArgs>>): Prisma__TeneurClient<$Result.GetResult<Prisma.$TeneurPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    utilisateur<T extends UtilisateurDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UtilisateurDefaultArgs<ExtArgs>>): Prisma__UtilisateurClient<$Result.GetResult<Prisma.$UtilisateurPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    DetailPanier<T extends Produit$DetailPanierArgs<ExtArgs> = {}>(args?: Subset<T, Produit$DetailPanierArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DetailPanierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    DetailClotureCaisse<T extends Produit$DetailClotureCaisseArgs<ExtArgs> = {}>(args?: Subset<T, Produit$DetailClotureCaisseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DetailClotureCaissePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Produit model
   */
  interface ProduitFieldRefs {
    readonly id: FieldRef<"Produit", 'Int'>
    readonly designation: FieldRef<"Produit", 'String'>
    readonly prix: FieldRef<"Produit", 'Float'>
    readonly qtte: FieldRef<"Produit", 'Int'>
    readonly description: FieldRef<"Produit", 'String'>
    readonly deviseId: FieldRef<"Produit", 'Int'>
    readonly teneurId: FieldRef<"Produit", 'Int'>
    readonly utilisateurId: FieldRef<"Produit", 'Int'>
    readonly createdAt: FieldRef<"Produit", 'DateTime'>
    readonly updatedAt: FieldRef<"Produit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Produit findUnique
   */
  export type ProduitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Produit
     */
    select?: ProduitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Produit
     */
    omit?: ProduitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProduitInclude<ExtArgs> | null
    /**
     * Filter, which Produit to fetch.
     */
    where: ProduitWhereUniqueInput
  }

  /**
   * Produit findUniqueOrThrow
   */
  export type ProduitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Produit
     */
    select?: ProduitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Produit
     */
    omit?: ProduitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProduitInclude<ExtArgs> | null
    /**
     * Filter, which Produit to fetch.
     */
    where: ProduitWhereUniqueInput
  }

  /**
   * Produit findFirst
   */
  export type ProduitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Produit
     */
    select?: ProduitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Produit
     */
    omit?: ProduitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProduitInclude<ExtArgs> | null
    /**
     * Filter, which Produit to fetch.
     */
    where?: ProduitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Produits to fetch.
     */
    orderBy?: ProduitOrderByWithRelationInput | ProduitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Produits.
     */
    cursor?: ProduitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Produits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Produits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Produits.
     */
    distinct?: ProduitScalarFieldEnum | ProduitScalarFieldEnum[]
  }

  /**
   * Produit findFirstOrThrow
   */
  export type ProduitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Produit
     */
    select?: ProduitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Produit
     */
    omit?: ProduitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProduitInclude<ExtArgs> | null
    /**
     * Filter, which Produit to fetch.
     */
    where?: ProduitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Produits to fetch.
     */
    orderBy?: ProduitOrderByWithRelationInput | ProduitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Produits.
     */
    cursor?: ProduitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Produits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Produits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Produits.
     */
    distinct?: ProduitScalarFieldEnum | ProduitScalarFieldEnum[]
  }

  /**
   * Produit findMany
   */
  export type ProduitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Produit
     */
    select?: ProduitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Produit
     */
    omit?: ProduitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProduitInclude<ExtArgs> | null
    /**
     * Filter, which Produits to fetch.
     */
    where?: ProduitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Produits to fetch.
     */
    orderBy?: ProduitOrderByWithRelationInput | ProduitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Produits.
     */
    cursor?: ProduitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Produits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Produits.
     */
    skip?: number
    distinct?: ProduitScalarFieldEnum | ProduitScalarFieldEnum[]
  }

  /**
   * Produit create
   */
  export type ProduitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Produit
     */
    select?: ProduitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Produit
     */
    omit?: ProduitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProduitInclude<ExtArgs> | null
    /**
     * The data needed to create a Produit.
     */
    data: XOR<ProduitCreateInput, ProduitUncheckedCreateInput>
  }

  /**
   * Produit createMany
   */
  export type ProduitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Produits.
     */
    data: ProduitCreateManyInput | ProduitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Produit createManyAndReturn
   */
  export type ProduitCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Produit
     */
    select?: ProduitSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Produit
     */
    omit?: ProduitOmit<ExtArgs> | null
    /**
     * The data used to create many Produits.
     */
    data: ProduitCreateManyInput | ProduitCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProduitIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Produit update
   */
  export type ProduitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Produit
     */
    select?: ProduitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Produit
     */
    omit?: ProduitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProduitInclude<ExtArgs> | null
    /**
     * The data needed to update a Produit.
     */
    data: XOR<ProduitUpdateInput, ProduitUncheckedUpdateInput>
    /**
     * Choose, which Produit to update.
     */
    where: ProduitWhereUniqueInput
  }

  /**
   * Produit updateMany
   */
  export type ProduitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Produits.
     */
    data: XOR<ProduitUpdateManyMutationInput, ProduitUncheckedUpdateManyInput>
    /**
     * Filter which Produits to update
     */
    where?: ProduitWhereInput
    /**
     * Limit how many Produits to update.
     */
    limit?: number
  }

  /**
   * Produit updateManyAndReturn
   */
  export type ProduitUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Produit
     */
    select?: ProduitSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Produit
     */
    omit?: ProduitOmit<ExtArgs> | null
    /**
     * The data used to update Produits.
     */
    data: XOR<ProduitUpdateManyMutationInput, ProduitUncheckedUpdateManyInput>
    /**
     * Filter which Produits to update
     */
    where?: ProduitWhereInput
    /**
     * Limit how many Produits to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProduitIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Produit upsert
   */
  export type ProduitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Produit
     */
    select?: ProduitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Produit
     */
    omit?: ProduitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProduitInclude<ExtArgs> | null
    /**
     * The filter to search for the Produit to update in case it exists.
     */
    where: ProduitWhereUniqueInput
    /**
     * In case the Produit found by the `where` argument doesn't exist, create a new Produit with this data.
     */
    create: XOR<ProduitCreateInput, ProduitUncheckedCreateInput>
    /**
     * In case the Produit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProduitUpdateInput, ProduitUncheckedUpdateInput>
  }

  /**
   * Produit delete
   */
  export type ProduitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Produit
     */
    select?: ProduitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Produit
     */
    omit?: ProduitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProduitInclude<ExtArgs> | null
    /**
     * Filter which Produit to delete.
     */
    where: ProduitWhereUniqueInput
  }

  /**
   * Produit deleteMany
   */
  export type ProduitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Produits to delete
     */
    where?: ProduitWhereInput
    /**
     * Limit how many Produits to delete.
     */
    limit?: number
  }

  /**
   * Produit.DetailPanier
   */
  export type Produit$DetailPanierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetailPanier
     */
    select?: DetailPanierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DetailPanier
     */
    omit?: DetailPanierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetailPanierInclude<ExtArgs> | null
    where?: DetailPanierWhereInput
    orderBy?: DetailPanierOrderByWithRelationInput | DetailPanierOrderByWithRelationInput[]
    cursor?: DetailPanierWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DetailPanierScalarFieldEnum | DetailPanierScalarFieldEnum[]
  }

  /**
   * Produit.DetailClotureCaisse
   */
  export type Produit$DetailClotureCaisseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetailClotureCaisse
     */
    select?: DetailClotureCaisseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DetailClotureCaisse
     */
    omit?: DetailClotureCaisseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetailClotureCaisseInclude<ExtArgs> | null
    where?: DetailClotureCaisseWhereInput
    orderBy?: DetailClotureCaisseOrderByWithRelationInput | DetailClotureCaisseOrderByWithRelationInput[]
    cursor?: DetailClotureCaisseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DetailClotureCaisseScalarFieldEnum | DetailClotureCaisseScalarFieldEnum[]
  }

  /**
   * Produit without action
   */
  export type ProduitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Produit
     */
    select?: ProduitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Produit
     */
    omit?: ProduitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProduitInclude<ExtArgs> | null
  }


  /**
   * Model Paiement
   */

  export type AggregatePaiement = {
    _count: PaiementCountAggregateOutputType | null
    _avg: PaiementAvgAggregateOutputType | null
    _sum: PaiementSumAggregateOutputType | null
    _min: PaiementMinAggregateOutputType | null
    _max: PaiementMaxAggregateOutputType | null
  }

  export type PaiementAvgAggregateOutputType = {
    id: number | null
    montant: number | null
    deviseId: number | null
    caisseId: number | null
  }

  export type PaiementSumAggregateOutputType = {
    id: number | null
    montant: number | null
    deviseId: number | null
    caisseId: number | null
  }

  export type PaiementMinAggregateOutputType = {
    id: number | null
    montant: number | null
    moyen_paiement: $Enums.MoyenPaiment | null
    deviseId: number | null
    caisseId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaiementMaxAggregateOutputType = {
    id: number | null
    montant: number | null
    moyen_paiement: $Enums.MoyenPaiment | null
    deviseId: number | null
    caisseId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaiementCountAggregateOutputType = {
    id: number
    montant: number
    moyen_paiement: number
    deviseId: number
    caisseId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaiementAvgAggregateInputType = {
    id?: true
    montant?: true
    deviseId?: true
    caisseId?: true
  }

  export type PaiementSumAggregateInputType = {
    id?: true
    montant?: true
    deviseId?: true
    caisseId?: true
  }

  export type PaiementMinAggregateInputType = {
    id?: true
    montant?: true
    moyen_paiement?: true
    deviseId?: true
    caisseId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaiementMaxAggregateInputType = {
    id?: true
    montant?: true
    moyen_paiement?: true
    deviseId?: true
    caisseId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaiementCountAggregateInputType = {
    id?: true
    montant?: true
    moyen_paiement?: true
    deviseId?: true
    caisseId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaiementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Paiement to aggregate.
     */
    where?: PaiementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Paiements to fetch.
     */
    orderBy?: PaiementOrderByWithRelationInput | PaiementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaiementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Paiements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Paiements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Paiements
    **/
    _count?: true | PaiementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaiementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaiementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaiementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaiementMaxAggregateInputType
  }

  export type GetPaiementAggregateType<T extends PaiementAggregateArgs> = {
        [P in keyof T & keyof AggregatePaiement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaiement[P]>
      : GetScalarType<T[P], AggregatePaiement[P]>
  }




  export type PaiementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaiementWhereInput
    orderBy?: PaiementOrderByWithAggregationInput | PaiementOrderByWithAggregationInput[]
    by: PaiementScalarFieldEnum[] | PaiementScalarFieldEnum
    having?: PaiementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaiementCountAggregateInputType | true
    _avg?: PaiementAvgAggregateInputType
    _sum?: PaiementSumAggregateInputType
    _min?: PaiementMinAggregateInputType
    _max?: PaiementMaxAggregateInputType
  }

  export type PaiementGroupByOutputType = {
    id: number
    montant: number
    moyen_paiement: $Enums.MoyenPaiment
    deviseId: number
    caisseId: number
    createdAt: Date
    updatedAt: Date
    _count: PaiementCountAggregateOutputType | null
    _avg: PaiementAvgAggregateOutputType | null
    _sum: PaiementSumAggregateOutputType | null
    _min: PaiementMinAggregateOutputType | null
    _max: PaiementMaxAggregateOutputType | null
  }

  type GetPaiementGroupByPayload<T extends PaiementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaiementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaiementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaiementGroupByOutputType[P]>
            : GetScalarType<T[P], PaiementGroupByOutputType[P]>
        }
      >
    >


  export type PaiementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    montant?: boolean
    moyen_paiement?: boolean
    deviseId?: boolean
    caisseId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    caisse?: boolean | CaisseDefaultArgs<ExtArgs>
    devise?: boolean | DeviseDefaultArgs<ExtArgs>
    Achat?: boolean | Paiement$AchatArgs<ExtArgs>
    Commande?: boolean | Paiement$CommandeArgs<ExtArgs>
    Vente?: boolean | Paiement$VenteArgs<ExtArgs>
    _count?: boolean | PaiementCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paiement"]>

  export type PaiementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    montant?: boolean
    moyen_paiement?: boolean
    deviseId?: boolean
    caisseId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    caisse?: boolean | CaisseDefaultArgs<ExtArgs>
    devise?: boolean | DeviseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paiement"]>

  export type PaiementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    montant?: boolean
    moyen_paiement?: boolean
    deviseId?: boolean
    caisseId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    caisse?: boolean | CaisseDefaultArgs<ExtArgs>
    devise?: boolean | DeviseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paiement"]>

  export type PaiementSelectScalar = {
    id?: boolean
    montant?: boolean
    moyen_paiement?: boolean
    deviseId?: boolean
    caisseId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaiementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "montant" | "moyen_paiement" | "deviseId" | "caisseId" | "createdAt" | "updatedAt", ExtArgs["result"]["paiement"]>
  export type PaiementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    caisse?: boolean | CaisseDefaultArgs<ExtArgs>
    devise?: boolean | DeviseDefaultArgs<ExtArgs>
    Achat?: boolean | Paiement$AchatArgs<ExtArgs>
    Commande?: boolean | Paiement$CommandeArgs<ExtArgs>
    Vente?: boolean | Paiement$VenteArgs<ExtArgs>
    _count?: boolean | PaiementCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PaiementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    caisse?: boolean | CaisseDefaultArgs<ExtArgs>
    devise?: boolean | DeviseDefaultArgs<ExtArgs>
  }
  export type PaiementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    caisse?: boolean | CaisseDefaultArgs<ExtArgs>
    devise?: boolean | DeviseDefaultArgs<ExtArgs>
  }

  export type $PaiementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Paiement"
    objects: {
      caisse: Prisma.$CaissePayload<ExtArgs>
      devise: Prisma.$DevisePayload<ExtArgs>
      Achat: Prisma.$AchatPayload<ExtArgs>[]
      Commande: Prisma.$CommandePayload<ExtArgs>[]
      Vente: Prisma.$VentePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      montant: number
      moyen_paiement: $Enums.MoyenPaiment
      deviseId: number
      caisseId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["paiement"]>
    composites: {}
  }

  type PaiementGetPayload<S extends boolean | null | undefined | PaiementDefaultArgs> = $Result.GetResult<Prisma.$PaiementPayload, S>

  type PaiementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaiementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaiementCountAggregateInputType | true
    }

  export interface PaiementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Paiement'], meta: { name: 'Paiement' } }
    /**
     * Find zero or one Paiement that matches the filter.
     * @param {PaiementFindUniqueArgs} args - Arguments to find a Paiement
     * @example
     * // Get one Paiement
     * const paiement = await prisma.paiement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaiementFindUniqueArgs>(args: SelectSubset<T, PaiementFindUniqueArgs<ExtArgs>>): Prisma__PaiementClient<$Result.GetResult<Prisma.$PaiementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Paiement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaiementFindUniqueOrThrowArgs} args - Arguments to find a Paiement
     * @example
     * // Get one Paiement
     * const paiement = await prisma.paiement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaiementFindUniqueOrThrowArgs>(args: SelectSubset<T, PaiementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaiementClient<$Result.GetResult<Prisma.$PaiementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Paiement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaiementFindFirstArgs} args - Arguments to find a Paiement
     * @example
     * // Get one Paiement
     * const paiement = await prisma.paiement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaiementFindFirstArgs>(args?: SelectSubset<T, PaiementFindFirstArgs<ExtArgs>>): Prisma__PaiementClient<$Result.GetResult<Prisma.$PaiementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Paiement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaiementFindFirstOrThrowArgs} args - Arguments to find a Paiement
     * @example
     * // Get one Paiement
     * const paiement = await prisma.paiement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaiementFindFirstOrThrowArgs>(args?: SelectSubset<T, PaiementFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaiementClient<$Result.GetResult<Prisma.$PaiementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Paiements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaiementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Paiements
     * const paiements = await prisma.paiement.findMany()
     * 
     * // Get first 10 Paiements
     * const paiements = await prisma.paiement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paiementWithIdOnly = await prisma.paiement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaiementFindManyArgs>(args?: SelectSubset<T, PaiementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaiementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Paiement.
     * @param {PaiementCreateArgs} args - Arguments to create a Paiement.
     * @example
     * // Create one Paiement
     * const Paiement = await prisma.paiement.create({
     *   data: {
     *     // ... data to create a Paiement
     *   }
     * })
     * 
     */
    create<T extends PaiementCreateArgs>(args: SelectSubset<T, PaiementCreateArgs<ExtArgs>>): Prisma__PaiementClient<$Result.GetResult<Prisma.$PaiementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Paiements.
     * @param {PaiementCreateManyArgs} args - Arguments to create many Paiements.
     * @example
     * // Create many Paiements
     * const paiement = await prisma.paiement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaiementCreateManyArgs>(args?: SelectSubset<T, PaiementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Paiements and returns the data saved in the database.
     * @param {PaiementCreateManyAndReturnArgs} args - Arguments to create many Paiements.
     * @example
     * // Create many Paiements
     * const paiement = await prisma.paiement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Paiements and only return the `id`
     * const paiementWithIdOnly = await prisma.paiement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaiementCreateManyAndReturnArgs>(args?: SelectSubset<T, PaiementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaiementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Paiement.
     * @param {PaiementDeleteArgs} args - Arguments to delete one Paiement.
     * @example
     * // Delete one Paiement
     * const Paiement = await prisma.paiement.delete({
     *   where: {
     *     // ... filter to delete one Paiement
     *   }
     * })
     * 
     */
    delete<T extends PaiementDeleteArgs>(args: SelectSubset<T, PaiementDeleteArgs<ExtArgs>>): Prisma__PaiementClient<$Result.GetResult<Prisma.$PaiementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Paiement.
     * @param {PaiementUpdateArgs} args - Arguments to update one Paiement.
     * @example
     * // Update one Paiement
     * const paiement = await prisma.paiement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaiementUpdateArgs>(args: SelectSubset<T, PaiementUpdateArgs<ExtArgs>>): Prisma__PaiementClient<$Result.GetResult<Prisma.$PaiementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Paiements.
     * @param {PaiementDeleteManyArgs} args - Arguments to filter Paiements to delete.
     * @example
     * // Delete a few Paiements
     * const { count } = await prisma.paiement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaiementDeleteManyArgs>(args?: SelectSubset<T, PaiementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Paiements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaiementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Paiements
     * const paiement = await prisma.paiement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaiementUpdateManyArgs>(args: SelectSubset<T, PaiementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Paiements and returns the data updated in the database.
     * @param {PaiementUpdateManyAndReturnArgs} args - Arguments to update many Paiements.
     * @example
     * // Update many Paiements
     * const paiement = await prisma.paiement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Paiements and only return the `id`
     * const paiementWithIdOnly = await prisma.paiement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaiementUpdateManyAndReturnArgs>(args: SelectSubset<T, PaiementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaiementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Paiement.
     * @param {PaiementUpsertArgs} args - Arguments to update or create a Paiement.
     * @example
     * // Update or create a Paiement
     * const paiement = await prisma.paiement.upsert({
     *   create: {
     *     // ... data to create a Paiement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Paiement we want to update
     *   }
     * })
     */
    upsert<T extends PaiementUpsertArgs>(args: SelectSubset<T, PaiementUpsertArgs<ExtArgs>>): Prisma__PaiementClient<$Result.GetResult<Prisma.$PaiementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Paiements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaiementCountArgs} args - Arguments to filter Paiements to count.
     * @example
     * // Count the number of Paiements
     * const count = await prisma.paiement.count({
     *   where: {
     *     // ... the filter for the Paiements we want to count
     *   }
     * })
    **/
    count<T extends PaiementCountArgs>(
      args?: Subset<T, PaiementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaiementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Paiement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaiementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaiementAggregateArgs>(args: Subset<T, PaiementAggregateArgs>): Prisma.PrismaPromise<GetPaiementAggregateType<T>>

    /**
     * Group by Paiement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaiementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaiementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaiementGroupByArgs['orderBy'] }
        : { orderBy?: PaiementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaiementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaiementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Paiement model
   */
  readonly fields: PaiementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Paiement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaiementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    caisse<T extends CaisseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CaisseDefaultArgs<ExtArgs>>): Prisma__CaisseClient<$Result.GetResult<Prisma.$CaissePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    devise<T extends DeviseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DeviseDefaultArgs<ExtArgs>>): Prisma__DeviseClient<$Result.GetResult<Prisma.$DevisePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Achat<T extends Paiement$AchatArgs<ExtArgs> = {}>(args?: Subset<T, Paiement$AchatArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Commande<T extends Paiement$CommandeArgs<ExtArgs> = {}>(args?: Subset<T, Paiement$CommandeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommandePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Vente<T extends Paiement$VenteArgs<ExtArgs> = {}>(args?: Subset<T, Paiement$VenteArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VentePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Paiement model
   */
  interface PaiementFieldRefs {
    readonly id: FieldRef<"Paiement", 'Int'>
    readonly montant: FieldRef<"Paiement", 'Float'>
    readonly moyen_paiement: FieldRef<"Paiement", 'MoyenPaiment'>
    readonly deviseId: FieldRef<"Paiement", 'Int'>
    readonly caisseId: FieldRef<"Paiement", 'Int'>
    readonly createdAt: FieldRef<"Paiement", 'DateTime'>
    readonly updatedAt: FieldRef<"Paiement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Paiement findUnique
   */
  export type PaiementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paiement
     */
    select?: PaiementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Paiement
     */
    omit?: PaiementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaiementInclude<ExtArgs> | null
    /**
     * Filter, which Paiement to fetch.
     */
    where: PaiementWhereUniqueInput
  }

  /**
   * Paiement findUniqueOrThrow
   */
  export type PaiementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paiement
     */
    select?: PaiementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Paiement
     */
    omit?: PaiementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaiementInclude<ExtArgs> | null
    /**
     * Filter, which Paiement to fetch.
     */
    where: PaiementWhereUniqueInput
  }

  /**
   * Paiement findFirst
   */
  export type PaiementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paiement
     */
    select?: PaiementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Paiement
     */
    omit?: PaiementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaiementInclude<ExtArgs> | null
    /**
     * Filter, which Paiement to fetch.
     */
    where?: PaiementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Paiements to fetch.
     */
    orderBy?: PaiementOrderByWithRelationInput | PaiementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Paiements.
     */
    cursor?: PaiementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Paiements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Paiements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Paiements.
     */
    distinct?: PaiementScalarFieldEnum | PaiementScalarFieldEnum[]
  }

  /**
   * Paiement findFirstOrThrow
   */
  export type PaiementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paiement
     */
    select?: PaiementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Paiement
     */
    omit?: PaiementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaiementInclude<ExtArgs> | null
    /**
     * Filter, which Paiement to fetch.
     */
    where?: PaiementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Paiements to fetch.
     */
    orderBy?: PaiementOrderByWithRelationInput | PaiementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Paiements.
     */
    cursor?: PaiementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Paiements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Paiements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Paiements.
     */
    distinct?: PaiementScalarFieldEnum | PaiementScalarFieldEnum[]
  }

  /**
   * Paiement findMany
   */
  export type PaiementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paiement
     */
    select?: PaiementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Paiement
     */
    omit?: PaiementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaiementInclude<ExtArgs> | null
    /**
     * Filter, which Paiements to fetch.
     */
    where?: PaiementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Paiements to fetch.
     */
    orderBy?: PaiementOrderByWithRelationInput | PaiementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Paiements.
     */
    cursor?: PaiementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Paiements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Paiements.
     */
    skip?: number
    distinct?: PaiementScalarFieldEnum | PaiementScalarFieldEnum[]
  }

  /**
   * Paiement create
   */
  export type PaiementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paiement
     */
    select?: PaiementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Paiement
     */
    omit?: PaiementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaiementInclude<ExtArgs> | null
    /**
     * The data needed to create a Paiement.
     */
    data: XOR<PaiementCreateInput, PaiementUncheckedCreateInput>
  }

  /**
   * Paiement createMany
   */
  export type PaiementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Paiements.
     */
    data: PaiementCreateManyInput | PaiementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Paiement createManyAndReturn
   */
  export type PaiementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paiement
     */
    select?: PaiementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Paiement
     */
    omit?: PaiementOmit<ExtArgs> | null
    /**
     * The data used to create many Paiements.
     */
    data: PaiementCreateManyInput | PaiementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaiementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Paiement update
   */
  export type PaiementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paiement
     */
    select?: PaiementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Paiement
     */
    omit?: PaiementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaiementInclude<ExtArgs> | null
    /**
     * The data needed to update a Paiement.
     */
    data: XOR<PaiementUpdateInput, PaiementUncheckedUpdateInput>
    /**
     * Choose, which Paiement to update.
     */
    where: PaiementWhereUniqueInput
  }

  /**
   * Paiement updateMany
   */
  export type PaiementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Paiements.
     */
    data: XOR<PaiementUpdateManyMutationInput, PaiementUncheckedUpdateManyInput>
    /**
     * Filter which Paiements to update
     */
    where?: PaiementWhereInput
    /**
     * Limit how many Paiements to update.
     */
    limit?: number
  }

  /**
   * Paiement updateManyAndReturn
   */
  export type PaiementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paiement
     */
    select?: PaiementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Paiement
     */
    omit?: PaiementOmit<ExtArgs> | null
    /**
     * The data used to update Paiements.
     */
    data: XOR<PaiementUpdateManyMutationInput, PaiementUncheckedUpdateManyInput>
    /**
     * Filter which Paiements to update
     */
    where?: PaiementWhereInput
    /**
     * Limit how many Paiements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaiementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Paiement upsert
   */
  export type PaiementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paiement
     */
    select?: PaiementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Paiement
     */
    omit?: PaiementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaiementInclude<ExtArgs> | null
    /**
     * The filter to search for the Paiement to update in case it exists.
     */
    where: PaiementWhereUniqueInput
    /**
     * In case the Paiement found by the `where` argument doesn't exist, create a new Paiement with this data.
     */
    create: XOR<PaiementCreateInput, PaiementUncheckedCreateInput>
    /**
     * In case the Paiement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaiementUpdateInput, PaiementUncheckedUpdateInput>
  }

  /**
   * Paiement delete
   */
  export type PaiementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paiement
     */
    select?: PaiementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Paiement
     */
    omit?: PaiementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaiementInclude<ExtArgs> | null
    /**
     * Filter which Paiement to delete.
     */
    where: PaiementWhereUniqueInput
  }

  /**
   * Paiement deleteMany
   */
  export type PaiementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Paiements to delete
     */
    where?: PaiementWhereInput
    /**
     * Limit how many Paiements to delete.
     */
    limit?: number
  }

  /**
   * Paiement.Achat
   */
  export type Paiement$AchatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achat
     */
    select?: AchatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achat
     */
    omit?: AchatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchatInclude<ExtArgs> | null
    where?: AchatWhereInput
    orderBy?: AchatOrderByWithRelationInput | AchatOrderByWithRelationInput[]
    cursor?: AchatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AchatScalarFieldEnum | AchatScalarFieldEnum[]
  }

  /**
   * Paiement.Commande
   */
  export type Paiement$CommandeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commande
     */
    select?: CommandeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Commande
     */
    omit?: CommandeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandeInclude<ExtArgs> | null
    where?: CommandeWhereInput
    orderBy?: CommandeOrderByWithRelationInput | CommandeOrderByWithRelationInput[]
    cursor?: CommandeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommandeScalarFieldEnum | CommandeScalarFieldEnum[]
  }

  /**
   * Paiement.Vente
   */
  export type Paiement$VenteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vente
     */
    select?: VenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vente
     */
    omit?: VenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenteInclude<ExtArgs> | null
    where?: VenteWhereInput
    orderBy?: VenteOrderByWithRelationInput | VenteOrderByWithRelationInput[]
    cursor?: VenteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VenteScalarFieldEnum | VenteScalarFieldEnum[]
  }

  /**
   * Paiement without action
   */
  export type PaiementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paiement
     */
    select?: PaiementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Paiement
     */
    omit?: PaiementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaiementInclude<ExtArgs> | null
  }


  /**
   * Model Caisse
   */

  export type AggregateCaisse = {
    _count: CaisseCountAggregateOutputType | null
    _avg: CaisseAvgAggregateOutputType | null
    _sum: CaisseSumAggregateOutputType | null
    _min: CaisseMinAggregateOutputType | null
    _max: CaisseMaxAggregateOutputType | null
  }

  export type CaisseAvgAggregateOutputType = {
    id: number | null
    soldeInitial: number | null
    soldeActuel: number | null
    deviseId: number | null
    creeParId: number | null
  }

  export type CaisseSumAggregateOutputType = {
    id: number | null
    soldeInitial: number | null
    soldeActuel: number | null
    deviseId: number | null
    creeParId: number | null
  }

  export type CaisseMinAggregateOutputType = {
    id: number | null
    nom: string | null
    description: string | null
    soldeInitial: number | null
    soldeActuel: number | null
    deviseId: number | null
    creeParId: number | null
    statut: $Enums.StatutCaisse | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CaisseMaxAggregateOutputType = {
    id: number | null
    nom: string | null
    description: string | null
    soldeInitial: number | null
    soldeActuel: number | null
    deviseId: number | null
    creeParId: number | null
    statut: $Enums.StatutCaisse | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CaisseCountAggregateOutputType = {
    id: number
    nom: number
    description: number
    soldeInitial: number
    soldeActuel: number
    deviseId: number
    creeParId: number
    statut: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CaisseAvgAggregateInputType = {
    id?: true
    soldeInitial?: true
    soldeActuel?: true
    deviseId?: true
    creeParId?: true
  }

  export type CaisseSumAggregateInputType = {
    id?: true
    soldeInitial?: true
    soldeActuel?: true
    deviseId?: true
    creeParId?: true
  }

  export type CaisseMinAggregateInputType = {
    id?: true
    nom?: true
    description?: true
    soldeInitial?: true
    soldeActuel?: true
    deviseId?: true
    creeParId?: true
    statut?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CaisseMaxAggregateInputType = {
    id?: true
    nom?: true
    description?: true
    soldeInitial?: true
    soldeActuel?: true
    deviseId?: true
    creeParId?: true
    statut?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CaisseCountAggregateInputType = {
    id?: true
    nom?: true
    description?: true
    soldeInitial?: true
    soldeActuel?: true
    deviseId?: true
    creeParId?: true
    statut?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CaisseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Caisse to aggregate.
     */
    where?: CaisseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Caisses to fetch.
     */
    orderBy?: CaisseOrderByWithRelationInput | CaisseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CaisseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Caisses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Caisses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Caisses
    **/
    _count?: true | CaisseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CaisseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CaisseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CaisseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CaisseMaxAggregateInputType
  }

  export type GetCaisseAggregateType<T extends CaisseAggregateArgs> = {
        [P in keyof T & keyof AggregateCaisse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCaisse[P]>
      : GetScalarType<T[P], AggregateCaisse[P]>
  }




  export type CaisseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CaisseWhereInput
    orderBy?: CaisseOrderByWithAggregationInput | CaisseOrderByWithAggregationInput[]
    by: CaisseScalarFieldEnum[] | CaisseScalarFieldEnum
    having?: CaisseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CaisseCountAggregateInputType | true
    _avg?: CaisseAvgAggregateInputType
    _sum?: CaisseSumAggregateInputType
    _min?: CaisseMinAggregateInputType
    _max?: CaisseMaxAggregateInputType
  }

  export type CaisseGroupByOutputType = {
    id: number
    nom: string
    description: string | null
    soldeInitial: number
    soldeActuel: number
    deviseId: number
    creeParId: number
    statut: $Enums.StatutCaisse
    createdAt: Date
    updatedAt: Date
    _count: CaisseCountAggregateOutputType | null
    _avg: CaisseAvgAggregateOutputType | null
    _sum: CaisseSumAggregateOutputType | null
    _min: CaisseMinAggregateOutputType | null
    _max: CaisseMaxAggregateOutputType | null
  }

  type GetCaisseGroupByPayload<T extends CaisseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CaisseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CaisseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CaisseGroupByOutputType[P]>
            : GetScalarType<T[P], CaisseGroupByOutputType[P]>
        }
      >
    >


  export type CaisseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    description?: boolean
    soldeInitial?: boolean
    soldeActuel?: boolean
    deviseId?: boolean
    creeParId?: boolean
    statut?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    devise?: boolean | DeviseDefaultArgs<ExtArgs>
    utilisateur?: boolean | UtilisateurDefaultArgs<ExtArgs>
    MouvementCaisse?: boolean | Caisse$MouvementCaisseArgs<ExtArgs>
    clotures?: boolean | Caisse$cloturesArgs<ExtArgs>
    Paiement?: boolean | Caisse$PaiementArgs<ExtArgs>
    _count?: boolean | CaisseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["caisse"]>

  export type CaisseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    description?: boolean
    soldeInitial?: boolean
    soldeActuel?: boolean
    deviseId?: boolean
    creeParId?: boolean
    statut?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    devise?: boolean | DeviseDefaultArgs<ExtArgs>
    utilisateur?: boolean | UtilisateurDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["caisse"]>

  export type CaisseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    description?: boolean
    soldeInitial?: boolean
    soldeActuel?: boolean
    deviseId?: boolean
    creeParId?: boolean
    statut?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    devise?: boolean | DeviseDefaultArgs<ExtArgs>
    utilisateur?: boolean | UtilisateurDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["caisse"]>

  export type CaisseSelectScalar = {
    id?: boolean
    nom?: boolean
    description?: boolean
    soldeInitial?: boolean
    soldeActuel?: boolean
    deviseId?: boolean
    creeParId?: boolean
    statut?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CaisseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nom" | "description" | "soldeInitial" | "soldeActuel" | "deviseId" | "creeParId" | "statut" | "createdAt" | "updatedAt", ExtArgs["result"]["caisse"]>
  export type CaisseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    devise?: boolean | DeviseDefaultArgs<ExtArgs>
    utilisateur?: boolean | UtilisateurDefaultArgs<ExtArgs>
    MouvementCaisse?: boolean | Caisse$MouvementCaisseArgs<ExtArgs>
    clotures?: boolean | Caisse$cloturesArgs<ExtArgs>
    Paiement?: boolean | Caisse$PaiementArgs<ExtArgs>
    _count?: boolean | CaisseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CaisseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    devise?: boolean | DeviseDefaultArgs<ExtArgs>
    utilisateur?: boolean | UtilisateurDefaultArgs<ExtArgs>
  }
  export type CaisseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    devise?: boolean | DeviseDefaultArgs<ExtArgs>
    utilisateur?: boolean | UtilisateurDefaultArgs<ExtArgs>
  }

  export type $CaissePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Caisse"
    objects: {
      devise: Prisma.$DevisePayload<ExtArgs>
      utilisateur: Prisma.$UtilisateurPayload<ExtArgs>
      MouvementCaisse: Prisma.$MouvementCaissePayload<ExtArgs>[]
      clotures: Prisma.$ClotureCaissePayload<ExtArgs>[]
      Paiement: Prisma.$PaiementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nom: string
      description: string | null
      soldeInitial: number
      soldeActuel: number
      deviseId: number
      creeParId: number
      statut: $Enums.StatutCaisse
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["caisse"]>
    composites: {}
  }

  type CaisseGetPayload<S extends boolean | null | undefined | CaisseDefaultArgs> = $Result.GetResult<Prisma.$CaissePayload, S>

  type CaisseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CaisseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CaisseCountAggregateInputType | true
    }

  export interface CaisseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Caisse'], meta: { name: 'Caisse' } }
    /**
     * Find zero or one Caisse that matches the filter.
     * @param {CaisseFindUniqueArgs} args - Arguments to find a Caisse
     * @example
     * // Get one Caisse
     * const caisse = await prisma.caisse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CaisseFindUniqueArgs>(args: SelectSubset<T, CaisseFindUniqueArgs<ExtArgs>>): Prisma__CaisseClient<$Result.GetResult<Prisma.$CaissePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Caisse that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CaisseFindUniqueOrThrowArgs} args - Arguments to find a Caisse
     * @example
     * // Get one Caisse
     * const caisse = await prisma.caisse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CaisseFindUniqueOrThrowArgs>(args: SelectSubset<T, CaisseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CaisseClient<$Result.GetResult<Prisma.$CaissePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Caisse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaisseFindFirstArgs} args - Arguments to find a Caisse
     * @example
     * // Get one Caisse
     * const caisse = await prisma.caisse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CaisseFindFirstArgs>(args?: SelectSubset<T, CaisseFindFirstArgs<ExtArgs>>): Prisma__CaisseClient<$Result.GetResult<Prisma.$CaissePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Caisse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaisseFindFirstOrThrowArgs} args - Arguments to find a Caisse
     * @example
     * // Get one Caisse
     * const caisse = await prisma.caisse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CaisseFindFirstOrThrowArgs>(args?: SelectSubset<T, CaisseFindFirstOrThrowArgs<ExtArgs>>): Prisma__CaisseClient<$Result.GetResult<Prisma.$CaissePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Caisses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaisseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Caisses
     * const caisses = await prisma.caisse.findMany()
     * 
     * // Get first 10 Caisses
     * const caisses = await prisma.caisse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const caisseWithIdOnly = await prisma.caisse.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CaisseFindManyArgs>(args?: SelectSubset<T, CaisseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CaissePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Caisse.
     * @param {CaisseCreateArgs} args - Arguments to create a Caisse.
     * @example
     * // Create one Caisse
     * const Caisse = await prisma.caisse.create({
     *   data: {
     *     // ... data to create a Caisse
     *   }
     * })
     * 
     */
    create<T extends CaisseCreateArgs>(args: SelectSubset<T, CaisseCreateArgs<ExtArgs>>): Prisma__CaisseClient<$Result.GetResult<Prisma.$CaissePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Caisses.
     * @param {CaisseCreateManyArgs} args - Arguments to create many Caisses.
     * @example
     * // Create many Caisses
     * const caisse = await prisma.caisse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CaisseCreateManyArgs>(args?: SelectSubset<T, CaisseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Caisses and returns the data saved in the database.
     * @param {CaisseCreateManyAndReturnArgs} args - Arguments to create many Caisses.
     * @example
     * // Create many Caisses
     * const caisse = await prisma.caisse.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Caisses and only return the `id`
     * const caisseWithIdOnly = await prisma.caisse.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CaisseCreateManyAndReturnArgs>(args?: SelectSubset<T, CaisseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CaissePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Caisse.
     * @param {CaisseDeleteArgs} args - Arguments to delete one Caisse.
     * @example
     * // Delete one Caisse
     * const Caisse = await prisma.caisse.delete({
     *   where: {
     *     // ... filter to delete one Caisse
     *   }
     * })
     * 
     */
    delete<T extends CaisseDeleteArgs>(args: SelectSubset<T, CaisseDeleteArgs<ExtArgs>>): Prisma__CaisseClient<$Result.GetResult<Prisma.$CaissePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Caisse.
     * @param {CaisseUpdateArgs} args - Arguments to update one Caisse.
     * @example
     * // Update one Caisse
     * const caisse = await prisma.caisse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CaisseUpdateArgs>(args: SelectSubset<T, CaisseUpdateArgs<ExtArgs>>): Prisma__CaisseClient<$Result.GetResult<Prisma.$CaissePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Caisses.
     * @param {CaisseDeleteManyArgs} args - Arguments to filter Caisses to delete.
     * @example
     * // Delete a few Caisses
     * const { count } = await prisma.caisse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CaisseDeleteManyArgs>(args?: SelectSubset<T, CaisseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Caisses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaisseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Caisses
     * const caisse = await prisma.caisse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CaisseUpdateManyArgs>(args: SelectSubset<T, CaisseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Caisses and returns the data updated in the database.
     * @param {CaisseUpdateManyAndReturnArgs} args - Arguments to update many Caisses.
     * @example
     * // Update many Caisses
     * const caisse = await prisma.caisse.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Caisses and only return the `id`
     * const caisseWithIdOnly = await prisma.caisse.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CaisseUpdateManyAndReturnArgs>(args: SelectSubset<T, CaisseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CaissePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Caisse.
     * @param {CaisseUpsertArgs} args - Arguments to update or create a Caisse.
     * @example
     * // Update or create a Caisse
     * const caisse = await prisma.caisse.upsert({
     *   create: {
     *     // ... data to create a Caisse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Caisse we want to update
     *   }
     * })
     */
    upsert<T extends CaisseUpsertArgs>(args: SelectSubset<T, CaisseUpsertArgs<ExtArgs>>): Prisma__CaisseClient<$Result.GetResult<Prisma.$CaissePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Caisses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaisseCountArgs} args - Arguments to filter Caisses to count.
     * @example
     * // Count the number of Caisses
     * const count = await prisma.caisse.count({
     *   where: {
     *     // ... the filter for the Caisses we want to count
     *   }
     * })
    **/
    count<T extends CaisseCountArgs>(
      args?: Subset<T, CaisseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CaisseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Caisse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaisseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CaisseAggregateArgs>(args: Subset<T, CaisseAggregateArgs>): Prisma.PrismaPromise<GetCaisseAggregateType<T>>

    /**
     * Group by Caisse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaisseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CaisseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CaisseGroupByArgs['orderBy'] }
        : { orderBy?: CaisseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CaisseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCaisseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Caisse model
   */
  readonly fields: CaisseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Caisse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CaisseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    devise<T extends DeviseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DeviseDefaultArgs<ExtArgs>>): Prisma__DeviseClient<$Result.GetResult<Prisma.$DevisePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    utilisateur<T extends UtilisateurDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UtilisateurDefaultArgs<ExtArgs>>): Prisma__UtilisateurClient<$Result.GetResult<Prisma.$UtilisateurPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    MouvementCaisse<T extends Caisse$MouvementCaisseArgs<ExtArgs> = {}>(args?: Subset<T, Caisse$MouvementCaisseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MouvementCaissePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    clotures<T extends Caisse$cloturesArgs<ExtArgs> = {}>(args?: Subset<T, Caisse$cloturesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClotureCaissePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Paiement<T extends Caisse$PaiementArgs<ExtArgs> = {}>(args?: Subset<T, Caisse$PaiementArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaiementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Caisse model
   */
  interface CaisseFieldRefs {
    readonly id: FieldRef<"Caisse", 'Int'>
    readonly nom: FieldRef<"Caisse", 'String'>
    readonly description: FieldRef<"Caisse", 'String'>
    readonly soldeInitial: FieldRef<"Caisse", 'Float'>
    readonly soldeActuel: FieldRef<"Caisse", 'Float'>
    readonly deviseId: FieldRef<"Caisse", 'Int'>
    readonly creeParId: FieldRef<"Caisse", 'Int'>
    readonly statut: FieldRef<"Caisse", 'StatutCaisse'>
    readonly createdAt: FieldRef<"Caisse", 'DateTime'>
    readonly updatedAt: FieldRef<"Caisse", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Caisse findUnique
   */
  export type CaisseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Caisse
     */
    select?: CaisseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Caisse
     */
    omit?: CaisseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaisseInclude<ExtArgs> | null
    /**
     * Filter, which Caisse to fetch.
     */
    where: CaisseWhereUniqueInput
  }

  /**
   * Caisse findUniqueOrThrow
   */
  export type CaisseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Caisse
     */
    select?: CaisseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Caisse
     */
    omit?: CaisseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaisseInclude<ExtArgs> | null
    /**
     * Filter, which Caisse to fetch.
     */
    where: CaisseWhereUniqueInput
  }

  /**
   * Caisse findFirst
   */
  export type CaisseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Caisse
     */
    select?: CaisseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Caisse
     */
    omit?: CaisseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaisseInclude<ExtArgs> | null
    /**
     * Filter, which Caisse to fetch.
     */
    where?: CaisseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Caisses to fetch.
     */
    orderBy?: CaisseOrderByWithRelationInput | CaisseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Caisses.
     */
    cursor?: CaisseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Caisses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Caisses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Caisses.
     */
    distinct?: CaisseScalarFieldEnum | CaisseScalarFieldEnum[]
  }

  /**
   * Caisse findFirstOrThrow
   */
  export type CaisseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Caisse
     */
    select?: CaisseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Caisse
     */
    omit?: CaisseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaisseInclude<ExtArgs> | null
    /**
     * Filter, which Caisse to fetch.
     */
    where?: CaisseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Caisses to fetch.
     */
    orderBy?: CaisseOrderByWithRelationInput | CaisseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Caisses.
     */
    cursor?: CaisseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Caisses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Caisses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Caisses.
     */
    distinct?: CaisseScalarFieldEnum | CaisseScalarFieldEnum[]
  }

  /**
   * Caisse findMany
   */
  export type CaisseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Caisse
     */
    select?: CaisseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Caisse
     */
    omit?: CaisseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaisseInclude<ExtArgs> | null
    /**
     * Filter, which Caisses to fetch.
     */
    where?: CaisseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Caisses to fetch.
     */
    orderBy?: CaisseOrderByWithRelationInput | CaisseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Caisses.
     */
    cursor?: CaisseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Caisses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Caisses.
     */
    skip?: number
    distinct?: CaisseScalarFieldEnum | CaisseScalarFieldEnum[]
  }

  /**
   * Caisse create
   */
  export type CaisseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Caisse
     */
    select?: CaisseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Caisse
     */
    omit?: CaisseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaisseInclude<ExtArgs> | null
    /**
     * The data needed to create a Caisse.
     */
    data: XOR<CaisseCreateInput, CaisseUncheckedCreateInput>
  }

  /**
   * Caisse createMany
   */
  export type CaisseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Caisses.
     */
    data: CaisseCreateManyInput | CaisseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Caisse createManyAndReturn
   */
  export type CaisseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Caisse
     */
    select?: CaisseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Caisse
     */
    omit?: CaisseOmit<ExtArgs> | null
    /**
     * The data used to create many Caisses.
     */
    data: CaisseCreateManyInput | CaisseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaisseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Caisse update
   */
  export type CaisseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Caisse
     */
    select?: CaisseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Caisse
     */
    omit?: CaisseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaisseInclude<ExtArgs> | null
    /**
     * The data needed to update a Caisse.
     */
    data: XOR<CaisseUpdateInput, CaisseUncheckedUpdateInput>
    /**
     * Choose, which Caisse to update.
     */
    where: CaisseWhereUniqueInput
  }

  /**
   * Caisse updateMany
   */
  export type CaisseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Caisses.
     */
    data: XOR<CaisseUpdateManyMutationInput, CaisseUncheckedUpdateManyInput>
    /**
     * Filter which Caisses to update
     */
    where?: CaisseWhereInput
    /**
     * Limit how many Caisses to update.
     */
    limit?: number
  }

  /**
   * Caisse updateManyAndReturn
   */
  export type CaisseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Caisse
     */
    select?: CaisseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Caisse
     */
    omit?: CaisseOmit<ExtArgs> | null
    /**
     * The data used to update Caisses.
     */
    data: XOR<CaisseUpdateManyMutationInput, CaisseUncheckedUpdateManyInput>
    /**
     * Filter which Caisses to update
     */
    where?: CaisseWhereInput
    /**
     * Limit how many Caisses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaisseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Caisse upsert
   */
  export type CaisseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Caisse
     */
    select?: CaisseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Caisse
     */
    omit?: CaisseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaisseInclude<ExtArgs> | null
    /**
     * The filter to search for the Caisse to update in case it exists.
     */
    where: CaisseWhereUniqueInput
    /**
     * In case the Caisse found by the `where` argument doesn't exist, create a new Caisse with this data.
     */
    create: XOR<CaisseCreateInput, CaisseUncheckedCreateInput>
    /**
     * In case the Caisse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CaisseUpdateInput, CaisseUncheckedUpdateInput>
  }

  /**
   * Caisse delete
   */
  export type CaisseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Caisse
     */
    select?: CaisseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Caisse
     */
    omit?: CaisseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaisseInclude<ExtArgs> | null
    /**
     * Filter which Caisse to delete.
     */
    where: CaisseWhereUniqueInput
  }

  /**
   * Caisse deleteMany
   */
  export type CaisseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Caisses to delete
     */
    where?: CaisseWhereInput
    /**
     * Limit how many Caisses to delete.
     */
    limit?: number
  }

  /**
   * Caisse.MouvementCaisse
   */
  export type Caisse$MouvementCaisseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MouvementCaisse
     */
    select?: MouvementCaisseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MouvementCaisse
     */
    omit?: MouvementCaisseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MouvementCaisseInclude<ExtArgs> | null
    where?: MouvementCaisseWhereInput
    orderBy?: MouvementCaisseOrderByWithRelationInput | MouvementCaisseOrderByWithRelationInput[]
    cursor?: MouvementCaisseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MouvementCaisseScalarFieldEnum | MouvementCaisseScalarFieldEnum[]
  }

  /**
   * Caisse.clotures
   */
  export type Caisse$cloturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClotureCaisse
     */
    select?: ClotureCaisseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClotureCaisse
     */
    omit?: ClotureCaisseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClotureCaisseInclude<ExtArgs> | null
    where?: ClotureCaisseWhereInput
    orderBy?: ClotureCaisseOrderByWithRelationInput | ClotureCaisseOrderByWithRelationInput[]
    cursor?: ClotureCaisseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClotureCaisseScalarFieldEnum | ClotureCaisseScalarFieldEnum[]
  }

  /**
   * Caisse.Paiement
   */
  export type Caisse$PaiementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paiement
     */
    select?: PaiementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Paiement
     */
    omit?: PaiementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaiementInclude<ExtArgs> | null
    where?: PaiementWhereInput
    orderBy?: PaiementOrderByWithRelationInput | PaiementOrderByWithRelationInput[]
    cursor?: PaiementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaiementScalarFieldEnum | PaiementScalarFieldEnum[]
  }

  /**
   * Caisse without action
   */
  export type CaisseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Caisse
     */
    select?: CaisseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Caisse
     */
    omit?: CaisseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaisseInclude<ExtArgs> | null
  }


  /**
   * Model Vente
   */

  export type AggregateVente = {
    _count: VenteCountAggregateOutputType | null
    _avg: VenteAvgAggregateOutputType | null
    _sum: VenteSumAggregateOutputType | null
    _min: VenteMinAggregateOutputType | null
    _max: VenteMaxAggregateOutputType | null
  }

  export type VenteAvgAggregateOutputType = {
    id: number | null
    total_ttc: number | null
    total_ht: number | null
    clientId: number | null
    enregistrerParId: number | null
    fournisseurId: number | null
    agentId: number | null
    paiementId: number | null
    panierId: number | null
  }

  export type VenteSumAggregateOutputType = {
    id: number | null
    total_ttc: number | null
    total_ht: number | null
    clientId: number | null
    enregistrerParId: number | null
    fournisseurId: number | null
    agentId: number | null
    paiementId: number | null
    panierId: number | null
  }

  export type VenteMinAggregateOutputType = {
    id: number | null
    statut: $Enums.StatutVente | null
    total_ttc: number | null
    total_ht: number | null
    type_acheteur: $Enums.TypeClient | null
    clientId: number | null
    enregistrerParId: number | null
    fournisseurId: number | null
    agentId: number | null
    paiementId: number | null
    panierId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VenteMaxAggregateOutputType = {
    id: number | null
    statut: $Enums.StatutVente | null
    total_ttc: number | null
    total_ht: number | null
    type_acheteur: $Enums.TypeClient | null
    clientId: number | null
    enregistrerParId: number | null
    fournisseurId: number | null
    agentId: number | null
    paiementId: number | null
    panierId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VenteCountAggregateOutputType = {
    id: number
    statut: number
    total_ttc: number
    total_ht: number
    type_acheteur: number
    clientId: number
    enregistrerParId: number
    fournisseurId: number
    agentId: number
    paiementId: number
    panierId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VenteAvgAggregateInputType = {
    id?: true
    total_ttc?: true
    total_ht?: true
    clientId?: true
    enregistrerParId?: true
    fournisseurId?: true
    agentId?: true
    paiementId?: true
    panierId?: true
  }

  export type VenteSumAggregateInputType = {
    id?: true
    total_ttc?: true
    total_ht?: true
    clientId?: true
    enregistrerParId?: true
    fournisseurId?: true
    agentId?: true
    paiementId?: true
    panierId?: true
  }

  export type VenteMinAggregateInputType = {
    id?: true
    statut?: true
    total_ttc?: true
    total_ht?: true
    type_acheteur?: true
    clientId?: true
    enregistrerParId?: true
    fournisseurId?: true
    agentId?: true
    paiementId?: true
    panierId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VenteMaxAggregateInputType = {
    id?: true
    statut?: true
    total_ttc?: true
    total_ht?: true
    type_acheteur?: true
    clientId?: true
    enregistrerParId?: true
    fournisseurId?: true
    agentId?: true
    paiementId?: true
    panierId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VenteCountAggregateInputType = {
    id?: true
    statut?: true
    total_ttc?: true
    total_ht?: true
    type_acheteur?: true
    clientId?: true
    enregistrerParId?: true
    fournisseurId?: true
    agentId?: true
    paiementId?: true
    panierId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VenteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vente to aggregate.
     */
    where?: VenteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ventes to fetch.
     */
    orderBy?: VenteOrderByWithRelationInput | VenteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VenteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ventes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ventes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Ventes
    **/
    _count?: true | VenteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VenteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VenteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VenteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VenteMaxAggregateInputType
  }

  export type GetVenteAggregateType<T extends VenteAggregateArgs> = {
        [P in keyof T & keyof AggregateVente]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVente[P]>
      : GetScalarType<T[P], AggregateVente[P]>
  }




  export type VenteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VenteWhereInput
    orderBy?: VenteOrderByWithAggregationInput | VenteOrderByWithAggregationInput[]
    by: VenteScalarFieldEnum[] | VenteScalarFieldEnum
    having?: VenteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VenteCountAggregateInputType | true
    _avg?: VenteAvgAggregateInputType
    _sum?: VenteSumAggregateInputType
    _min?: VenteMinAggregateInputType
    _max?: VenteMaxAggregateInputType
  }

  export type VenteGroupByOutputType = {
    id: number
    statut: $Enums.StatutVente
    total_ttc: number
    total_ht: number
    type_acheteur: $Enums.TypeClient
    clientId: number | null
    enregistrerParId: number
    fournisseurId: number | null
    agentId: number | null
    paiementId: number
    panierId: number
    createdAt: Date
    updatedAt: Date
    _count: VenteCountAggregateOutputType | null
    _avg: VenteAvgAggregateOutputType | null
    _sum: VenteSumAggregateOutputType | null
    _min: VenteMinAggregateOutputType | null
    _max: VenteMaxAggregateOutputType | null
  }

  type GetVenteGroupByPayload<T extends VenteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VenteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VenteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VenteGroupByOutputType[P]>
            : GetScalarType<T[P], VenteGroupByOutputType[P]>
        }
      >
    >


  export type VenteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    statut?: boolean
    total_ttc?: boolean
    total_ht?: boolean
    type_acheteur?: boolean
    clientId?: boolean
    enregistrerParId?: boolean
    fournisseurId?: boolean
    agentId?: boolean
    paiementId?: boolean
    panierId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    paiement?: boolean | Vente$paiementArgs<ExtArgs>
    panier?: boolean | PanierDefaultArgs<ExtArgs>
    utilisateur?: boolean | UtilisateurDefaultArgs<ExtArgs>
    fournisseur?: boolean | Vente$fournisseurArgs<ExtArgs>
  }, ExtArgs["result"]["vente"]>

  export type VenteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    statut?: boolean
    total_ttc?: boolean
    total_ht?: boolean
    type_acheteur?: boolean
    clientId?: boolean
    enregistrerParId?: boolean
    fournisseurId?: boolean
    agentId?: boolean
    paiementId?: boolean
    panierId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    paiement?: boolean | Vente$paiementArgs<ExtArgs>
    panier?: boolean | PanierDefaultArgs<ExtArgs>
    utilisateur?: boolean | UtilisateurDefaultArgs<ExtArgs>
    fournisseur?: boolean | Vente$fournisseurArgs<ExtArgs>
  }, ExtArgs["result"]["vente"]>

  export type VenteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    statut?: boolean
    total_ttc?: boolean
    total_ht?: boolean
    type_acheteur?: boolean
    clientId?: boolean
    enregistrerParId?: boolean
    fournisseurId?: boolean
    agentId?: boolean
    paiementId?: boolean
    panierId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    paiement?: boolean | Vente$paiementArgs<ExtArgs>
    panier?: boolean | PanierDefaultArgs<ExtArgs>
    utilisateur?: boolean | UtilisateurDefaultArgs<ExtArgs>
    fournisseur?: boolean | Vente$fournisseurArgs<ExtArgs>
  }, ExtArgs["result"]["vente"]>

  export type VenteSelectScalar = {
    id?: boolean
    statut?: boolean
    total_ttc?: boolean
    total_ht?: boolean
    type_acheteur?: boolean
    clientId?: boolean
    enregistrerParId?: boolean
    fournisseurId?: boolean
    agentId?: boolean
    paiementId?: boolean
    panierId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VenteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "statut" | "total_ttc" | "total_ht" | "type_acheteur" | "clientId" | "enregistrerParId" | "fournisseurId" | "agentId" | "paiementId" | "panierId" | "createdAt" | "updatedAt", ExtArgs["result"]["vente"]>
  export type VenteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    paiement?: boolean | Vente$paiementArgs<ExtArgs>
    panier?: boolean | PanierDefaultArgs<ExtArgs>
    utilisateur?: boolean | UtilisateurDefaultArgs<ExtArgs>
    fournisseur?: boolean | Vente$fournisseurArgs<ExtArgs>
  }
  export type VenteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    paiement?: boolean | Vente$paiementArgs<ExtArgs>
    panier?: boolean | PanierDefaultArgs<ExtArgs>
    utilisateur?: boolean | UtilisateurDefaultArgs<ExtArgs>
    fournisseur?: boolean | Vente$fournisseurArgs<ExtArgs>
  }
  export type VenteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    paiement?: boolean | Vente$paiementArgs<ExtArgs>
    panier?: boolean | PanierDefaultArgs<ExtArgs>
    utilisateur?: boolean | UtilisateurDefaultArgs<ExtArgs>
    fournisseur?: boolean | Vente$fournisseurArgs<ExtArgs>
  }

  export type $VentePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Vente"
    objects: {
      paiement: Prisma.$PaiementPayload<ExtArgs> | null
      panier: Prisma.$PanierPayload<ExtArgs>
      utilisateur: Prisma.$UtilisateurPayload<ExtArgs>
      fournisseur: Prisma.$FournisseurPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      statut: $Enums.StatutVente
      total_ttc: number
      total_ht: number
      type_acheteur: $Enums.TypeClient
      clientId: number | null
      enregistrerParId: number
      fournisseurId: number | null
      agentId: number | null
      paiementId: number
      panierId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["vente"]>
    composites: {}
  }

  type VenteGetPayload<S extends boolean | null | undefined | VenteDefaultArgs> = $Result.GetResult<Prisma.$VentePayload, S>

  type VenteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VenteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VenteCountAggregateInputType | true
    }

  export interface VenteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Vente'], meta: { name: 'Vente' } }
    /**
     * Find zero or one Vente that matches the filter.
     * @param {VenteFindUniqueArgs} args - Arguments to find a Vente
     * @example
     * // Get one Vente
     * const vente = await prisma.vente.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VenteFindUniqueArgs>(args: SelectSubset<T, VenteFindUniqueArgs<ExtArgs>>): Prisma__VenteClient<$Result.GetResult<Prisma.$VentePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Vente that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VenteFindUniqueOrThrowArgs} args - Arguments to find a Vente
     * @example
     * // Get one Vente
     * const vente = await prisma.vente.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VenteFindUniqueOrThrowArgs>(args: SelectSubset<T, VenteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VenteClient<$Result.GetResult<Prisma.$VentePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vente that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenteFindFirstArgs} args - Arguments to find a Vente
     * @example
     * // Get one Vente
     * const vente = await prisma.vente.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VenteFindFirstArgs>(args?: SelectSubset<T, VenteFindFirstArgs<ExtArgs>>): Prisma__VenteClient<$Result.GetResult<Prisma.$VentePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vente that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenteFindFirstOrThrowArgs} args - Arguments to find a Vente
     * @example
     * // Get one Vente
     * const vente = await prisma.vente.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VenteFindFirstOrThrowArgs>(args?: SelectSubset<T, VenteFindFirstOrThrowArgs<ExtArgs>>): Prisma__VenteClient<$Result.GetResult<Prisma.$VentePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ventes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ventes
     * const ventes = await prisma.vente.findMany()
     * 
     * // Get first 10 Ventes
     * const ventes = await prisma.vente.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const venteWithIdOnly = await prisma.vente.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VenteFindManyArgs>(args?: SelectSubset<T, VenteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VentePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Vente.
     * @param {VenteCreateArgs} args - Arguments to create a Vente.
     * @example
     * // Create one Vente
     * const Vente = await prisma.vente.create({
     *   data: {
     *     // ... data to create a Vente
     *   }
     * })
     * 
     */
    create<T extends VenteCreateArgs>(args: SelectSubset<T, VenteCreateArgs<ExtArgs>>): Prisma__VenteClient<$Result.GetResult<Prisma.$VentePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ventes.
     * @param {VenteCreateManyArgs} args - Arguments to create many Ventes.
     * @example
     * // Create many Ventes
     * const vente = await prisma.vente.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VenteCreateManyArgs>(args?: SelectSubset<T, VenteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ventes and returns the data saved in the database.
     * @param {VenteCreateManyAndReturnArgs} args - Arguments to create many Ventes.
     * @example
     * // Create many Ventes
     * const vente = await prisma.vente.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ventes and only return the `id`
     * const venteWithIdOnly = await prisma.vente.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VenteCreateManyAndReturnArgs>(args?: SelectSubset<T, VenteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VentePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Vente.
     * @param {VenteDeleteArgs} args - Arguments to delete one Vente.
     * @example
     * // Delete one Vente
     * const Vente = await prisma.vente.delete({
     *   where: {
     *     // ... filter to delete one Vente
     *   }
     * })
     * 
     */
    delete<T extends VenteDeleteArgs>(args: SelectSubset<T, VenteDeleteArgs<ExtArgs>>): Prisma__VenteClient<$Result.GetResult<Prisma.$VentePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Vente.
     * @param {VenteUpdateArgs} args - Arguments to update one Vente.
     * @example
     * // Update one Vente
     * const vente = await prisma.vente.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VenteUpdateArgs>(args: SelectSubset<T, VenteUpdateArgs<ExtArgs>>): Prisma__VenteClient<$Result.GetResult<Prisma.$VentePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ventes.
     * @param {VenteDeleteManyArgs} args - Arguments to filter Ventes to delete.
     * @example
     * // Delete a few Ventes
     * const { count } = await prisma.vente.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VenteDeleteManyArgs>(args?: SelectSubset<T, VenteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ventes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ventes
     * const vente = await prisma.vente.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VenteUpdateManyArgs>(args: SelectSubset<T, VenteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ventes and returns the data updated in the database.
     * @param {VenteUpdateManyAndReturnArgs} args - Arguments to update many Ventes.
     * @example
     * // Update many Ventes
     * const vente = await prisma.vente.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Ventes and only return the `id`
     * const venteWithIdOnly = await prisma.vente.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VenteUpdateManyAndReturnArgs>(args: SelectSubset<T, VenteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VentePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Vente.
     * @param {VenteUpsertArgs} args - Arguments to update or create a Vente.
     * @example
     * // Update or create a Vente
     * const vente = await prisma.vente.upsert({
     *   create: {
     *     // ... data to create a Vente
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vente we want to update
     *   }
     * })
     */
    upsert<T extends VenteUpsertArgs>(args: SelectSubset<T, VenteUpsertArgs<ExtArgs>>): Prisma__VenteClient<$Result.GetResult<Prisma.$VentePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ventes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenteCountArgs} args - Arguments to filter Ventes to count.
     * @example
     * // Count the number of Ventes
     * const count = await prisma.vente.count({
     *   where: {
     *     // ... the filter for the Ventes we want to count
     *   }
     * })
    **/
    count<T extends VenteCountArgs>(
      args?: Subset<T, VenteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VenteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VenteAggregateArgs>(args: Subset<T, VenteAggregateArgs>): Prisma.PrismaPromise<GetVenteAggregateType<T>>

    /**
     * Group by Vente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VenteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VenteGroupByArgs['orderBy'] }
        : { orderBy?: VenteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VenteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVenteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Vente model
   */
  readonly fields: VenteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Vente.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VenteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    paiement<T extends Vente$paiementArgs<ExtArgs> = {}>(args?: Subset<T, Vente$paiementArgs<ExtArgs>>): Prisma__PaiementClient<$Result.GetResult<Prisma.$PaiementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    panier<T extends PanierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PanierDefaultArgs<ExtArgs>>): Prisma__PanierClient<$Result.GetResult<Prisma.$PanierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    utilisateur<T extends UtilisateurDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UtilisateurDefaultArgs<ExtArgs>>): Prisma__UtilisateurClient<$Result.GetResult<Prisma.$UtilisateurPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    fournisseur<T extends Vente$fournisseurArgs<ExtArgs> = {}>(args?: Subset<T, Vente$fournisseurArgs<ExtArgs>>): Prisma__FournisseurClient<$Result.GetResult<Prisma.$FournisseurPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Vente model
   */
  interface VenteFieldRefs {
    readonly id: FieldRef<"Vente", 'Int'>
    readonly statut: FieldRef<"Vente", 'StatutVente'>
    readonly total_ttc: FieldRef<"Vente", 'Float'>
    readonly total_ht: FieldRef<"Vente", 'Float'>
    readonly type_acheteur: FieldRef<"Vente", 'TypeClient'>
    readonly clientId: FieldRef<"Vente", 'Int'>
    readonly enregistrerParId: FieldRef<"Vente", 'Int'>
    readonly fournisseurId: FieldRef<"Vente", 'Int'>
    readonly agentId: FieldRef<"Vente", 'Int'>
    readonly paiementId: FieldRef<"Vente", 'Int'>
    readonly panierId: FieldRef<"Vente", 'Int'>
    readonly createdAt: FieldRef<"Vente", 'DateTime'>
    readonly updatedAt: FieldRef<"Vente", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Vente findUnique
   */
  export type VenteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vente
     */
    select?: VenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vente
     */
    omit?: VenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenteInclude<ExtArgs> | null
    /**
     * Filter, which Vente to fetch.
     */
    where: VenteWhereUniqueInput
  }

  /**
   * Vente findUniqueOrThrow
   */
  export type VenteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vente
     */
    select?: VenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vente
     */
    omit?: VenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenteInclude<ExtArgs> | null
    /**
     * Filter, which Vente to fetch.
     */
    where: VenteWhereUniqueInput
  }

  /**
   * Vente findFirst
   */
  export type VenteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vente
     */
    select?: VenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vente
     */
    omit?: VenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenteInclude<ExtArgs> | null
    /**
     * Filter, which Vente to fetch.
     */
    where?: VenteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ventes to fetch.
     */
    orderBy?: VenteOrderByWithRelationInput | VenteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ventes.
     */
    cursor?: VenteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ventes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ventes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ventes.
     */
    distinct?: VenteScalarFieldEnum | VenteScalarFieldEnum[]
  }

  /**
   * Vente findFirstOrThrow
   */
  export type VenteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vente
     */
    select?: VenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vente
     */
    omit?: VenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenteInclude<ExtArgs> | null
    /**
     * Filter, which Vente to fetch.
     */
    where?: VenteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ventes to fetch.
     */
    orderBy?: VenteOrderByWithRelationInput | VenteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ventes.
     */
    cursor?: VenteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ventes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ventes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ventes.
     */
    distinct?: VenteScalarFieldEnum | VenteScalarFieldEnum[]
  }

  /**
   * Vente findMany
   */
  export type VenteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vente
     */
    select?: VenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vente
     */
    omit?: VenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenteInclude<ExtArgs> | null
    /**
     * Filter, which Ventes to fetch.
     */
    where?: VenteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ventes to fetch.
     */
    orderBy?: VenteOrderByWithRelationInput | VenteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Ventes.
     */
    cursor?: VenteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ventes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ventes.
     */
    skip?: number
    distinct?: VenteScalarFieldEnum | VenteScalarFieldEnum[]
  }

  /**
   * Vente create
   */
  export type VenteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vente
     */
    select?: VenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vente
     */
    omit?: VenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenteInclude<ExtArgs> | null
    /**
     * The data needed to create a Vente.
     */
    data: XOR<VenteCreateInput, VenteUncheckedCreateInput>
  }

  /**
   * Vente createMany
   */
  export type VenteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Ventes.
     */
    data: VenteCreateManyInput | VenteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Vente createManyAndReturn
   */
  export type VenteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vente
     */
    select?: VenteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Vente
     */
    omit?: VenteOmit<ExtArgs> | null
    /**
     * The data used to create many Ventes.
     */
    data: VenteCreateManyInput | VenteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Vente update
   */
  export type VenteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vente
     */
    select?: VenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vente
     */
    omit?: VenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenteInclude<ExtArgs> | null
    /**
     * The data needed to update a Vente.
     */
    data: XOR<VenteUpdateInput, VenteUncheckedUpdateInput>
    /**
     * Choose, which Vente to update.
     */
    where: VenteWhereUniqueInput
  }

  /**
   * Vente updateMany
   */
  export type VenteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Ventes.
     */
    data: XOR<VenteUpdateManyMutationInput, VenteUncheckedUpdateManyInput>
    /**
     * Filter which Ventes to update
     */
    where?: VenteWhereInput
    /**
     * Limit how many Ventes to update.
     */
    limit?: number
  }

  /**
   * Vente updateManyAndReturn
   */
  export type VenteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vente
     */
    select?: VenteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Vente
     */
    omit?: VenteOmit<ExtArgs> | null
    /**
     * The data used to update Ventes.
     */
    data: XOR<VenteUpdateManyMutationInput, VenteUncheckedUpdateManyInput>
    /**
     * Filter which Ventes to update
     */
    where?: VenteWhereInput
    /**
     * Limit how many Ventes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Vente upsert
   */
  export type VenteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vente
     */
    select?: VenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vente
     */
    omit?: VenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenteInclude<ExtArgs> | null
    /**
     * The filter to search for the Vente to update in case it exists.
     */
    where: VenteWhereUniqueInput
    /**
     * In case the Vente found by the `where` argument doesn't exist, create a new Vente with this data.
     */
    create: XOR<VenteCreateInput, VenteUncheckedCreateInput>
    /**
     * In case the Vente was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VenteUpdateInput, VenteUncheckedUpdateInput>
  }

  /**
   * Vente delete
   */
  export type VenteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vente
     */
    select?: VenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vente
     */
    omit?: VenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenteInclude<ExtArgs> | null
    /**
     * Filter which Vente to delete.
     */
    where: VenteWhereUniqueInput
  }

  /**
   * Vente deleteMany
   */
  export type VenteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ventes to delete
     */
    where?: VenteWhereInput
    /**
     * Limit how many Ventes to delete.
     */
    limit?: number
  }

  /**
   * Vente.paiement
   */
  export type Vente$paiementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paiement
     */
    select?: PaiementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Paiement
     */
    omit?: PaiementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaiementInclude<ExtArgs> | null
    where?: PaiementWhereInput
  }

  /**
   * Vente.fournisseur
   */
  export type Vente$fournisseurArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fournisseur
     */
    select?: FournisseurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fournisseur
     */
    omit?: FournisseurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FournisseurInclude<ExtArgs> | null
    where?: FournisseurWhereInput
  }

  /**
   * Vente without action
   */
  export type VenteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vente
     */
    select?: VenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vente
     */
    omit?: VenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenteInclude<ExtArgs> | null
  }


  /**
   * Model Panier
   */

  export type AggregatePanier = {
    _count: PanierCountAggregateOutputType | null
    _avg: PanierAvgAggregateOutputType | null
    _sum: PanierSumAggregateOutputType | null
    _min: PanierMinAggregateOutputType | null
    _max: PanierMaxAggregateOutputType | null
  }

  export type PanierAvgAggregateOutputType = {
    id: number | null
    utilisateurId: number | null
  }

  export type PanierSumAggregateOutputType = {
    id: number | null
    utilisateurId: number | null
  }

  export type PanierMinAggregateOutputType = {
    id: number | null
    utilisateurId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PanierMaxAggregateOutputType = {
    id: number | null
    utilisateurId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PanierCountAggregateOutputType = {
    id: number
    utilisateurId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PanierAvgAggregateInputType = {
    id?: true
    utilisateurId?: true
  }

  export type PanierSumAggregateInputType = {
    id?: true
    utilisateurId?: true
  }

  export type PanierMinAggregateInputType = {
    id?: true
    utilisateurId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PanierMaxAggregateInputType = {
    id?: true
    utilisateurId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PanierCountAggregateInputType = {
    id?: true
    utilisateurId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PanierAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Panier to aggregate.
     */
    where?: PanierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Paniers to fetch.
     */
    orderBy?: PanierOrderByWithRelationInput | PanierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PanierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Paniers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Paniers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Paniers
    **/
    _count?: true | PanierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PanierAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PanierSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PanierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PanierMaxAggregateInputType
  }

  export type GetPanierAggregateType<T extends PanierAggregateArgs> = {
        [P in keyof T & keyof AggregatePanier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePanier[P]>
      : GetScalarType<T[P], AggregatePanier[P]>
  }




  export type PanierGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PanierWhereInput
    orderBy?: PanierOrderByWithAggregationInput | PanierOrderByWithAggregationInput[]
    by: PanierScalarFieldEnum[] | PanierScalarFieldEnum
    having?: PanierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PanierCountAggregateInputType | true
    _avg?: PanierAvgAggregateInputType
    _sum?: PanierSumAggregateInputType
    _min?: PanierMinAggregateInputType
    _max?: PanierMaxAggregateInputType
  }

  export type PanierGroupByOutputType = {
    id: number
    utilisateurId: number
    createdAt: Date
    updatedAt: Date
    _count: PanierCountAggregateOutputType | null
    _avg: PanierAvgAggregateOutputType | null
    _sum: PanierSumAggregateOutputType | null
    _min: PanierMinAggregateOutputType | null
    _max: PanierMaxAggregateOutputType | null
  }

  type GetPanierGroupByPayload<T extends PanierGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PanierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PanierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PanierGroupByOutputType[P]>
            : GetScalarType<T[P], PanierGroupByOutputType[P]>
        }
      >
    >


  export type PanierSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    utilisateurId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    utilisateur?: boolean | UtilisateurDefaultArgs<ExtArgs>
    DetailPanier?: boolean | Panier$DetailPanierArgs<ExtArgs>
    Achat?: boolean | Panier$AchatArgs<ExtArgs>
    Vente?: boolean | Panier$VenteArgs<ExtArgs>
    Reservation?: boolean | Panier$ReservationArgs<ExtArgs>
    Commande?: boolean | Panier$CommandeArgs<ExtArgs>
    _count?: boolean | PanierCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["panier"]>

  export type PanierSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    utilisateurId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    utilisateur?: boolean | UtilisateurDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["panier"]>

  export type PanierSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    utilisateurId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    utilisateur?: boolean | UtilisateurDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["panier"]>

  export type PanierSelectScalar = {
    id?: boolean
    utilisateurId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PanierOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "utilisateurId" | "createdAt" | "updatedAt", ExtArgs["result"]["panier"]>
  export type PanierInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    utilisateur?: boolean | UtilisateurDefaultArgs<ExtArgs>
    DetailPanier?: boolean | Panier$DetailPanierArgs<ExtArgs>
    Achat?: boolean | Panier$AchatArgs<ExtArgs>
    Vente?: boolean | Panier$VenteArgs<ExtArgs>
    Reservation?: boolean | Panier$ReservationArgs<ExtArgs>
    Commande?: boolean | Panier$CommandeArgs<ExtArgs>
    _count?: boolean | PanierCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PanierIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    utilisateur?: boolean | UtilisateurDefaultArgs<ExtArgs>
  }
  export type PanierIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    utilisateur?: boolean | UtilisateurDefaultArgs<ExtArgs>
  }

  export type $PanierPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Panier"
    objects: {
      utilisateur: Prisma.$UtilisateurPayload<ExtArgs>
      DetailPanier: Prisma.$DetailPanierPayload<ExtArgs>[]
      Achat: Prisma.$AchatPayload<ExtArgs>[]
      Vente: Prisma.$VentePayload<ExtArgs>[]
      Reservation: Prisma.$ReservationPayload<ExtArgs>[]
      Commande: Prisma.$CommandePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      utilisateurId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["panier"]>
    composites: {}
  }

  type PanierGetPayload<S extends boolean | null | undefined | PanierDefaultArgs> = $Result.GetResult<Prisma.$PanierPayload, S>

  type PanierCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PanierFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PanierCountAggregateInputType | true
    }

  export interface PanierDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Panier'], meta: { name: 'Panier' } }
    /**
     * Find zero or one Panier that matches the filter.
     * @param {PanierFindUniqueArgs} args - Arguments to find a Panier
     * @example
     * // Get one Panier
     * const panier = await prisma.panier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PanierFindUniqueArgs>(args: SelectSubset<T, PanierFindUniqueArgs<ExtArgs>>): Prisma__PanierClient<$Result.GetResult<Prisma.$PanierPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Panier that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PanierFindUniqueOrThrowArgs} args - Arguments to find a Panier
     * @example
     * // Get one Panier
     * const panier = await prisma.panier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PanierFindUniqueOrThrowArgs>(args: SelectSubset<T, PanierFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PanierClient<$Result.GetResult<Prisma.$PanierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Panier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PanierFindFirstArgs} args - Arguments to find a Panier
     * @example
     * // Get one Panier
     * const panier = await prisma.panier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PanierFindFirstArgs>(args?: SelectSubset<T, PanierFindFirstArgs<ExtArgs>>): Prisma__PanierClient<$Result.GetResult<Prisma.$PanierPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Panier that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PanierFindFirstOrThrowArgs} args - Arguments to find a Panier
     * @example
     * // Get one Panier
     * const panier = await prisma.panier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PanierFindFirstOrThrowArgs>(args?: SelectSubset<T, PanierFindFirstOrThrowArgs<ExtArgs>>): Prisma__PanierClient<$Result.GetResult<Prisma.$PanierPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Paniers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PanierFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Paniers
     * const paniers = await prisma.panier.findMany()
     * 
     * // Get first 10 Paniers
     * const paniers = await prisma.panier.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const panierWithIdOnly = await prisma.panier.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PanierFindManyArgs>(args?: SelectSubset<T, PanierFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PanierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Panier.
     * @param {PanierCreateArgs} args - Arguments to create a Panier.
     * @example
     * // Create one Panier
     * const Panier = await prisma.panier.create({
     *   data: {
     *     // ... data to create a Panier
     *   }
     * })
     * 
     */
    create<T extends PanierCreateArgs>(args: SelectSubset<T, PanierCreateArgs<ExtArgs>>): Prisma__PanierClient<$Result.GetResult<Prisma.$PanierPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Paniers.
     * @param {PanierCreateManyArgs} args - Arguments to create many Paniers.
     * @example
     * // Create many Paniers
     * const panier = await prisma.panier.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PanierCreateManyArgs>(args?: SelectSubset<T, PanierCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Paniers and returns the data saved in the database.
     * @param {PanierCreateManyAndReturnArgs} args - Arguments to create many Paniers.
     * @example
     * // Create many Paniers
     * const panier = await prisma.panier.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Paniers and only return the `id`
     * const panierWithIdOnly = await prisma.panier.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PanierCreateManyAndReturnArgs>(args?: SelectSubset<T, PanierCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PanierPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Panier.
     * @param {PanierDeleteArgs} args - Arguments to delete one Panier.
     * @example
     * // Delete one Panier
     * const Panier = await prisma.panier.delete({
     *   where: {
     *     // ... filter to delete one Panier
     *   }
     * })
     * 
     */
    delete<T extends PanierDeleteArgs>(args: SelectSubset<T, PanierDeleteArgs<ExtArgs>>): Prisma__PanierClient<$Result.GetResult<Prisma.$PanierPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Panier.
     * @param {PanierUpdateArgs} args - Arguments to update one Panier.
     * @example
     * // Update one Panier
     * const panier = await prisma.panier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PanierUpdateArgs>(args: SelectSubset<T, PanierUpdateArgs<ExtArgs>>): Prisma__PanierClient<$Result.GetResult<Prisma.$PanierPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Paniers.
     * @param {PanierDeleteManyArgs} args - Arguments to filter Paniers to delete.
     * @example
     * // Delete a few Paniers
     * const { count } = await prisma.panier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PanierDeleteManyArgs>(args?: SelectSubset<T, PanierDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Paniers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PanierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Paniers
     * const panier = await prisma.panier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PanierUpdateManyArgs>(args: SelectSubset<T, PanierUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Paniers and returns the data updated in the database.
     * @param {PanierUpdateManyAndReturnArgs} args - Arguments to update many Paniers.
     * @example
     * // Update many Paniers
     * const panier = await prisma.panier.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Paniers and only return the `id`
     * const panierWithIdOnly = await prisma.panier.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PanierUpdateManyAndReturnArgs>(args: SelectSubset<T, PanierUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PanierPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Panier.
     * @param {PanierUpsertArgs} args - Arguments to update or create a Panier.
     * @example
     * // Update or create a Panier
     * const panier = await prisma.panier.upsert({
     *   create: {
     *     // ... data to create a Panier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Panier we want to update
     *   }
     * })
     */
    upsert<T extends PanierUpsertArgs>(args: SelectSubset<T, PanierUpsertArgs<ExtArgs>>): Prisma__PanierClient<$Result.GetResult<Prisma.$PanierPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Paniers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PanierCountArgs} args - Arguments to filter Paniers to count.
     * @example
     * // Count the number of Paniers
     * const count = await prisma.panier.count({
     *   where: {
     *     // ... the filter for the Paniers we want to count
     *   }
     * })
    **/
    count<T extends PanierCountArgs>(
      args?: Subset<T, PanierCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PanierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Panier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PanierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PanierAggregateArgs>(args: Subset<T, PanierAggregateArgs>): Prisma.PrismaPromise<GetPanierAggregateType<T>>

    /**
     * Group by Panier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PanierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PanierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PanierGroupByArgs['orderBy'] }
        : { orderBy?: PanierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PanierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPanierGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Panier model
   */
  readonly fields: PanierFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Panier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PanierClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    utilisateur<T extends UtilisateurDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UtilisateurDefaultArgs<ExtArgs>>): Prisma__UtilisateurClient<$Result.GetResult<Prisma.$UtilisateurPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    DetailPanier<T extends Panier$DetailPanierArgs<ExtArgs> = {}>(args?: Subset<T, Panier$DetailPanierArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DetailPanierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Achat<T extends Panier$AchatArgs<ExtArgs> = {}>(args?: Subset<T, Panier$AchatArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Vente<T extends Panier$VenteArgs<ExtArgs> = {}>(args?: Subset<T, Panier$VenteArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VentePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Reservation<T extends Panier$ReservationArgs<ExtArgs> = {}>(args?: Subset<T, Panier$ReservationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Commande<T extends Panier$CommandeArgs<ExtArgs> = {}>(args?: Subset<T, Panier$CommandeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommandePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Panier model
   */
  interface PanierFieldRefs {
    readonly id: FieldRef<"Panier", 'Int'>
    readonly utilisateurId: FieldRef<"Panier", 'Int'>
    readonly createdAt: FieldRef<"Panier", 'DateTime'>
    readonly updatedAt: FieldRef<"Panier", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Panier findUnique
   */
  export type PanierFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Panier
     */
    select?: PanierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Panier
     */
    omit?: PanierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PanierInclude<ExtArgs> | null
    /**
     * Filter, which Panier to fetch.
     */
    where: PanierWhereUniqueInput
  }

  /**
   * Panier findUniqueOrThrow
   */
  export type PanierFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Panier
     */
    select?: PanierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Panier
     */
    omit?: PanierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PanierInclude<ExtArgs> | null
    /**
     * Filter, which Panier to fetch.
     */
    where: PanierWhereUniqueInput
  }

  /**
   * Panier findFirst
   */
  export type PanierFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Panier
     */
    select?: PanierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Panier
     */
    omit?: PanierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PanierInclude<ExtArgs> | null
    /**
     * Filter, which Panier to fetch.
     */
    where?: PanierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Paniers to fetch.
     */
    orderBy?: PanierOrderByWithRelationInput | PanierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Paniers.
     */
    cursor?: PanierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Paniers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Paniers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Paniers.
     */
    distinct?: PanierScalarFieldEnum | PanierScalarFieldEnum[]
  }

  /**
   * Panier findFirstOrThrow
   */
  export type PanierFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Panier
     */
    select?: PanierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Panier
     */
    omit?: PanierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PanierInclude<ExtArgs> | null
    /**
     * Filter, which Panier to fetch.
     */
    where?: PanierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Paniers to fetch.
     */
    orderBy?: PanierOrderByWithRelationInput | PanierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Paniers.
     */
    cursor?: PanierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Paniers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Paniers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Paniers.
     */
    distinct?: PanierScalarFieldEnum | PanierScalarFieldEnum[]
  }

  /**
   * Panier findMany
   */
  export type PanierFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Panier
     */
    select?: PanierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Panier
     */
    omit?: PanierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PanierInclude<ExtArgs> | null
    /**
     * Filter, which Paniers to fetch.
     */
    where?: PanierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Paniers to fetch.
     */
    orderBy?: PanierOrderByWithRelationInput | PanierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Paniers.
     */
    cursor?: PanierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Paniers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Paniers.
     */
    skip?: number
    distinct?: PanierScalarFieldEnum | PanierScalarFieldEnum[]
  }

  /**
   * Panier create
   */
  export type PanierCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Panier
     */
    select?: PanierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Panier
     */
    omit?: PanierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PanierInclude<ExtArgs> | null
    /**
     * The data needed to create a Panier.
     */
    data: XOR<PanierCreateInput, PanierUncheckedCreateInput>
  }

  /**
   * Panier createMany
   */
  export type PanierCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Paniers.
     */
    data: PanierCreateManyInput | PanierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Panier createManyAndReturn
   */
  export type PanierCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Panier
     */
    select?: PanierSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Panier
     */
    omit?: PanierOmit<ExtArgs> | null
    /**
     * The data used to create many Paniers.
     */
    data: PanierCreateManyInput | PanierCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PanierIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Panier update
   */
  export type PanierUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Panier
     */
    select?: PanierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Panier
     */
    omit?: PanierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PanierInclude<ExtArgs> | null
    /**
     * The data needed to update a Panier.
     */
    data: XOR<PanierUpdateInput, PanierUncheckedUpdateInput>
    /**
     * Choose, which Panier to update.
     */
    where: PanierWhereUniqueInput
  }

  /**
   * Panier updateMany
   */
  export type PanierUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Paniers.
     */
    data: XOR<PanierUpdateManyMutationInput, PanierUncheckedUpdateManyInput>
    /**
     * Filter which Paniers to update
     */
    where?: PanierWhereInput
    /**
     * Limit how many Paniers to update.
     */
    limit?: number
  }

  /**
   * Panier updateManyAndReturn
   */
  export type PanierUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Panier
     */
    select?: PanierSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Panier
     */
    omit?: PanierOmit<ExtArgs> | null
    /**
     * The data used to update Paniers.
     */
    data: XOR<PanierUpdateManyMutationInput, PanierUncheckedUpdateManyInput>
    /**
     * Filter which Paniers to update
     */
    where?: PanierWhereInput
    /**
     * Limit how many Paniers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PanierIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Panier upsert
   */
  export type PanierUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Panier
     */
    select?: PanierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Panier
     */
    omit?: PanierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PanierInclude<ExtArgs> | null
    /**
     * The filter to search for the Panier to update in case it exists.
     */
    where: PanierWhereUniqueInput
    /**
     * In case the Panier found by the `where` argument doesn't exist, create a new Panier with this data.
     */
    create: XOR<PanierCreateInput, PanierUncheckedCreateInput>
    /**
     * In case the Panier was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PanierUpdateInput, PanierUncheckedUpdateInput>
  }

  /**
   * Panier delete
   */
  export type PanierDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Panier
     */
    select?: PanierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Panier
     */
    omit?: PanierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PanierInclude<ExtArgs> | null
    /**
     * Filter which Panier to delete.
     */
    where: PanierWhereUniqueInput
  }

  /**
   * Panier deleteMany
   */
  export type PanierDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Paniers to delete
     */
    where?: PanierWhereInput
    /**
     * Limit how many Paniers to delete.
     */
    limit?: number
  }

  /**
   * Panier.DetailPanier
   */
  export type Panier$DetailPanierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetailPanier
     */
    select?: DetailPanierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DetailPanier
     */
    omit?: DetailPanierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetailPanierInclude<ExtArgs> | null
    where?: DetailPanierWhereInput
    orderBy?: DetailPanierOrderByWithRelationInput | DetailPanierOrderByWithRelationInput[]
    cursor?: DetailPanierWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DetailPanierScalarFieldEnum | DetailPanierScalarFieldEnum[]
  }

  /**
   * Panier.Achat
   */
  export type Panier$AchatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achat
     */
    select?: AchatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achat
     */
    omit?: AchatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchatInclude<ExtArgs> | null
    where?: AchatWhereInput
    orderBy?: AchatOrderByWithRelationInput | AchatOrderByWithRelationInput[]
    cursor?: AchatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AchatScalarFieldEnum | AchatScalarFieldEnum[]
  }

  /**
   * Panier.Vente
   */
  export type Panier$VenteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vente
     */
    select?: VenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vente
     */
    omit?: VenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenteInclude<ExtArgs> | null
    where?: VenteWhereInput
    orderBy?: VenteOrderByWithRelationInput | VenteOrderByWithRelationInput[]
    cursor?: VenteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VenteScalarFieldEnum | VenteScalarFieldEnum[]
  }

  /**
   * Panier.Reservation
   */
  export type Panier$ReservationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    where?: ReservationWhereInput
    orderBy?: ReservationOrderByWithRelationInput | ReservationOrderByWithRelationInput[]
    cursor?: ReservationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReservationScalarFieldEnum | ReservationScalarFieldEnum[]
  }

  /**
   * Panier.Commande
   */
  export type Panier$CommandeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commande
     */
    select?: CommandeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Commande
     */
    omit?: CommandeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandeInclude<ExtArgs> | null
    where?: CommandeWhereInput
    orderBy?: CommandeOrderByWithRelationInput | CommandeOrderByWithRelationInput[]
    cursor?: CommandeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommandeScalarFieldEnum | CommandeScalarFieldEnum[]
  }

  /**
   * Panier without action
   */
  export type PanierDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Panier
     */
    select?: PanierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Panier
     */
    omit?: PanierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PanierInclude<ExtArgs> | null
  }


  /**
   * Model DetailPanier
   */

  export type AggregateDetailPanier = {
    _count: DetailPanierCountAggregateOutputType | null
    _avg: DetailPanierAvgAggregateOutputType | null
    _sum: DetailPanierSumAggregateOutputType | null
    _min: DetailPanierMinAggregateOutputType | null
    _max: DetailPanierMaxAggregateOutputType | null
  }

  export type DetailPanierAvgAggregateOutputType = {
    id: number | null
    produitId: number | null
    qtte: number | null
    prixUnitaire: number | null
    prixTotal: number | null
    panierId: number | null
  }

  export type DetailPanierSumAggregateOutputType = {
    id: number | null
    produitId: number | null
    qtte: number | null
    prixUnitaire: number | null
    prixTotal: number | null
    panierId: number | null
  }

  export type DetailPanierMinAggregateOutputType = {
    id: number | null
    produitId: number | null
    qtte: number | null
    prixUnitaire: number | null
    prixTotal: number | null
    panierId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DetailPanierMaxAggregateOutputType = {
    id: number | null
    produitId: number | null
    qtte: number | null
    prixUnitaire: number | null
    prixTotal: number | null
    panierId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DetailPanierCountAggregateOutputType = {
    id: number
    produitId: number
    qtte: number
    prixUnitaire: number
    prixTotal: number
    panierId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DetailPanierAvgAggregateInputType = {
    id?: true
    produitId?: true
    qtte?: true
    prixUnitaire?: true
    prixTotal?: true
    panierId?: true
  }

  export type DetailPanierSumAggregateInputType = {
    id?: true
    produitId?: true
    qtte?: true
    prixUnitaire?: true
    prixTotal?: true
    panierId?: true
  }

  export type DetailPanierMinAggregateInputType = {
    id?: true
    produitId?: true
    qtte?: true
    prixUnitaire?: true
    prixTotal?: true
    panierId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DetailPanierMaxAggregateInputType = {
    id?: true
    produitId?: true
    qtte?: true
    prixUnitaire?: true
    prixTotal?: true
    panierId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DetailPanierCountAggregateInputType = {
    id?: true
    produitId?: true
    qtte?: true
    prixUnitaire?: true
    prixTotal?: true
    panierId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DetailPanierAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DetailPanier to aggregate.
     */
    where?: DetailPanierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DetailPaniers to fetch.
     */
    orderBy?: DetailPanierOrderByWithRelationInput | DetailPanierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DetailPanierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DetailPaniers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DetailPaniers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DetailPaniers
    **/
    _count?: true | DetailPanierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DetailPanierAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DetailPanierSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DetailPanierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DetailPanierMaxAggregateInputType
  }

  export type GetDetailPanierAggregateType<T extends DetailPanierAggregateArgs> = {
        [P in keyof T & keyof AggregateDetailPanier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDetailPanier[P]>
      : GetScalarType<T[P], AggregateDetailPanier[P]>
  }




  export type DetailPanierGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DetailPanierWhereInput
    orderBy?: DetailPanierOrderByWithAggregationInput | DetailPanierOrderByWithAggregationInput[]
    by: DetailPanierScalarFieldEnum[] | DetailPanierScalarFieldEnum
    having?: DetailPanierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DetailPanierCountAggregateInputType | true
    _avg?: DetailPanierAvgAggregateInputType
    _sum?: DetailPanierSumAggregateInputType
    _min?: DetailPanierMinAggregateInputType
    _max?: DetailPanierMaxAggregateInputType
  }

  export type DetailPanierGroupByOutputType = {
    id: number
    produitId: number
    qtte: number
    prixUnitaire: number
    prixTotal: number
    panierId: number
    createdAt: Date
    updatedAt: Date
    _count: DetailPanierCountAggregateOutputType | null
    _avg: DetailPanierAvgAggregateOutputType | null
    _sum: DetailPanierSumAggregateOutputType | null
    _min: DetailPanierMinAggregateOutputType | null
    _max: DetailPanierMaxAggregateOutputType | null
  }

  type GetDetailPanierGroupByPayload<T extends DetailPanierGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DetailPanierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DetailPanierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DetailPanierGroupByOutputType[P]>
            : GetScalarType<T[P], DetailPanierGroupByOutputType[P]>
        }
      >
    >


  export type DetailPanierSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    produitId?: boolean
    qtte?: boolean
    prixUnitaire?: boolean
    prixTotal?: boolean
    panierId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    produit?: boolean | ProduitDefaultArgs<ExtArgs>
    panier?: boolean | PanierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["detailPanier"]>

  export type DetailPanierSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    produitId?: boolean
    qtte?: boolean
    prixUnitaire?: boolean
    prixTotal?: boolean
    panierId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    produit?: boolean | ProduitDefaultArgs<ExtArgs>
    panier?: boolean | PanierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["detailPanier"]>

  export type DetailPanierSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    produitId?: boolean
    qtte?: boolean
    prixUnitaire?: boolean
    prixTotal?: boolean
    panierId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    produit?: boolean | ProduitDefaultArgs<ExtArgs>
    panier?: boolean | PanierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["detailPanier"]>

  export type DetailPanierSelectScalar = {
    id?: boolean
    produitId?: boolean
    qtte?: boolean
    prixUnitaire?: boolean
    prixTotal?: boolean
    panierId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DetailPanierOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "produitId" | "qtte" | "prixUnitaire" | "prixTotal" | "panierId" | "createdAt" | "updatedAt", ExtArgs["result"]["detailPanier"]>
  export type DetailPanierInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    produit?: boolean | ProduitDefaultArgs<ExtArgs>
    panier?: boolean | PanierDefaultArgs<ExtArgs>
  }
  export type DetailPanierIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    produit?: boolean | ProduitDefaultArgs<ExtArgs>
    panier?: boolean | PanierDefaultArgs<ExtArgs>
  }
  export type DetailPanierIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    produit?: boolean | ProduitDefaultArgs<ExtArgs>
    panier?: boolean | PanierDefaultArgs<ExtArgs>
  }

  export type $DetailPanierPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DetailPanier"
    objects: {
      produit: Prisma.$ProduitPayload<ExtArgs>
      panier: Prisma.$PanierPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      produitId: number
      qtte: number
      prixUnitaire: number
      prixTotal: number
      panierId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["detailPanier"]>
    composites: {}
  }

  type DetailPanierGetPayload<S extends boolean | null | undefined | DetailPanierDefaultArgs> = $Result.GetResult<Prisma.$DetailPanierPayload, S>

  type DetailPanierCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DetailPanierFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DetailPanierCountAggregateInputType | true
    }

  export interface DetailPanierDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DetailPanier'], meta: { name: 'DetailPanier' } }
    /**
     * Find zero or one DetailPanier that matches the filter.
     * @param {DetailPanierFindUniqueArgs} args - Arguments to find a DetailPanier
     * @example
     * // Get one DetailPanier
     * const detailPanier = await prisma.detailPanier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DetailPanierFindUniqueArgs>(args: SelectSubset<T, DetailPanierFindUniqueArgs<ExtArgs>>): Prisma__DetailPanierClient<$Result.GetResult<Prisma.$DetailPanierPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DetailPanier that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DetailPanierFindUniqueOrThrowArgs} args - Arguments to find a DetailPanier
     * @example
     * // Get one DetailPanier
     * const detailPanier = await prisma.detailPanier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DetailPanierFindUniqueOrThrowArgs>(args: SelectSubset<T, DetailPanierFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DetailPanierClient<$Result.GetResult<Prisma.$DetailPanierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DetailPanier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetailPanierFindFirstArgs} args - Arguments to find a DetailPanier
     * @example
     * // Get one DetailPanier
     * const detailPanier = await prisma.detailPanier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DetailPanierFindFirstArgs>(args?: SelectSubset<T, DetailPanierFindFirstArgs<ExtArgs>>): Prisma__DetailPanierClient<$Result.GetResult<Prisma.$DetailPanierPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DetailPanier that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetailPanierFindFirstOrThrowArgs} args - Arguments to find a DetailPanier
     * @example
     * // Get one DetailPanier
     * const detailPanier = await prisma.detailPanier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DetailPanierFindFirstOrThrowArgs>(args?: SelectSubset<T, DetailPanierFindFirstOrThrowArgs<ExtArgs>>): Prisma__DetailPanierClient<$Result.GetResult<Prisma.$DetailPanierPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DetailPaniers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetailPanierFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DetailPaniers
     * const detailPaniers = await prisma.detailPanier.findMany()
     * 
     * // Get first 10 DetailPaniers
     * const detailPaniers = await prisma.detailPanier.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const detailPanierWithIdOnly = await prisma.detailPanier.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DetailPanierFindManyArgs>(args?: SelectSubset<T, DetailPanierFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DetailPanierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DetailPanier.
     * @param {DetailPanierCreateArgs} args - Arguments to create a DetailPanier.
     * @example
     * // Create one DetailPanier
     * const DetailPanier = await prisma.detailPanier.create({
     *   data: {
     *     // ... data to create a DetailPanier
     *   }
     * })
     * 
     */
    create<T extends DetailPanierCreateArgs>(args: SelectSubset<T, DetailPanierCreateArgs<ExtArgs>>): Prisma__DetailPanierClient<$Result.GetResult<Prisma.$DetailPanierPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DetailPaniers.
     * @param {DetailPanierCreateManyArgs} args - Arguments to create many DetailPaniers.
     * @example
     * // Create many DetailPaniers
     * const detailPanier = await prisma.detailPanier.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DetailPanierCreateManyArgs>(args?: SelectSubset<T, DetailPanierCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DetailPaniers and returns the data saved in the database.
     * @param {DetailPanierCreateManyAndReturnArgs} args - Arguments to create many DetailPaniers.
     * @example
     * // Create many DetailPaniers
     * const detailPanier = await prisma.detailPanier.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DetailPaniers and only return the `id`
     * const detailPanierWithIdOnly = await prisma.detailPanier.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DetailPanierCreateManyAndReturnArgs>(args?: SelectSubset<T, DetailPanierCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DetailPanierPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DetailPanier.
     * @param {DetailPanierDeleteArgs} args - Arguments to delete one DetailPanier.
     * @example
     * // Delete one DetailPanier
     * const DetailPanier = await prisma.detailPanier.delete({
     *   where: {
     *     // ... filter to delete one DetailPanier
     *   }
     * })
     * 
     */
    delete<T extends DetailPanierDeleteArgs>(args: SelectSubset<T, DetailPanierDeleteArgs<ExtArgs>>): Prisma__DetailPanierClient<$Result.GetResult<Prisma.$DetailPanierPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DetailPanier.
     * @param {DetailPanierUpdateArgs} args - Arguments to update one DetailPanier.
     * @example
     * // Update one DetailPanier
     * const detailPanier = await prisma.detailPanier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DetailPanierUpdateArgs>(args: SelectSubset<T, DetailPanierUpdateArgs<ExtArgs>>): Prisma__DetailPanierClient<$Result.GetResult<Prisma.$DetailPanierPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DetailPaniers.
     * @param {DetailPanierDeleteManyArgs} args - Arguments to filter DetailPaniers to delete.
     * @example
     * // Delete a few DetailPaniers
     * const { count } = await prisma.detailPanier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DetailPanierDeleteManyArgs>(args?: SelectSubset<T, DetailPanierDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DetailPaniers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetailPanierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DetailPaniers
     * const detailPanier = await prisma.detailPanier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DetailPanierUpdateManyArgs>(args: SelectSubset<T, DetailPanierUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DetailPaniers and returns the data updated in the database.
     * @param {DetailPanierUpdateManyAndReturnArgs} args - Arguments to update many DetailPaniers.
     * @example
     * // Update many DetailPaniers
     * const detailPanier = await prisma.detailPanier.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DetailPaniers and only return the `id`
     * const detailPanierWithIdOnly = await prisma.detailPanier.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DetailPanierUpdateManyAndReturnArgs>(args: SelectSubset<T, DetailPanierUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DetailPanierPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DetailPanier.
     * @param {DetailPanierUpsertArgs} args - Arguments to update or create a DetailPanier.
     * @example
     * // Update or create a DetailPanier
     * const detailPanier = await prisma.detailPanier.upsert({
     *   create: {
     *     // ... data to create a DetailPanier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DetailPanier we want to update
     *   }
     * })
     */
    upsert<T extends DetailPanierUpsertArgs>(args: SelectSubset<T, DetailPanierUpsertArgs<ExtArgs>>): Prisma__DetailPanierClient<$Result.GetResult<Prisma.$DetailPanierPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DetailPaniers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetailPanierCountArgs} args - Arguments to filter DetailPaniers to count.
     * @example
     * // Count the number of DetailPaniers
     * const count = await prisma.detailPanier.count({
     *   where: {
     *     // ... the filter for the DetailPaniers we want to count
     *   }
     * })
    **/
    count<T extends DetailPanierCountArgs>(
      args?: Subset<T, DetailPanierCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DetailPanierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DetailPanier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetailPanierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DetailPanierAggregateArgs>(args: Subset<T, DetailPanierAggregateArgs>): Prisma.PrismaPromise<GetDetailPanierAggregateType<T>>

    /**
     * Group by DetailPanier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetailPanierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DetailPanierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DetailPanierGroupByArgs['orderBy'] }
        : { orderBy?: DetailPanierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DetailPanierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDetailPanierGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DetailPanier model
   */
  readonly fields: DetailPanierFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DetailPanier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DetailPanierClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    produit<T extends ProduitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProduitDefaultArgs<ExtArgs>>): Prisma__ProduitClient<$Result.GetResult<Prisma.$ProduitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    panier<T extends PanierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PanierDefaultArgs<ExtArgs>>): Prisma__PanierClient<$Result.GetResult<Prisma.$PanierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DetailPanier model
   */
  interface DetailPanierFieldRefs {
    readonly id: FieldRef<"DetailPanier", 'Int'>
    readonly produitId: FieldRef<"DetailPanier", 'Int'>
    readonly qtte: FieldRef<"DetailPanier", 'Int'>
    readonly prixUnitaire: FieldRef<"DetailPanier", 'Float'>
    readonly prixTotal: FieldRef<"DetailPanier", 'Float'>
    readonly panierId: FieldRef<"DetailPanier", 'Int'>
    readonly createdAt: FieldRef<"DetailPanier", 'DateTime'>
    readonly updatedAt: FieldRef<"DetailPanier", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DetailPanier findUnique
   */
  export type DetailPanierFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetailPanier
     */
    select?: DetailPanierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DetailPanier
     */
    omit?: DetailPanierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetailPanierInclude<ExtArgs> | null
    /**
     * Filter, which DetailPanier to fetch.
     */
    where: DetailPanierWhereUniqueInput
  }

  /**
   * DetailPanier findUniqueOrThrow
   */
  export type DetailPanierFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetailPanier
     */
    select?: DetailPanierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DetailPanier
     */
    omit?: DetailPanierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetailPanierInclude<ExtArgs> | null
    /**
     * Filter, which DetailPanier to fetch.
     */
    where: DetailPanierWhereUniqueInput
  }

  /**
   * DetailPanier findFirst
   */
  export type DetailPanierFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetailPanier
     */
    select?: DetailPanierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DetailPanier
     */
    omit?: DetailPanierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetailPanierInclude<ExtArgs> | null
    /**
     * Filter, which DetailPanier to fetch.
     */
    where?: DetailPanierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DetailPaniers to fetch.
     */
    orderBy?: DetailPanierOrderByWithRelationInput | DetailPanierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DetailPaniers.
     */
    cursor?: DetailPanierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DetailPaniers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DetailPaniers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DetailPaniers.
     */
    distinct?: DetailPanierScalarFieldEnum | DetailPanierScalarFieldEnum[]
  }

  /**
   * DetailPanier findFirstOrThrow
   */
  export type DetailPanierFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetailPanier
     */
    select?: DetailPanierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DetailPanier
     */
    omit?: DetailPanierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetailPanierInclude<ExtArgs> | null
    /**
     * Filter, which DetailPanier to fetch.
     */
    where?: DetailPanierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DetailPaniers to fetch.
     */
    orderBy?: DetailPanierOrderByWithRelationInput | DetailPanierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DetailPaniers.
     */
    cursor?: DetailPanierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DetailPaniers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DetailPaniers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DetailPaniers.
     */
    distinct?: DetailPanierScalarFieldEnum | DetailPanierScalarFieldEnum[]
  }

  /**
   * DetailPanier findMany
   */
  export type DetailPanierFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetailPanier
     */
    select?: DetailPanierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DetailPanier
     */
    omit?: DetailPanierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetailPanierInclude<ExtArgs> | null
    /**
     * Filter, which DetailPaniers to fetch.
     */
    where?: DetailPanierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DetailPaniers to fetch.
     */
    orderBy?: DetailPanierOrderByWithRelationInput | DetailPanierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DetailPaniers.
     */
    cursor?: DetailPanierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DetailPaniers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DetailPaniers.
     */
    skip?: number
    distinct?: DetailPanierScalarFieldEnum | DetailPanierScalarFieldEnum[]
  }

  /**
   * DetailPanier create
   */
  export type DetailPanierCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetailPanier
     */
    select?: DetailPanierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DetailPanier
     */
    omit?: DetailPanierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetailPanierInclude<ExtArgs> | null
    /**
     * The data needed to create a DetailPanier.
     */
    data: XOR<DetailPanierCreateInput, DetailPanierUncheckedCreateInput>
  }

  /**
   * DetailPanier createMany
   */
  export type DetailPanierCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DetailPaniers.
     */
    data: DetailPanierCreateManyInput | DetailPanierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DetailPanier createManyAndReturn
   */
  export type DetailPanierCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetailPanier
     */
    select?: DetailPanierSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DetailPanier
     */
    omit?: DetailPanierOmit<ExtArgs> | null
    /**
     * The data used to create many DetailPaniers.
     */
    data: DetailPanierCreateManyInput | DetailPanierCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetailPanierIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DetailPanier update
   */
  export type DetailPanierUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetailPanier
     */
    select?: DetailPanierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DetailPanier
     */
    omit?: DetailPanierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetailPanierInclude<ExtArgs> | null
    /**
     * The data needed to update a DetailPanier.
     */
    data: XOR<DetailPanierUpdateInput, DetailPanierUncheckedUpdateInput>
    /**
     * Choose, which DetailPanier to update.
     */
    where: DetailPanierWhereUniqueInput
  }

  /**
   * DetailPanier updateMany
   */
  export type DetailPanierUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DetailPaniers.
     */
    data: XOR<DetailPanierUpdateManyMutationInput, DetailPanierUncheckedUpdateManyInput>
    /**
     * Filter which DetailPaniers to update
     */
    where?: DetailPanierWhereInput
    /**
     * Limit how many DetailPaniers to update.
     */
    limit?: number
  }

  /**
   * DetailPanier updateManyAndReturn
   */
  export type DetailPanierUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetailPanier
     */
    select?: DetailPanierSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DetailPanier
     */
    omit?: DetailPanierOmit<ExtArgs> | null
    /**
     * The data used to update DetailPaniers.
     */
    data: XOR<DetailPanierUpdateManyMutationInput, DetailPanierUncheckedUpdateManyInput>
    /**
     * Filter which DetailPaniers to update
     */
    where?: DetailPanierWhereInput
    /**
     * Limit how many DetailPaniers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetailPanierIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DetailPanier upsert
   */
  export type DetailPanierUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetailPanier
     */
    select?: DetailPanierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DetailPanier
     */
    omit?: DetailPanierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetailPanierInclude<ExtArgs> | null
    /**
     * The filter to search for the DetailPanier to update in case it exists.
     */
    where: DetailPanierWhereUniqueInput
    /**
     * In case the DetailPanier found by the `where` argument doesn't exist, create a new DetailPanier with this data.
     */
    create: XOR<DetailPanierCreateInput, DetailPanierUncheckedCreateInput>
    /**
     * In case the DetailPanier was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DetailPanierUpdateInput, DetailPanierUncheckedUpdateInput>
  }

  /**
   * DetailPanier delete
   */
  export type DetailPanierDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetailPanier
     */
    select?: DetailPanierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DetailPanier
     */
    omit?: DetailPanierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetailPanierInclude<ExtArgs> | null
    /**
     * Filter which DetailPanier to delete.
     */
    where: DetailPanierWhereUniqueInput
  }

  /**
   * DetailPanier deleteMany
   */
  export type DetailPanierDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DetailPaniers to delete
     */
    where?: DetailPanierWhereInput
    /**
     * Limit how many DetailPaniers to delete.
     */
    limit?: number
  }

  /**
   * DetailPanier without action
   */
  export type DetailPanierDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetailPanier
     */
    select?: DetailPanierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DetailPanier
     */
    omit?: DetailPanierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetailPanierInclude<ExtArgs> | null
  }


  /**
   * Model Achat
   */

  export type AggregateAchat = {
    _count: AchatCountAggregateOutputType | null
    _avg: AchatAvgAggregateOutputType | null
    _sum: AchatSumAggregateOutputType | null
    _min: AchatMinAggregateOutputType | null
    _max: AchatMaxAggregateOutputType | null
  }

  export type AchatAvgAggregateOutputType = {
    id: number | null
    panierId: number | null
    fournisseurId: number | null
    enregistrerParId: number | null
    paiementId: number | null
  }

  export type AchatSumAggregateOutputType = {
    id: number | null
    panierId: number | null
    fournisseurId: number | null
    enregistrerParId: number | null
    paiementId: number | null
  }

  export type AchatMinAggregateOutputType = {
    id: number | null
    statut: $Enums.StatutAchat | null
    panierId: number | null
    fournisseurId: number | null
    enregistrerParId: number | null
    paiementId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AchatMaxAggregateOutputType = {
    id: number | null
    statut: $Enums.StatutAchat | null
    panierId: number | null
    fournisseurId: number | null
    enregistrerParId: number | null
    paiementId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AchatCountAggregateOutputType = {
    id: number
    statut: number
    panierId: number
    fournisseurId: number
    enregistrerParId: number
    paiementId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AchatAvgAggregateInputType = {
    id?: true
    panierId?: true
    fournisseurId?: true
    enregistrerParId?: true
    paiementId?: true
  }

  export type AchatSumAggregateInputType = {
    id?: true
    panierId?: true
    fournisseurId?: true
    enregistrerParId?: true
    paiementId?: true
  }

  export type AchatMinAggregateInputType = {
    id?: true
    statut?: true
    panierId?: true
    fournisseurId?: true
    enregistrerParId?: true
    paiementId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AchatMaxAggregateInputType = {
    id?: true
    statut?: true
    panierId?: true
    fournisseurId?: true
    enregistrerParId?: true
    paiementId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AchatCountAggregateInputType = {
    id?: true
    statut?: true
    panierId?: true
    fournisseurId?: true
    enregistrerParId?: true
    paiementId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AchatAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Achat to aggregate.
     */
    where?: AchatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achats to fetch.
     */
    orderBy?: AchatOrderByWithRelationInput | AchatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AchatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Achats
    **/
    _count?: true | AchatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AchatAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AchatSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AchatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AchatMaxAggregateInputType
  }

  export type GetAchatAggregateType<T extends AchatAggregateArgs> = {
        [P in keyof T & keyof AggregateAchat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAchat[P]>
      : GetScalarType<T[P], AggregateAchat[P]>
  }




  export type AchatGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AchatWhereInput
    orderBy?: AchatOrderByWithAggregationInput | AchatOrderByWithAggregationInput[]
    by: AchatScalarFieldEnum[] | AchatScalarFieldEnum
    having?: AchatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AchatCountAggregateInputType | true
    _avg?: AchatAvgAggregateInputType
    _sum?: AchatSumAggregateInputType
    _min?: AchatMinAggregateInputType
    _max?: AchatMaxAggregateInputType
  }

  export type AchatGroupByOutputType = {
    id: number
    statut: $Enums.StatutAchat
    panierId: number
    fournisseurId: number
    enregistrerParId: number
    paiementId: number
    createdAt: Date
    updatedAt: Date
    _count: AchatCountAggregateOutputType | null
    _avg: AchatAvgAggregateOutputType | null
    _sum: AchatSumAggregateOutputType | null
    _min: AchatMinAggregateOutputType | null
    _max: AchatMaxAggregateOutputType | null
  }

  type GetAchatGroupByPayload<T extends AchatGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AchatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AchatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AchatGroupByOutputType[P]>
            : GetScalarType<T[P], AchatGroupByOutputType[P]>
        }
      >
    >


  export type AchatSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    statut?: boolean
    panierId?: boolean
    fournisseurId?: boolean
    enregistrerParId?: boolean
    paiementId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    panier?: boolean | PanierDefaultArgs<ExtArgs>
    fournisseur?: boolean | FournisseurDefaultArgs<ExtArgs>
    utilisateur?: boolean | UtilisateurDefaultArgs<ExtArgs>
    paiement?: boolean | PaiementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["achat"]>

  export type AchatSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    statut?: boolean
    panierId?: boolean
    fournisseurId?: boolean
    enregistrerParId?: boolean
    paiementId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    panier?: boolean | PanierDefaultArgs<ExtArgs>
    fournisseur?: boolean | FournisseurDefaultArgs<ExtArgs>
    utilisateur?: boolean | UtilisateurDefaultArgs<ExtArgs>
    paiement?: boolean | PaiementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["achat"]>

  export type AchatSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    statut?: boolean
    panierId?: boolean
    fournisseurId?: boolean
    enregistrerParId?: boolean
    paiementId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    panier?: boolean | PanierDefaultArgs<ExtArgs>
    fournisseur?: boolean | FournisseurDefaultArgs<ExtArgs>
    utilisateur?: boolean | UtilisateurDefaultArgs<ExtArgs>
    paiement?: boolean | PaiementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["achat"]>

  export type AchatSelectScalar = {
    id?: boolean
    statut?: boolean
    panierId?: boolean
    fournisseurId?: boolean
    enregistrerParId?: boolean
    paiementId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AchatOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "statut" | "panierId" | "fournisseurId" | "enregistrerParId" | "paiementId" | "createdAt" | "updatedAt", ExtArgs["result"]["achat"]>
  export type AchatInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    panier?: boolean | PanierDefaultArgs<ExtArgs>
    fournisseur?: boolean | FournisseurDefaultArgs<ExtArgs>
    utilisateur?: boolean | UtilisateurDefaultArgs<ExtArgs>
    paiement?: boolean | PaiementDefaultArgs<ExtArgs>
  }
  export type AchatIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    panier?: boolean | PanierDefaultArgs<ExtArgs>
    fournisseur?: boolean | FournisseurDefaultArgs<ExtArgs>
    utilisateur?: boolean | UtilisateurDefaultArgs<ExtArgs>
    paiement?: boolean | PaiementDefaultArgs<ExtArgs>
  }
  export type AchatIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    panier?: boolean | PanierDefaultArgs<ExtArgs>
    fournisseur?: boolean | FournisseurDefaultArgs<ExtArgs>
    utilisateur?: boolean | UtilisateurDefaultArgs<ExtArgs>
    paiement?: boolean | PaiementDefaultArgs<ExtArgs>
  }

  export type $AchatPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Achat"
    objects: {
      panier: Prisma.$PanierPayload<ExtArgs>
      fournisseur: Prisma.$FournisseurPayload<ExtArgs>
      utilisateur: Prisma.$UtilisateurPayload<ExtArgs>
      paiement: Prisma.$PaiementPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      statut: $Enums.StatutAchat
      panierId: number
      fournisseurId: number
      enregistrerParId: number
      paiementId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["achat"]>
    composites: {}
  }

  type AchatGetPayload<S extends boolean | null | undefined | AchatDefaultArgs> = $Result.GetResult<Prisma.$AchatPayload, S>

  type AchatCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AchatFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AchatCountAggregateInputType | true
    }

  export interface AchatDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Achat'], meta: { name: 'Achat' } }
    /**
     * Find zero or one Achat that matches the filter.
     * @param {AchatFindUniqueArgs} args - Arguments to find a Achat
     * @example
     * // Get one Achat
     * const achat = await prisma.achat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AchatFindUniqueArgs>(args: SelectSubset<T, AchatFindUniqueArgs<ExtArgs>>): Prisma__AchatClient<$Result.GetResult<Prisma.$AchatPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Achat that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AchatFindUniqueOrThrowArgs} args - Arguments to find a Achat
     * @example
     * // Get one Achat
     * const achat = await prisma.achat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AchatFindUniqueOrThrowArgs>(args: SelectSubset<T, AchatFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AchatClient<$Result.GetResult<Prisma.$AchatPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Achat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchatFindFirstArgs} args - Arguments to find a Achat
     * @example
     * // Get one Achat
     * const achat = await prisma.achat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AchatFindFirstArgs>(args?: SelectSubset<T, AchatFindFirstArgs<ExtArgs>>): Prisma__AchatClient<$Result.GetResult<Prisma.$AchatPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Achat that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchatFindFirstOrThrowArgs} args - Arguments to find a Achat
     * @example
     * // Get one Achat
     * const achat = await prisma.achat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AchatFindFirstOrThrowArgs>(args?: SelectSubset<T, AchatFindFirstOrThrowArgs<ExtArgs>>): Prisma__AchatClient<$Result.GetResult<Prisma.$AchatPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Achats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchatFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Achats
     * const achats = await prisma.achat.findMany()
     * 
     * // Get first 10 Achats
     * const achats = await prisma.achat.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const achatWithIdOnly = await prisma.achat.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AchatFindManyArgs>(args?: SelectSubset<T, AchatFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Achat.
     * @param {AchatCreateArgs} args - Arguments to create a Achat.
     * @example
     * // Create one Achat
     * const Achat = await prisma.achat.create({
     *   data: {
     *     // ... data to create a Achat
     *   }
     * })
     * 
     */
    create<T extends AchatCreateArgs>(args: SelectSubset<T, AchatCreateArgs<ExtArgs>>): Prisma__AchatClient<$Result.GetResult<Prisma.$AchatPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Achats.
     * @param {AchatCreateManyArgs} args - Arguments to create many Achats.
     * @example
     * // Create many Achats
     * const achat = await prisma.achat.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AchatCreateManyArgs>(args?: SelectSubset<T, AchatCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Achats and returns the data saved in the database.
     * @param {AchatCreateManyAndReturnArgs} args - Arguments to create many Achats.
     * @example
     * // Create many Achats
     * const achat = await prisma.achat.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Achats and only return the `id`
     * const achatWithIdOnly = await prisma.achat.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AchatCreateManyAndReturnArgs>(args?: SelectSubset<T, AchatCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchatPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Achat.
     * @param {AchatDeleteArgs} args - Arguments to delete one Achat.
     * @example
     * // Delete one Achat
     * const Achat = await prisma.achat.delete({
     *   where: {
     *     // ... filter to delete one Achat
     *   }
     * })
     * 
     */
    delete<T extends AchatDeleteArgs>(args: SelectSubset<T, AchatDeleteArgs<ExtArgs>>): Prisma__AchatClient<$Result.GetResult<Prisma.$AchatPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Achat.
     * @param {AchatUpdateArgs} args - Arguments to update one Achat.
     * @example
     * // Update one Achat
     * const achat = await prisma.achat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AchatUpdateArgs>(args: SelectSubset<T, AchatUpdateArgs<ExtArgs>>): Prisma__AchatClient<$Result.GetResult<Prisma.$AchatPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Achats.
     * @param {AchatDeleteManyArgs} args - Arguments to filter Achats to delete.
     * @example
     * // Delete a few Achats
     * const { count } = await prisma.achat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AchatDeleteManyArgs>(args?: SelectSubset<T, AchatDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Achats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Achats
     * const achat = await prisma.achat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AchatUpdateManyArgs>(args: SelectSubset<T, AchatUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Achats and returns the data updated in the database.
     * @param {AchatUpdateManyAndReturnArgs} args - Arguments to update many Achats.
     * @example
     * // Update many Achats
     * const achat = await prisma.achat.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Achats and only return the `id`
     * const achatWithIdOnly = await prisma.achat.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AchatUpdateManyAndReturnArgs>(args: SelectSubset<T, AchatUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchatPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Achat.
     * @param {AchatUpsertArgs} args - Arguments to update or create a Achat.
     * @example
     * // Update or create a Achat
     * const achat = await prisma.achat.upsert({
     *   create: {
     *     // ... data to create a Achat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Achat we want to update
     *   }
     * })
     */
    upsert<T extends AchatUpsertArgs>(args: SelectSubset<T, AchatUpsertArgs<ExtArgs>>): Prisma__AchatClient<$Result.GetResult<Prisma.$AchatPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Achats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchatCountArgs} args - Arguments to filter Achats to count.
     * @example
     * // Count the number of Achats
     * const count = await prisma.achat.count({
     *   where: {
     *     // ... the filter for the Achats we want to count
     *   }
     * })
    **/
    count<T extends AchatCountArgs>(
      args?: Subset<T, AchatCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AchatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Achat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AchatAggregateArgs>(args: Subset<T, AchatAggregateArgs>): Prisma.PrismaPromise<GetAchatAggregateType<T>>

    /**
     * Group by Achat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AchatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AchatGroupByArgs['orderBy'] }
        : { orderBy?: AchatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AchatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAchatGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Achat model
   */
  readonly fields: AchatFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Achat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AchatClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    panier<T extends PanierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PanierDefaultArgs<ExtArgs>>): Prisma__PanierClient<$Result.GetResult<Prisma.$PanierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    fournisseur<T extends FournisseurDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FournisseurDefaultArgs<ExtArgs>>): Prisma__FournisseurClient<$Result.GetResult<Prisma.$FournisseurPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    utilisateur<T extends UtilisateurDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UtilisateurDefaultArgs<ExtArgs>>): Prisma__UtilisateurClient<$Result.GetResult<Prisma.$UtilisateurPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    paiement<T extends PaiementDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PaiementDefaultArgs<ExtArgs>>): Prisma__PaiementClient<$Result.GetResult<Prisma.$PaiementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Achat model
   */
  interface AchatFieldRefs {
    readonly id: FieldRef<"Achat", 'Int'>
    readonly statut: FieldRef<"Achat", 'StatutAchat'>
    readonly panierId: FieldRef<"Achat", 'Int'>
    readonly fournisseurId: FieldRef<"Achat", 'Int'>
    readonly enregistrerParId: FieldRef<"Achat", 'Int'>
    readonly paiementId: FieldRef<"Achat", 'Int'>
    readonly createdAt: FieldRef<"Achat", 'DateTime'>
    readonly updatedAt: FieldRef<"Achat", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Achat findUnique
   */
  export type AchatFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achat
     */
    select?: AchatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achat
     */
    omit?: AchatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchatInclude<ExtArgs> | null
    /**
     * Filter, which Achat to fetch.
     */
    where: AchatWhereUniqueInput
  }

  /**
   * Achat findUniqueOrThrow
   */
  export type AchatFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achat
     */
    select?: AchatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achat
     */
    omit?: AchatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchatInclude<ExtArgs> | null
    /**
     * Filter, which Achat to fetch.
     */
    where: AchatWhereUniqueInput
  }

  /**
   * Achat findFirst
   */
  export type AchatFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achat
     */
    select?: AchatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achat
     */
    omit?: AchatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchatInclude<ExtArgs> | null
    /**
     * Filter, which Achat to fetch.
     */
    where?: AchatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achats to fetch.
     */
    orderBy?: AchatOrderByWithRelationInput | AchatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Achats.
     */
    cursor?: AchatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Achats.
     */
    distinct?: AchatScalarFieldEnum | AchatScalarFieldEnum[]
  }

  /**
   * Achat findFirstOrThrow
   */
  export type AchatFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achat
     */
    select?: AchatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achat
     */
    omit?: AchatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchatInclude<ExtArgs> | null
    /**
     * Filter, which Achat to fetch.
     */
    where?: AchatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achats to fetch.
     */
    orderBy?: AchatOrderByWithRelationInput | AchatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Achats.
     */
    cursor?: AchatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Achats.
     */
    distinct?: AchatScalarFieldEnum | AchatScalarFieldEnum[]
  }

  /**
   * Achat findMany
   */
  export type AchatFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achat
     */
    select?: AchatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achat
     */
    omit?: AchatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchatInclude<ExtArgs> | null
    /**
     * Filter, which Achats to fetch.
     */
    where?: AchatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achats to fetch.
     */
    orderBy?: AchatOrderByWithRelationInput | AchatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Achats.
     */
    cursor?: AchatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achats.
     */
    skip?: number
    distinct?: AchatScalarFieldEnum | AchatScalarFieldEnum[]
  }

  /**
   * Achat create
   */
  export type AchatCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achat
     */
    select?: AchatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achat
     */
    omit?: AchatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchatInclude<ExtArgs> | null
    /**
     * The data needed to create a Achat.
     */
    data: XOR<AchatCreateInput, AchatUncheckedCreateInput>
  }

  /**
   * Achat createMany
   */
  export type AchatCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Achats.
     */
    data: AchatCreateManyInput | AchatCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Achat createManyAndReturn
   */
  export type AchatCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achat
     */
    select?: AchatSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Achat
     */
    omit?: AchatOmit<ExtArgs> | null
    /**
     * The data used to create many Achats.
     */
    data: AchatCreateManyInput | AchatCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchatIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Achat update
   */
  export type AchatUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achat
     */
    select?: AchatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achat
     */
    omit?: AchatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchatInclude<ExtArgs> | null
    /**
     * The data needed to update a Achat.
     */
    data: XOR<AchatUpdateInput, AchatUncheckedUpdateInput>
    /**
     * Choose, which Achat to update.
     */
    where: AchatWhereUniqueInput
  }

  /**
   * Achat updateMany
   */
  export type AchatUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Achats.
     */
    data: XOR<AchatUpdateManyMutationInput, AchatUncheckedUpdateManyInput>
    /**
     * Filter which Achats to update
     */
    where?: AchatWhereInput
    /**
     * Limit how many Achats to update.
     */
    limit?: number
  }

  /**
   * Achat updateManyAndReturn
   */
  export type AchatUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achat
     */
    select?: AchatSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Achat
     */
    omit?: AchatOmit<ExtArgs> | null
    /**
     * The data used to update Achats.
     */
    data: XOR<AchatUpdateManyMutationInput, AchatUncheckedUpdateManyInput>
    /**
     * Filter which Achats to update
     */
    where?: AchatWhereInput
    /**
     * Limit how many Achats to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchatIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Achat upsert
   */
  export type AchatUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achat
     */
    select?: AchatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achat
     */
    omit?: AchatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchatInclude<ExtArgs> | null
    /**
     * The filter to search for the Achat to update in case it exists.
     */
    where: AchatWhereUniqueInput
    /**
     * In case the Achat found by the `where` argument doesn't exist, create a new Achat with this data.
     */
    create: XOR<AchatCreateInput, AchatUncheckedCreateInput>
    /**
     * In case the Achat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AchatUpdateInput, AchatUncheckedUpdateInput>
  }

  /**
   * Achat delete
   */
  export type AchatDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achat
     */
    select?: AchatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achat
     */
    omit?: AchatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchatInclude<ExtArgs> | null
    /**
     * Filter which Achat to delete.
     */
    where: AchatWhereUniqueInput
  }

  /**
   * Achat deleteMany
   */
  export type AchatDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Achats to delete
     */
    where?: AchatWhereInput
    /**
     * Limit how many Achats to delete.
     */
    limit?: number
  }

  /**
   * Achat without action
   */
  export type AchatDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achat
     */
    select?: AchatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achat
     */
    omit?: AchatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchatInclude<ExtArgs> | null
  }


  /**
   * Model Reservation
   */

  export type AggregateReservation = {
    _count: ReservationCountAggregateOutputType | null
    _avg: ReservationAvgAggregateOutputType | null
    _sum: ReservationSumAggregateOutputType | null
    _min: ReservationMinAggregateOutputType | null
    _max: ReservationMaxAggregateOutputType | null
  }

  export type ReservationAvgAggregateOutputType = {
    id: number | null
    clientId: number | null
    panierId: number | null
    adresseId: number | null
    contactId: number | null
    enregistrerParId: number | null
    fournisseurId: number | null
  }

  export type ReservationSumAggregateOutputType = {
    id: number | null
    clientId: number | null
    panierId: number | null
    adresseId: number | null
    contactId: number | null
    enregistrerParId: number | null
    fournisseurId: number | null
  }

  export type ReservationMinAggregateOutputType = {
    id: number | null
    dateLivraisonSouhaitee: Date | null
    adresseLivraison: string | null
    statut: $Enums.StatutReservation | null
    notes: string | null
    type_client: $Enums.TypeClient | null
    clientId: number | null
    panierId: number | null
    nom: string | null
    tel: string | null
    adresseId: number | null
    contactId: number | null
    enregistrerParId: number | null
    fournisseurId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReservationMaxAggregateOutputType = {
    id: number | null
    dateLivraisonSouhaitee: Date | null
    adresseLivraison: string | null
    statut: $Enums.StatutReservation | null
    notes: string | null
    type_client: $Enums.TypeClient | null
    clientId: number | null
    panierId: number | null
    nom: string | null
    tel: string | null
    adresseId: number | null
    contactId: number | null
    enregistrerParId: number | null
    fournisseurId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReservationCountAggregateOutputType = {
    id: number
    dateLivraisonSouhaitee: number
    adresseLivraison: number
    statut: number
    notes: number
    type_client: number
    clientId: number
    panierId: number
    nom: number
    tel: number
    adresseId: number
    contactId: number
    enregistrerParId: number
    fournisseurId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReservationAvgAggregateInputType = {
    id?: true
    clientId?: true
    panierId?: true
    adresseId?: true
    contactId?: true
    enregistrerParId?: true
    fournisseurId?: true
  }

  export type ReservationSumAggregateInputType = {
    id?: true
    clientId?: true
    panierId?: true
    adresseId?: true
    contactId?: true
    enregistrerParId?: true
    fournisseurId?: true
  }

  export type ReservationMinAggregateInputType = {
    id?: true
    dateLivraisonSouhaitee?: true
    adresseLivraison?: true
    statut?: true
    notes?: true
    type_client?: true
    clientId?: true
    panierId?: true
    nom?: true
    tel?: true
    adresseId?: true
    contactId?: true
    enregistrerParId?: true
    fournisseurId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReservationMaxAggregateInputType = {
    id?: true
    dateLivraisonSouhaitee?: true
    adresseLivraison?: true
    statut?: true
    notes?: true
    type_client?: true
    clientId?: true
    panierId?: true
    nom?: true
    tel?: true
    adresseId?: true
    contactId?: true
    enregistrerParId?: true
    fournisseurId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReservationCountAggregateInputType = {
    id?: true
    dateLivraisonSouhaitee?: true
    adresseLivraison?: true
    statut?: true
    notes?: true
    type_client?: true
    clientId?: true
    panierId?: true
    nom?: true
    tel?: true
    adresseId?: true
    contactId?: true
    enregistrerParId?: true
    fournisseurId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReservationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reservation to aggregate.
     */
    where?: ReservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reservations to fetch.
     */
    orderBy?: ReservationOrderByWithRelationInput | ReservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reservations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reservations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reservations
    **/
    _count?: true | ReservationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReservationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReservationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReservationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReservationMaxAggregateInputType
  }

  export type GetReservationAggregateType<T extends ReservationAggregateArgs> = {
        [P in keyof T & keyof AggregateReservation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReservation[P]>
      : GetScalarType<T[P], AggregateReservation[P]>
  }




  export type ReservationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReservationWhereInput
    orderBy?: ReservationOrderByWithAggregationInput | ReservationOrderByWithAggregationInput[]
    by: ReservationScalarFieldEnum[] | ReservationScalarFieldEnum
    having?: ReservationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReservationCountAggregateInputType | true
    _avg?: ReservationAvgAggregateInputType
    _sum?: ReservationSumAggregateInputType
    _min?: ReservationMinAggregateInputType
    _max?: ReservationMaxAggregateInputType
  }

  export type ReservationGroupByOutputType = {
    id: number
    dateLivraisonSouhaitee: Date
    adresseLivraison: string | null
    statut: $Enums.StatutReservation
    notes: string | null
    type_client: $Enums.TypeClient
    clientId: number | null
    panierId: number
    nom: string | null
    tel: string | null
    adresseId: number | null
    contactId: number | null
    enregistrerParId: number | null
    fournisseurId: number | null
    createdAt: Date
    updatedAt: Date
    _count: ReservationCountAggregateOutputType | null
    _avg: ReservationAvgAggregateOutputType | null
    _sum: ReservationSumAggregateOutputType | null
    _min: ReservationMinAggregateOutputType | null
    _max: ReservationMaxAggregateOutputType | null
  }

  type GetReservationGroupByPayload<T extends ReservationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReservationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReservationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReservationGroupByOutputType[P]>
            : GetScalarType<T[P], ReservationGroupByOutputType[P]>
        }
      >
    >


  export type ReservationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dateLivraisonSouhaitee?: boolean
    adresseLivraison?: boolean
    statut?: boolean
    notes?: boolean
    type_client?: boolean
    clientId?: boolean
    panierId?: boolean
    nom?: boolean
    tel?: boolean
    adresseId?: boolean
    contactId?: boolean
    enregistrerParId?: boolean
    fournisseurId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    panier?: boolean | PanierDefaultArgs<ExtArgs>
    utilisateur?: boolean | Reservation$utilisateurArgs<ExtArgs>
    fournisseur?: boolean | Reservation$fournisseurArgs<ExtArgs>
    adresse?: boolean | Reservation$adresseArgs<ExtArgs>
    contact?: boolean | Reservation$contactArgs<ExtArgs>
  }, ExtArgs["result"]["reservation"]>

  export type ReservationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dateLivraisonSouhaitee?: boolean
    adresseLivraison?: boolean
    statut?: boolean
    notes?: boolean
    type_client?: boolean
    clientId?: boolean
    panierId?: boolean
    nom?: boolean
    tel?: boolean
    adresseId?: boolean
    contactId?: boolean
    enregistrerParId?: boolean
    fournisseurId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    panier?: boolean | PanierDefaultArgs<ExtArgs>
    utilisateur?: boolean | Reservation$utilisateurArgs<ExtArgs>
    fournisseur?: boolean | Reservation$fournisseurArgs<ExtArgs>
    adresse?: boolean | Reservation$adresseArgs<ExtArgs>
    contact?: boolean | Reservation$contactArgs<ExtArgs>
  }, ExtArgs["result"]["reservation"]>

  export type ReservationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dateLivraisonSouhaitee?: boolean
    adresseLivraison?: boolean
    statut?: boolean
    notes?: boolean
    type_client?: boolean
    clientId?: boolean
    panierId?: boolean
    nom?: boolean
    tel?: boolean
    adresseId?: boolean
    contactId?: boolean
    enregistrerParId?: boolean
    fournisseurId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    panier?: boolean | PanierDefaultArgs<ExtArgs>
    utilisateur?: boolean | Reservation$utilisateurArgs<ExtArgs>
    fournisseur?: boolean | Reservation$fournisseurArgs<ExtArgs>
    adresse?: boolean | Reservation$adresseArgs<ExtArgs>
    contact?: boolean | Reservation$contactArgs<ExtArgs>
  }, ExtArgs["result"]["reservation"]>

  export type ReservationSelectScalar = {
    id?: boolean
    dateLivraisonSouhaitee?: boolean
    adresseLivraison?: boolean
    statut?: boolean
    notes?: boolean
    type_client?: boolean
    clientId?: boolean
    panierId?: boolean
    nom?: boolean
    tel?: boolean
    adresseId?: boolean
    contactId?: boolean
    enregistrerParId?: boolean
    fournisseurId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReservationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "dateLivraisonSouhaitee" | "adresseLivraison" | "statut" | "notes" | "type_client" | "clientId" | "panierId" | "nom" | "tel" | "adresseId" | "contactId" | "enregistrerParId" | "fournisseurId" | "createdAt" | "updatedAt", ExtArgs["result"]["reservation"]>
  export type ReservationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    panier?: boolean | PanierDefaultArgs<ExtArgs>
    utilisateur?: boolean | Reservation$utilisateurArgs<ExtArgs>
    fournisseur?: boolean | Reservation$fournisseurArgs<ExtArgs>
    adresse?: boolean | Reservation$adresseArgs<ExtArgs>
    contact?: boolean | Reservation$contactArgs<ExtArgs>
  }
  export type ReservationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    panier?: boolean | PanierDefaultArgs<ExtArgs>
    utilisateur?: boolean | Reservation$utilisateurArgs<ExtArgs>
    fournisseur?: boolean | Reservation$fournisseurArgs<ExtArgs>
    adresse?: boolean | Reservation$adresseArgs<ExtArgs>
    contact?: boolean | Reservation$contactArgs<ExtArgs>
  }
  export type ReservationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    panier?: boolean | PanierDefaultArgs<ExtArgs>
    utilisateur?: boolean | Reservation$utilisateurArgs<ExtArgs>
    fournisseur?: boolean | Reservation$fournisseurArgs<ExtArgs>
    adresse?: boolean | Reservation$adresseArgs<ExtArgs>
    contact?: boolean | Reservation$contactArgs<ExtArgs>
  }

  export type $ReservationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Reservation"
    objects: {
      panier: Prisma.$PanierPayload<ExtArgs>
      utilisateur: Prisma.$UtilisateurPayload<ExtArgs> | null
      fournisseur: Prisma.$FournisseurPayload<ExtArgs> | null
      adresse: Prisma.$AdressePayload<ExtArgs> | null
      contact: Prisma.$ContactPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      dateLivraisonSouhaitee: Date
      adresseLivraison: string | null
      statut: $Enums.StatutReservation
      notes: string | null
      type_client: $Enums.TypeClient
      clientId: number | null
      panierId: number
      nom: string | null
      tel: string | null
      adresseId: number | null
      contactId: number | null
      enregistrerParId: number | null
      fournisseurId: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["reservation"]>
    composites: {}
  }

  type ReservationGetPayload<S extends boolean | null | undefined | ReservationDefaultArgs> = $Result.GetResult<Prisma.$ReservationPayload, S>

  type ReservationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReservationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReservationCountAggregateInputType | true
    }

  export interface ReservationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Reservation'], meta: { name: 'Reservation' } }
    /**
     * Find zero or one Reservation that matches the filter.
     * @param {ReservationFindUniqueArgs} args - Arguments to find a Reservation
     * @example
     * // Get one Reservation
     * const reservation = await prisma.reservation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReservationFindUniqueArgs>(args: SelectSubset<T, ReservationFindUniqueArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Reservation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReservationFindUniqueOrThrowArgs} args - Arguments to find a Reservation
     * @example
     * // Get one Reservation
     * const reservation = await prisma.reservation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReservationFindUniqueOrThrowArgs>(args: SelectSubset<T, ReservationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reservation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationFindFirstArgs} args - Arguments to find a Reservation
     * @example
     * // Get one Reservation
     * const reservation = await prisma.reservation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReservationFindFirstArgs>(args?: SelectSubset<T, ReservationFindFirstArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reservation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationFindFirstOrThrowArgs} args - Arguments to find a Reservation
     * @example
     * // Get one Reservation
     * const reservation = await prisma.reservation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReservationFindFirstOrThrowArgs>(args?: SelectSubset<T, ReservationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reservations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reservations
     * const reservations = await prisma.reservation.findMany()
     * 
     * // Get first 10 Reservations
     * const reservations = await prisma.reservation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reservationWithIdOnly = await prisma.reservation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReservationFindManyArgs>(args?: SelectSubset<T, ReservationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Reservation.
     * @param {ReservationCreateArgs} args - Arguments to create a Reservation.
     * @example
     * // Create one Reservation
     * const Reservation = await prisma.reservation.create({
     *   data: {
     *     // ... data to create a Reservation
     *   }
     * })
     * 
     */
    create<T extends ReservationCreateArgs>(args: SelectSubset<T, ReservationCreateArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reservations.
     * @param {ReservationCreateManyArgs} args - Arguments to create many Reservations.
     * @example
     * // Create many Reservations
     * const reservation = await prisma.reservation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReservationCreateManyArgs>(args?: SelectSubset<T, ReservationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reservations and returns the data saved in the database.
     * @param {ReservationCreateManyAndReturnArgs} args - Arguments to create many Reservations.
     * @example
     * // Create many Reservations
     * const reservation = await prisma.reservation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reservations and only return the `id`
     * const reservationWithIdOnly = await prisma.reservation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReservationCreateManyAndReturnArgs>(args?: SelectSubset<T, ReservationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Reservation.
     * @param {ReservationDeleteArgs} args - Arguments to delete one Reservation.
     * @example
     * // Delete one Reservation
     * const Reservation = await prisma.reservation.delete({
     *   where: {
     *     // ... filter to delete one Reservation
     *   }
     * })
     * 
     */
    delete<T extends ReservationDeleteArgs>(args: SelectSubset<T, ReservationDeleteArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Reservation.
     * @param {ReservationUpdateArgs} args - Arguments to update one Reservation.
     * @example
     * // Update one Reservation
     * const reservation = await prisma.reservation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReservationUpdateArgs>(args: SelectSubset<T, ReservationUpdateArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reservations.
     * @param {ReservationDeleteManyArgs} args - Arguments to filter Reservations to delete.
     * @example
     * // Delete a few Reservations
     * const { count } = await prisma.reservation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReservationDeleteManyArgs>(args?: SelectSubset<T, ReservationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reservations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reservations
     * const reservation = await prisma.reservation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReservationUpdateManyArgs>(args: SelectSubset<T, ReservationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reservations and returns the data updated in the database.
     * @param {ReservationUpdateManyAndReturnArgs} args - Arguments to update many Reservations.
     * @example
     * // Update many Reservations
     * const reservation = await prisma.reservation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Reservations and only return the `id`
     * const reservationWithIdOnly = await prisma.reservation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReservationUpdateManyAndReturnArgs>(args: SelectSubset<T, ReservationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Reservation.
     * @param {ReservationUpsertArgs} args - Arguments to update or create a Reservation.
     * @example
     * // Update or create a Reservation
     * const reservation = await prisma.reservation.upsert({
     *   create: {
     *     // ... data to create a Reservation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reservation we want to update
     *   }
     * })
     */
    upsert<T extends ReservationUpsertArgs>(args: SelectSubset<T, ReservationUpsertArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reservations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationCountArgs} args - Arguments to filter Reservations to count.
     * @example
     * // Count the number of Reservations
     * const count = await prisma.reservation.count({
     *   where: {
     *     // ... the filter for the Reservations we want to count
     *   }
     * })
    **/
    count<T extends ReservationCountArgs>(
      args?: Subset<T, ReservationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReservationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reservation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReservationAggregateArgs>(args: Subset<T, ReservationAggregateArgs>): Prisma.PrismaPromise<GetReservationAggregateType<T>>

    /**
     * Group by Reservation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReservationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReservationGroupByArgs['orderBy'] }
        : { orderBy?: ReservationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReservationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReservationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Reservation model
   */
  readonly fields: ReservationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Reservation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReservationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    panier<T extends PanierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PanierDefaultArgs<ExtArgs>>): Prisma__PanierClient<$Result.GetResult<Prisma.$PanierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    utilisateur<T extends Reservation$utilisateurArgs<ExtArgs> = {}>(args?: Subset<T, Reservation$utilisateurArgs<ExtArgs>>): Prisma__UtilisateurClient<$Result.GetResult<Prisma.$UtilisateurPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    fournisseur<T extends Reservation$fournisseurArgs<ExtArgs> = {}>(args?: Subset<T, Reservation$fournisseurArgs<ExtArgs>>): Prisma__FournisseurClient<$Result.GetResult<Prisma.$FournisseurPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    adresse<T extends Reservation$adresseArgs<ExtArgs> = {}>(args?: Subset<T, Reservation$adresseArgs<ExtArgs>>): Prisma__AdresseClient<$Result.GetResult<Prisma.$AdressePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    contact<T extends Reservation$contactArgs<ExtArgs> = {}>(args?: Subset<T, Reservation$contactArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Reservation model
   */
  interface ReservationFieldRefs {
    readonly id: FieldRef<"Reservation", 'Int'>
    readonly dateLivraisonSouhaitee: FieldRef<"Reservation", 'DateTime'>
    readonly adresseLivraison: FieldRef<"Reservation", 'String'>
    readonly statut: FieldRef<"Reservation", 'StatutReservation'>
    readonly notes: FieldRef<"Reservation", 'String'>
    readonly type_client: FieldRef<"Reservation", 'TypeClient'>
    readonly clientId: FieldRef<"Reservation", 'Int'>
    readonly panierId: FieldRef<"Reservation", 'Int'>
    readonly nom: FieldRef<"Reservation", 'String'>
    readonly tel: FieldRef<"Reservation", 'String'>
    readonly adresseId: FieldRef<"Reservation", 'Int'>
    readonly contactId: FieldRef<"Reservation", 'Int'>
    readonly enregistrerParId: FieldRef<"Reservation", 'Int'>
    readonly fournisseurId: FieldRef<"Reservation", 'Int'>
    readonly createdAt: FieldRef<"Reservation", 'DateTime'>
    readonly updatedAt: FieldRef<"Reservation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Reservation findUnique
   */
  export type ReservationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * Filter, which Reservation to fetch.
     */
    where: ReservationWhereUniqueInput
  }

  /**
   * Reservation findUniqueOrThrow
   */
  export type ReservationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * Filter, which Reservation to fetch.
     */
    where: ReservationWhereUniqueInput
  }

  /**
   * Reservation findFirst
   */
  export type ReservationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * Filter, which Reservation to fetch.
     */
    where?: ReservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reservations to fetch.
     */
    orderBy?: ReservationOrderByWithRelationInput | ReservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reservations.
     */
    cursor?: ReservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reservations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reservations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reservations.
     */
    distinct?: ReservationScalarFieldEnum | ReservationScalarFieldEnum[]
  }

  /**
   * Reservation findFirstOrThrow
   */
  export type ReservationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * Filter, which Reservation to fetch.
     */
    where?: ReservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reservations to fetch.
     */
    orderBy?: ReservationOrderByWithRelationInput | ReservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reservations.
     */
    cursor?: ReservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reservations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reservations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reservations.
     */
    distinct?: ReservationScalarFieldEnum | ReservationScalarFieldEnum[]
  }

  /**
   * Reservation findMany
   */
  export type ReservationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * Filter, which Reservations to fetch.
     */
    where?: ReservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reservations to fetch.
     */
    orderBy?: ReservationOrderByWithRelationInput | ReservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reservations.
     */
    cursor?: ReservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reservations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reservations.
     */
    skip?: number
    distinct?: ReservationScalarFieldEnum | ReservationScalarFieldEnum[]
  }

  /**
   * Reservation create
   */
  export type ReservationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * The data needed to create a Reservation.
     */
    data: XOR<ReservationCreateInput, ReservationUncheckedCreateInput>
  }

  /**
   * Reservation createMany
   */
  export type ReservationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reservations.
     */
    data: ReservationCreateManyInput | ReservationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Reservation createManyAndReturn
   */
  export type ReservationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * The data used to create many Reservations.
     */
    data: ReservationCreateManyInput | ReservationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Reservation update
   */
  export type ReservationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * The data needed to update a Reservation.
     */
    data: XOR<ReservationUpdateInput, ReservationUncheckedUpdateInput>
    /**
     * Choose, which Reservation to update.
     */
    where: ReservationWhereUniqueInput
  }

  /**
   * Reservation updateMany
   */
  export type ReservationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reservations.
     */
    data: XOR<ReservationUpdateManyMutationInput, ReservationUncheckedUpdateManyInput>
    /**
     * Filter which Reservations to update
     */
    where?: ReservationWhereInput
    /**
     * Limit how many Reservations to update.
     */
    limit?: number
  }

  /**
   * Reservation updateManyAndReturn
   */
  export type ReservationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * The data used to update Reservations.
     */
    data: XOR<ReservationUpdateManyMutationInput, ReservationUncheckedUpdateManyInput>
    /**
     * Filter which Reservations to update
     */
    where?: ReservationWhereInput
    /**
     * Limit how many Reservations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Reservation upsert
   */
  export type ReservationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * The filter to search for the Reservation to update in case it exists.
     */
    where: ReservationWhereUniqueInput
    /**
     * In case the Reservation found by the `where` argument doesn't exist, create a new Reservation with this data.
     */
    create: XOR<ReservationCreateInput, ReservationUncheckedCreateInput>
    /**
     * In case the Reservation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReservationUpdateInput, ReservationUncheckedUpdateInput>
  }

  /**
   * Reservation delete
   */
  export type ReservationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * Filter which Reservation to delete.
     */
    where: ReservationWhereUniqueInput
  }

  /**
   * Reservation deleteMany
   */
  export type ReservationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reservations to delete
     */
    where?: ReservationWhereInput
    /**
     * Limit how many Reservations to delete.
     */
    limit?: number
  }

  /**
   * Reservation.utilisateur
   */
  export type Reservation$utilisateurArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Utilisateur
     */
    select?: UtilisateurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Utilisateur
     */
    omit?: UtilisateurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UtilisateurInclude<ExtArgs> | null
    where?: UtilisateurWhereInput
  }

  /**
   * Reservation.fournisseur
   */
  export type Reservation$fournisseurArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fournisseur
     */
    select?: FournisseurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fournisseur
     */
    omit?: FournisseurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FournisseurInclude<ExtArgs> | null
    where?: FournisseurWhereInput
  }

  /**
   * Reservation.adresse
   */
  export type Reservation$adresseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adresse
     */
    select?: AdresseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Adresse
     */
    omit?: AdresseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdresseInclude<ExtArgs> | null
    where?: AdresseWhereInput
  }

  /**
   * Reservation.contact
   */
  export type Reservation$contactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
  }

  /**
   * Reservation without action
   */
  export type ReservationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
  }


  /**
   * Model Commande
   */

  export type AggregateCommande = {
    _count: CommandeCountAggregateOutputType | null
    _avg: CommandeAvgAggregateOutputType | null
    _sum: CommandeSumAggregateOutputType | null
    _min: CommandeMinAggregateOutputType | null
    _max: CommandeMaxAggregateOutputType | null
  }

  export type CommandeAvgAggregateOutputType = {
    id: number | null
    panierId: number | null
    clientId: number | null
    paiementId: number | null
    adresseId: number | null
    contactId: number | null
    fournisseurId: number | null
    enregistrerParId: number | null
  }

  export type CommandeSumAggregateOutputType = {
    id: number | null
    panierId: number | null
    clientId: number | null
    paiementId: number | null
    adresseId: number | null
    contactId: number | null
    fournisseurId: number | null
    enregistrerParId: number | null
  }

  export type CommandeMinAggregateOutputType = {
    id: number | null
    panierId: number | null
    clientId: number | null
    nom: string | null
    tel: string | null
    type_client: $Enums.TypeClient | null
    paiementId: number | null
    adresseId: number | null
    contactId: number | null
    fournisseurId: number | null
    notes: string | null
    dateLivraisonEffective: Date | null
    adresseLivraison: string | null
    enregistrerParId: number | null
    statut: $Enums.StatutCommande | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommandeMaxAggregateOutputType = {
    id: number | null
    panierId: number | null
    clientId: number | null
    nom: string | null
    tel: string | null
    type_client: $Enums.TypeClient | null
    paiementId: number | null
    adresseId: number | null
    contactId: number | null
    fournisseurId: number | null
    notes: string | null
    dateLivraisonEffective: Date | null
    adresseLivraison: string | null
    enregistrerParId: number | null
    statut: $Enums.StatutCommande | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommandeCountAggregateOutputType = {
    id: number
    panierId: number
    clientId: number
    nom: number
    tel: number
    type_client: number
    paiementId: number
    adresseId: number
    contactId: number
    fournisseurId: number
    notes: number
    dateLivraisonEffective: number
    adresseLivraison: number
    enregistrerParId: number
    statut: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CommandeAvgAggregateInputType = {
    id?: true
    panierId?: true
    clientId?: true
    paiementId?: true
    adresseId?: true
    contactId?: true
    fournisseurId?: true
    enregistrerParId?: true
  }

  export type CommandeSumAggregateInputType = {
    id?: true
    panierId?: true
    clientId?: true
    paiementId?: true
    adresseId?: true
    contactId?: true
    fournisseurId?: true
    enregistrerParId?: true
  }

  export type CommandeMinAggregateInputType = {
    id?: true
    panierId?: true
    clientId?: true
    nom?: true
    tel?: true
    type_client?: true
    paiementId?: true
    adresseId?: true
    contactId?: true
    fournisseurId?: true
    notes?: true
    dateLivraisonEffective?: true
    adresseLivraison?: true
    enregistrerParId?: true
    statut?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommandeMaxAggregateInputType = {
    id?: true
    panierId?: true
    clientId?: true
    nom?: true
    tel?: true
    type_client?: true
    paiementId?: true
    adresseId?: true
    contactId?: true
    fournisseurId?: true
    notes?: true
    dateLivraisonEffective?: true
    adresseLivraison?: true
    enregistrerParId?: true
    statut?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommandeCountAggregateInputType = {
    id?: true
    panierId?: true
    clientId?: true
    nom?: true
    tel?: true
    type_client?: true
    paiementId?: true
    adresseId?: true
    contactId?: true
    fournisseurId?: true
    notes?: true
    dateLivraisonEffective?: true
    adresseLivraison?: true
    enregistrerParId?: true
    statut?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CommandeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Commande to aggregate.
     */
    where?: CommandeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Commandes to fetch.
     */
    orderBy?: CommandeOrderByWithRelationInput | CommandeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommandeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Commandes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Commandes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Commandes
    **/
    _count?: true | CommandeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommandeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommandeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommandeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommandeMaxAggregateInputType
  }

  export type GetCommandeAggregateType<T extends CommandeAggregateArgs> = {
        [P in keyof T & keyof AggregateCommande]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommande[P]>
      : GetScalarType<T[P], AggregateCommande[P]>
  }




  export type CommandeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommandeWhereInput
    orderBy?: CommandeOrderByWithAggregationInput | CommandeOrderByWithAggregationInput[]
    by: CommandeScalarFieldEnum[] | CommandeScalarFieldEnum
    having?: CommandeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommandeCountAggregateInputType | true
    _avg?: CommandeAvgAggregateInputType
    _sum?: CommandeSumAggregateInputType
    _min?: CommandeMinAggregateInputType
    _max?: CommandeMaxAggregateInputType
  }

  export type CommandeGroupByOutputType = {
    id: number
    panierId: number
    clientId: number | null
    nom: string | null
    tel: string | null
    type_client: $Enums.TypeClient
    paiementId: number
    adresseId: number | null
    contactId: number | null
    fournisseurId: number | null
    notes: string | null
    dateLivraisonEffective: Date | null
    adresseLivraison: string | null
    enregistrerParId: number | null
    statut: $Enums.StatutCommande
    createdAt: Date
    updatedAt: Date
    _count: CommandeCountAggregateOutputType | null
    _avg: CommandeAvgAggregateOutputType | null
    _sum: CommandeSumAggregateOutputType | null
    _min: CommandeMinAggregateOutputType | null
    _max: CommandeMaxAggregateOutputType | null
  }

  type GetCommandeGroupByPayload<T extends CommandeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommandeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommandeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommandeGroupByOutputType[P]>
            : GetScalarType<T[P], CommandeGroupByOutputType[P]>
        }
      >
    >


  export type CommandeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    panierId?: boolean
    clientId?: boolean
    nom?: boolean
    tel?: boolean
    type_client?: boolean
    paiementId?: boolean
    adresseId?: boolean
    contactId?: boolean
    fournisseurId?: boolean
    notes?: boolean
    dateLivraisonEffective?: boolean
    adresseLivraison?: boolean
    enregistrerParId?: boolean
    statut?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    panier?: boolean | PanierDefaultArgs<ExtArgs>
    client?: boolean | Commande$clientArgs<ExtArgs>
    paiement?: boolean | PaiementDefaultArgs<ExtArgs>
    fournisseur?: boolean | Commande$fournisseurArgs<ExtArgs>
    adresse?: boolean | Commande$adresseArgs<ExtArgs>
    contact?: boolean | Commande$contactArgs<ExtArgs>
  }, ExtArgs["result"]["commande"]>

  export type CommandeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    panierId?: boolean
    clientId?: boolean
    nom?: boolean
    tel?: boolean
    type_client?: boolean
    paiementId?: boolean
    adresseId?: boolean
    contactId?: boolean
    fournisseurId?: boolean
    notes?: boolean
    dateLivraisonEffective?: boolean
    adresseLivraison?: boolean
    enregistrerParId?: boolean
    statut?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    panier?: boolean | PanierDefaultArgs<ExtArgs>
    client?: boolean | Commande$clientArgs<ExtArgs>
    paiement?: boolean | PaiementDefaultArgs<ExtArgs>
    fournisseur?: boolean | Commande$fournisseurArgs<ExtArgs>
    adresse?: boolean | Commande$adresseArgs<ExtArgs>
    contact?: boolean | Commande$contactArgs<ExtArgs>
  }, ExtArgs["result"]["commande"]>

  export type CommandeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    panierId?: boolean
    clientId?: boolean
    nom?: boolean
    tel?: boolean
    type_client?: boolean
    paiementId?: boolean
    adresseId?: boolean
    contactId?: boolean
    fournisseurId?: boolean
    notes?: boolean
    dateLivraisonEffective?: boolean
    adresseLivraison?: boolean
    enregistrerParId?: boolean
    statut?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    panier?: boolean | PanierDefaultArgs<ExtArgs>
    client?: boolean | Commande$clientArgs<ExtArgs>
    paiement?: boolean | PaiementDefaultArgs<ExtArgs>
    fournisseur?: boolean | Commande$fournisseurArgs<ExtArgs>
    adresse?: boolean | Commande$adresseArgs<ExtArgs>
    contact?: boolean | Commande$contactArgs<ExtArgs>
  }, ExtArgs["result"]["commande"]>

  export type CommandeSelectScalar = {
    id?: boolean
    panierId?: boolean
    clientId?: boolean
    nom?: boolean
    tel?: boolean
    type_client?: boolean
    paiementId?: boolean
    adresseId?: boolean
    contactId?: boolean
    fournisseurId?: boolean
    notes?: boolean
    dateLivraisonEffective?: boolean
    adresseLivraison?: boolean
    enregistrerParId?: boolean
    statut?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CommandeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "panierId" | "clientId" | "nom" | "tel" | "type_client" | "paiementId" | "adresseId" | "contactId" | "fournisseurId" | "notes" | "dateLivraisonEffective" | "adresseLivraison" | "enregistrerParId" | "statut" | "createdAt" | "updatedAt", ExtArgs["result"]["commande"]>
  export type CommandeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    panier?: boolean | PanierDefaultArgs<ExtArgs>
    client?: boolean | Commande$clientArgs<ExtArgs>
    paiement?: boolean | PaiementDefaultArgs<ExtArgs>
    fournisseur?: boolean | Commande$fournisseurArgs<ExtArgs>
    adresse?: boolean | Commande$adresseArgs<ExtArgs>
    contact?: boolean | Commande$contactArgs<ExtArgs>
  }
  export type CommandeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    panier?: boolean | PanierDefaultArgs<ExtArgs>
    client?: boolean | Commande$clientArgs<ExtArgs>
    paiement?: boolean | PaiementDefaultArgs<ExtArgs>
    fournisseur?: boolean | Commande$fournisseurArgs<ExtArgs>
    adresse?: boolean | Commande$adresseArgs<ExtArgs>
    contact?: boolean | Commande$contactArgs<ExtArgs>
  }
  export type CommandeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    panier?: boolean | PanierDefaultArgs<ExtArgs>
    client?: boolean | Commande$clientArgs<ExtArgs>
    paiement?: boolean | PaiementDefaultArgs<ExtArgs>
    fournisseur?: boolean | Commande$fournisseurArgs<ExtArgs>
    adresse?: boolean | Commande$adresseArgs<ExtArgs>
    contact?: boolean | Commande$contactArgs<ExtArgs>
  }

  export type $CommandePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Commande"
    objects: {
      panier: Prisma.$PanierPayload<ExtArgs>
      client: Prisma.$UtilisateurPayload<ExtArgs> | null
      paiement: Prisma.$PaiementPayload<ExtArgs>
      fournisseur: Prisma.$FournisseurPayload<ExtArgs> | null
      adresse: Prisma.$AdressePayload<ExtArgs> | null
      contact: Prisma.$ContactPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      panierId: number
      clientId: number | null
      nom: string | null
      tel: string | null
      type_client: $Enums.TypeClient
      paiementId: number
      adresseId: number | null
      contactId: number | null
      fournisseurId: number | null
      notes: string | null
      dateLivraisonEffective: Date | null
      adresseLivraison: string | null
      enregistrerParId: number | null
      statut: $Enums.StatutCommande
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["commande"]>
    composites: {}
  }

  type CommandeGetPayload<S extends boolean | null | undefined | CommandeDefaultArgs> = $Result.GetResult<Prisma.$CommandePayload, S>

  type CommandeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommandeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommandeCountAggregateInputType | true
    }

  export interface CommandeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Commande'], meta: { name: 'Commande' } }
    /**
     * Find zero or one Commande that matches the filter.
     * @param {CommandeFindUniqueArgs} args - Arguments to find a Commande
     * @example
     * // Get one Commande
     * const commande = await prisma.commande.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommandeFindUniqueArgs>(args: SelectSubset<T, CommandeFindUniqueArgs<ExtArgs>>): Prisma__CommandeClient<$Result.GetResult<Prisma.$CommandePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Commande that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommandeFindUniqueOrThrowArgs} args - Arguments to find a Commande
     * @example
     * // Get one Commande
     * const commande = await prisma.commande.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommandeFindUniqueOrThrowArgs>(args: SelectSubset<T, CommandeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommandeClient<$Result.GetResult<Prisma.$CommandePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Commande that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandeFindFirstArgs} args - Arguments to find a Commande
     * @example
     * // Get one Commande
     * const commande = await prisma.commande.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommandeFindFirstArgs>(args?: SelectSubset<T, CommandeFindFirstArgs<ExtArgs>>): Prisma__CommandeClient<$Result.GetResult<Prisma.$CommandePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Commande that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandeFindFirstOrThrowArgs} args - Arguments to find a Commande
     * @example
     * // Get one Commande
     * const commande = await prisma.commande.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommandeFindFirstOrThrowArgs>(args?: SelectSubset<T, CommandeFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommandeClient<$Result.GetResult<Prisma.$CommandePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Commandes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Commandes
     * const commandes = await prisma.commande.findMany()
     * 
     * // Get first 10 Commandes
     * const commandes = await prisma.commande.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commandeWithIdOnly = await prisma.commande.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommandeFindManyArgs>(args?: SelectSubset<T, CommandeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommandePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Commande.
     * @param {CommandeCreateArgs} args - Arguments to create a Commande.
     * @example
     * // Create one Commande
     * const Commande = await prisma.commande.create({
     *   data: {
     *     // ... data to create a Commande
     *   }
     * })
     * 
     */
    create<T extends CommandeCreateArgs>(args: SelectSubset<T, CommandeCreateArgs<ExtArgs>>): Prisma__CommandeClient<$Result.GetResult<Prisma.$CommandePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Commandes.
     * @param {CommandeCreateManyArgs} args - Arguments to create many Commandes.
     * @example
     * // Create many Commandes
     * const commande = await prisma.commande.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommandeCreateManyArgs>(args?: SelectSubset<T, CommandeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Commandes and returns the data saved in the database.
     * @param {CommandeCreateManyAndReturnArgs} args - Arguments to create many Commandes.
     * @example
     * // Create many Commandes
     * const commande = await prisma.commande.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Commandes and only return the `id`
     * const commandeWithIdOnly = await prisma.commande.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommandeCreateManyAndReturnArgs>(args?: SelectSubset<T, CommandeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommandePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Commande.
     * @param {CommandeDeleteArgs} args - Arguments to delete one Commande.
     * @example
     * // Delete one Commande
     * const Commande = await prisma.commande.delete({
     *   where: {
     *     // ... filter to delete one Commande
     *   }
     * })
     * 
     */
    delete<T extends CommandeDeleteArgs>(args: SelectSubset<T, CommandeDeleteArgs<ExtArgs>>): Prisma__CommandeClient<$Result.GetResult<Prisma.$CommandePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Commande.
     * @param {CommandeUpdateArgs} args - Arguments to update one Commande.
     * @example
     * // Update one Commande
     * const commande = await prisma.commande.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommandeUpdateArgs>(args: SelectSubset<T, CommandeUpdateArgs<ExtArgs>>): Prisma__CommandeClient<$Result.GetResult<Prisma.$CommandePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Commandes.
     * @param {CommandeDeleteManyArgs} args - Arguments to filter Commandes to delete.
     * @example
     * // Delete a few Commandes
     * const { count } = await prisma.commande.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommandeDeleteManyArgs>(args?: SelectSubset<T, CommandeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Commandes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Commandes
     * const commande = await prisma.commande.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommandeUpdateManyArgs>(args: SelectSubset<T, CommandeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Commandes and returns the data updated in the database.
     * @param {CommandeUpdateManyAndReturnArgs} args - Arguments to update many Commandes.
     * @example
     * // Update many Commandes
     * const commande = await prisma.commande.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Commandes and only return the `id`
     * const commandeWithIdOnly = await prisma.commande.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CommandeUpdateManyAndReturnArgs>(args: SelectSubset<T, CommandeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommandePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Commande.
     * @param {CommandeUpsertArgs} args - Arguments to update or create a Commande.
     * @example
     * // Update or create a Commande
     * const commande = await prisma.commande.upsert({
     *   create: {
     *     // ... data to create a Commande
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Commande we want to update
     *   }
     * })
     */
    upsert<T extends CommandeUpsertArgs>(args: SelectSubset<T, CommandeUpsertArgs<ExtArgs>>): Prisma__CommandeClient<$Result.GetResult<Prisma.$CommandePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Commandes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandeCountArgs} args - Arguments to filter Commandes to count.
     * @example
     * // Count the number of Commandes
     * const count = await prisma.commande.count({
     *   where: {
     *     // ... the filter for the Commandes we want to count
     *   }
     * })
    **/
    count<T extends CommandeCountArgs>(
      args?: Subset<T, CommandeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommandeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Commande.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommandeAggregateArgs>(args: Subset<T, CommandeAggregateArgs>): Prisma.PrismaPromise<GetCommandeAggregateType<T>>

    /**
     * Group by Commande.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommandeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommandeGroupByArgs['orderBy'] }
        : { orderBy?: CommandeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommandeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommandeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Commande model
   */
  readonly fields: CommandeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Commande.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommandeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    panier<T extends PanierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PanierDefaultArgs<ExtArgs>>): Prisma__PanierClient<$Result.GetResult<Prisma.$PanierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    client<T extends Commande$clientArgs<ExtArgs> = {}>(args?: Subset<T, Commande$clientArgs<ExtArgs>>): Prisma__UtilisateurClient<$Result.GetResult<Prisma.$UtilisateurPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    paiement<T extends PaiementDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PaiementDefaultArgs<ExtArgs>>): Prisma__PaiementClient<$Result.GetResult<Prisma.$PaiementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    fournisseur<T extends Commande$fournisseurArgs<ExtArgs> = {}>(args?: Subset<T, Commande$fournisseurArgs<ExtArgs>>): Prisma__FournisseurClient<$Result.GetResult<Prisma.$FournisseurPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    adresse<T extends Commande$adresseArgs<ExtArgs> = {}>(args?: Subset<T, Commande$adresseArgs<ExtArgs>>): Prisma__AdresseClient<$Result.GetResult<Prisma.$AdressePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    contact<T extends Commande$contactArgs<ExtArgs> = {}>(args?: Subset<T, Commande$contactArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Commande model
   */
  interface CommandeFieldRefs {
    readonly id: FieldRef<"Commande", 'Int'>
    readonly panierId: FieldRef<"Commande", 'Int'>
    readonly clientId: FieldRef<"Commande", 'Int'>
    readonly nom: FieldRef<"Commande", 'String'>
    readonly tel: FieldRef<"Commande", 'String'>
    readonly type_client: FieldRef<"Commande", 'TypeClient'>
    readonly paiementId: FieldRef<"Commande", 'Int'>
    readonly adresseId: FieldRef<"Commande", 'Int'>
    readonly contactId: FieldRef<"Commande", 'Int'>
    readonly fournisseurId: FieldRef<"Commande", 'Int'>
    readonly notes: FieldRef<"Commande", 'String'>
    readonly dateLivraisonEffective: FieldRef<"Commande", 'DateTime'>
    readonly adresseLivraison: FieldRef<"Commande", 'String'>
    readonly enregistrerParId: FieldRef<"Commande", 'Int'>
    readonly statut: FieldRef<"Commande", 'StatutCommande'>
    readonly createdAt: FieldRef<"Commande", 'DateTime'>
    readonly updatedAt: FieldRef<"Commande", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Commande findUnique
   */
  export type CommandeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commande
     */
    select?: CommandeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Commande
     */
    omit?: CommandeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandeInclude<ExtArgs> | null
    /**
     * Filter, which Commande to fetch.
     */
    where: CommandeWhereUniqueInput
  }

  /**
   * Commande findUniqueOrThrow
   */
  export type CommandeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commande
     */
    select?: CommandeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Commande
     */
    omit?: CommandeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandeInclude<ExtArgs> | null
    /**
     * Filter, which Commande to fetch.
     */
    where: CommandeWhereUniqueInput
  }

  /**
   * Commande findFirst
   */
  export type CommandeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commande
     */
    select?: CommandeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Commande
     */
    omit?: CommandeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandeInclude<ExtArgs> | null
    /**
     * Filter, which Commande to fetch.
     */
    where?: CommandeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Commandes to fetch.
     */
    orderBy?: CommandeOrderByWithRelationInput | CommandeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Commandes.
     */
    cursor?: CommandeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Commandes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Commandes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Commandes.
     */
    distinct?: CommandeScalarFieldEnum | CommandeScalarFieldEnum[]
  }

  /**
   * Commande findFirstOrThrow
   */
  export type CommandeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commande
     */
    select?: CommandeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Commande
     */
    omit?: CommandeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandeInclude<ExtArgs> | null
    /**
     * Filter, which Commande to fetch.
     */
    where?: CommandeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Commandes to fetch.
     */
    orderBy?: CommandeOrderByWithRelationInput | CommandeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Commandes.
     */
    cursor?: CommandeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Commandes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Commandes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Commandes.
     */
    distinct?: CommandeScalarFieldEnum | CommandeScalarFieldEnum[]
  }

  /**
   * Commande findMany
   */
  export type CommandeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commande
     */
    select?: CommandeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Commande
     */
    omit?: CommandeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandeInclude<ExtArgs> | null
    /**
     * Filter, which Commandes to fetch.
     */
    where?: CommandeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Commandes to fetch.
     */
    orderBy?: CommandeOrderByWithRelationInput | CommandeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Commandes.
     */
    cursor?: CommandeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Commandes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Commandes.
     */
    skip?: number
    distinct?: CommandeScalarFieldEnum | CommandeScalarFieldEnum[]
  }

  /**
   * Commande create
   */
  export type CommandeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commande
     */
    select?: CommandeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Commande
     */
    omit?: CommandeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandeInclude<ExtArgs> | null
    /**
     * The data needed to create a Commande.
     */
    data: XOR<CommandeCreateInput, CommandeUncheckedCreateInput>
  }

  /**
   * Commande createMany
   */
  export type CommandeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Commandes.
     */
    data: CommandeCreateManyInput | CommandeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Commande createManyAndReturn
   */
  export type CommandeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commande
     */
    select?: CommandeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Commande
     */
    omit?: CommandeOmit<ExtArgs> | null
    /**
     * The data used to create many Commandes.
     */
    data: CommandeCreateManyInput | CommandeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Commande update
   */
  export type CommandeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commande
     */
    select?: CommandeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Commande
     */
    omit?: CommandeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandeInclude<ExtArgs> | null
    /**
     * The data needed to update a Commande.
     */
    data: XOR<CommandeUpdateInput, CommandeUncheckedUpdateInput>
    /**
     * Choose, which Commande to update.
     */
    where: CommandeWhereUniqueInput
  }

  /**
   * Commande updateMany
   */
  export type CommandeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Commandes.
     */
    data: XOR<CommandeUpdateManyMutationInput, CommandeUncheckedUpdateManyInput>
    /**
     * Filter which Commandes to update
     */
    where?: CommandeWhereInput
    /**
     * Limit how many Commandes to update.
     */
    limit?: number
  }

  /**
   * Commande updateManyAndReturn
   */
  export type CommandeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commande
     */
    select?: CommandeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Commande
     */
    omit?: CommandeOmit<ExtArgs> | null
    /**
     * The data used to update Commandes.
     */
    data: XOR<CommandeUpdateManyMutationInput, CommandeUncheckedUpdateManyInput>
    /**
     * Filter which Commandes to update
     */
    where?: CommandeWhereInput
    /**
     * Limit how many Commandes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Commande upsert
   */
  export type CommandeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commande
     */
    select?: CommandeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Commande
     */
    omit?: CommandeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandeInclude<ExtArgs> | null
    /**
     * The filter to search for the Commande to update in case it exists.
     */
    where: CommandeWhereUniqueInput
    /**
     * In case the Commande found by the `where` argument doesn't exist, create a new Commande with this data.
     */
    create: XOR<CommandeCreateInput, CommandeUncheckedCreateInput>
    /**
     * In case the Commande was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommandeUpdateInput, CommandeUncheckedUpdateInput>
  }

  /**
   * Commande delete
   */
  export type CommandeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commande
     */
    select?: CommandeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Commande
     */
    omit?: CommandeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandeInclude<ExtArgs> | null
    /**
     * Filter which Commande to delete.
     */
    where: CommandeWhereUniqueInput
  }

  /**
   * Commande deleteMany
   */
  export type CommandeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Commandes to delete
     */
    where?: CommandeWhereInput
    /**
     * Limit how many Commandes to delete.
     */
    limit?: number
  }

  /**
   * Commande.client
   */
  export type Commande$clientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Utilisateur
     */
    select?: UtilisateurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Utilisateur
     */
    omit?: UtilisateurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UtilisateurInclude<ExtArgs> | null
    where?: UtilisateurWhereInput
  }

  /**
   * Commande.fournisseur
   */
  export type Commande$fournisseurArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fournisseur
     */
    select?: FournisseurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fournisseur
     */
    omit?: FournisseurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FournisseurInclude<ExtArgs> | null
    where?: FournisseurWhereInput
  }

  /**
   * Commande.adresse
   */
  export type Commande$adresseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adresse
     */
    select?: AdresseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Adresse
     */
    omit?: AdresseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdresseInclude<ExtArgs> | null
    where?: AdresseWhereInput
  }

  /**
   * Commande.contact
   */
  export type Commande$contactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
  }

  /**
   * Commande without action
   */
  export type CommandeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commande
     */
    select?: CommandeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Commande
     */
    omit?: CommandeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandeInclude<ExtArgs> | null
  }


  /**
   * Model MouvementCaisse
   */

  export type AggregateMouvementCaisse = {
    _count: MouvementCaisseCountAggregateOutputType | null
    _avg: MouvementCaisseAvgAggregateOutputType | null
    _sum: MouvementCaisseSumAggregateOutputType | null
    _min: MouvementCaisseMinAggregateOutputType | null
    _max: MouvementCaisseMaxAggregateOutputType | null
  }

  export type MouvementCaisseAvgAggregateOutputType = {
    id: number | null
    caisseId: number | null
    montant: number | null
    enregistrerParId: number | null
  }

  export type MouvementCaisseSumAggregateOutputType = {
    id: number | null
    caisseId: number | null
    montant: number | null
    enregistrerParId: number | null
  }

  export type MouvementCaisseMinAggregateOutputType = {
    id: number | null
    caisseId: number | null
    type_mouvement: $Enums.TypeMouvementCaisse | null
    categorie: $Enums.CategorieMouvement | null
    montant: number | null
    description: string | null
    enregistrerParId: number | null
    referenceExterne: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MouvementCaisseMaxAggregateOutputType = {
    id: number | null
    caisseId: number | null
    type_mouvement: $Enums.TypeMouvementCaisse | null
    categorie: $Enums.CategorieMouvement | null
    montant: number | null
    description: string | null
    enregistrerParId: number | null
    referenceExterne: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MouvementCaisseCountAggregateOutputType = {
    id: number
    caisseId: number
    type_mouvement: number
    categorie: number
    montant: number
    description: number
    enregistrerParId: number
    referenceExterne: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MouvementCaisseAvgAggregateInputType = {
    id?: true
    caisseId?: true
    montant?: true
    enregistrerParId?: true
  }

  export type MouvementCaisseSumAggregateInputType = {
    id?: true
    caisseId?: true
    montant?: true
    enregistrerParId?: true
  }

  export type MouvementCaisseMinAggregateInputType = {
    id?: true
    caisseId?: true
    type_mouvement?: true
    categorie?: true
    montant?: true
    description?: true
    enregistrerParId?: true
    referenceExterne?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MouvementCaisseMaxAggregateInputType = {
    id?: true
    caisseId?: true
    type_mouvement?: true
    categorie?: true
    montant?: true
    description?: true
    enregistrerParId?: true
    referenceExterne?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MouvementCaisseCountAggregateInputType = {
    id?: true
    caisseId?: true
    type_mouvement?: true
    categorie?: true
    montant?: true
    description?: true
    enregistrerParId?: true
    referenceExterne?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MouvementCaisseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MouvementCaisse to aggregate.
     */
    where?: MouvementCaisseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MouvementCaisses to fetch.
     */
    orderBy?: MouvementCaisseOrderByWithRelationInput | MouvementCaisseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MouvementCaisseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MouvementCaisses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MouvementCaisses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MouvementCaisses
    **/
    _count?: true | MouvementCaisseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MouvementCaisseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MouvementCaisseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MouvementCaisseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MouvementCaisseMaxAggregateInputType
  }

  export type GetMouvementCaisseAggregateType<T extends MouvementCaisseAggregateArgs> = {
        [P in keyof T & keyof AggregateMouvementCaisse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMouvementCaisse[P]>
      : GetScalarType<T[P], AggregateMouvementCaisse[P]>
  }




  export type MouvementCaisseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MouvementCaisseWhereInput
    orderBy?: MouvementCaisseOrderByWithAggregationInput | MouvementCaisseOrderByWithAggregationInput[]
    by: MouvementCaisseScalarFieldEnum[] | MouvementCaisseScalarFieldEnum
    having?: MouvementCaisseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MouvementCaisseCountAggregateInputType | true
    _avg?: MouvementCaisseAvgAggregateInputType
    _sum?: MouvementCaisseSumAggregateInputType
    _min?: MouvementCaisseMinAggregateInputType
    _max?: MouvementCaisseMaxAggregateInputType
  }

  export type MouvementCaisseGroupByOutputType = {
    id: number
    caisseId: number
    type_mouvement: $Enums.TypeMouvementCaisse
    categorie: $Enums.CategorieMouvement
    montant: number
    description: string | null
    enregistrerParId: number
    referenceExterne: string | null
    createdAt: Date
    updatedAt: Date
    _count: MouvementCaisseCountAggregateOutputType | null
    _avg: MouvementCaisseAvgAggregateOutputType | null
    _sum: MouvementCaisseSumAggregateOutputType | null
    _min: MouvementCaisseMinAggregateOutputType | null
    _max: MouvementCaisseMaxAggregateOutputType | null
  }

  type GetMouvementCaisseGroupByPayload<T extends MouvementCaisseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MouvementCaisseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MouvementCaisseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MouvementCaisseGroupByOutputType[P]>
            : GetScalarType<T[P], MouvementCaisseGroupByOutputType[P]>
        }
      >
    >


  export type MouvementCaisseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    caisseId?: boolean
    type_mouvement?: boolean
    categorie?: boolean
    montant?: boolean
    description?: boolean
    enregistrerParId?: boolean
    referenceExterne?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    caisse?: boolean | CaisseDefaultArgs<ExtArgs>
    utilisateur?: boolean | UtilisateurDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mouvementCaisse"]>

  export type MouvementCaisseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    caisseId?: boolean
    type_mouvement?: boolean
    categorie?: boolean
    montant?: boolean
    description?: boolean
    enregistrerParId?: boolean
    referenceExterne?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    caisse?: boolean | CaisseDefaultArgs<ExtArgs>
    utilisateur?: boolean | UtilisateurDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mouvementCaisse"]>

  export type MouvementCaisseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    caisseId?: boolean
    type_mouvement?: boolean
    categorie?: boolean
    montant?: boolean
    description?: boolean
    enregistrerParId?: boolean
    referenceExterne?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    caisse?: boolean | CaisseDefaultArgs<ExtArgs>
    utilisateur?: boolean | UtilisateurDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mouvementCaisse"]>

  export type MouvementCaisseSelectScalar = {
    id?: boolean
    caisseId?: boolean
    type_mouvement?: boolean
    categorie?: boolean
    montant?: boolean
    description?: boolean
    enregistrerParId?: boolean
    referenceExterne?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MouvementCaisseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "caisseId" | "type_mouvement" | "categorie" | "montant" | "description" | "enregistrerParId" | "referenceExterne" | "createdAt" | "updatedAt", ExtArgs["result"]["mouvementCaisse"]>
  export type MouvementCaisseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    caisse?: boolean | CaisseDefaultArgs<ExtArgs>
    utilisateur?: boolean | UtilisateurDefaultArgs<ExtArgs>
  }
  export type MouvementCaisseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    caisse?: boolean | CaisseDefaultArgs<ExtArgs>
    utilisateur?: boolean | UtilisateurDefaultArgs<ExtArgs>
  }
  export type MouvementCaisseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    caisse?: boolean | CaisseDefaultArgs<ExtArgs>
    utilisateur?: boolean | UtilisateurDefaultArgs<ExtArgs>
  }

  export type $MouvementCaissePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MouvementCaisse"
    objects: {
      caisse: Prisma.$CaissePayload<ExtArgs>
      utilisateur: Prisma.$UtilisateurPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      caisseId: number
      type_mouvement: $Enums.TypeMouvementCaisse
      categorie: $Enums.CategorieMouvement
      montant: number
      description: string | null
      enregistrerParId: number
      referenceExterne: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["mouvementCaisse"]>
    composites: {}
  }

  type MouvementCaisseGetPayload<S extends boolean | null | undefined | MouvementCaisseDefaultArgs> = $Result.GetResult<Prisma.$MouvementCaissePayload, S>

  type MouvementCaisseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MouvementCaisseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MouvementCaisseCountAggregateInputType | true
    }

  export interface MouvementCaisseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MouvementCaisse'], meta: { name: 'MouvementCaisse' } }
    /**
     * Find zero or one MouvementCaisse that matches the filter.
     * @param {MouvementCaisseFindUniqueArgs} args - Arguments to find a MouvementCaisse
     * @example
     * // Get one MouvementCaisse
     * const mouvementCaisse = await prisma.mouvementCaisse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MouvementCaisseFindUniqueArgs>(args: SelectSubset<T, MouvementCaisseFindUniqueArgs<ExtArgs>>): Prisma__MouvementCaisseClient<$Result.GetResult<Prisma.$MouvementCaissePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MouvementCaisse that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MouvementCaisseFindUniqueOrThrowArgs} args - Arguments to find a MouvementCaisse
     * @example
     * // Get one MouvementCaisse
     * const mouvementCaisse = await prisma.mouvementCaisse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MouvementCaisseFindUniqueOrThrowArgs>(args: SelectSubset<T, MouvementCaisseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MouvementCaisseClient<$Result.GetResult<Prisma.$MouvementCaissePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MouvementCaisse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MouvementCaisseFindFirstArgs} args - Arguments to find a MouvementCaisse
     * @example
     * // Get one MouvementCaisse
     * const mouvementCaisse = await prisma.mouvementCaisse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MouvementCaisseFindFirstArgs>(args?: SelectSubset<T, MouvementCaisseFindFirstArgs<ExtArgs>>): Prisma__MouvementCaisseClient<$Result.GetResult<Prisma.$MouvementCaissePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MouvementCaisse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MouvementCaisseFindFirstOrThrowArgs} args - Arguments to find a MouvementCaisse
     * @example
     * // Get one MouvementCaisse
     * const mouvementCaisse = await prisma.mouvementCaisse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MouvementCaisseFindFirstOrThrowArgs>(args?: SelectSubset<T, MouvementCaisseFindFirstOrThrowArgs<ExtArgs>>): Prisma__MouvementCaisseClient<$Result.GetResult<Prisma.$MouvementCaissePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MouvementCaisses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MouvementCaisseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MouvementCaisses
     * const mouvementCaisses = await prisma.mouvementCaisse.findMany()
     * 
     * // Get first 10 MouvementCaisses
     * const mouvementCaisses = await prisma.mouvementCaisse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mouvementCaisseWithIdOnly = await prisma.mouvementCaisse.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MouvementCaisseFindManyArgs>(args?: SelectSubset<T, MouvementCaisseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MouvementCaissePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MouvementCaisse.
     * @param {MouvementCaisseCreateArgs} args - Arguments to create a MouvementCaisse.
     * @example
     * // Create one MouvementCaisse
     * const MouvementCaisse = await prisma.mouvementCaisse.create({
     *   data: {
     *     // ... data to create a MouvementCaisse
     *   }
     * })
     * 
     */
    create<T extends MouvementCaisseCreateArgs>(args: SelectSubset<T, MouvementCaisseCreateArgs<ExtArgs>>): Prisma__MouvementCaisseClient<$Result.GetResult<Prisma.$MouvementCaissePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MouvementCaisses.
     * @param {MouvementCaisseCreateManyArgs} args - Arguments to create many MouvementCaisses.
     * @example
     * // Create many MouvementCaisses
     * const mouvementCaisse = await prisma.mouvementCaisse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MouvementCaisseCreateManyArgs>(args?: SelectSubset<T, MouvementCaisseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MouvementCaisses and returns the data saved in the database.
     * @param {MouvementCaisseCreateManyAndReturnArgs} args - Arguments to create many MouvementCaisses.
     * @example
     * // Create many MouvementCaisses
     * const mouvementCaisse = await prisma.mouvementCaisse.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MouvementCaisses and only return the `id`
     * const mouvementCaisseWithIdOnly = await prisma.mouvementCaisse.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MouvementCaisseCreateManyAndReturnArgs>(args?: SelectSubset<T, MouvementCaisseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MouvementCaissePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MouvementCaisse.
     * @param {MouvementCaisseDeleteArgs} args - Arguments to delete one MouvementCaisse.
     * @example
     * // Delete one MouvementCaisse
     * const MouvementCaisse = await prisma.mouvementCaisse.delete({
     *   where: {
     *     // ... filter to delete one MouvementCaisse
     *   }
     * })
     * 
     */
    delete<T extends MouvementCaisseDeleteArgs>(args: SelectSubset<T, MouvementCaisseDeleteArgs<ExtArgs>>): Prisma__MouvementCaisseClient<$Result.GetResult<Prisma.$MouvementCaissePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MouvementCaisse.
     * @param {MouvementCaisseUpdateArgs} args - Arguments to update one MouvementCaisse.
     * @example
     * // Update one MouvementCaisse
     * const mouvementCaisse = await prisma.mouvementCaisse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MouvementCaisseUpdateArgs>(args: SelectSubset<T, MouvementCaisseUpdateArgs<ExtArgs>>): Prisma__MouvementCaisseClient<$Result.GetResult<Prisma.$MouvementCaissePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MouvementCaisses.
     * @param {MouvementCaisseDeleteManyArgs} args - Arguments to filter MouvementCaisses to delete.
     * @example
     * // Delete a few MouvementCaisses
     * const { count } = await prisma.mouvementCaisse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MouvementCaisseDeleteManyArgs>(args?: SelectSubset<T, MouvementCaisseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MouvementCaisses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MouvementCaisseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MouvementCaisses
     * const mouvementCaisse = await prisma.mouvementCaisse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MouvementCaisseUpdateManyArgs>(args: SelectSubset<T, MouvementCaisseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MouvementCaisses and returns the data updated in the database.
     * @param {MouvementCaisseUpdateManyAndReturnArgs} args - Arguments to update many MouvementCaisses.
     * @example
     * // Update many MouvementCaisses
     * const mouvementCaisse = await prisma.mouvementCaisse.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MouvementCaisses and only return the `id`
     * const mouvementCaisseWithIdOnly = await prisma.mouvementCaisse.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MouvementCaisseUpdateManyAndReturnArgs>(args: SelectSubset<T, MouvementCaisseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MouvementCaissePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MouvementCaisse.
     * @param {MouvementCaisseUpsertArgs} args - Arguments to update or create a MouvementCaisse.
     * @example
     * // Update or create a MouvementCaisse
     * const mouvementCaisse = await prisma.mouvementCaisse.upsert({
     *   create: {
     *     // ... data to create a MouvementCaisse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MouvementCaisse we want to update
     *   }
     * })
     */
    upsert<T extends MouvementCaisseUpsertArgs>(args: SelectSubset<T, MouvementCaisseUpsertArgs<ExtArgs>>): Prisma__MouvementCaisseClient<$Result.GetResult<Prisma.$MouvementCaissePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MouvementCaisses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MouvementCaisseCountArgs} args - Arguments to filter MouvementCaisses to count.
     * @example
     * // Count the number of MouvementCaisses
     * const count = await prisma.mouvementCaisse.count({
     *   where: {
     *     // ... the filter for the MouvementCaisses we want to count
     *   }
     * })
    **/
    count<T extends MouvementCaisseCountArgs>(
      args?: Subset<T, MouvementCaisseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MouvementCaisseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MouvementCaisse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MouvementCaisseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MouvementCaisseAggregateArgs>(args: Subset<T, MouvementCaisseAggregateArgs>): Prisma.PrismaPromise<GetMouvementCaisseAggregateType<T>>

    /**
     * Group by MouvementCaisse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MouvementCaisseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MouvementCaisseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MouvementCaisseGroupByArgs['orderBy'] }
        : { orderBy?: MouvementCaisseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MouvementCaisseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMouvementCaisseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MouvementCaisse model
   */
  readonly fields: MouvementCaisseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MouvementCaisse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MouvementCaisseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    caisse<T extends CaisseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CaisseDefaultArgs<ExtArgs>>): Prisma__CaisseClient<$Result.GetResult<Prisma.$CaissePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    utilisateur<T extends UtilisateurDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UtilisateurDefaultArgs<ExtArgs>>): Prisma__UtilisateurClient<$Result.GetResult<Prisma.$UtilisateurPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MouvementCaisse model
   */
  interface MouvementCaisseFieldRefs {
    readonly id: FieldRef<"MouvementCaisse", 'Int'>
    readonly caisseId: FieldRef<"MouvementCaisse", 'Int'>
    readonly type_mouvement: FieldRef<"MouvementCaisse", 'TypeMouvementCaisse'>
    readonly categorie: FieldRef<"MouvementCaisse", 'CategorieMouvement'>
    readonly montant: FieldRef<"MouvementCaisse", 'Float'>
    readonly description: FieldRef<"MouvementCaisse", 'String'>
    readonly enregistrerParId: FieldRef<"MouvementCaisse", 'Int'>
    readonly referenceExterne: FieldRef<"MouvementCaisse", 'String'>
    readonly createdAt: FieldRef<"MouvementCaisse", 'DateTime'>
    readonly updatedAt: FieldRef<"MouvementCaisse", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MouvementCaisse findUnique
   */
  export type MouvementCaisseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MouvementCaisse
     */
    select?: MouvementCaisseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MouvementCaisse
     */
    omit?: MouvementCaisseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MouvementCaisseInclude<ExtArgs> | null
    /**
     * Filter, which MouvementCaisse to fetch.
     */
    where: MouvementCaisseWhereUniqueInput
  }

  /**
   * MouvementCaisse findUniqueOrThrow
   */
  export type MouvementCaisseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MouvementCaisse
     */
    select?: MouvementCaisseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MouvementCaisse
     */
    omit?: MouvementCaisseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MouvementCaisseInclude<ExtArgs> | null
    /**
     * Filter, which MouvementCaisse to fetch.
     */
    where: MouvementCaisseWhereUniqueInput
  }

  /**
   * MouvementCaisse findFirst
   */
  export type MouvementCaisseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MouvementCaisse
     */
    select?: MouvementCaisseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MouvementCaisse
     */
    omit?: MouvementCaisseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MouvementCaisseInclude<ExtArgs> | null
    /**
     * Filter, which MouvementCaisse to fetch.
     */
    where?: MouvementCaisseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MouvementCaisses to fetch.
     */
    orderBy?: MouvementCaisseOrderByWithRelationInput | MouvementCaisseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MouvementCaisses.
     */
    cursor?: MouvementCaisseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MouvementCaisses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MouvementCaisses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MouvementCaisses.
     */
    distinct?: MouvementCaisseScalarFieldEnum | MouvementCaisseScalarFieldEnum[]
  }

  /**
   * MouvementCaisse findFirstOrThrow
   */
  export type MouvementCaisseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MouvementCaisse
     */
    select?: MouvementCaisseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MouvementCaisse
     */
    omit?: MouvementCaisseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MouvementCaisseInclude<ExtArgs> | null
    /**
     * Filter, which MouvementCaisse to fetch.
     */
    where?: MouvementCaisseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MouvementCaisses to fetch.
     */
    orderBy?: MouvementCaisseOrderByWithRelationInput | MouvementCaisseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MouvementCaisses.
     */
    cursor?: MouvementCaisseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MouvementCaisses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MouvementCaisses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MouvementCaisses.
     */
    distinct?: MouvementCaisseScalarFieldEnum | MouvementCaisseScalarFieldEnum[]
  }

  /**
   * MouvementCaisse findMany
   */
  export type MouvementCaisseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MouvementCaisse
     */
    select?: MouvementCaisseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MouvementCaisse
     */
    omit?: MouvementCaisseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MouvementCaisseInclude<ExtArgs> | null
    /**
     * Filter, which MouvementCaisses to fetch.
     */
    where?: MouvementCaisseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MouvementCaisses to fetch.
     */
    orderBy?: MouvementCaisseOrderByWithRelationInput | MouvementCaisseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MouvementCaisses.
     */
    cursor?: MouvementCaisseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MouvementCaisses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MouvementCaisses.
     */
    skip?: number
    distinct?: MouvementCaisseScalarFieldEnum | MouvementCaisseScalarFieldEnum[]
  }

  /**
   * MouvementCaisse create
   */
  export type MouvementCaisseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MouvementCaisse
     */
    select?: MouvementCaisseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MouvementCaisse
     */
    omit?: MouvementCaisseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MouvementCaisseInclude<ExtArgs> | null
    /**
     * The data needed to create a MouvementCaisse.
     */
    data: XOR<MouvementCaisseCreateInput, MouvementCaisseUncheckedCreateInput>
  }

  /**
   * MouvementCaisse createMany
   */
  export type MouvementCaisseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MouvementCaisses.
     */
    data: MouvementCaisseCreateManyInput | MouvementCaisseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MouvementCaisse createManyAndReturn
   */
  export type MouvementCaisseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MouvementCaisse
     */
    select?: MouvementCaisseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MouvementCaisse
     */
    omit?: MouvementCaisseOmit<ExtArgs> | null
    /**
     * The data used to create many MouvementCaisses.
     */
    data: MouvementCaisseCreateManyInput | MouvementCaisseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MouvementCaisseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MouvementCaisse update
   */
  export type MouvementCaisseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MouvementCaisse
     */
    select?: MouvementCaisseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MouvementCaisse
     */
    omit?: MouvementCaisseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MouvementCaisseInclude<ExtArgs> | null
    /**
     * The data needed to update a MouvementCaisse.
     */
    data: XOR<MouvementCaisseUpdateInput, MouvementCaisseUncheckedUpdateInput>
    /**
     * Choose, which MouvementCaisse to update.
     */
    where: MouvementCaisseWhereUniqueInput
  }

  /**
   * MouvementCaisse updateMany
   */
  export type MouvementCaisseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MouvementCaisses.
     */
    data: XOR<MouvementCaisseUpdateManyMutationInput, MouvementCaisseUncheckedUpdateManyInput>
    /**
     * Filter which MouvementCaisses to update
     */
    where?: MouvementCaisseWhereInput
    /**
     * Limit how many MouvementCaisses to update.
     */
    limit?: number
  }

  /**
   * MouvementCaisse updateManyAndReturn
   */
  export type MouvementCaisseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MouvementCaisse
     */
    select?: MouvementCaisseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MouvementCaisse
     */
    omit?: MouvementCaisseOmit<ExtArgs> | null
    /**
     * The data used to update MouvementCaisses.
     */
    data: XOR<MouvementCaisseUpdateManyMutationInput, MouvementCaisseUncheckedUpdateManyInput>
    /**
     * Filter which MouvementCaisses to update
     */
    where?: MouvementCaisseWhereInput
    /**
     * Limit how many MouvementCaisses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MouvementCaisseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MouvementCaisse upsert
   */
  export type MouvementCaisseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MouvementCaisse
     */
    select?: MouvementCaisseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MouvementCaisse
     */
    omit?: MouvementCaisseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MouvementCaisseInclude<ExtArgs> | null
    /**
     * The filter to search for the MouvementCaisse to update in case it exists.
     */
    where: MouvementCaisseWhereUniqueInput
    /**
     * In case the MouvementCaisse found by the `where` argument doesn't exist, create a new MouvementCaisse with this data.
     */
    create: XOR<MouvementCaisseCreateInput, MouvementCaisseUncheckedCreateInput>
    /**
     * In case the MouvementCaisse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MouvementCaisseUpdateInput, MouvementCaisseUncheckedUpdateInput>
  }

  /**
   * MouvementCaisse delete
   */
  export type MouvementCaisseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MouvementCaisse
     */
    select?: MouvementCaisseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MouvementCaisse
     */
    omit?: MouvementCaisseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MouvementCaisseInclude<ExtArgs> | null
    /**
     * Filter which MouvementCaisse to delete.
     */
    where: MouvementCaisseWhereUniqueInput
  }

  /**
   * MouvementCaisse deleteMany
   */
  export type MouvementCaisseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MouvementCaisses to delete
     */
    where?: MouvementCaisseWhereInput
    /**
     * Limit how many MouvementCaisses to delete.
     */
    limit?: number
  }

  /**
   * MouvementCaisse without action
   */
  export type MouvementCaisseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MouvementCaisse
     */
    select?: MouvementCaisseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MouvementCaisse
     */
    omit?: MouvementCaisseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MouvementCaisseInclude<ExtArgs> | null
  }


  /**
   * Model DetailClotureCaisse
   */

  export type AggregateDetailClotureCaisse = {
    _count: DetailClotureCaisseCountAggregateOutputType | null
    _avg: DetailClotureCaisseAvgAggregateOutputType | null
    _sum: DetailClotureCaisseSumAggregateOutputType | null
    _min: DetailClotureCaisseMinAggregateOutputType | null
    _max: DetailClotureCaisseMaxAggregateOutputType | null
  }

  export type DetailClotureCaisseAvgAggregateOutputType = {
    id: number | null
    produitId: number | null
    teneurId: number | null
    qtteRestante: number | null
    clotureCaisseId: number | null
  }

  export type DetailClotureCaisseSumAggregateOutputType = {
    id: number | null
    produitId: number | null
    teneurId: number | null
    qtteRestante: number | null
    clotureCaisseId: number | null
  }

  export type DetailClotureCaisseMinAggregateOutputType = {
    id: number | null
    produitId: number | null
    teneurId: number | null
    qtteRestante: number | null
    clotureCaisseId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DetailClotureCaisseMaxAggregateOutputType = {
    id: number | null
    produitId: number | null
    teneurId: number | null
    qtteRestante: number | null
    clotureCaisseId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DetailClotureCaisseCountAggregateOutputType = {
    id: number
    produitId: number
    teneurId: number
    qtteRestante: number
    clotureCaisseId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DetailClotureCaisseAvgAggregateInputType = {
    id?: true
    produitId?: true
    teneurId?: true
    qtteRestante?: true
    clotureCaisseId?: true
  }

  export type DetailClotureCaisseSumAggregateInputType = {
    id?: true
    produitId?: true
    teneurId?: true
    qtteRestante?: true
    clotureCaisseId?: true
  }

  export type DetailClotureCaisseMinAggregateInputType = {
    id?: true
    produitId?: true
    teneurId?: true
    qtteRestante?: true
    clotureCaisseId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DetailClotureCaisseMaxAggregateInputType = {
    id?: true
    produitId?: true
    teneurId?: true
    qtteRestante?: true
    clotureCaisseId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DetailClotureCaisseCountAggregateInputType = {
    id?: true
    produitId?: true
    teneurId?: true
    qtteRestante?: true
    clotureCaisseId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DetailClotureCaisseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DetailClotureCaisse to aggregate.
     */
    where?: DetailClotureCaisseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DetailClotureCaisses to fetch.
     */
    orderBy?: DetailClotureCaisseOrderByWithRelationInput | DetailClotureCaisseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DetailClotureCaisseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DetailClotureCaisses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DetailClotureCaisses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DetailClotureCaisses
    **/
    _count?: true | DetailClotureCaisseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DetailClotureCaisseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DetailClotureCaisseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DetailClotureCaisseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DetailClotureCaisseMaxAggregateInputType
  }

  export type GetDetailClotureCaisseAggregateType<T extends DetailClotureCaisseAggregateArgs> = {
        [P in keyof T & keyof AggregateDetailClotureCaisse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDetailClotureCaisse[P]>
      : GetScalarType<T[P], AggregateDetailClotureCaisse[P]>
  }




  export type DetailClotureCaisseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DetailClotureCaisseWhereInput
    orderBy?: DetailClotureCaisseOrderByWithAggregationInput | DetailClotureCaisseOrderByWithAggregationInput[]
    by: DetailClotureCaisseScalarFieldEnum[] | DetailClotureCaisseScalarFieldEnum
    having?: DetailClotureCaisseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DetailClotureCaisseCountAggregateInputType | true
    _avg?: DetailClotureCaisseAvgAggregateInputType
    _sum?: DetailClotureCaisseSumAggregateInputType
    _min?: DetailClotureCaisseMinAggregateInputType
    _max?: DetailClotureCaisseMaxAggregateInputType
  }

  export type DetailClotureCaisseGroupByOutputType = {
    id: number
    produitId: number
    teneurId: number
    qtteRestante: number
    clotureCaisseId: number
    createdAt: Date
    updatedAt: Date
    _count: DetailClotureCaisseCountAggregateOutputType | null
    _avg: DetailClotureCaisseAvgAggregateOutputType | null
    _sum: DetailClotureCaisseSumAggregateOutputType | null
    _min: DetailClotureCaisseMinAggregateOutputType | null
    _max: DetailClotureCaisseMaxAggregateOutputType | null
  }

  type GetDetailClotureCaisseGroupByPayload<T extends DetailClotureCaisseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DetailClotureCaisseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DetailClotureCaisseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DetailClotureCaisseGroupByOutputType[P]>
            : GetScalarType<T[P], DetailClotureCaisseGroupByOutputType[P]>
        }
      >
    >


  export type DetailClotureCaisseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    produitId?: boolean
    teneurId?: boolean
    qtteRestante?: boolean
    clotureCaisseId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    produit?: boolean | ProduitDefaultArgs<ExtArgs>
    teneur?: boolean | TeneurDefaultArgs<ExtArgs>
    clotureCaisse?: boolean | ClotureCaisseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["detailClotureCaisse"]>

  export type DetailClotureCaisseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    produitId?: boolean
    teneurId?: boolean
    qtteRestante?: boolean
    clotureCaisseId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    produit?: boolean | ProduitDefaultArgs<ExtArgs>
    teneur?: boolean | TeneurDefaultArgs<ExtArgs>
    clotureCaisse?: boolean | ClotureCaisseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["detailClotureCaisse"]>

  export type DetailClotureCaisseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    produitId?: boolean
    teneurId?: boolean
    qtteRestante?: boolean
    clotureCaisseId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    produit?: boolean | ProduitDefaultArgs<ExtArgs>
    teneur?: boolean | TeneurDefaultArgs<ExtArgs>
    clotureCaisse?: boolean | ClotureCaisseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["detailClotureCaisse"]>

  export type DetailClotureCaisseSelectScalar = {
    id?: boolean
    produitId?: boolean
    teneurId?: boolean
    qtteRestante?: boolean
    clotureCaisseId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DetailClotureCaisseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "produitId" | "teneurId" | "qtteRestante" | "clotureCaisseId" | "createdAt" | "updatedAt", ExtArgs["result"]["detailClotureCaisse"]>
  export type DetailClotureCaisseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    produit?: boolean | ProduitDefaultArgs<ExtArgs>
    teneur?: boolean | TeneurDefaultArgs<ExtArgs>
    clotureCaisse?: boolean | ClotureCaisseDefaultArgs<ExtArgs>
  }
  export type DetailClotureCaisseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    produit?: boolean | ProduitDefaultArgs<ExtArgs>
    teneur?: boolean | TeneurDefaultArgs<ExtArgs>
    clotureCaisse?: boolean | ClotureCaisseDefaultArgs<ExtArgs>
  }
  export type DetailClotureCaisseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    produit?: boolean | ProduitDefaultArgs<ExtArgs>
    teneur?: boolean | TeneurDefaultArgs<ExtArgs>
    clotureCaisse?: boolean | ClotureCaisseDefaultArgs<ExtArgs>
  }

  export type $DetailClotureCaissePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DetailClotureCaisse"
    objects: {
      produit: Prisma.$ProduitPayload<ExtArgs>
      teneur: Prisma.$TeneurPayload<ExtArgs>
      clotureCaisse: Prisma.$ClotureCaissePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      produitId: number
      teneurId: number
      qtteRestante: number
      clotureCaisseId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["detailClotureCaisse"]>
    composites: {}
  }

  type DetailClotureCaisseGetPayload<S extends boolean | null | undefined | DetailClotureCaisseDefaultArgs> = $Result.GetResult<Prisma.$DetailClotureCaissePayload, S>

  type DetailClotureCaisseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DetailClotureCaisseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DetailClotureCaisseCountAggregateInputType | true
    }

  export interface DetailClotureCaisseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DetailClotureCaisse'], meta: { name: 'DetailClotureCaisse' } }
    /**
     * Find zero or one DetailClotureCaisse that matches the filter.
     * @param {DetailClotureCaisseFindUniqueArgs} args - Arguments to find a DetailClotureCaisse
     * @example
     * // Get one DetailClotureCaisse
     * const detailClotureCaisse = await prisma.detailClotureCaisse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DetailClotureCaisseFindUniqueArgs>(args: SelectSubset<T, DetailClotureCaisseFindUniqueArgs<ExtArgs>>): Prisma__DetailClotureCaisseClient<$Result.GetResult<Prisma.$DetailClotureCaissePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DetailClotureCaisse that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DetailClotureCaisseFindUniqueOrThrowArgs} args - Arguments to find a DetailClotureCaisse
     * @example
     * // Get one DetailClotureCaisse
     * const detailClotureCaisse = await prisma.detailClotureCaisse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DetailClotureCaisseFindUniqueOrThrowArgs>(args: SelectSubset<T, DetailClotureCaisseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DetailClotureCaisseClient<$Result.GetResult<Prisma.$DetailClotureCaissePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DetailClotureCaisse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetailClotureCaisseFindFirstArgs} args - Arguments to find a DetailClotureCaisse
     * @example
     * // Get one DetailClotureCaisse
     * const detailClotureCaisse = await prisma.detailClotureCaisse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DetailClotureCaisseFindFirstArgs>(args?: SelectSubset<T, DetailClotureCaisseFindFirstArgs<ExtArgs>>): Prisma__DetailClotureCaisseClient<$Result.GetResult<Prisma.$DetailClotureCaissePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DetailClotureCaisse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetailClotureCaisseFindFirstOrThrowArgs} args - Arguments to find a DetailClotureCaisse
     * @example
     * // Get one DetailClotureCaisse
     * const detailClotureCaisse = await prisma.detailClotureCaisse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DetailClotureCaisseFindFirstOrThrowArgs>(args?: SelectSubset<T, DetailClotureCaisseFindFirstOrThrowArgs<ExtArgs>>): Prisma__DetailClotureCaisseClient<$Result.GetResult<Prisma.$DetailClotureCaissePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DetailClotureCaisses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetailClotureCaisseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DetailClotureCaisses
     * const detailClotureCaisses = await prisma.detailClotureCaisse.findMany()
     * 
     * // Get first 10 DetailClotureCaisses
     * const detailClotureCaisses = await prisma.detailClotureCaisse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const detailClotureCaisseWithIdOnly = await prisma.detailClotureCaisse.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DetailClotureCaisseFindManyArgs>(args?: SelectSubset<T, DetailClotureCaisseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DetailClotureCaissePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DetailClotureCaisse.
     * @param {DetailClotureCaisseCreateArgs} args - Arguments to create a DetailClotureCaisse.
     * @example
     * // Create one DetailClotureCaisse
     * const DetailClotureCaisse = await prisma.detailClotureCaisse.create({
     *   data: {
     *     // ... data to create a DetailClotureCaisse
     *   }
     * })
     * 
     */
    create<T extends DetailClotureCaisseCreateArgs>(args: SelectSubset<T, DetailClotureCaisseCreateArgs<ExtArgs>>): Prisma__DetailClotureCaisseClient<$Result.GetResult<Prisma.$DetailClotureCaissePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DetailClotureCaisses.
     * @param {DetailClotureCaisseCreateManyArgs} args - Arguments to create many DetailClotureCaisses.
     * @example
     * // Create many DetailClotureCaisses
     * const detailClotureCaisse = await prisma.detailClotureCaisse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DetailClotureCaisseCreateManyArgs>(args?: SelectSubset<T, DetailClotureCaisseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DetailClotureCaisses and returns the data saved in the database.
     * @param {DetailClotureCaisseCreateManyAndReturnArgs} args - Arguments to create many DetailClotureCaisses.
     * @example
     * // Create many DetailClotureCaisses
     * const detailClotureCaisse = await prisma.detailClotureCaisse.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DetailClotureCaisses and only return the `id`
     * const detailClotureCaisseWithIdOnly = await prisma.detailClotureCaisse.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DetailClotureCaisseCreateManyAndReturnArgs>(args?: SelectSubset<T, DetailClotureCaisseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DetailClotureCaissePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DetailClotureCaisse.
     * @param {DetailClotureCaisseDeleteArgs} args - Arguments to delete one DetailClotureCaisse.
     * @example
     * // Delete one DetailClotureCaisse
     * const DetailClotureCaisse = await prisma.detailClotureCaisse.delete({
     *   where: {
     *     // ... filter to delete one DetailClotureCaisse
     *   }
     * })
     * 
     */
    delete<T extends DetailClotureCaisseDeleteArgs>(args: SelectSubset<T, DetailClotureCaisseDeleteArgs<ExtArgs>>): Prisma__DetailClotureCaisseClient<$Result.GetResult<Prisma.$DetailClotureCaissePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DetailClotureCaisse.
     * @param {DetailClotureCaisseUpdateArgs} args - Arguments to update one DetailClotureCaisse.
     * @example
     * // Update one DetailClotureCaisse
     * const detailClotureCaisse = await prisma.detailClotureCaisse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DetailClotureCaisseUpdateArgs>(args: SelectSubset<T, DetailClotureCaisseUpdateArgs<ExtArgs>>): Prisma__DetailClotureCaisseClient<$Result.GetResult<Prisma.$DetailClotureCaissePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DetailClotureCaisses.
     * @param {DetailClotureCaisseDeleteManyArgs} args - Arguments to filter DetailClotureCaisses to delete.
     * @example
     * // Delete a few DetailClotureCaisses
     * const { count } = await prisma.detailClotureCaisse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DetailClotureCaisseDeleteManyArgs>(args?: SelectSubset<T, DetailClotureCaisseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DetailClotureCaisses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetailClotureCaisseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DetailClotureCaisses
     * const detailClotureCaisse = await prisma.detailClotureCaisse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DetailClotureCaisseUpdateManyArgs>(args: SelectSubset<T, DetailClotureCaisseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DetailClotureCaisses and returns the data updated in the database.
     * @param {DetailClotureCaisseUpdateManyAndReturnArgs} args - Arguments to update many DetailClotureCaisses.
     * @example
     * // Update many DetailClotureCaisses
     * const detailClotureCaisse = await prisma.detailClotureCaisse.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DetailClotureCaisses and only return the `id`
     * const detailClotureCaisseWithIdOnly = await prisma.detailClotureCaisse.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DetailClotureCaisseUpdateManyAndReturnArgs>(args: SelectSubset<T, DetailClotureCaisseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DetailClotureCaissePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DetailClotureCaisse.
     * @param {DetailClotureCaisseUpsertArgs} args - Arguments to update or create a DetailClotureCaisse.
     * @example
     * // Update or create a DetailClotureCaisse
     * const detailClotureCaisse = await prisma.detailClotureCaisse.upsert({
     *   create: {
     *     // ... data to create a DetailClotureCaisse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DetailClotureCaisse we want to update
     *   }
     * })
     */
    upsert<T extends DetailClotureCaisseUpsertArgs>(args: SelectSubset<T, DetailClotureCaisseUpsertArgs<ExtArgs>>): Prisma__DetailClotureCaisseClient<$Result.GetResult<Prisma.$DetailClotureCaissePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DetailClotureCaisses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetailClotureCaisseCountArgs} args - Arguments to filter DetailClotureCaisses to count.
     * @example
     * // Count the number of DetailClotureCaisses
     * const count = await prisma.detailClotureCaisse.count({
     *   where: {
     *     // ... the filter for the DetailClotureCaisses we want to count
     *   }
     * })
    **/
    count<T extends DetailClotureCaisseCountArgs>(
      args?: Subset<T, DetailClotureCaisseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DetailClotureCaisseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DetailClotureCaisse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetailClotureCaisseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DetailClotureCaisseAggregateArgs>(args: Subset<T, DetailClotureCaisseAggregateArgs>): Prisma.PrismaPromise<GetDetailClotureCaisseAggregateType<T>>

    /**
     * Group by DetailClotureCaisse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetailClotureCaisseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DetailClotureCaisseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DetailClotureCaisseGroupByArgs['orderBy'] }
        : { orderBy?: DetailClotureCaisseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DetailClotureCaisseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDetailClotureCaisseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DetailClotureCaisse model
   */
  readonly fields: DetailClotureCaisseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DetailClotureCaisse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DetailClotureCaisseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    produit<T extends ProduitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProduitDefaultArgs<ExtArgs>>): Prisma__ProduitClient<$Result.GetResult<Prisma.$ProduitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    teneur<T extends TeneurDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeneurDefaultArgs<ExtArgs>>): Prisma__TeneurClient<$Result.GetResult<Prisma.$TeneurPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    clotureCaisse<T extends ClotureCaisseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClotureCaisseDefaultArgs<ExtArgs>>): Prisma__ClotureCaisseClient<$Result.GetResult<Prisma.$ClotureCaissePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DetailClotureCaisse model
   */
  interface DetailClotureCaisseFieldRefs {
    readonly id: FieldRef<"DetailClotureCaisse", 'Int'>
    readonly produitId: FieldRef<"DetailClotureCaisse", 'Int'>
    readonly teneurId: FieldRef<"DetailClotureCaisse", 'Int'>
    readonly qtteRestante: FieldRef<"DetailClotureCaisse", 'Int'>
    readonly clotureCaisseId: FieldRef<"DetailClotureCaisse", 'Int'>
    readonly createdAt: FieldRef<"DetailClotureCaisse", 'DateTime'>
    readonly updatedAt: FieldRef<"DetailClotureCaisse", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DetailClotureCaisse findUnique
   */
  export type DetailClotureCaisseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetailClotureCaisse
     */
    select?: DetailClotureCaisseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DetailClotureCaisse
     */
    omit?: DetailClotureCaisseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetailClotureCaisseInclude<ExtArgs> | null
    /**
     * Filter, which DetailClotureCaisse to fetch.
     */
    where: DetailClotureCaisseWhereUniqueInput
  }

  /**
   * DetailClotureCaisse findUniqueOrThrow
   */
  export type DetailClotureCaisseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetailClotureCaisse
     */
    select?: DetailClotureCaisseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DetailClotureCaisse
     */
    omit?: DetailClotureCaisseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetailClotureCaisseInclude<ExtArgs> | null
    /**
     * Filter, which DetailClotureCaisse to fetch.
     */
    where: DetailClotureCaisseWhereUniqueInput
  }

  /**
   * DetailClotureCaisse findFirst
   */
  export type DetailClotureCaisseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetailClotureCaisse
     */
    select?: DetailClotureCaisseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DetailClotureCaisse
     */
    omit?: DetailClotureCaisseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetailClotureCaisseInclude<ExtArgs> | null
    /**
     * Filter, which DetailClotureCaisse to fetch.
     */
    where?: DetailClotureCaisseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DetailClotureCaisses to fetch.
     */
    orderBy?: DetailClotureCaisseOrderByWithRelationInput | DetailClotureCaisseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DetailClotureCaisses.
     */
    cursor?: DetailClotureCaisseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DetailClotureCaisses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DetailClotureCaisses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DetailClotureCaisses.
     */
    distinct?: DetailClotureCaisseScalarFieldEnum | DetailClotureCaisseScalarFieldEnum[]
  }

  /**
   * DetailClotureCaisse findFirstOrThrow
   */
  export type DetailClotureCaisseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetailClotureCaisse
     */
    select?: DetailClotureCaisseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DetailClotureCaisse
     */
    omit?: DetailClotureCaisseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetailClotureCaisseInclude<ExtArgs> | null
    /**
     * Filter, which DetailClotureCaisse to fetch.
     */
    where?: DetailClotureCaisseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DetailClotureCaisses to fetch.
     */
    orderBy?: DetailClotureCaisseOrderByWithRelationInput | DetailClotureCaisseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DetailClotureCaisses.
     */
    cursor?: DetailClotureCaisseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DetailClotureCaisses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DetailClotureCaisses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DetailClotureCaisses.
     */
    distinct?: DetailClotureCaisseScalarFieldEnum | DetailClotureCaisseScalarFieldEnum[]
  }

  /**
   * DetailClotureCaisse findMany
   */
  export type DetailClotureCaisseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetailClotureCaisse
     */
    select?: DetailClotureCaisseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DetailClotureCaisse
     */
    omit?: DetailClotureCaisseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetailClotureCaisseInclude<ExtArgs> | null
    /**
     * Filter, which DetailClotureCaisses to fetch.
     */
    where?: DetailClotureCaisseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DetailClotureCaisses to fetch.
     */
    orderBy?: DetailClotureCaisseOrderByWithRelationInput | DetailClotureCaisseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DetailClotureCaisses.
     */
    cursor?: DetailClotureCaisseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DetailClotureCaisses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DetailClotureCaisses.
     */
    skip?: number
    distinct?: DetailClotureCaisseScalarFieldEnum | DetailClotureCaisseScalarFieldEnum[]
  }

  /**
   * DetailClotureCaisse create
   */
  export type DetailClotureCaisseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetailClotureCaisse
     */
    select?: DetailClotureCaisseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DetailClotureCaisse
     */
    omit?: DetailClotureCaisseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetailClotureCaisseInclude<ExtArgs> | null
    /**
     * The data needed to create a DetailClotureCaisse.
     */
    data: XOR<DetailClotureCaisseCreateInput, DetailClotureCaisseUncheckedCreateInput>
  }

  /**
   * DetailClotureCaisse createMany
   */
  export type DetailClotureCaisseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DetailClotureCaisses.
     */
    data: DetailClotureCaisseCreateManyInput | DetailClotureCaisseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DetailClotureCaisse createManyAndReturn
   */
  export type DetailClotureCaisseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetailClotureCaisse
     */
    select?: DetailClotureCaisseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DetailClotureCaisse
     */
    omit?: DetailClotureCaisseOmit<ExtArgs> | null
    /**
     * The data used to create many DetailClotureCaisses.
     */
    data: DetailClotureCaisseCreateManyInput | DetailClotureCaisseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetailClotureCaisseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DetailClotureCaisse update
   */
  export type DetailClotureCaisseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetailClotureCaisse
     */
    select?: DetailClotureCaisseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DetailClotureCaisse
     */
    omit?: DetailClotureCaisseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetailClotureCaisseInclude<ExtArgs> | null
    /**
     * The data needed to update a DetailClotureCaisse.
     */
    data: XOR<DetailClotureCaisseUpdateInput, DetailClotureCaisseUncheckedUpdateInput>
    /**
     * Choose, which DetailClotureCaisse to update.
     */
    where: DetailClotureCaisseWhereUniqueInput
  }

  /**
   * DetailClotureCaisse updateMany
   */
  export type DetailClotureCaisseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DetailClotureCaisses.
     */
    data: XOR<DetailClotureCaisseUpdateManyMutationInput, DetailClotureCaisseUncheckedUpdateManyInput>
    /**
     * Filter which DetailClotureCaisses to update
     */
    where?: DetailClotureCaisseWhereInput
    /**
     * Limit how many DetailClotureCaisses to update.
     */
    limit?: number
  }

  /**
   * DetailClotureCaisse updateManyAndReturn
   */
  export type DetailClotureCaisseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetailClotureCaisse
     */
    select?: DetailClotureCaisseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DetailClotureCaisse
     */
    omit?: DetailClotureCaisseOmit<ExtArgs> | null
    /**
     * The data used to update DetailClotureCaisses.
     */
    data: XOR<DetailClotureCaisseUpdateManyMutationInput, DetailClotureCaisseUncheckedUpdateManyInput>
    /**
     * Filter which DetailClotureCaisses to update
     */
    where?: DetailClotureCaisseWhereInput
    /**
     * Limit how many DetailClotureCaisses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetailClotureCaisseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DetailClotureCaisse upsert
   */
  export type DetailClotureCaisseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetailClotureCaisse
     */
    select?: DetailClotureCaisseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DetailClotureCaisse
     */
    omit?: DetailClotureCaisseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetailClotureCaisseInclude<ExtArgs> | null
    /**
     * The filter to search for the DetailClotureCaisse to update in case it exists.
     */
    where: DetailClotureCaisseWhereUniqueInput
    /**
     * In case the DetailClotureCaisse found by the `where` argument doesn't exist, create a new DetailClotureCaisse with this data.
     */
    create: XOR<DetailClotureCaisseCreateInput, DetailClotureCaisseUncheckedCreateInput>
    /**
     * In case the DetailClotureCaisse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DetailClotureCaisseUpdateInput, DetailClotureCaisseUncheckedUpdateInput>
  }

  /**
   * DetailClotureCaisse delete
   */
  export type DetailClotureCaisseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetailClotureCaisse
     */
    select?: DetailClotureCaisseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DetailClotureCaisse
     */
    omit?: DetailClotureCaisseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetailClotureCaisseInclude<ExtArgs> | null
    /**
     * Filter which DetailClotureCaisse to delete.
     */
    where: DetailClotureCaisseWhereUniqueInput
  }

  /**
   * DetailClotureCaisse deleteMany
   */
  export type DetailClotureCaisseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DetailClotureCaisses to delete
     */
    where?: DetailClotureCaisseWhereInput
    /**
     * Limit how many DetailClotureCaisses to delete.
     */
    limit?: number
  }

  /**
   * DetailClotureCaisse without action
   */
  export type DetailClotureCaisseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetailClotureCaisse
     */
    select?: DetailClotureCaisseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DetailClotureCaisse
     */
    omit?: DetailClotureCaisseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetailClotureCaisseInclude<ExtArgs> | null
  }


  /**
   * Model ClotureCaisse
   */

  export type AggregateClotureCaisse = {
    _count: ClotureCaisseCountAggregateOutputType | null
    _avg: ClotureCaisseAvgAggregateOutputType | null
    _sum: ClotureCaisseSumAggregateOutputType | null
    _min: ClotureCaisseMinAggregateOutputType | null
    _max: ClotureCaisseMaxAggregateOutputType | null
  }

  export type ClotureCaisseAvgAggregateOutputType = {
    id: number | null
    caisseId: number | null
    utilisateurClotureId: number | null
  }

  export type ClotureCaisseSumAggregateOutputType = {
    id: number | null
    caisseId: number | null
    utilisateurClotureId: number | null
  }

  export type ClotureCaisseMinAggregateOutputType = {
    id: number | null
    caisseId: number | null
    dateCloture: Date | null
    utilisateurClotureId: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClotureCaisseMaxAggregateOutputType = {
    id: number | null
    caisseId: number | null
    dateCloture: Date | null
    utilisateurClotureId: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClotureCaisseCountAggregateOutputType = {
    id: number
    caisseId: number
    dateCloture: number
    utilisateurClotureId: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClotureCaisseAvgAggregateInputType = {
    id?: true
    caisseId?: true
    utilisateurClotureId?: true
  }

  export type ClotureCaisseSumAggregateInputType = {
    id?: true
    caisseId?: true
    utilisateurClotureId?: true
  }

  export type ClotureCaisseMinAggregateInputType = {
    id?: true
    caisseId?: true
    dateCloture?: true
    utilisateurClotureId?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClotureCaisseMaxAggregateInputType = {
    id?: true
    caisseId?: true
    dateCloture?: true
    utilisateurClotureId?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClotureCaisseCountAggregateInputType = {
    id?: true
    caisseId?: true
    dateCloture?: true
    utilisateurClotureId?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClotureCaisseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClotureCaisse to aggregate.
     */
    where?: ClotureCaisseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClotureCaisses to fetch.
     */
    orderBy?: ClotureCaisseOrderByWithRelationInput | ClotureCaisseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClotureCaisseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClotureCaisses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClotureCaisses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClotureCaisses
    **/
    _count?: true | ClotureCaisseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClotureCaisseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClotureCaisseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClotureCaisseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClotureCaisseMaxAggregateInputType
  }

  export type GetClotureCaisseAggregateType<T extends ClotureCaisseAggregateArgs> = {
        [P in keyof T & keyof AggregateClotureCaisse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClotureCaisse[P]>
      : GetScalarType<T[P], AggregateClotureCaisse[P]>
  }




  export type ClotureCaisseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClotureCaisseWhereInput
    orderBy?: ClotureCaisseOrderByWithAggregationInput | ClotureCaisseOrderByWithAggregationInput[]
    by: ClotureCaisseScalarFieldEnum[] | ClotureCaisseScalarFieldEnum
    having?: ClotureCaisseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClotureCaisseCountAggregateInputType | true
    _avg?: ClotureCaisseAvgAggregateInputType
    _sum?: ClotureCaisseSumAggregateInputType
    _min?: ClotureCaisseMinAggregateInputType
    _max?: ClotureCaisseMaxAggregateInputType
  }

  export type ClotureCaisseGroupByOutputType = {
    id: number
    caisseId: number
    dateCloture: Date
    utilisateurClotureId: number
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: ClotureCaisseCountAggregateOutputType | null
    _avg: ClotureCaisseAvgAggregateOutputType | null
    _sum: ClotureCaisseSumAggregateOutputType | null
    _min: ClotureCaisseMinAggregateOutputType | null
    _max: ClotureCaisseMaxAggregateOutputType | null
  }

  type GetClotureCaisseGroupByPayload<T extends ClotureCaisseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClotureCaisseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClotureCaisseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClotureCaisseGroupByOutputType[P]>
            : GetScalarType<T[P], ClotureCaisseGroupByOutputType[P]>
        }
      >
    >


  export type ClotureCaisseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    caisseId?: boolean
    dateCloture?: boolean
    utilisateurClotureId?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    caisse?: boolean | CaisseDefaultArgs<ExtArgs>
    utilisateurCloture?: boolean | UtilisateurDefaultArgs<ExtArgs>
    DetailClotureCaisse?: boolean | ClotureCaisse$DetailClotureCaisseArgs<ExtArgs>
    _count?: boolean | ClotureCaisseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clotureCaisse"]>

  export type ClotureCaisseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    caisseId?: boolean
    dateCloture?: boolean
    utilisateurClotureId?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    caisse?: boolean | CaisseDefaultArgs<ExtArgs>
    utilisateurCloture?: boolean | UtilisateurDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clotureCaisse"]>

  export type ClotureCaisseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    caisseId?: boolean
    dateCloture?: boolean
    utilisateurClotureId?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    caisse?: boolean | CaisseDefaultArgs<ExtArgs>
    utilisateurCloture?: boolean | UtilisateurDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clotureCaisse"]>

  export type ClotureCaisseSelectScalar = {
    id?: boolean
    caisseId?: boolean
    dateCloture?: boolean
    utilisateurClotureId?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClotureCaisseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "caisseId" | "dateCloture" | "utilisateurClotureId" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["clotureCaisse"]>
  export type ClotureCaisseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    caisse?: boolean | CaisseDefaultArgs<ExtArgs>
    utilisateurCloture?: boolean | UtilisateurDefaultArgs<ExtArgs>
    DetailClotureCaisse?: boolean | ClotureCaisse$DetailClotureCaisseArgs<ExtArgs>
    _count?: boolean | ClotureCaisseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClotureCaisseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    caisse?: boolean | CaisseDefaultArgs<ExtArgs>
    utilisateurCloture?: boolean | UtilisateurDefaultArgs<ExtArgs>
  }
  export type ClotureCaisseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    caisse?: boolean | CaisseDefaultArgs<ExtArgs>
    utilisateurCloture?: boolean | UtilisateurDefaultArgs<ExtArgs>
  }

  export type $ClotureCaissePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClotureCaisse"
    objects: {
      caisse: Prisma.$CaissePayload<ExtArgs>
      utilisateurCloture: Prisma.$UtilisateurPayload<ExtArgs>
      DetailClotureCaisse: Prisma.$DetailClotureCaissePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      caisseId: number
      dateCloture: Date
      utilisateurClotureId: number
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["clotureCaisse"]>
    composites: {}
  }

  type ClotureCaisseGetPayload<S extends boolean | null | undefined | ClotureCaisseDefaultArgs> = $Result.GetResult<Prisma.$ClotureCaissePayload, S>

  type ClotureCaisseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClotureCaisseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClotureCaisseCountAggregateInputType | true
    }

  export interface ClotureCaisseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClotureCaisse'], meta: { name: 'ClotureCaisse' } }
    /**
     * Find zero or one ClotureCaisse that matches the filter.
     * @param {ClotureCaisseFindUniqueArgs} args - Arguments to find a ClotureCaisse
     * @example
     * // Get one ClotureCaisse
     * const clotureCaisse = await prisma.clotureCaisse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClotureCaisseFindUniqueArgs>(args: SelectSubset<T, ClotureCaisseFindUniqueArgs<ExtArgs>>): Prisma__ClotureCaisseClient<$Result.GetResult<Prisma.$ClotureCaissePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClotureCaisse that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClotureCaisseFindUniqueOrThrowArgs} args - Arguments to find a ClotureCaisse
     * @example
     * // Get one ClotureCaisse
     * const clotureCaisse = await prisma.clotureCaisse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClotureCaisseFindUniqueOrThrowArgs>(args: SelectSubset<T, ClotureCaisseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClotureCaisseClient<$Result.GetResult<Prisma.$ClotureCaissePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClotureCaisse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClotureCaisseFindFirstArgs} args - Arguments to find a ClotureCaisse
     * @example
     * // Get one ClotureCaisse
     * const clotureCaisse = await prisma.clotureCaisse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClotureCaisseFindFirstArgs>(args?: SelectSubset<T, ClotureCaisseFindFirstArgs<ExtArgs>>): Prisma__ClotureCaisseClient<$Result.GetResult<Prisma.$ClotureCaissePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClotureCaisse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClotureCaisseFindFirstOrThrowArgs} args - Arguments to find a ClotureCaisse
     * @example
     * // Get one ClotureCaisse
     * const clotureCaisse = await prisma.clotureCaisse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClotureCaisseFindFirstOrThrowArgs>(args?: SelectSubset<T, ClotureCaisseFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClotureCaisseClient<$Result.GetResult<Prisma.$ClotureCaissePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClotureCaisses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClotureCaisseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClotureCaisses
     * const clotureCaisses = await prisma.clotureCaisse.findMany()
     * 
     * // Get first 10 ClotureCaisses
     * const clotureCaisses = await prisma.clotureCaisse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clotureCaisseWithIdOnly = await prisma.clotureCaisse.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClotureCaisseFindManyArgs>(args?: SelectSubset<T, ClotureCaisseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClotureCaissePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClotureCaisse.
     * @param {ClotureCaisseCreateArgs} args - Arguments to create a ClotureCaisse.
     * @example
     * // Create one ClotureCaisse
     * const ClotureCaisse = await prisma.clotureCaisse.create({
     *   data: {
     *     // ... data to create a ClotureCaisse
     *   }
     * })
     * 
     */
    create<T extends ClotureCaisseCreateArgs>(args: SelectSubset<T, ClotureCaisseCreateArgs<ExtArgs>>): Prisma__ClotureCaisseClient<$Result.GetResult<Prisma.$ClotureCaissePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClotureCaisses.
     * @param {ClotureCaisseCreateManyArgs} args - Arguments to create many ClotureCaisses.
     * @example
     * // Create many ClotureCaisses
     * const clotureCaisse = await prisma.clotureCaisse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClotureCaisseCreateManyArgs>(args?: SelectSubset<T, ClotureCaisseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClotureCaisses and returns the data saved in the database.
     * @param {ClotureCaisseCreateManyAndReturnArgs} args - Arguments to create many ClotureCaisses.
     * @example
     * // Create many ClotureCaisses
     * const clotureCaisse = await prisma.clotureCaisse.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClotureCaisses and only return the `id`
     * const clotureCaisseWithIdOnly = await prisma.clotureCaisse.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClotureCaisseCreateManyAndReturnArgs>(args?: SelectSubset<T, ClotureCaisseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClotureCaissePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ClotureCaisse.
     * @param {ClotureCaisseDeleteArgs} args - Arguments to delete one ClotureCaisse.
     * @example
     * // Delete one ClotureCaisse
     * const ClotureCaisse = await prisma.clotureCaisse.delete({
     *   where: {
     *     // ... filter to delete one ClotureCaisse
     *   }
     * })
     * 
     */
    delete<T extends ClotureCaisseDeleteArgs>(args: SelectSubset<T, ClotureCaisseDeleteArgs<ExtArgs>>): Prisma__ClotureCaisseClient<$Result.GetResult<Prisma.$ClotureCaissePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClotureCaisse.
     * @param {ClotureCaisseUpdateArgs} args - Arguments to update one ClotureCaisse.
     * @example
     * // Update one ClotureCaisse
     * const clotureCaisse = await prisma.clotureCaisse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClotureCaisseUpdateArgs>(args: SelectSubset<T, ClotureCaisseUpdateArgs<ExtArgs>>): Prisma__ClotureCaisseClient<$Result.GetResult<Prisma.$ClotureCaissePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClotureCaisses.
     * @param {ClotureCaisseDeleteManyArgs} args - Arguments to filter ClotureCaisses to delete.
     * @example
     * // Delete a few ClotureCaisses
     * const { count } = await prisma.clotureCaisse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClotureCaisseDeleteManyArgs>(args?: SelectSubset<T, ClotureCaisseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClotureCaisses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClotureCaisseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClotureCaisses
     * const clotureCaisse = await prisma.clotureCaisse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClotureCaisseUpdateManyArgs>(args: SelectSubset<T, ClotureCaisseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClotureCaisses and returns the data updated in the database.
     * @param {ClotureCaisseUpdateManyAndReturnArgs} args - Arguments to update many ClotureCaisses.
     * @example
     * // Update many ClotureCaisses
     * const clotureCaisse = await prisma.clotureCaisse.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ClotureCaisses and only return the `id`
     * const clotureCaisseWithIdOnly = await prisma.clotureCaisse.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClotureCaisseUpdateManyAndReturnArgs>(args: SelectSubset<T, ClotureCaisseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClotureCaissePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ClotureCaisse.
     * @param {ClotureCaisseUpsertArgs} args - Arguments to update or create a ClotureCaisse.
     * @example
     * // Update or create a ClotureCaisse
     * const clotureCaisse = await prisma.clotureCaisse.upsert({
     *   create: {
     *     // ... data to create a ClotureCaisse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClotureCaisse we want to update
     *   }
     * })
     */
    upsert<T extends ClotureCaisseUpsertArgs>(args: SelectSubset<T, ClotureCaisseUpsertArgs<ExtArgs>>): Prisma__ClotureCaisseClient<$Result.GetResult<Prisma.$ClotureCaissePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClotureCaisses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClotureCaisseCountArgs} args - Arguments to filter ClotureCaisses to count.
     * @example
     * // Count the number of ClotureCaisses
     * const count = await prisma.clotureCaisse.count({
     *   where: {
     *     // ... the filter for the ClotureCaisses we want to count
     *   }
     * })
    **/
    count<T extends ClotureCaisseCountArgs>(
      args?: Subset<T, ClotureCaisseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClotureCaisseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClotureCaisse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClotureCaisseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClotureCaisseAggregateArgs>(args: Subset<T, ClotureCaisseAggregateArgs>): Prisma.PrismaPromise<GetClotureCaisseAggregateType<T>>

    /**
     * Group by ClotureCaisse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClotureCaisseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClotureCaisseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClotureCaisseGroupByArgs['orderBy'] }
        : { orderBy?: ClotureCaisseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClotureCaisseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClotureCaisseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClotureCaisse model
   */
  readonly fields: ClotureCaisseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClotureCaisse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClotureCaisseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    caisse<T extends CaisseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CaisseDefaultArgs<ExtArgs>>): Prisma__CaisseClient<$Result.GetResult<Prisma.$CaissePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    utilisateurCloture<T extends UtilisateurDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UtilisateurDefaultArgs<ExtArgs>>): Prisma__UtilisateurClient<$Result.GetResult<Prisma.$UtilisateurPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    DetailClotureCaisse<T extends ClotureCaisse$DetailClotureCaisseArgs<ExtArgs> = {}>(args?: Subset<T, ClotureCaisse$DetailClotureCaisseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DetailClotureCaissePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClotureCaisse model
   */
  interface ClotureCaisseFieldRefs {
    readonly id: FieldRef<"ClotureCaisse", 'Int'>
    readonly caisseId: FieldRef<"ClotureCaisse", 'Int'>
    readonly dateCloture: FieldRef<"ClotureCaisse", 'DateTime'>
    readonly utilisateurClotureId: FieldRef<"ClotureCaisse", 'Int'>
    readonly notes: FieldRef<"ClotureCaisse", 'String'>
    readonly createdAt: FieldRef<"ClotureCaisse", 'DateTime'>
    readonly updatedAt: FieldRef<"ClotureCaisse", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ClotureCaisse findUnique
   */
  export type ClotureCaisseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClotureCaisse
     */
    select?: ClotureCaisseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClotureCaisse
     */
    omit?: ClotureCaisseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClotureCaisseInclude<ExtArgs> | null
    /**
     * Filter, which ClotureCaisse to fetch.
     */
    where: ClotureCaisseWhereUniqueInput
  }

  /**
   * ClotureCaisse findUniqueOrThrow
   */
  export type ClotureCaisseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClotureCaisse
     */
    select?: ClotureCaisseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClotureCaisse
     */
    omit?: ClotureCaisseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClotureCaisseInclude<ExtArgs> | null
    /**
     * Filter, which ClotureCaisse to fetch.
     */
    where: ClotureCaisseWhereUniqueInput
  }

  /**
   * ClotureCaisse findFirst
   */
  export type ClotureCaisseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClotureCaisse
     */
    select?: ClotureCaisseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClotureCaisse
     */
    omit?: ClotureCaisseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClotureCaisseInclude<ExtArgs> | null
    /**
     * Filter, which ClotureCaisse to fetch.
     */
    where?: ClotureCaisseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClotureCaisses to fetch.
     */
    orderBy?: ClotureCaisseOrderByWithRelationInput | ClotureCaisseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClotureCaisses.
     */
    cursor?: ClotureCaisseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClotureCaisses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClotureCaisses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClotureCaisses.
     */
    distinct?: ClotureCaisseScalarFieldEnum | ClotureCaisseScalarFieldEnum[]
  }

  /**
   * ClotureCaisse findFirstOrThrow
   */
  export type ClotureCaisseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClotureCaisse
     */
    select?: ClotureCaisseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClotureCaisse
     */
    omit?: ClotureCaisseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClotureCaisseInclude<ExtArgs> | null
    /**
     * Filter, which ClotureCaisse to fetch.
     */
    where?: ClotureCaisseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClotureCaisses to fetch.
     */
    orderBy?: ClotureCaisseOrderByWithRelationInput | ClotureCaisseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClotureCaisses.
     */
    cursor?: ClotureCaisseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClotureCaisses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClotureCaisses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClotureCaisses.
     */
    distinct?: ClotureCaisseScalarFieldEnum | ClotureCaisseScalarFieldEnum[]
  }

  /**
   * ClotureCaisse findMany
   */
  export type ClotureCaisseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClotureCaisse
     */
    select?: ClotureCaisseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClotureCaisse
     */
    omit?: ClotureCaisseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClotureCaisseInclude<ExtArgs> | null
    /**
     * Filter, which ClotureCaisses to fetch.
     */
    where?: ClotureCaisseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClotureCaisses to fetch.
     */
    orderBy?: ClotureCaisseOrderByWithRelationInput | ClotureCaisseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClotureCaisses.
     */
    cursor?: ClotureCaisseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClotureCaisses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClotureCaisses.
     */
    skip?: number
    distinct?: ClotureCaisseScalarFieldEnum | ClotureCaisseScalarFieldEnum[]
  }

  /**
   * ClotureCaisse create
   */
  export type ClotureCaisseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClotureCaisse
     */
    select?: ClotureCaisseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClotureCaisse
     */
    omit?: ClotureCaisseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClotureCaisseInclude<ExtArgs> | null
    /**
     * The data needed to create a ClotureCaisse.
     */
    data: XOR<ClotureCaisseCreateInput, ClotureCaisseUncheckedCreateInput>
  }

  /**
   * ClotureCaisse createMany
   */
  export type ClotureCaisseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClotureCaisses.
     */
    data: ClotureCaisseCreateManyInput | ClotureCaisseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClotureCaisse createManyAndReturn
   */
  export type ClotureCaisseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClotureCaisse
     */
    select?: ClotureCaisseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClotureCaisse
     */
    omit?: ClotureCaisseOmit<ExtArgs> | null
    /**
     * The data used to create many ClotureCaisses.
     */
    data: ClotureCaisseCreateManyInput | ClotureCaisseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClotureCaisseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClotureCaisse update
   */
  export type ClotureCaisseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClotureCaisse
     */
    select?: ClotureCaisseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClotureCaisse
     */
    omit?: ClotureCaisseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClotureCaisseInclude<ExtArgs> | null
    /**
     * The data needed to update a ClotureCaisse.
     */
    data: XOR<ClotureCaisseUpdateInput, ClotureCaisseUncheckedUpdateInput>
    /**
     * Choose, which ClotureCaisse to update.
     */
    where: ClotureCaisseWhereUniqueInput
  }

  /**
   * ClotureCaisse updateMany
   */
  export type ClotureCaisseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClotureCaisses.
     */
    data: XOR<ClotureCaisseUpdateManyMutationInput, ClotureCaisseUncheckedUpdateManyInput>
    /**
     * Filter which ClotureCaisses to update
     */
    where?: ClotureCaisseWhereInput
    /**
     * Limit how many ClotureCaisses to update.
     */
    limit?: number
  }

  /**
   * ClotureCaisse updateManyAndReturn
   */
  export type ClotureCaisseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClotureCaisse
     */
    select?: ClotureCaisseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClotureCaisse
     */
    omit?: ClotureCaisseOmit<ExtArgs> | null
    /**
     * The data used to update ClotureCaisses.
     */
    data: XOR<ClotureCaisseUpdateManyMutationInput, ClotureCaisseUncheckedUpdateManyInput>
    /**
     * Filter which ClotureCaisses to update
     */
    where?: ClotureCaisseWhereInput
    /**
     * Limit how many ClotureCaisses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClotureCaisseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClotureCaisse upsert
   */
  export type ClotureCaisseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClotureCaisse
     */
    select?: ClotureCaisseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClotureCaisse
     */
    omit?: ClotureCaisseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClotureCaisseInclude<ExtArgs> | null
    /**
     * The filter to search for the ClotureCaisse to update in case it exists.
     */
    where: ClotureCaisseWhereUniqueInput
    /**
     * In case the ClotureCaisse found by the `where` argument doesn't exist, create a new ClotureCaisse with this data.
     */
    create: XOR<ClotureCaisseCreateInput, ClotureCaisseUncheckedCreateInput>
    /**
     * In case the ClotureCaisse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClotureCaisseUpdateInput, ClotureCaisseUncheckedUpdateInput>
  }

  /**
   * ClotureCaisse delete
   */
  export type ClotureCaisseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClotureCaisse
     */
    select?: ClotureCaisseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClotureCaisse
     */
    omit?: ClotureCaisseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClotureCaisseInclude<ExtArgs> | null
    /**
     * Filter which ClotureCaisse to delete.
     */
    where: ClotureCaisseWhereUniqueInput
  }

  /**
   * ClotureCaisse deleteMany
   */
  export type ClotureCaisseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClotureCaisses to delete
     */
    where?: ClotureCaisseWhereInput
    /**
     * Limit how many ClotureCaisses to delete.
     */
    limit?: number
  }

  /**
   * ClotureCaisse.DetailClotureCaisse
   */
  export type ClotureCaisse$DetailClotureCaisseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetailClotureCaisse
     */
    select?: DetailClotureCaisseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DetailClotureCaisse
     */
    omit?: DetailClotureCaisseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetailClotureCaisseInclude<ExtArgs> | null
    where?: DetailClotureCaisseWhereInput
    orderBy?: DetailClotureCaisseOrderByWithRelationInput | DetailClotureCaisseOrderByWithRelationInput[]
    cursor?: DetailClotureCaisseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DetailClotureCaisseScalarFieldEnum | DetailClotureCaisseScalarFieldEnum[]
  }

  /**
   * ClotureCaisse without action
   */
  export type ClotureCaisseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClotureCaisse
     */
    select?: ClotureCaisseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClotureCaisse
     */
    omit?: ClotureCaisseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClotureCaisseInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const EntrepriseScalarFieldEnum: {
    id: 'id',
    nom: 'nom',
    encronyme: 'encronyme',
    code_postale: 'code_postale',
    adresse: 'adresse',
    tel: 'tel',
    site: 'site',
    email: 'email',
    description: 'description',
    logo: 'logo'
  };

  export type EntrepriseScalarFieldEnum = (typeof EntrepriseScalarFieldEnum)[keyof typeof EntrepriseScalarFieldEnum]


  export const UtilisateurScalarFieldEnum: {
    id: 'id',
    email: 'email',
    nom: 'nom',
    postnom: 'postnom',
    nom_complet: 'nom_complet',
    sexe: 'sexe',
    role: 'role',
    poste: 'poste',
    picture: 'picture',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UtilisateurScalarFieldEnum = (typeof UtilisateurScalarFieldEnum)[keyof typeof UtilisateurScalarFieldEnum]


  export const AdresseScalarFieldEnum: {
    id: 'id',
    ville: 'ville',
    commune: 'commune',
    adresse: 'adresse',
    utilisateurId: 'utilisateurId',
    fournisseurId: 'fournisseurId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AdresseScalarFieldEnum = (typeof AdresseScalarFieldEnum)[keyof typeof AdresseScalarFieldEnum]


  export const ContactScalarFieldEnum: {
    id: 'id',
    tel: 'tel',
    utilisateurId: 'utilisateurId',
    fournisseurId: 'fournisseurId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContactScalarFieldEnum = (typeof ContactScalarFieldEnum)[keyof typeof ContactScalarFieldEnum]


  export const FournisseurScalarFieldEnum: {
    id: 'id',
    nom: 'nom',
    email: 'email',
    code_postal: 'code_postal',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FournisseurScalarFieldEnum = (typeof FournisseurScalarFieldEnum)[keyof typeof FournisseurScalarFieldEnum]


  export const TeneurScalarFieldEnum: {
    id: 'id',
    valeur: 'valeur',
    utilisateurId: 'utilisateurId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TeneurScalarFieldEnum = (typeof TeneurScalarFieldEnum)[keyof typeof TeneurScalarFieldEnum]


  export const DeviseScalarFieldEnum: {
    id: 'id',
    nom: 'nom',
    code: 'code',
    symbole: 'symbole',
    utilisateurId: 'utilisateurId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DeviseScalarFieldEnum = (typeof DeviseScalarFieldEnum)[keyof typeof DeviseScalarFieldEnum]


  export const ProduitScalarFieldEnum: {
    id: 'id',
    designation: 'designation',
    prix: 'prix',
    qtte: 'qtte',
    description: 'description',
    deviseId: 'deviseId',
    teneurId: 'teneurId',
    utilisateurId: 'utilisateurId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProduitScalarFieldEnum = (typeof ProduitScalarFieldEnum)[keyof typeof ProduitScalarFieldEnum]


  export const PaiementScalarFieldEnum: {
    id: 'id',
    montant: 'montant',
    moyen_paiement: 'moyen_paiement',
    deviseId: 'deviseId',
    caisseId: 'caisseId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaiementScalarFieldEnum = (typeof PaiementScalarFieldEnum)[keyof typeof PaiementScalarFieldEnum]


  export const CaisseScalarFieldEnum: {
    id: 'id',
    nom: 'nom',
    description: 'description',
    soldeInitial: 'soldeInitial',
    soldeActuel: 'soldeActuel',
    deviseId: 'deviseId',
    creeParId: 'creeParId',
    statut: 'statut',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CaisseScalarFieldEnum = (typeof CaisseScalarFieldEnum)[keyof typeof CaisseScalarFieldEnum]


  export const VenteScalarFieldEnum: {
    id: 'id',
    statut: 'statut',
    total_ttc: 'total_ttc',
    total_ht: 'total_ht',
    type_acheteur: 'type_acheteur',
    clientId: 'clientId',
    enregistrerParId: 'enregistrerParId',
    fournisseurId: 'fournisseurId',
    agentId: 'agentId',
    paiementId: 'paiementId',
    panierId: 'panierId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VenteScalarFieldEnum = (typeof VenteScalarFieldEnum)[keyof typeof VenteScalarFieldEnum]


  export const PanierScalarFieldEnum: {
    id: 'id',
    utilisateurId: 'utilisateurId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PanierScalarFieldEnum = (typeof PanierScalarFieldEnum)[keyof typeof PanierScalarFieldEnum]


  export const DetailPanierScalarFieldEnum: {
    id: 'id',
    produitId: 'produitId',
    qtte: 'qtte',
    prixUnitaire: 'prixUnitaire',
    prixTotal: 'prixTotal',
    panierId: 'panierId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DetailPanierScalarFieldEnum = (typeof DetailPanierScalarFieldEnum)[keyof typeof DetailPanierScalarFieldEnum]


  export const AchatScalarFieldEnum: {
    id: 'id',
    statut: 'statut',
    panierId: 'panierId',
    fournisseurId: 'fournisseurId',
    enregistrerParId: 'enregistrerParId',
    paiementId: 'paiementId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AchatScalarFieldEnum = (typeof AchatScalarFieldEnum)[keyof typeof AchatScalarFieldEnum]


  export const ReservationScalarFieldEnum: {
    id: 'id',
    dateLivraisonSouhaitee: 'dateLivraisonSouhaitee',
    adresseLivraison: 'adresseLivraison',
    statut: 'statut',
    notes: 'notes',
    type_client: 'type_client',
    clientId: 'clientId',
    panierId: 'panierId',
    nom: 'nom',
    tel: 'tel',
    adresseId: 'adresseId',
    contactId: 'contactId',
    enregistrerParId: 'enregistrerParId',
    fournisseurId: 'fournisseurId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReservationScalarFieldEnum = (typeof ReservationScalarFieldEnum)[keyof typeof ReservationScalarFieldEnum]


  export const CommandeScalarFieldEnum: {
    id: 'id',
    panierId: 'panierId',
    clientId: 'clientId',
    nom: 'nom',
    tel: 'tel',
    type_client: 'type_client',
    paiementId: 'paiementId',
    adresseId: 'adresseId',
    contactId: 'contactId',
    fournisseurId: 'fournisseurId',
    notes: 'notes',
    dateLivraisonEffective: 'dateLivraisonEffective',
    adresseLivraison: 'adresseLivraison',
    enregistrerParId: 'enregistrerParId',
    statut: 'statut',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CommandeScalarFieldEnum = (typeof CommandeScalarFieldEnum)[keyof typeof CommandeScalarFieldEnum]


  export const MouvementCaisseScalarFieldEnum: {
    id: 'id',
    caisseId: 'caisseId',
    type_mouvement: 'type_mouvement',
    categorie: 'categorie',
    montant: 'montant',
    description: 'description',
    enregistrerParId: 'enregistrerParId',
    referenceExterne: 'referenceExterne',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MouvementCaisseScalarFieldEnum = (typeof MouvementCaisseScalarFieldEnum)[keyof typeof MouvementCaisseScalarFieldEnum]


  export const DetailClotureCaisseScalarFieldEnum: {
    id: 'id',
    produitId: 'produitId',
    teneurId: 'teneurId',
    qtteRestante: 'qtteRestante',
    clotureCaisseId: 'clotureCaisseId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DetailClotureCaisseScalarFieldEnum = (typeof DetailClotureCaisseScalarFieldEnum)[keyof typeof DetailClotureCaisseScalarFieldEnum]


  export const ClotureCaisseScalarFieldEnum: {
    id: 'id',
    caisseId: 'caisseId',
    dateCloture: 'dateCloture',
    utilisateurClotureId: 'utilisateurClotureId',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClotureCaisseScalarFieldEnum = (typeof ClotureCaisseScalarFieldEnum)[keyof typeof ClotureCaisseScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Sexe'
   */
  export type EnumSexeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Sexe'>
    


  /**
   * Reference to a field of type 'Sexe[]'
   */
  export type ListEnumSexeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Sexe[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'Poste'
   */
  export type EnumPosteFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Poste'>
    


  /**
   * Reference to a field of type 'Poste[]'
   */
  export type ListEnumPosteFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Poste[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'MoyenPaiment'
   */
  export type EnumMoyenPaimentFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MoyenPaiment'>
    


  /**
   * Reference to a field of type 'MoyenPaiment[]'
   */
  export type ListEnumMoyenPaimentFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MoyenPaiment[]'>
    


  /**
   * Reference to a field of type 'StatutCaisse'
   */
  export type EnumStatutCaisseFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatutCaisse'>
    


  /**
   * Reference to a field of type 'StatutCaisse[]'
   */
  export type ListEnumStatutCaisseFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatutCaisse[]'>
    


  /**
   * Reference to a field of type 'StatutVente'
   */
  export type EnumStatutVenteFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatutVente'>
    


  /**
   * Reference to a field of type 'StatutVente[]'
   */
  export type ListEnumStatutVenteFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatutVente[]'>
    


  /**
   * Reference to a field of type 'TypeClient'
   */
  export type EnumTypeClientFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TypeClient'>
    


  /**
   * Reference to a field of type 'TypeClient[]'
   */
  export type ListEnumTypeClientFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TypeClient[]'>
    


  /**
   * Reference to a field of type 'StatutAchat'
   */
  export type EnumStatutAchatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatutAchat'>
    


  /**
   * Reference to a field of type 'StatutAchat[]'
   */
  export type ListEnumStatutAchatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatutAchat[]'>
    


  /**
   * Reference to a field of type 'StatutReservation'
   */
  export type EnumStatutReservationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatutReservation'>
    


  /**
   * Reference to a field of type 'StatutReservation[]'
   */
  export type ListEnumStatutReservationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatutReservation[]'>
    


  /**
   * Reference to a field of type 'StatutCommande'
   */
  export type EnumStatutCommandeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatutCommande'>
    


  /**
   * Reference to a field of type 'StatutCommande[]'
   */
  export type ListEnumStatutCommandeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatutCommande[]'>
    


  /**
   * Reference to a field of type 'TypeMouvementCaisse'
   */
  export type EnumTypeMouvementCaisseFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TypeMouvementCaisse'>
    


  /**
   * Reference to a field of type 'TypeMouvementCaisse[]'
   */
  export type ListEnumTypeMouvementCaisseFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TypeMouvementCaisse[]'>
    


  /**
   * Reference to a field of type 'CategorieMouvement'
   */
  export type EnumCategorieMouvementFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CategorieMouvement'>
    


  /**
   * Reference to a field of type 'CategorieMouvement[]'
   */
  export type ListEnumCategorieMouvementFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CategorieMouvement[]'>
    
  /**
   * Deep Input Types
   */


  export type EntrepriseWhereInput = {
    AND?: EntrepriseWhereInput | EntrepriseWhereInput[]
    OR?: EntrepriseWhereInput[]
    NOT?: EntrepriseWhereInput | EntrepriseWhereInput[]
    id?: IntFilter<"Entreprise"> | number
    nom?: StringFilter<"Entreprise"> | string
    encronyme?: StringFilter<"Entreprise"> | string
    code_postale?: StringFilter<"Entreprise"> | string
    adresse?: StringFilter<"Entreprise"> | string
    tel?: StringFilter<"Entreprise"> | string
    site?: StringNullableFilter<"Entreprise"> | string | null
    email?: StringFilter<"Entreprise"> | string
    description?: StringNullableFilter<"Entreprise"> | string | null
    logo?: StringNullableFilter<"Entreprise"> | string | null
  }

  export type EntrepriseOrderByWithRelationInput = {
    id?: SortOrder
    nom?: SortOrder
    encronyme?: SortOrder
    code_postale?: SortOrder
    adresse?: SortOrder
    tel?: SortOrder
    site?: SortOrderInput | SortOrder
    email?: SortOrder
    description?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
  }

  export type EntrepriseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    nom?: string
    encronyme?: string
    code_postale?: string
    tel?: string
    email?: string
    AND?: EntrepriseWhereInput | EntrepriseWhereInput[]
    OR?: EntrepriseWhereInput[]
    NOT?: EntrepriseWhereInput | EntrepriseWhereInput[]
    adresse?: StringFilter<"Entreprise"> | string
    site?: StringNullableFilter<"Entreprise"> | string | null
    description?: StringNullableFilter<"Entreprise"> | string | null
    logo?: StringNullableFilter<"Entreprise"> | string | null
  }, "id" | "nom" | "encronyme" | "code_postale" | "tel" | "email">

  export type EntrepriseOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrder
    encronyme?: SortOrder
    code_postale?: SortOrder
    adresse?: SortOrder
    tel?: SortOrder
    site?: SortOrderInput | SortOrder
    email?: SortOrder
    description?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    _count?: EntrepriseCountOrderByAggregateInput
    _avg?: EntrepriseAvgOrderByAggregateInput
    _max?: EntrepriseMaxOrderByAggregateInput
    _min?: EntrepriseMinOrderByAggregateInput
    _sum?: EntrepriseSumOrderByAggregateInput
  }

  export type EntrepriseScalarWhereWithAggregatesInput = {
    AND?: EntrepriseScalarWhereWithAggregatesInput | EntrepriseScalarWhereWithAggregatesInput[]
    OR?: EntrepriseScalarWhereWithAggregatesInput[]
    NOT?: EntrepriseScalarWhereWithAggregatesInput | EntrepriseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Entreprise"> | number
    nom?: StringWithAggregatesFilter<"Entreprise"> | string
    encronyme?: StringWithAggregatesFilter<"Entreprise"> | string
    code_postale?: StringWithAggregatesFilter<"Entreprise"> | string
    adresse?: StringWithAggregatesFilter<"Entreprise"> | string
    tel?: StringWithAggregatesFilter<"Entreprise"> | string
    site?: StringNullableWithAggregatesFilter<"Entreprise"> | string | null
    email?: StringWithAggregatesFilter<"Entreprise"> | string
    description?: StringNullableWithAggregatesFilter<"Entreprise"> | string | null
    logo?: StringNullableWithAggregatesFilter<"Entreprise"> | string | null
  }

  export type UtilisateurWhereInput = {
    AND?: UtilisateurWhereInput | UtilisateurWhereInput[]
    OR?: UtilisateurWhereInput[]
    NOT?: UtilisateurWhereInput | UtilisateurWhereInput[]
    id?: IntFilter<"Utilisateur"> | number
    email?: StringFilter<"Utilisateur"> | string
    nom?: StringFilter<"Utilisateur"> | string
    postnom?: StringFilter<"Utilisateur"> | string
    nom_complet?: StringNullableFilter<"Utilisateur"> | string | null
    sexe?: EnumSexeNullableFilter<"Utilisateur"> | $Enums.Sexe | null
    role?: EnumRoleFilter<"Utilisateur"> | $Enums.Role
    poste?: EnumPosteNullableFilter<"Utilisateur"> | $Enums.Poste | null
    picture?: StringNullableFilter<"Utilisateur"> | string | null
    createdAt?: DateTimeFilter<"Utilisateur"> | Date | string
    updatedAt?: DateTimeFilter<"Utilisateur"> | Date | string
    Adresse?: AdresseListRelationFilter
    Contact?: ContactListRelationFilter
    Produit?: ProduitListRelationFilter
    Vente?: VenteListRelationFilter
    Achat?: AchatListRelationFilter
    Teneur?: TeneurListRelationFilter
    Devise?: DeviseListRelationFilter
    Panier?: PanierListRelationFilter
    Reservation?: ReservationListRelationFilter
    Commande?: CommandeListRelationFilter
    Caisse?: CaisseListRelationFilter
    MouvementCaisse?: MouvementCaisseListRelationFilter
    ClotureCaisse?: ClotureCaisseListRelationFilter
  }

  export type UtilisateurOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    nom?: SortOrder
    postnom?: SortOrder
    nom_complet?: SortOrderInput | SortOrder
    sexe?: SortOrderInput | SortOrder
    role?: SortOrder
    poste?: SortOrderInput | SortOrder
    picture?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Adresse?: AdresseOrderByRelationAggregateInput
    Contact?: ContactOrderByRelationAggregateInput
    Produit?: ProduitOrderByRelationAggregateInput
    Vente?: VenteOrderByRelationAggregateInput
    Achat?: AchatOrderByRelationAggregateInput
    Teneur?: TeneurOrderByRelationAggregateInput
    Devise?: DeviseOrderByRelationAggregateInput
    Panier?: PanierOrderByRelationAggregateInput
    Reservation?: ReservationOrderByRelationAggregateInput
    Commande?: CommandeOrderByRelationAggregateInput
    Caisse?: CaisseOrderByRelationAggregateInput
    MouvementCaisse?: MouvementCaisseOrderByRelationAggregateInput
    ClotureCaisse?: ClotureCaisseOrderByRelationAggregateInput
  }

  export type UtilisateurWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UtilisateurWhereInput | UtilisateurWhereInput[]
    OR?: UtilisateurWhereInput[]
    NOT?: UtilisateurWhereInput | UtilisateurWhereInput[]
    nom?: StringFilter<"Utilisateur"> | string
    postnom?: StringFilter<"Utilisateur"> | string
    nom_complet?: StringNullableFilter<"Utilisateur"> | string | null
    sexe?: EnumSexeNullableFilter<"Utilisateur"> | $Enums.Sexe | null
    role?: EnumRoleFilter<"Utilisateur"> | $Enums.Role
    poste?: EnumPosteNullableFilter<"Utilisateur"> | $Enums.Poste | null
    picture?: StringNullableFilter<"Utilisateur"> | string | null
    createdAt?: DateTimeFilter<"Utilisateur"> | Date | string
    updatedAt?: DateTimeFilter<"Utilisateur"> | Date | string
    Adresse?: AdresseListRelationFilter
    Contact?: ContactListRelationFilter
    Produit?: ProduitListRelationFilter
    Vente?: VenteListRelationFilter
    Achat?: AchatListRelationFilter
    Teneur?: TeneurListRelationFilter
    Devise?: DeviseListRelationFilter
    Panier?: PanierListRelationFilter
    Reservation?: ReservationListRelationFilter
    Commande?: CommandeListRelationFilter
    Caisse?: CaisseListRelationFilter
    MouvementCaisse?: MouvementCaisseListRelationFilter
    ClotureCaisse?: ClotureCaisseListRelationFilter
  }, "id" | "email">

  export type UtilisateurOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    nom?: SortOrder
    postnom?: SortOrder
    nom_complet?: SortOrderInput | SortOrder
    sexe?: SortOrderInput | SortOrder
    role?: SortOrder
    poste?: SortOrderInput | SortOrder
    picture?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UtilisateurCountOrderByAggregateInput
    _avg?: UtilisateurAvgOrderByAggregateInput
    _max?: UtilisateurMaxOrderByAggregateInput
    _min?: UtilisateurMinOrderByAggregateInput
    _sum?: UtilisateurSumOrderByAggregateInput
  }

  export type UtilisateurScalarWhereWithAggregatesInput = {
    AND?: UtilisateurScalarWhereWithAggregatesInput | UtilisateurScalarWhereWithAggregatesInput[]
    OR?: UtilisateurScalarWhereWithAggregatesInput[]
    NOT?: UtilisateurScalarWhereWithAggregatesInput | UtilisateurScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Utilisateur"> | number
    email?: StringWithAggregatesFilter<"Utilisateur"> | string
    nom?: StringWithAggregatesFilter<"Utilisateur"> | string
    postnom?: StringWithAggregatesFilter<"Utilisateur"> | string
    nom_complet?: StringNullableWithAggregatesFilter<"Utilisateur"> | string | null
    sexe?: EnumSexeNullableWithAggregatesFilter<"Utilisateur"> | $Enums.Sexe | null
    role?: EnumRoleWithAggregatesFilter<"Utilisateur"> | $Enums.Role
    poste?: EnumPosteNullableWithAggregatesFilter<"Utilisateur"> | $Enums.Poste | null
    picture?: StringNullableWithAggregatesFilter<"Utilisateur"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Utilisateur"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Utilisateur"> | Date | string
  }

  export type AdresseWhereInput = {
    AND?: AdresseWhereInput | AdresseWhereInput[]
    OR?: AdresseWhereInput[]
    NOT?: AdresseWhereInput | AdresseWhereInput[]
    id?: IntFilter<"Adresse"> | number
    ville?: StringFilter<"Adresse"> | string
    commune?: StringFilter<"Adresse"> | string
    adresse?: StringFilter<"Adresse"> | string
    utilisateurId?: IntNullableFilter<"Adresse"> | number | null
    fournisseurId?: IntNullableFilter<"Adresse"> | number | null
    createdAt?: DateTimeFilter<"Adresse"> | Date | string
    updatedAt?: DateTimeFilter<"Adresse"> | Date | string
    utilisateur?: XOR<UtilisateurNullableScalarRelationFilter, UtilisateurWhereInput> | null
    fournisseur?: XOR<FournisseurNullableScalarRelationFilter, FournisseurWhereInput> | null
    Reservation?: ReservationListRelationFilter
    Commande?: CommandeListRelationFilter
  }

  export type AdresseOrderByWithRelationInput = {
    id?: SortOrder
    ville?: SortOrder
    commune?: SortOrder
    adresse?: SortOrder
    utilisateurId?: SortOrderInput | SortOrder
    fournisseurId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    utilisateur?: UtilisateurOrderByWithRelationInput
    fournisseur?: FournisseurOrderByWithRelationInput
    Reservation?: ReservationOrderByRelationAggregateInput
    Commande?: CommandeOrderByRelationAggregateInput
  }

  export type AdresseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AdresseWhereInput | AdresseWhereInput[]
    OR?: AdresseWhereInput[]
    NOT?: AdresseWhereInput | AdresseWhereInput[]
    ville?: StringFilter<"Adresse"> | string
    commune?: StringFilter<"Adresse"> | string
    adresse?: StringFilter<"Adresse"> | string
    utilisateurId?: IntNullableFilter<"Adresse"> | number | null
    fournisseurId?: IntNullableFilter<"Adresse"> | number | null
    createdAt?: DateTimeFilter<"Adresse"> | Date | string
    updatedAt?: DateTimeFilter<"Adresse"> | Date | string
    utilisateur?: XOR<UtilisateurNullableScalarRelationFilter, UtilisateurWhereInput> | null
    fournisseur?: XOR<FournisseurNullableScalarRelationFilter, FournisseurWhereInput> | null
    Reservation?: ReservationListRelationFilter
    Commande?: CommandeListRelationFilter
  }, "id">

  export type AdresseOrderByWithAggregationInput = {
    id?: SortOrder
    ville?: SortOrder
    commune?: SortOrder
    adresse?: SortOrder
    utilisateurId?: SortOrderInput | SortOrder
    fournisseurId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AdresseCountOrderByAggregateInput
    _avg?: AdresseAvgOrderByAggregateInput
    _max?: AdresseMaxOrderByAggregateInput
    _min?: AdresseMinOrderByAggregateInput
    _sum?: AdresseSumOrderByAggregateInput
  }

  export type AdresseScalarWhereWithAggregatesInput = {
    AND?: AdresseScalarWhereWithAggregatesInput | AdresseScalarWhereWithAggregatesInput[]
    OR?: AdresseScalarWhereWithAggregatesInput[]
    NOT?: AdresseScalarWhereWithAggregatesInput | AdresseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Adresse"> | number
    ville?: StringWithAggregatesFilter<"Adresse"> | string
    commune?: StringWithAggregatesFilter<"Adresse"> | string
    adresse?: StringWithAggregatesFilter<"Adresse"> | string
    utilisateurId?: IntNullableWithAggregatesFilter<"Adresse"> | number | null
    fournisseurId?: IntNullableWithAggregatesFilter<"Adresse"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Adresse"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Adresse"> | Date | string
  }

  export type ContactWhereInput = {
    AND?: ContactWhereInput | ContactWhereInput[]
    OR?: ContactWhereInput[]
    NOT?: ContactWhereInput | ContactWhereInput[]
    id?: IntFilter<"Contact"> | number
    tel?: StringFilter<"Contact"> | string
    utilisateurId?: IntNullableFilter<"Contact"> | number | null
    fournisseurId?: IntNullableFilter<"Contact"> | number | null
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    updatedAt?: DateTimeFilter<"Contact"> | Date | string
    utilisateur?: XOR<UtilisateurNullableScalarRelationFilter, UtilisateurWhereInput> | null
    fournisseur?: XOR<FournisseurNullableScalarRelationFilter, FournisseurWhereInput> | null
    Reservation?: ReservationListRelationFilter
    Commande?: CommandeListRelationFilter
  }

  export type ContactOrderByWithRelationInput = {
    id?: SortOrder
    tel?: SortOrder
    utilisateurId?: SortOrderInput | SortOrder
    fournisseurId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    utilisateur?: UtilisateurOrderByWithRelationInput
    fournisseur?: FournisseurOrderByWithRelationInput
    Reservation?: ReservationOrderByRelationAggregateInput
    Commande?: CommandeOrderByRelationAggregateInput
  }

  export type ContactWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    tel?: string
    AND?: ContactWhereInput | ContactWhereInput[]
    OR?: ContactWhereInput[]
    NOT?: ContactWhereInput | ContactWhereInput[]
    utilisateurId?: IntNullableFilter<"Contact"> | number | null
    fournisseurId?: IntNullableFilter<"Contact"> | number | null
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    updatedAt?: DateTimeFilter<"Contact"> | Date | string
    utilisateur?: XOR<UtilisateurNullableScalarRelationFilter, UtilisateurWhereInput> | null
    fournisseur?: XOR<FournisseurNullableScalarRelationFilter, FournisseurWhereInput> | null
    Reservation?: ReservationListRelationFilter
    Commande?: CommandeListRelationFilter
  }, "id" | "tel">

  export type ContactOrderByWithAggregationInput = {
    id?: SortOrder
    tel?: SortOrder
    utilisateurId?: SortOrderInput | SortOrder
    fournisseurId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContactCountOrderByAggregateInput
    _avg?: ContactAvgOrderByAggregateInput
    _max?: ContactMaxOrderByAggregateInput
    _min?: ContactMinOrderByAggregateInput
    _sum?: ContactSumOrderByAggregateInput
  }

  export type ContactScalarWhereWithAggregatesInput = {
    AND?: ContactScalarWhereWithAggregatesInput | ContactScalarWhereWithAggregatesInput[]
    OR?: ContactScalarWhereWithAggregatesInput[]
    NOT?: ContactScalarWhereWithAggregatesInput | ContactScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Contact"> | number
    tel?: StringWithAggregatesFilter<"Contact"> | string
    utilisateurId?: IntNullableWithAggregatesFilter<"Contact"> | number | null
    fournisseurId?: IntNullableWithAggregatesFilter<"Contact"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Contact"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Contact"> | Date | string
  }

  export type FournisseurWhereInput = {
    AND?: FournisseurWhereInput | FournisseurWhereInput[]
    OR?: FournisseurWhereInput[]
    NOT?: FournisseurWhereInput | FournisseurWhereInput[]
    id?: IntFilter<"Fournisseur"> | number
    nom?: StringFilter<"Fournisseur"> | string
    email?: StringFilter<"Fournisseur"> | string
    code_postal?: StringNullableFilter<"Fournisseur"> | string | null
    createdAt?: DateTimeFilter<"Fournisseur"> | Date | string
    updatedAt?: DateTimeFilter<"Fournisseur"> | Date | string
    Vente?: VenteListRelationFilter
    Achat?: AchatListRelationFilter
    Adresse?: AdresseListRelationFilter
    Contact?: ContactListRelationFilter
    Reservation?: ReservationListRelationFilter
    Commande?: CommandeListRelationFilter
  }

  export type FournisseurOrderByWithRelationInput = {
    id?: SortOrder
    nom?: SortOrder
    email?: SortOrder
    code_postal?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Vente?: VenteOrderByRelationAggregateInput
    Achat?: AchatOrderByRelationAggregateInput
    Adresse?: AdresseOrderByRelationAggregateInput
    Contact?: ContactOrderByRelationAggregateInput
    Reservation?: ReservationOrderByRelationAggregateInput
    Commande?: CommandeOrderByRelationAggregateInput
  }

  export type FournisseurWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: FournisseurWhereInput | FournisseurWhereInput[]
    OR?: FournisseurWhereInput[]
    NOT?: FournisseurWhereInput | FournisseurWhereInput[]
    nom?: StringFilter<"Fournisseur"> | string
    code_postal?: StringNullableFilter<"Fournisseur"> | string | null
    createdAt?: DateTimeFilter<"Fournisseur"> | Date | string
    updatedAt?: DateTimeFilter<"Fournisseur"> | Date | string
    Vente?: VenteListRelationFilter
    Achat?: AchatListRelationFilter
    Adresse?: AdresseListRelationFilter
    Contact?: ContactListRelationFilter
    Reservation?: ReservationListRelationFilter
    Commande?: CommandeListRelationFilter
  }, "id" | "email">

  export type FournisseurOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrder
    email?: SortOrder
    code_postal?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FournisseurCountOrderByAggregateInput
    _avg?: FournisseurAvgOrderByAggregateInput
    _max?: FournisseurMaxOrderByAggregateInput
    _min?: FournisseurMinOrderByAggregateInput
    _sum?: FournisseurSumOrderByAggregateInput
  }

  export type FournisseurScalarWhereWithAggregatesInput = {
    AND?: FournisseurScalarWhereWithAggregatesInput | FournisseurScalarWhereWithAggregatesInput[]
    OR?: FournisseurScalarWhereWithAggregatesInput[]
    NOT?: FournisseurScalarWhereWithAggregatesInput | FournisseurScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Fournisseur"> | number
    nom?: StringWithAggregatesFilter<"Fournisseur"> | string
    email?: StringWithAggregatesFilter<"Fournisseur"> | string
    code_postal?: StringNullableWithAggregatesFilter<"Fournisseur"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Fournisseur"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Fournisseur"> | Date | string
  }

  export type TeneurWhereInput = {
    AND?: TeneurWhereInput | TeneurWhereInput[]
    OR?: TeneurWhereInput[]
    NOT?: TeneurWhereInput | TeneurWhereInput[]
    id?: IntFilter<"Teneur"> | number
    valeur?: FloatFilter<"Teneur"> | number
    utilisateurId?: IntFilter<"Teneur"> | number
    createdAt?: DateTimeFilter<"Teneur"> | Date | string
    updatedAt?: DateTimeFilter<"Teneur"> | Date | string
    utilisateur?: XOR<UtilisateurScalarRelationFilter, UtilisateurWhereInput>
    Produit?: ProduitListRelationFilter
    DetailClotureCaisse?: DetailClotureCaisseListRelationFilter
  }

  export type TeneurOrderByWithRelationInput = {
    id?: SortOrder
    valeur?: SortOrder
    utilisateurId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    utilisateur?: UtilisateurOrderByWithRelationInput
    Produit?: ProduitOrderByRelationAggregateInput
    DetailClotureCaisse?: DetailClotureCaisseOrderByRelationAggregateInput
  }

  export type TeneurWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    valeur?: number
    AND?: TeneurWhereInput | TeneurWhereInput[]
    OR?: TeneurWhereInput[]
    NOT?: TeneurWhereInput | TeneurWhereInput[]
    utilisateurId?: IntFilter<"Teneur"> | number
    createdAt?: DateTimeFilter<"Teneur"> | Date | string
    updatedAt?: DateTimeFilter<"Teneur"> | Date | string
    utilisateur?: XOR<UtilisateurScalarRelationFilter, UtilisateurWhereInput>
    Produit?: ProduitListRelationFilter
    DetailClotureCaisse?: DetailClotureCaisseListRelationFilter
  }, "id" | "valeur">

  export type TeneurOrderByWithAggregationInput = {
    id?: SortOrder
    valeur?: SortOrder
    utilisateurId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TeneurCountOrderByAggregateInput
    _avg?: TeneurAvgOrderByAggregateInput
    _max?: TeneurMaxOrderByAggregateInput
    _min?: TeneurMinOrderByAggregateInput
    _sum?: TeneurSumOrderByAggregateInput
  }

  export type TeneurScalarWhereWithAggregatesInput = {
    AND?: TeneurScalarWhereWithAggregatesInput | TeneurScalarWhereWithAggregatesInput[]
    OR?: TeneurScalarWhereWithAggregatesInput[]
    NOT?: TeneurScalarWhereWithAggregatesInput | TeneurScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Teneur"> | number
    valeur?: FloatWithAggregatesFilter<"Teneur"> | number
    utilisateurId?: IntWithAggregatesFilter<"Teneur"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Teneur"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Teneur"> | Date | string
  }

  export type DeviseWhereInput = {
    AND?: DeviseWhereInput | DeviseWhereInput[]
    OR?: DeviseWhereInput[]
    NOT?: DeviseWhereInput | DeviseWhereInput[]
    id?: IntFilter<"Devise"> | number
    nom?: StringFilter<"Devise"> | string
    code?: StringFilter<"Devise"> | string
    symbole?: StringFilter<"Devise"> | string
    utilisateurId?: IntFilter<"Devise"> | number
    createdAt?: DateTimeFilter<"Devise"> | Date | string
    updatedAt?: DateTimeFilter<"Devise"> | Date | string
    utilisateur?: XOR<UtilisateurScalarRelationFilter, UtilisateurWhereInput>
    Produit?: ProduitListRelationFilter
    Paiement?: PaiementListRelationFilter
    Caisse?: CaisseListRelationFilter
  }

  export type DeviseOrderByWithRelationInput = {
    id?: SortOrder
    nom?: SortOrder
    code?: SortOrder
    symbole?: SortOrder
    utilisateurId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    utilisateur?: UtilisateurOrderByWithRelationInput
    Produit?: ProduitOrderByRelationAggregateInput
    Paiement?: PaiementOrderByRelationAggregateInput
    Caisse?: CaisseOrderByRelationAggregateInput
  }

  export type DeviseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    nom?: string
    code?: string
    AND?: DeviseWhereInput | DeviseWhereInput[]
    OR?: DeviseWhereInput[]
    NOT?: DeviseWhereInput | DeviseWhereInput[]
    symbole?: StringFilter<"Devise"> | string
    utilisateurId?: IntFilter<"Devise"> | number
    createdAt?: DateTimeFilter<"Devise"> | Date | string
    updatedAt?: DateTimeFilter<"Devise"> | Date | string
    utilisateur?: XOR<UtilisateurScalarRelationFilter, UtilisateurWhereInput>
    Produit?: ProduitListRelationFilter
    Paiement?: PaiementListRelationFilter
    Caisse?: CaisseListRelationFilter
  }, "id" | "nom" | "code">

  export type DeviseOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrder
    code?: SortOrder
    symbole?: SortOrder
    utilisateurId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DeviseCountOrderByAggregateInput
    _avg?: DeviseAvgOrderByAggregateInput
    _max?: DeviseMaxOrderByAggregateInput
    _min?: DeviseMinOrderByAggregateInput
    _sum?: DeviseSumOrderByAggregateInput
  }

  export type DeviseScalarWhereWithAggregatesInput = {
    AND?: DeviseScalarWhereWithAggregatesInput | DeviseScalarWhereWithAggregatesInput[]
    OR?: DeviseScalarWhereWithAggregatesInput[]
    NOT?: DeviseScalarWhereWithAggregatesInput | DeviseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Devise"> | number
    nom?: StringWithAggregatesFilter<"Devise"> | string
    code?: StringWithAggregatesFilter<"Devise"> | string
    symbole?: StringWithAggregatesFilter<"Devise"> | string
    utilisateurId?: IntWithAggregatesFilter<"Devise"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Devise"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Devise"> | Date | string
  }

  export type ProduitWhereInput = {
    AND?: ProduitWhereInput | ProduitWhereInput[]
    OR?: ProduitWhereInput[]
    NOT?: ProduitWhereInput | ProduitWhereInput[]
    id?: IntFilter<"Produit"> | number
    designation?: StringFilter<"Produit"> | string
    prix?: FloatFilter<"Produit"> | number
    qtte?: IntFilter<"Produit"> | number
    description?: StringFilter<"Produit"> | string
    deviseId?: IntFilter<"Produit"> | number
    teneurId?: IntFilter<"Produit"> | number
    utilisateurId?: IntFilter<"Produit"> | number
    createdAt?: DateTimeFilter<"Produit"> | Date | string
    updatedAt?: DateTimeFilter<"Produit"> | Date | string
    devise?: XOR<DeviseScalarRelationFilter, DeviseWhereInput>
    teneur?: XOR<TeneurScalarRelationFilter, TeneurWhereInput>
    utilisateur?: XOR<UtilisateurScalarRelationFilter, UtilisateurWhereInput>
    DetailPanier?: DetailPanierListRelationFilter
    DetailClotureCaisse?: DetailClotureCaisseListRelationFilter
  }

  export type ProduitOrderByWithRelationInput = {
    id?: SortOrder
    designation?: SortOrder
    prix?: SortOrder
    qtte?: SortOrder
    description?: SortOrder
    deviseId?: SortOrder
    teneurId?: SortOrder
    utilisateurId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    devise?: DeviseOrderByWithRelationInput
    teneur?: TeneurOrderByWithRelationInput
    utilisateur?: UtilisateurOrderByWithRelationInput
    DetailPanier?: DetailPanierOrderByRelationAggregateInput
    DetailClotureCaisse?: DetailClotureCaisseOrderByRelationAggregateInput
  }

  export type ProduitWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProduitWhereInput | ProduitWhereInput[]
    OR?: ProduitWhereInput[]
    NOT?: ProduitWhereInput | ProduitWhereInput[]
    designation?: StringFilter<"Produit"> | string
    prix?: FloatFilter<"Produit"> | number
    qtte?: IntFilter<"Produit"> | number
    description?: StringFilter<"Produit"> | string
    deviseId?: IntFilter<"Produit"> | number
    teneurId?: IntFilter<"Produit"> | number
    utilisateurId?: IntFilter<"Produit"> | number
    createdAt?: DateTimeFilter<"Produit"> | Date | string
    updatedAt?: DateTimeFilter<"Produit"> | Date | string
    devise?: XOR<DeviseScalarRelationFilter, DeviseWhereInput>
    teneur?: XOR<TeneurScalarRelationFilter, TeneurWhereInput>
    utilisateur?: XOR<UtilisateurScalarRelationFilter, UtilisateurWhereInput>
    DetailPanier?: DetailPanierListRelationFilter
    DetailClotureCaisse?: DetailClotureCaisseListRelationFilter
  }, "id">

  export type ProduitOrderByWithAggregationInput = {
    id?: SortOrder
    designation?: SortOrder
    prix?: SortOrder
    qtte?: SortOrder
    description?: SortOrder
    deviseId?: SortOrder
    teneurId?: SortOrder
    utilisateurId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProduitCountOrderByAggregateInput
    _avg?: ProduitAvgOrderByAggregateInput
    _max?: ProduitMaxOrderByAggregateInput
    _min?: ProduitMinOrderByAggregateInput
    _sum?: ProduitSumOrderByAggregateInput
  }

  export type ProduitScalarWhereWithAggregatesInput = {
    AND?: ProduitScalarWhereWithAggregatesInput | ProduitScalarWhereWithAggregatesInput[]
    OR?: ProduitScalarWhereWithAggregatesInput[]
    NOT?: ProduitScalarWhereWithAggregatesInput | ProduitScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Produit"> | number
    designation?: StringWithAggregatesFilter<"Produit"> | string
    prix?: FloatWithAggregatesFilter<"Produit"> | number
    qtte?: IntWithAggregatesFilter<"Produit"> | number
    description?: StringWithAggregatesFilter<"Produit"> | string
    deviseId?: IntWithAggregatesFilter<"Produit"> | number
    teneurId?: IntWithAggregatesFilter<"Produit"> | number
    utilisateurId?: IntWithAggregatesFilter<"Produit"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Produit"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Produit"> | Date | string
  }

  export type PaiementWhereInput = {
    AND?: PaiementWhereInput | PaiementWhereInput[]
    OR?: PaiementWhereInput[]
    NOT?: PaiementWhereInput | PaiementWhereInput[]
    id?: IntFilter<"Paiement"> | number
    montant?: FloatFilter<"Paiement"> | number
    moyen_paiement?: EnumMoyenPaimentFilter<"Paiement"> | $Enums.MoyenPaiment
    deviseId?: IntFilter<"Paiement"> | number
    caisseId?: IntFilter<"Paiement"> | number
    createdAt?: DateTimeFilter<"Paiement"> | Date | string
    updatedAt?: DateTimeFilter<"Paiement"> | Date | string
    caisse?: XOR<CaisseScalarRelationFilter, CaisseWhereInput>
    devise?: XOR<DeviseScalarRelationFilter, DeviseWhereInput>
    Achat?: AchatListRelationFilter
    Commande?: CommandeListRelationFilter
    Vente?: VenteListRelationFilter
  }

  export type PaiementOrderByWithRelationInput = {
    id?: SortOrder
    montant?: SortOrder
    moyen_paiement?: SortOrder
    deviseId?: SortOrder
    caisseId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    caisse?: CaisseOrderByWithRelationInput
    devise?: DeviseOrderByWithRelationInput
    Achat?: AchatOrderByRelationAggregateInput
    Commande?: CommandeOrderByRelationAggregateInput
    Vente?: VenteOrderByRelationAggregateInput
  }

  export type PaiementWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PaiementWhereInput | PaiementWhereInput[]
    OR?: PaiementWhereInput[]
    NOT?: PaiementWhereInput | PaiementWhereInput[]
    montant?: FloatFilter<"Paiement"> | number
    moyen_paiement?: EnumMoyenPaimentFilter<"Paiement"> | $Enums.MoyenPaiment
    deviseId?: IntFilter<"Paiement"> | number
    caisseId?: IntFilter<"Paiement"> | number
    createdAt?: DateTimeFilter<"Paiement"> | Date | string
    updatedAt?: DateTimeFilter<"Paiement"> | Date | string
    caisse?: XOR<CaisseScalarRelationFilter, CaisseWhereInput>
    devise?: XOR<DeviseScalarRelationFilter, DeviseWhereInput>
    Achat?: AchatListRelationFilter
    Commande?: CommandeListRelationFilter
    Vente?: VenteListRelationFilter
  }, "id">

  export type PaiementOrderByWithAggregationInput = {
    id?: SortOrder
    montant?: SortOrder
    moyen_paiement?: SortOrder
    deviseId?: SortOrder
    caisseId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaiementCountOrderByAggregateInput
    _avg?: PaiementAvgOrderByAggregateInput
    _max?: PaiementMaxOrderByAggregateInput
    _min?: PaiementMinOrderByAggregateInput
    _sum?: PaiementSumOrderByAggregateInput
  }

  export type PaiementScalarWhereWithAggregatesInput = {
    AND?: PaiementScalarWhereWithAggregatesInput | PaiementScalarWhereWithAggregatesInput[]
    OR?: PaiementScalarWhereWithAggregatesInput[]
    NOT?: PaiementScalarWhereWithAggregatesInput | PaiementScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Paiement"> | number
    montant?: FloatWithAggregatesFilter<"Paiement"> | number
    moyen_paiement?: EnumMoyenPaimentWithAggregatesFilter<"Paiement"> | $Enums.MoyenPaiment
    deviseId?: IntWithAggregatesFilter<"Paiement"> | number
    caisseId?: IntWithAggregatesFilter<"Paiement"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Paiement"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Paiement"> | Date | string
  }

  export type CaisseWhereInput = {
    AND?: CaisseWhereInput | CaisseWhereInput[]
    OR?: CaisseWhereInput[]
    NOT?: CaisseWhereInput | CaisseWhereInput[]
    id?: IntFilter<"Caisse"> | number
    nom?: StringFilter<"Caisse"> | string
    description?: StringNullableFilter<"Caisse"> | string | null
    soldeInitial?: FloatFilter<"Caisse"> | number
    soldeActuel?: FloatFilter<"Caisse"> | number
    deviseId?: IntFilter<"Caisse"> | number
    creeParId?: IntFilter<"Caisse"> | number
    statut?: EnumStatutCaisseFilter<"Caisse"> | $Enums.StatutCaisse
    createdAt?: DateTimeFilter<"Caisse"> | Date | string
    updatedAt?: DateTimeFilter<"Caisse"> | Date | string
    devise?: XOR<DeviseScalarRelationFilter, DeviseWhereInput>
    utilisateur?: XOR<UtilisateurScalarRelationFilter, UtilisateurWhereInput>
    MouvementCaisse?: MouvementCaisseListRelationFilter
    clotures?: ClotureCaisseListRelationFilter
    Paiement?: PaiementListRelationFilter
  }

  export type CaisseOrderByWithRelationInput = {
    id?: SortOrder
    nom?: SortOrder
    description?: SortOrderInput | SortOrder
    soldeInitial?: SortOrder
    soldeActuel?: SortOrder
    deviseId?: SortOrder
    creeParId?: SortOrder
    statut?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    devise?: DeviseOrderByWithRelationInput
    utilisateur?: UtilisateurOrderByWithRelationInput
    MouvementCaisse?: MouvementCaisseOrderByRelationAggregateInput
    clotures?: ClotureCaisseOrderByRelationAggregateInput
    Paiement?: PaiementOrderByRelationAggregateInput
  }

  export type CaisseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    nom?: string
    AND?: CaisseWhereInput | CaisseWhereInput[]
    OR?: CaisseWhereInput[]
    NOT?: CaisseWhereInput | CaisseWhereInput[]
    description?: StringNullableFilter<"Caisse"> | string | null
    soldeInitial?: FloatFilter<"Caisse"> | number
    soldeActuel?: FloatFilter<"Caisse"> | number
    deviseId?: IntFilter<"Caisse"> | number
    creeParId?: IntFilter<"Caisse"> | number
    statut?: EnumStatutCaisseFilter<"Caisse"> | $Enums.StatutCaisse
    createdAt?: DateTimeFilter<"Caisse"> | Date | string
    updatedAt?: DateTimeFilter<"Caisse"> | Date | string
    devise?: XOR<DeviseScalarRelationFilter, DeviseWhereInput>
    utilisateur?: XOR<UtilisateurScalarRelationFilter, UtilisateurWhereInput>
    MouvementCaisse?: MouvementCaisseListRelationFilter
    clotures?: ClotureCaisseListRelationFilter
    Paiement?: PaiementListRelationFilter
  }, "id" | "nom">

  export type CaisseOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrder
    description?: SortOrderInput | SortOrder
    soldeInitial?: SortOrder
    soldeActuel?: SortOrder
    deviseId?: SortOrder
    creeParId?: SortOrder
    statut?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CaisseCountOrderByAggregateInput
    _avg?: CaisseAvgOrderByAggregateInput
    _max?: CaisseMaxOrderByAggregateInput
    _min?: CaisseMinOrderByAggregateInput
    _sum?: CaisseSumOrderByAggregateInput
  }

  export type CaisseScalarWhereWithAggregatesInput = {
    AND?: CaisseScalarWhereWithAggregatesInput | CaisseScalarWhereWithAggregatesInput[]
    OR?: CaisseScalarWhereWithAggregatesInput[]
    NOT?: CaisseScalarWhereWithAggregatesInput | CaisseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Caisse"> | number
    nom?: StringWithAggregatesFilter<"Caisse"> | string
    description?: StringNullableWithAggregatesFilter<"Caisse"> | string | null
    soldeInitial?: FloatWithAggregatesFilter<"Caisse"> | number
    soldeActuel?: FloatWithAggregatesFilter<"Caisse"> | number
    deviseId?: IntWithAggregatesFilter<"Caisse"> | number
    creeParId?: IntWithAggregatesFilter<"Caisse"> | number
    statut?: EnumStatutCaisseWithAggregatesFilter<"Caisse"> | $Enums.StatutCaisse
    createdAt?: DateTimeWithAggregatesFilter<"Caisse"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Caisse"> | Date | string
  }

  export type VenteWhereInput = {
    AND?: VenteWhereInput | VenteWhereInput[]
    OR?: VenteWhereInput[]
    NOT?: VenteWhereInput | VenteWhereInput[]
    id?: IntFilter<"Vente"> | number
    statut?: EnumStatutVenteFilter<"Vente"> | $Enums.StatutVente
    total_ttc?: FloatFilter<"Vente"> | number
    total_ht?: FloatFilter<"Vente"> | number
    type_acheteur?: EnumTypeClientFilter<"Vente"> | $Enums.TypeClient
    clientId?: IntNullableFilter<"Vente"> | number | null
    enregistrerParId?: IntFilter<"Vente"> | number
    fournisseurId?: IntNullableFilter<"Vente"> | number | null
    agentId?: IntNullableFilter<"Vente"> | number | null
    paiementId?: IntFilter<"Vente"> | number
    panierId?: IntFilter<"Vente"> | number
    createdAt?: DateTimeFilter<"Vente"> | Date | string
    updatedAt?: DateTimeFilter<"Vente"> | Date | string
    paiement?: XOR<PaiementNullableScalarRelationFilter, PaiementWhereInput> | null
    panier?: XOR<PanierScalarRelationFilter, PanierWhereInput>
    utilisateur?: XOR<UtilisateurScalarRelationFilter, UtilisateurWhereInput>
    fournisseur?: XOR<FournisseurNullableScalarRelationFilter, FournisseurWhereInput> | null
  }

  export type VenteOrderByWithRelationInput = {
    id?: SortOrder
    statut?: SortOrder
    total_ttc?: SortOrder
    total_ht?: SortOrder
    type_acheteur?: SortOrder
    clientId?: SortOrderInput | SortOrder
    enregistrerParId?: SortOrder
    fournisseurId?: SortOrderInput | SortOrder
    agentId?: SortOrderInput | SortOrder
    paiementId?: SortOrder
    panierId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    paiement?: PaiementOrderByWithRelationInput
    panier?: PanierOrderByWithRelationInput
    utilisateur?: UtilisateurOrderByWithRelationInput
    fournisseur?: FournisseurOrderByWithRelationInput
  }

  export type VenteWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: VenteWhereInput | VenteWhereInput[]
    OR?: VenteWhereInput[]
    NOT?: VenteWhereInput | VenteWhereInput[]
    statut?: EnumStatutVenteFilter<"Vente"> | $Enums.StatutVente
    total_ttc?: FloatFilter<"Vente"> | number
    total_ht?: FloatFilter<"Vente"> | number
    type_acheteur?: EnumTypeClientFilter<"Vente"> | $Enums.TypeClient
    clientId?: IntNullableFilter<"Vente"> | number | null
    enregistrerParId?: IntFilter<"Vente"> | number
    fournisseurId?: IntNullableFilter<"Vente"> | number | null
    agentId?: IntNullableFilter<"Vente"> | number | null
    paiementId?: IntFilter<"Vente"> | number
    panierId?: IntFilter<"Vente"> | number
    createdAt?: DateTimeFilter<"Vente"> | Date | string
    updatedAt?: DateTimeFilter<"Vente"> | Date | string
    paiement?: XOR<PaiementNullableScalarRelationFilter, PaiementWhereInput> | null
    panier?: XOR<PanierScalarRelationFilter, PanierWhereInput>
    utilisateur?: XOR<UtilisateurScalarRelationFilter, UtilisateurWhereInput>
    fournisseur?: XOR<FournisseurNullableScalarRelationFilter, FournisseurWhereInput> | null
  }, "id">

  export type VenteOrderByWithAggregationInput = {
    id?: SortOrder
    statut?: SortOrder
    total_ttc?: SortOrder
    total_ht?: SortOrder
    type_acheteur?: SortOrder
    clientId?: SortOrderInput | SortOrder
    enregistrerParId?: SortOrder
    fournisseurId?: SortOrderInput | SortOrder
    agentId?: SortOrderInput | SortOrder
    paiementId?: SortOrder
    panierId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VenteCountOrderByAggregateInput
    _avg?: VenteAvgOrderByAggregateInput
    _max?: VenteMaxOrderByAggregateInput
    _min?: VenteMinOrderByAggregateInput
    _sum?: VenteSumOrderByAggregateInput
  }

  export type VenteScalarWhereWithAggregatesInput = {
    AND?: VenteScalarWhereWithAggregatesInput | VenteScalarWhereWithAggregatesInput[]
    OR?: VenteScalarWhereWithAggregatesInput[]
    NOT?: VenteScalarWhereWithAggregatesInput | VenteScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Vente"> | number
    statut?: EnumStatutVenteWithAggregatesFilter<"Vente"> | $Enums.StatutVente
    total_ttc?: FloatWithAggregatesFilter<"Vente"> | number
    total_ht?: FloatWithAggregatesFilter<"Vente"> | number
    type_acheteur?: EnumTypeClientWithAggregatesFilter<"Vente"> | $Enums.TypeClient
    clientId?: IntNullableWithAggregatesFilter<"Vente"> | number | null
    enregistrerParId?: IntWithAggregatesFilter<"Vente"> | number
    fournisseurId?: IntNullableWithAggregatesFilter<"Vente"> | number | null
    agentId?: IntNullableWithAggregatesFilter<"Vente"> | number | null
    paiementId?: IntWithAggregatesFilter<"Vente"> | number
    panierId?: IntWithAggregatesFilter<"Vente"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Vente"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Vente"> | Date | string
  }

  export type PanierWhereInput = {
    AND?: PanierWhereInput | PanierWhereInput[]
    OR?: PanierWhereInput[]
    NOT?: PanierWhereInput | PanierWhereInput[]
    id?: IntFilter<"Panier"> | number
    utilisateurId?: IntFilter<"Panier"> | number
    createdAt?: DateTimeFilter<"Panier"> | Date | string
    updatedAt?: DateTimeFilter<"Panier"> | Date | string
    utilisateur?: XOR<UtilisateurScalarRelationFilter, UtilisateurWhereInput>
    DetailPanier?: DetailPanierListRelationFilter
    Achat?: AchatListRelationFilter
    Vente?: VenteListRelationFilter
    Reservation?: ReservationListRelationFilter
    Commande?: CommandeListRelationFilter
  }

  export type PanierOrderByWithRelationInput = {
    id?: SortOrder
    utilisateurId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    utilisateur?: UtilisateurOrderByWithRelationInput
    DetailPanier?: DetailPanierOrderByRelationAggregateInput
    Achat?: AchatOrderByRelationAggregateInput
    Vente?: VenteOrderByRelationAggregateInput
    Reservation?: ReservationOrderByRelationAggregateInput
    Commande?: CommandeOrderByRelationAggregateInput
  }

  export type PanierWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PanierWhereInput | PanierWhereInput[]
    OR?: PanierWhereInput[]
    NOT?: PanierWhereInput | PanierWhereInput[]
    utilisateurId?: IntFilter<"Panier"> | number
    createdAt?: DateTimeFilter<"Panier"> | Date | string
    updatedAt?: DateTimeFilter<"Panier"> | Date | string
    utilisateur?: XOR<UtilisateurScalarRelationFilter, UtilisateurWhereInput>
    DetailPanier?: DetailPanierListRelationFilter
    Achat?: AchatListRelationFilter
    Vente?: VenteListRelationFilter
    Reservation?: ReservationListRelationFilter
    Commande?: CommandeListRelationFilter
  }, "id">

  export type PanierOrderByWithAggregationInput = {
    id?: SortOrder
    utilisateurId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PanierCountOrderByAggregateInput
    _avg?: PanierAvgOrderByAggregateInput
    _max?: PanierMaxOrderByAggregateInput
    _min?: PanierMinOrderByAggregateInput
    _sum?: PanierSumOrderByAggregateInput
  }

  export type PanierScalarWhereWithAggregatesInput = {
    AND?: PanierScalarWhereWithAggregatesInput | PanierScalarWhereWithAggregatesInput[]
    OR?: PanierScalarWhereWithAggregatesInput[]
    NOT?: PanierScalarWhereWithAggregatesInput | PanierScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Panier"> | number
    utilisateurId?: IntWithAggregatesFilter<"Panier"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Panier"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Panier"> | Date | string
  }

  export type DetailPanierWhereInput = {
    AND?: DetailPanierWhereInput | DetailPanierWhereInput[]
    OR?: DetailPanierWhereInput[]
    NOT?: DetailPanierWhereInput | DetailPanierWhereInput[]
    id?: IntFilter<"DetailPanier"> | number
    produitId?: IntFilter<"DetailPanier"> | number
    qtte?: IntFilter<"DetailPanier"> | number
    prixUnitaire?: FloatFilter<"DetailPanier"> | number
    prixTotal?: FloatFilter<"DetailPanier"> | number
    panierId?: IntFilter<"DetailPanier"> | number
    createdAt?: DateTimeFilter<"DetailPanier"> | Date | string
    updatedAt?: DateTimeFilter<"DetailPanier"> | Date | string
    produit?: XOR<ProduitScalarRelationFilter, ProduitWhereInput>
    panier?: XOR<PanierScalarRelationFilter, PanierWhereInput>
  }

  export type DetailPanierOrderByWithRelationInput = {
    id?: SortOrder
    produitId?: SortOrder
    qtte?: SortOrder
    prixUnitaire?: SortOrder
    prixTotal?: SortOrder
    panierId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    produit?: ProduitOrderByWithRelationInput
    panier?: PanierOrderByWithRelationInput
  }

  export type DetailPanierWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DetailPanierWhereInput | DetailPanierWhereInput[]
    OR?: DetailPanierWhereInput[]
    NOT?: DetailPanierWhereInput | DetailPanierWhereInput[]
    produitId?: IntFilter<"DetailPanier"> | number
    qtte?: IntFilter<"DetailPanier"> | number
    prixUnitaire?: FloatFilter<"DetailPanier"> | number
    prixTotal?: FloatFilter<"DetailPanier"> | number
    panierId?: IntFilter<"DetailPanier"> | number
    createdAt?: DateTimeFilter<"DetailPanier"> | Date | string
    updatedAt?: DateTimeFilter<"DetailPanier"> | Date | string
    produit?: XOR<ProduitScalarRelationFilter, ProduitWhereInput>
    panier?: XOR<PanierScalarRelationFilter, PanierWhereInput>
  }, "id">

  export type DetailPanierOrderByWithAggregationInput = {
    id?: SortOrder
    produitId?: SortOrder
    qtte?: SortOrder
    prixUnitaire?: SortOrder
    prixTotal?: SortOrder
    panierId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DetailPanierCountOrderByAggregateInput
    _avg?: DetailPanierAvgOrderByAggregateInput
    _max?: DetailPanierMaxOrderByAggregateInput
    _min?: DetailPanierMinOrderByAggregateInput
    _sum?: DetailPanierSumOrderByAggregateInput
  }

  export type DetailPanierScalarWhereWithAggregatesInput = {
    AND?: DetailPanierScalarWhereWithAggregatesInput | DetailPanierScalarWhereWithAggregatesInput[]
    OR?: DetailPanierScalarWhereWithAggregatesInput[]
    NOT?: DetailPanierScalarWhereWithAggregatesInput | DetailPanierScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DetailPanier"> | number
    produitId?: IntWithAggregatesFilter<"DetailPanier"> | number
    qtte?: IntWithAggregatesFilter<"DetailPanier"> | number
    prixUnitaire?: FloatWithAggregatesFilter<"DetailPanier"> | number
    prixTotal?: FloatWithAggregatesFilter<"DetailPanier"> | number
    panierId?: IntWithAggregatesFilter<"DetailPanier"> | number
    createdAt?: DateTimeWithAggregatesFilter<"DetailPanier"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DetailPanier"> | Date | string
  }

  export type AchatWhereInput = {
    AND?: AchatWhereInput | AchatWhereInput[]
    OR?: AchatWhereInput[]
    NOT?: AchatWhereInput | AchatWhereInput[]
    id?: IntFilter<"Achat"> | number
    statut?: EnumStatutAchatFilter<"Achat"> | $Enums.StatutAchat
    panierId?: IntFilter<"Achat"> | number
    fournisseurId?: IntFilter<"Achat"> | number
    enregistrerParId?: IntFilter<"Achat"> | number
    paiementId?: IntFilter<"Achat"> | number
    createdAt?: DateTimeFilter<"Achat"> | Date | string
    updatedAt?: DateTimeFilter<"Achat"> | Date | string
    panier?: XOR<PanierScalarRelationFilter, PanierWhereInput>
    fournisseur?: XOR<FournisseurScalarRelationFilter, FournisseurWhereInput>
    utilisateur?: XOR<UtilisateurScalarRelationFilter, UtilisateurWhereInput>
    paiement?: XOR<PaiementScalarRelationFilter, PaiementWhereInput>
  }

  export type AchatOrderByWithRelationInput = {
    id?: SortOrder
    statut?: SortOrder
    panierId?: SortOrder
    fournisseurId?: SortOrder
    enregistrerParId?: SortOrder
    paiementId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    panier?: PanierOrderByWithRelationInput
    fournisseur?: FournisseurOrderByWithRelationInput
    utilisateur?: UtilisateurOrderByWithRelationInput
    paiement?: PaiementOrderByWithRelationInput
  }

  export type AchatWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AchatWhereInput | AchatWhereInput[]
    OR?: AchatWhereInput[]
    NOT?: AchatWhereInput | AchatWhereInput[]
    statut?: EnumStatutAchatFilter<"Achat"> | $Enums.StatutAchat
    panierId?: IntFilter<"Achat"> | number
    fournisseurId?: IntFilter<"Achat"> | number
    enregistrerParId?: IntFilter<"Achat"> | number
    paiementId?: IntFilter<"Achat"> | number
    createdAt?: DateTimeFilter<"Achat"> | Date | string
    updatedAt?: DateTimeFilter<"Achat"> | Date | string
    panier?: XOR<PanierScalarRelationFilter, PanierWhereInput>
    fournisseur?: XOR<FournisseurScalarRelationFilter, FournisseurWhereInput>
    utilisateur?: XOR<UtilisateurScalarRelationFilter, UtilisateurWhereInput>
    paiement?: XOR<PaiementScalarRelationFilter, PaiementWhereInput>
  }, "id">

  export type AchatOrderByWithAggregationInput = {
    id?: SortOrder
    statut?: SortOrder
    panierId?: SortOrder
    fournisseurId?: SortOrder
    enregistrerParId?: SortOrder
    paiementId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AchatCountOrderByAggregateInput
    _avg?: AchatAvgOrderByAggregateInput
    _max?: AchatMaxOrderByAggregateInput
    _min?: AchatMinOrderByAggregateInput
    _sum?: AchatSumOrderByAggregateInput
  }

  export type AchatScalarWhereWithAggregatesInput = {
    AND?: AchatScalarWhereWithAggregatesInput | AchatScalarWhereWithAggregatesInput[]
    OR?: AchatScalarWhereWithAggregatesInput[]
    NOT?: AchatScalarWhereWithAggregatesInput | AchatScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Achat"> | number
    statut?: EnumStatutAchatWithAggregatesFilter<"Achat"> | $Enums.StatutAchat
    panierId?: IntWithAggregatesFilter<"Achat"> | number
    fournisseurId?: IntWithAggregatesFilter<"Achat"> | number
    enregistrerParId?: IntWithAggregatesFilter<"Achat"> | number
    paiementId?: IntWithAggregatesFilter<"Achat"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Achat"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Achat"> | Date | string
  }

  export type ReservationWhereInput = {
    AND?: ReservationWhereInput | ReservationWhereInput[]
    OR?: ReservationWhereInput[]
    NOT?: ReservationWhereInput | ReservationWhereInput[]
    id?: IntFilter<"Reservation"> | number
    dateLivraisonSouhaitee?: DateTimeFilter<"Reservation"> | Date | string
    adresseLivraison?: StringNullableFilter<"Reservation"> | string | null
    statut?: EnumStatutReservationFilter<"Reservation"> | $Enums.StatutReservation
    notes?: StringNullableFilter<"Reservation"> | string | null
    type_client?: EnumTypeClientFilter<"Reservation"> | $Enums.TypeClient
    clientId?: IntNullableFilter<"Reservation"> | number | null
    panierId?: IntFilter<"Reservation"> | number
    nom?: StringNullableFilter<"Reservation"> | string | null
    tel?: StringNullableFilter<"Reservation"> | string | null
    adresseId?: IntNullableFilter<"Reservation"> | number | null
    contactId?: IntNullableFilter<"Reservation"> | number | null
    enregistrerParId?: IntNullableFilter<"Reservation"> | number | null
    fournisseurId?: IntNullableFilter<"Reservation"> | number | null
    createdAt?: DateTimeFilter<"Reservation"> | Date | string
    updatedAt?: DateTimeFilter<"Reservation"> | Date | string
    panier?: XOR<PanierScalarRelationFilter, PanierWhereInput>
    utilisateur?: XOR<UtilisateurNullableScalarRelationFilter, UtilisateurWhereInput> | null
    fournisseur?: XOR<FournisseurNullableScalarRelationFilter, FournisseurWhereInput> | null
    adresse?: XOR<AdresseNullableScalarRelationFilter, AdresseWhereInput> | null
    contact?: XOR<ContactNullableScalarRelationFilter, ContactWhereInput> | null
  }

  export type ReservationOrderByWithRelationInput = {
    id?: SortOrder
    dateLivraisonSouhaitee?: SortOrder
    adresseLivraison?: SortOrderInput | SortOrder
    statut?: SortOrder
    notes?: SortOrderInput | SortOrder
    type_client?: SortOrder
    clientId?: SortOrderInput | SortOrder
    panierId?: SortOrder
    nom?: SortOrderInput | SortOrder
    tel?: SortOrderInput | SortOrder
    adresseId?: SortOrderInput | SortOrder
    contactId?: SortOrderInput | SortOrder
    enregistrerParId?: SortOrderInput | SortOrder
    fournisseurId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    panier?: PanierOrderByWithRelationInput
    utilisateur?: UtilisateurOrderByWithRelationInput
    fournisseur?: FournisseurOrderByWithRelationInput
    adresse?: AdresseOrderByWithRelationInput
    contact?: ContactOrderByWithRelationInput
  }

  export type ReservationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ReservationWhereInput | ReservationWhereInput[]
    OR?: ReservationWhereInput[]
    NOT?: ReservationWhereInput | ReservationWhereInput[]
    dateLivraisonSouhaitee?: DateTimeFilter<"Reservation"> | Date | string
    adresseLivraison?: StringNullableFilter<"Reservation"> | string | null
    statut?: EnumStatutReservationFilter<"Reservation"> | $Enums.StatutReservation
    notes?: StringNullableFilter<"Reservation"> | string | null
    type_client?: EnumTypeClientFilter<"Reservation"> | $Enums.TypeClient
    clientId?: IntNullableFilter<"Reservation"> | number | null
    panierId?: IntFilter<"Reservation"> | number
    nom?: StringNullableFilter<"Reservation"> | string | null
    tel?: StringNullableFilter<"Reservation"> | string | null
    adresseId?: IntNullableFilter<"Reservation"> | number | null
    contactId?: IntNullableFilter<"Reservation"> | number | null
    enregistrerParId?: IntNullableFilter<"Reservation"> | number | null
    fournisseurId?: IntNullableFilter<"Reservation"> | number | null
    createdAt?: DateTimeFilter<"Reservation"> | Date | string
    updatedAt?: DateTimeFilter<"Reservation"> | Date | string
    panier?: XOR<PanierScalarRelationFilter, PanierWhereInput>
    utilisateur?: XOR<UtilisateurNullableScalarRelationFilter, UtilisateurWhereInput> | null
    fournisseur?: XOR<FournisseurNullableScalarRelationFilter, FournisseurWhereInput> | null
    adresse?: XOR<AdresseNullableScalarRelationFilter, AdresseWhereInput> | null
    contact?: XOR<ContactNullableScalarRelationFilter, ContactWhereInput> | null
  }, "id">

  export type ReservationOrderByWithAggregationInput = {
    id?: SortOrder
    dateLivraisonSouhaitee?: SortOrder
    adresseLivraison?: SortOrderInput | SortOrder
    statut?: SortOrder
    notes?: SortOrderInput | SortOrder
    type_client?: SortOrder
    clientId?: SortOrderInput | SortOrder
    panierId?: SortOrder
    nom?: SortOrderInput | SortOrder
    tel?: SortOrderInput | SortOrder
    adresseId?: SortOrderInput | SortOrder
    contactId?: SortOrderInput | SortOrder
    enregistrerParId?: SortOrderInput | SortOrder
    fournisseurId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReservationCountOrderByAggregateInput
    _avg?: ReservationAvgOrderByAggregateInput
    _max?: ReservationMaxOrderByAggregateInput
    _min?: ReservationMinOrderByAggregateInput
    _sum?: ReservationSumOrderByAggregateInput
  }

  export type ReservationScalarWhereWithAggregatesInput = {
    AND?: ReservationScalarWhereWithAggregatesInput | ReservationScalarWhereWithAggregatesInput[]
    OR?: ReservationScalarWhereWithAggregatesInput[]
    NOT?: ReservationScalarWhereWithAggregatesInput | ReservationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Reservation"> | number
    dateLivraisonSouhaitee?: DateTimeWithAggregatesFilter<"Reservation"> | Date | string
    adresseLivraison?: StringNullableWithAggregatesFilter<"Reservation"> | string | null
    statut?: EnumStatutReservationWithAggregatesFilter<"Reservation"> | $Enums.StatutReservation
    notes?: StringNullableWithAggregatesFilter<"Reservation"> | string | null
    type_client?: EnumTypeClientWithAggregatesFilter<"Reservation"> | $Enums.TypeClient
    clientId?: IntNullableWithAggregatesFilter<"Reservation"> | number | null
    panierId?: IntWithAggregatesFilter<"Reservation"> | number
    nom?: StringNullableWithAggregatesFilter<"Reservation"> | string | null
    tel?: StringNullableWithAggregatesFilter<"Reservation"> | string | null
    adresseId?: IntNullableWithAggregatesFilter<"Reservation"> | number | null
    contactId?: IntNullableWithAggregatesFilter<"Reservation"> | number | null
    enregistrerParId?: IntNullableWithAggregatesFilter<"Reservation"> | number | null
    fournisseurId?: IntNullableWithAggregatesFilter<"Reservation"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Reservation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Reservation"> | Date | string
  }

  export type CommandeWhereInput = {
    AND?: CommandeWhereInput | CommandeWhereInput[]
    OR?: CommandeWhereInput[]
    NOT?: CommandeWhereInput | CommandeWhereInput[]
    id?: IntFilter<"Commande"> | number
    panierId?: IntFilter<"Commande"> | number
    clientId?: IntNullableFilter<"Commande"> | number | null
    nom?: StringNullableFilter<"Commande"> | string | null
    tel?: StringNullableFilter<"Commande"> | string | null
    type_client?: EnumTypeClientFilter<"Commande"> | $Enums.TypeClient
    paiementId?: IntFilter<"Commande"> | number
    adresseId?: IntNullableFilter<"Commande"> | number | null
    contactId?: IntNullableFilter<"Commande"> | number | null
    fournisseurId?: IntNullableFilter<"Commande"> | number | null
    notes?: StringNullableFilter<"Commande"> | string | null
    dateLivraisonEffective?: DateTimeNullableFilter<"Commande"> | Date | string | null
    adresseLivraison?: StringNullableFilter<"Commande"> | string | null
    enregistrerParId?: IntNullableFilter<"Commande"> | number | null
    statut?: EnumStatutCommandeFilter<"Commande"> | $Enums.StatutCommande
    createdAt?: DateTimeFilter<"Commande"> | Date | string
    updatedAt?: DateTimeFilter<"Commande"> | Date | string
    panier?: XOR<PanierScalarRelationFilter, PanierWhereInput>
    client?: XOR<UtilisateurNullableScalarRelationFilter, UtilisateurWhereInput> | null
    paiement?: XOR<PaiementScalarRelationFilter, PaiementWhereInput>
    fournisseur?: XOR<FournisseurNullableScalarRelationFilter, FournisseurWhereInput> | null
    adresse?: XOR<AdresseNullableScalarRelationFilter, AdresseWhereInput> | null
    contact?: XOR<ContactNullableScalarRelationFilter, ContactWhereInput> | null
  }

  export type CommandeOrderByWithRelationInput = {
    id?: SortOrder
    panierId?: SortOrder
    clientId?: SortOrderInput | SortOrder
    nom?: SortOrderInput | SortOrder
    tel?: SortOrderInput | SortOrder
    type_client?: SortOrder
    paiementId?: SortOrder
    adresseId?: SortOrderInput | SortOrder
    contactId?: SortOrderInput | SortOrder
    fournisseurId?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    dateLivraisonEffective?: SortOrderInput | SortOrder
    adresseLivraison?: SortOrderInput | SortOrder
    enregistrerParId?: SortOrderInput | SortOrder
    statut?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    panier?: PanierOrderByWithRelationInput
    client?: UtilisateurOrderByWithRelationInput
    paiement?: PaiementOrderByWithRelationInput
    fournisseur?: FournisseurOrderByWithRelationInput
    adresse?: AdresseOrderByWithRelationInput
    contact?: ContactOrderByWithRelationInput
  }

  export type CommandeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CommandeWhereInput | CommandeWhereInput[]
    OR?: CommandeWhereInput[]
    NOT?: CommandeWhereInput | CommandeWhereInput[]
    panierId?: IntFilter<"Commande"> | number
    clientId?: IntNullableFilter<"Commande"> | number | null
    nom?: StringNullableFilter<"Commande"> | string | null
    tel?: StringNullableFilter<"Commande"> | string | null
    type_client?: EnumTypeClientFilter<"Commande"> | $Enums.TypeClient
    paiementId?: IntFilter<"Commande"> | number
    adresseId?: IntNullableFilter<"Commande"> | number | null
    contactId?: IntNullableFilter<"Commande"> | number | null
    fournisseurId?: IntNullableFilter<"Commande"> | number | null
    notes?: StringNullableFilter<"Commande"> | string | null
    dateLivraisonEffective?: DateTimeNullableFilter<"Commande"> | Date | string | null
    adresseLivraison?: StringNullableFilter<"Commande"> | string | null
    enregistrerParId?: IntNullableFilter<"Commande"> | number | null
    statut?: EnumStatutCommandeFilter<"Commande"> | $Enums.StatutCommande
    createdAt?: DateTimeFilter<"Commande"> | Date | string
    updatedAt?: DateTimeFilter<"Commande"> | Date | string
    panier?: XOR<PanierScalarRelationFilter, PanierWhereInput>
    client?: XOR<UtilisateurNullableScalarRelationFilter, UtilisateurWhereInput> | null
    paiement?: XOR<PaiementScalarRelationFilter, PaiementWhereInput>
    fournisseur?: XOR<FournisseurNullableScalarRelationFilter, FournisseurWhereInput> | null
    adresse?: XOR<AdresseNullableScalarRelationFilter, AdresseWhereInput> | null
    contact?: XOR<ContactNullableScalarRelationFilter, ContactWhereInput> | null
  }, "id">

  export type CommandeOrderByWithAggregationInput = {
    id?: SortOrder
    panierId?: SortOrder
    clientId?: SortOrderInput | SortOrder
    nom?: SortOrderInput | SortOrder
    tel?: SortOrderInput | SortOrder
    type_client?: SortOrder
    paiementId?: SortOrder
    adresseId?: SortOrderInput | SortOrder
    contactId?: SortOrderInput | SortOrder
    fournisseurId?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    dateLivraisonEffective?: SortOrderInput | SortOrder
    adresseLivraison?: SortOrderInput | SortOrder
    enregistrerParId?: SortOrderInput | SortOrder
    statut?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CommandeCountOrderByAggregateInput
    _avg?: CommandeAvgOrderByAggregateInput
    _max?: CommandeMaxOrderByAggregateInput
    _min?: CommandeMinOrderByAggregateInput
    _sum?: CommandeSumOrderByAggregateInput
  }

  export type CommandeScalarWhereWithAggregatesInput = {
    AND?: CommandeScalarWhereWithAggregatesInput | CommandeScalarWhereWithAggregatesInput[]
    OR?: CommandeScalarWhereWithAggregatesInput[]
    NOT?: CommandeScalarWhereWithAggregatesInput | CommandeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Commande"> | number
    panierId?: IntWithAggregatesFilter<"Commande"> | number
    clientId?: IntNullableWithAggregatesFilter<"Commande"> | number | null
    nom?: StringNullableWithAggregatesFilter<"Commande"> | string | null
    tel?: StringNullableWithAggregatesFilter<"Commande"> | string | null
    type_client?: EnumTypeClientWithAggregatesFilter<"Commande"> | $Enums.TypeClient
    paiementId?: IntWithAggregatesFilter<"Commande"> | number
    adresseId?: IntNullableWithAggregatesFilter<"Commande"> | number | null
    contactId?: IntNullableWithAggregatesFilter<"Commande"> | number | null
    fournisseurId?: IntNullableWithAggregatesFilter<"Commande"> | number | null
    notes?: StringNullableWithAggregatesFilter<"Commande"> | string | null
    dateLivraisonEffective?: DateTimeNullableWithAggregatesFilter<"Commande"> | Date | string | null
    adresseLivraison?: StringNullableWithAggregatesFilter<"Commande"> | string | null
    enregistrerParId?: IntNullableWithAggregatesFilter<"Commande"> | number | null
    statut?: EnumStatutCommandeWithAggregatesFilter<"Commande"> | $Enums.StatutCommande
    createdAt?: DateTimeWithAggregatesFilter<"Commande"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Commande"> | Date | string
  }

  export type MouvementCaisseWhereInput = {
    AND?: MouvementCaisseWhereInput | MouvementCaisseWhereInput[]
    OR?: MouvementCaisseWhereInput[]
    NOT?: MouvementCaisseWhereInput | MouvementCaisseWhereInput[]
    id?: IntFilter<"MouvementCaisse"> | number
    caisseId?: IntFilter<"MouvementCaisse"> | number
    type_mouvement?: EnumTypeMouvementCaisseFilter<"MouvementCaisse"> | $Enums.TypeMouvementCaisse
    categorie?: EnumCategorieMouvementFilter<"MouvementCaisse"> | $Enums.CategorieMouvement
    montant?: FloatFilter<"MouvementCaisse"> | number
    description?: StringNullableFilter<"MouvementCaisse"> | string | null
    enregistrerParId?: IntFilter<"MouvementCaisse"> | number
    referenceExterne?: StringNullableFilter<"MouvementCaisse"> | string | null
    createdAt?: DateTimeFilter<"MouvementCaisse"> | Date | string
    updatedAt?: DateTimeFilter<"MouvementCaisse"> | Date | string
    caisse?: XOR<CaisseScalarRelationFilter, CaisseWhereInput>
    utilisateur?: XOR<UtilisateurScalarRelationFilter, UtilisateurWhereInput>
  }

  export type MouvementCaisseOrderByWithRelationInput = {
    id?: SortOrder
    caisseId?: SortOrder
    type_mouvement?: SortOrder
    categorie?: SortOrder
    montant?: SortOrder
    description?: SortOrderInput | SortOrder
    enregistrerParId?: SortOrder
    referenceExterne?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    caisse?: CaisseOrderByWithRelationInput
    utilisateur?: UtilisateurOrderByWithRelationInput
  }

  export type MouvementCaisseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    referenceExterne?: string
    AND?: MouvementCaisseWhereInput | MouvementCaisseWhereInput[]
    OR?: MouvementCaisseWhereInput[]
    NOT?: MouvementCaisseWhereInput | MouvementCaisseWhereInput[]
    caisseId?: IntFilter<"MouvementCaisse"> | number
    type_mouvement?: EnumTypeMouvementCaisseFilter<"MouvementCaisse"> | $Enums.TypeMouvementCaisse
    categorie?: EnumCategorieMouvementFilter<"MouvementCaisse"> | $Enums.CategorieMouvement
    montant?: FloatFilter<"MouvementCaisse"> | number
    description?: StringNullableFilter<"MouvementCaisse"> | string | null
    enregistrerParId?: IntFilter<"MouvementCaisse"> | number
    createdAt?: DateTimeFilter<"MouvementCaisse"> | Date | string
    updatedAt?: DateTimeFilter<"MouvementCaisse"> | Date | string
    caisse?: XOR<CaisseScalarRelationFilter, CaisseWhereInput>
    utilisateur?: XOR<UtilisateurScalarRelationFilter, UtilisateurWhereInput>
  }, "id" | "referenceExterne">

  export type MouvementCaisseOrderByWithAggregationInput = {
    id?: SortOrder
    caisseId?: SortOrder
    type_mouvement?: SortOrder
    categorie?: SortOrder
    montant?: SortOrder
    description?: SortOrderInput | SortOrder
    enregistrerParId?: SortOrder
    referenceExterne?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MouvementCaisseCountOrderByAggregateInput
    _avg?: MouvementCaisseAvgOrderByAggregateInput
    _max?: MouvementCaisseMaxOrderByAggregateInput
    _min?: MouvementCaisseMinOrderByAggregateInput
    _sum?: MouvementCaisseSumOrderByAggregateInput
  }

  export type MouvementCaisseScalarWhereWithAggregatesInput = {
    AND?: MouvementCaisseScalarWhereWithAggregatesInput | MouvementCaisseScalarWhereWithAggregatesInput[]
    OR?: MouvementCaisseScalarWhereWithAggregatesInput[]
    NOT?: MouvementCaisseScalarWhereWithAggregatesInput | MouvementCaisseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MouvementCaisse"> | number
    caisseId?: IntWithAggregatesFilter<"MouvementCaisse"> | number
    type_mouvement?: EnumTypeMouvementCaisseWithAggregatesFilter<"MouvementCaisse"> | $Enums.TypeMouvementCaisse
    categorie?: EnumCategorieMouvementWithAggregatesFilter<"MouvementCaisse"> | $Enums.CategorieMouvement
    montant?: FloatWithAggregatesFilter<"MouvementCaisse"> | number
    description?: StringNullableWithAggregatesFilter<"MouvementCaisse"> | string | null
    enregistrerParId?: IntWithAggregatesFilter<"MouvementCaisse"> | number
    referenceExterne?: StringNullableWithAggregatesFilter<"MouvementCaisse"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MouvementCaisse"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MouvementCaisse"> | Date | string
  }

  export type DetailClotureCaisseWhereInput = {
    AND?: DetailClotureCaisseWhereInput | DetailClotureCaisseWhereInput[]
    OR?: DetailClotureCaisseWhereInput[]
    NOT?: DetailClotureCaisseWhereInput | DetailClotureCaisseWhereInput[]
    id?: IntFilter<"DetailClotureCaisse"> | number
    produitId?: IntFilter<"DetailClotureCaisse"> | number
    teneurId?: IntFilter<"DetailClotureCaisse"> | number
    qtteRestante?: IntFilter<"DetailClotureCaisse"> | number
    clotureCaisseId?: IntFilter<"DetailClotureCaisse"> | number
    createdAt?: DateTimeFilter<"DetailClotureCaisse"> | Date | string
    updatedAt?: DateTimeFilter<"DetailClotureCaisse"> | Date | string
    produit?: XOR<ProduitScalarRelationFilter, ProduitWhereInput>
    teneur?: XOR<TeneurScalarRelationFilter, TeneurWhereInput>
    clotureCaisse?: XOR<ClotureCaisseScalarRelationFilter, ClotureCaisseWhereInput>
  }

  export type DetailClotureCaisseOrderByWithRelationInput = {
    id?: SortOrder
    produitId?: SortOrder
    teneurId?: SortOrder
    qtteRestante?: SortOrder
    clotureCaisseId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    produit?: ProduitOrderByWithRelationInput
    teneur?: TeneurOrderByWithRelationInput
    clotureCaisse?: ClotureCaisseOrderByWithRelationInput
  }

  export type DetailClotureCaisseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DetailClotureCaisseWhereInput | DetailClotureCaisseWhereInput[]
    OR?: DetailClotureCaisseWhereInput[]
    NOT?: DetailClotureCaisseWhereInput | DetailClotureCaisseWhereInput[]
    produitId?: IntFilter<"DetailClotureCaisse"> | number
    teneurId?: IntFilter<"DetailClotureCaisse"> | number
    qtteRestante?: IntFilter<"DetailClotureCaisse"> | number
    clotureCaisseId?: IntFilter<"DetailClotureCaisse"> | number
    createdAt?: DateTimeFilter<"DetailClotureCaisse"> | Date | string
    updatedAt?: DateTimeFilter<"DetailClotureCaisse"> | Date | string
    produit?: XOR<ProduitScalarRelationFilter, ProduitWhereInput>
    teneur?: XOR<TeneurScalarRelationFilter, TeneurWhereInput>
    clotureCaisse?: XOR<ClotureCaisseScalarRelationFilter, ClotureCaisseWhereInput>
  }, "id">

  export type DetailClotureCaisseOrderByWithAggregationInput = {
    id?: SortOrder
    produitId?: SortOrder
    teneurId?: SortOrder
    qtteRestante?: SortOrder
    clotureCaisseId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DetailClotureCaisseCountOrderByAggregateInput
    _avg?: DetailClotureCaisseAvgOrderByAggregateInput
    _max?: DetailClotureCaisseMaxOrderByAggregateInput
    _min?: DetailClotureCaisseMinOrderByAggregateInput
    _sum?: DetailClotureCaisseSumOrderByAggregateInput
  }

  export type DetailClotureCaisseScalarWhereWithAggregatesInput = {
    AND?: DetailClotureCaisseScalarWhereWithAggregatesInput | DetailClotureCaisseScalarWhereWithAggregatesInput[]
    OR?: DetailClotureCaisseScalarWhereWithAggregatesInput[]
    NOT?: DetailClotureCaisseScalarWhereWithAggregatesInput | DetailClotureCaisseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DetailClotureCaisse"> | number
    produitId?: IntWithAggregatesFilter<"DetailClotureCaisse"> | number
    teneurId?: IntWithAggregatesFilter<"DetailClotureCaisse"> | number
    qtteRestante?: IntWithAggregatesFilter<"DetailClotureCaisse"> | number
    clotureCaisseId?: IntWithAggregatesFilter<"DetailClotureCaisse"> | number
    createdAt?: DateTimeWithAggregatesFilter<"DetailClotureCaisse"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DetailClotureCaisse"> | Date | string
  }

  export type ClotureCaisseWhereInput = {
    AND?: ClotureCaisseWhereInput | ClotureCaisseWhereInput[]
    OR?: ClotureCaisseWhereInput[]
    NOT?: ClotureCaisseWhereInput | ClotureCaisseWhereInput[]
    id?: IntFilter<"ClotureCaisse"> | number
    caisseId?: IntFilter<"ClotureCaisse"> | number
    dateCloture?: DateTimeFilter<"ClotureCaisse"> | Date | string
    utilisateurClotureId?: IntFilter<"ClotureCaisse"> | number
    notes?: StringNullableFilter<"ClotureCaisse"> | string | null
    createdAt?: DateTimeFilter<"ClotureCaisse"> | Date | string
    updatedAt?: DateTimeFilter<"ClotureCaisse"> | Date | string
    caisse?: XOR<CaisseScalarRelationFilter, CaisseWhereInput>
    utilisateurCloture?: XOR<UtilisateurScalarRelationFilter, UtilisateurWhereInput>
    DetailClotureCaisse?: DetailClotureCaisseListRelationFilter
  }

  export type ClotureCaisseOrderByWithRelationInput = {
    id?: SortOrder
    caisseId?: SortOrder
    dateCloture?: SortOrder
    utilisateurClotureId?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    caisse?: CaisseOrderByWithRelationInput
    utilisateurCloture?: UtilisateurOrderByWithRelationInput
    DetailClotureCaisse?: DetailClotureCaisseOrderByRelationAggregateInput
  }

  export type ClotureCaisseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ClotureCaisseWhereInput | ClotureCaisseWhereInput[]
    OR?: ClotureCaisseWhereInput[]
    NOT?: ClotureCaisseWhereInput | ClotureCaisseWhereInput[]
    caisseId?: IntFilter<"ClotureCaisse"> | number
    dateCloture?: DateTimeFilter<"ClotureCaisse"> | Date | string
    utilisateurClotureId?: IntFilter<"ClotureCaisse"> | number
    notes?: StringNullableFilter<"ClotureCaisse"> | string | null
    createdAt?: DateTimeFilter<"ClotureCaisse"> | Date | string
    updatedAt?: DateTimeFilter<"ClotureCaisse"> | Date | string
    caisse?: XOR<CaisseScalarRelationFilter, CaisseWhereInput>
    utilisateurCloture?: XOR<UtilisateurScalarRelationFilter, UtilisateurWhereInput>
    DetailClotureCaisse?: DetailClotureCaisseListRelationFilter
  }, "id">

  export type ClotureCaisseOrderByWithAggregationInput = {
    id?: SortOrder
    caisseId?: SortOrder
    dateCloture?: SortOrder
    utilisateurClotureId?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClotureCaisseCountOrderByAggregateInput
    _avg?: ClotureCaisseAvgOrderByAggregateInput
    _max?: ClotureCaisseMaxOrderByAggregateInput
    _min?: ClotureCaisseMinOrderByAggregateInput
    _sum?: ClotureCaisseSumOrderByAggregateInput
  }

  export type ClotureCaisseScalarWhereWithAggregatesInput = {
    AND?: ClotureCaisseScalarWhereWithAggregatesInput | ClotureCaisseScalarWhereWithAggregatesInput[]
    OR?: ClotureCaisseScalarWhereWithAggregatesInput[]
    NOT?: ClotureCaisseScalarWhereWithAggregatesInput | ClotureCaisseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ClotureCaisse"> | number
    caisseId?: IntWithAggregatesFilter<"ClotureCaisse"> | number
    dateCloture?: DateTimeWithAggregatesFilter<"ClotureCaisse"> | Date | string
    utilisateurClotureId?: IntWithAggregatesFilter<"ClotureCaisse"> | number
    notes?: StringNullableWithAggregatesFilter<"ClotureCaisse"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ClotureCaisse"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ClotureCaisse"> | Date | string
  }

  export type EntrepriseCreateInput = {
    nom: string
    encronyme: string
    code_postale: string
    adresse: string
    tel: string
    site?: string | null
    email: string
    description?: string | null
    logo?: string | null
  }

  export type EntrepriseUncheckedCreateInput = {
    id?: number
    nom: string
    encronyme: string
    code_postale: string
    adresse: string
    tel: string
    site?: string | null
    email: string
    description?: string | null
    logo?: string | null
  }

  export type EntrepriseUpdateInput = {
    nom?: StringFieldUpdateOperationsInput | string
    encronyme?: StringFieldUpdateOperationsInput | string
    code_postale?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    tel?: StringFieldUpdateOperationsInput | string
    site?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EntrepriseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    encronyme?: StringFieldUpdateOperationsInput | string
    code_postale?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    tel?: StringFieldUpdateOperationsInput | string
    site?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EntrepriseCreateManyInput = {
    id?: number
    nom: string
    encronyme: string
    code_postale: string
    adresse: string
    tel: string
    site?: string | null
    email: string
    description?: string | null
    logo?: string | null
  }

  export type EntrepriseUpdateManyMutationInput = {
    nom?: StringFieldUpdateOperationsInput | string
    encronyme?: StringFieldUpdateOperationsInput | string
    code_postale?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    tel?: StringFieldUpdateOperationsInput | string
    site?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EntrepriseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    encronyme?: StringFieldUpdateOperationsInput | string
    code_postale?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    tel?: StringFieldUpdateOperationsInput | string
    site?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UtilisateurCreateInput = {
    email: string
    nom: string
    postnom: string
    nom_complet?: string | null
    sexe?: $Enums.Sexe | null
    role?: $Enums.Role
    poste?: $Enums.Poste | null
    picture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Adresse?: AdresseCreateNestedManyWithoutUtilisateurInput
    Contact?: ContactCreateNestedManyWithoutUtilisateurInput
    Produit?: ProduitCreateNestedManyWithoutUtilisateurInput
    Vente?: VenteCreateNestedManyWithoutUtilisateurInput
    Achat?: AchatCreateNestedManyWithoutUtilisateurInput
    Teneur?: TeneurCreateNestedManyWithoutUtilisateurInput
    Devise?: DeviseCreateNestedManyWithoutUtilisateurInput
    Panier?: PanierCreateNestedManyWithoutUtilisateurInput
    Reservation?: ReservationCreateNestedManyWithoutUtilisateurInput
    Commande?: CommandeCreateNestedManyWithoutClientInput
    Caisse?: CaisseCreateNestedManyWithoutUtilisateurInput
    MouvementCaisse?: MouvementCaisseCreateNestedManyWithoutUtilisateurInput
    ClotureCaisse?: ClotureCaisseCreateNestedManyWithoutUtilisateurClotureInput
  }

  export type UtilisateurUncheckedCreateInput = {
    id?: number
    email: string
    nom: string
    postnom: string
    nom_complet?: string | null
    sexe?: $Enums.Sexe | null
    role?: $Enums.Role
    poste?: $Enums.Poste | null
    picture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Adresse?: AdresseUncheckedCreateNestedManyWithoutUtilisateurInput
    Contact?: ContactUncheckedCreateNestedManyWithoutUtilisateurInput
    Produit?: ProduitUncheckedCreateNestedManyWithoutUtilisateurInput
    Vente?: VenteUncheckedCreateNestedManyWithoutUtilisateurInput
    Achat?: AchatUncheckedCreateNestedManyWithoutUtilisateurInput
    Teneur?: TeneurUncheckedCreateNestedManyWithoutUtilisateurInput
    Devise?: DeviseUncheckedCreateNestedManyWithoutUtilisateurInput
    Panier?: PanierUncheckedCreateNestedManyWithoutUtilisateurInput
    Reservation?: ReservationUncheckedCreateNestedManyWithoutUtilisateurInput
    Commande?: CommandeUncheckedCreateNestedManyWithoutClientInput
    Caisse?: CaisseUncheckedCreateNestedManyWithoutUtilisateurInput
    MouvementCaisse?: MouvementCaisseUncheckedCreateNestedManyWithoutUtilisateurInput
    ClotureCaisse?: ClotureCaisseUncheckedCreateNestedManyWithoutUtilisateurClotureInput
  }

  export type UtilisateurUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    postnom?: StringFieldUpdateOperationsInput | string
    nom_complet?: NullableStringFieldUpdateOperationsInput | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    poste?: NullableEnumPosteFieldUpdateOperationsInput | $Enums.Poste | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Adresse?: AdresseUpdateManyWithoutUtilisateurNestedInput
    Contact?: ContactUpdateManyWithoutUtilisateurNestedInput
    Produit?: ProduitUpdateManyWithoutUtilisateurNestedInput
    Vente?: VenteUpdateManyWithoutUtilisateurNestedInput
    Achat?: AchatUpdateManyWithoutUtilisateurNestedInput
    Teneur?: TeneurUpdateManyWithoutUtilisateurNestedInput
    Devise?: DeviseUpdateManyWithoutUtilisateurNestedInput
    Panier?: PanierUpdateManyWithoutUtilisateurNestedInput
    Reservation?: ReservationUpdateManyWithoutUtilisateurNestedInput
    Commande?: CommandeUpdateManyWithoutClientNestedInput
    Caisse?: CaisseUpdateManyWithoutUtilisateurNestedInput
    MouvementCaisse?: MouvementCaisseUpdateManyWithoutUtilisateurNestedInput
    ClotureCaisse?: ClotureCaisseUpdateManyWithoutUtilisateurClotureNestedInput
  }

  export type UtilisateurUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    postnom?: StringFieldUpdateOperationsInput | string
    nom_complet?: NullableStringFieldUpdateOperationsInput | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    poste?: NullableEnumPosteFieldUpdateOperationsInput | $Enums.Poste | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Adresse?: AdresseUncheckedUpdateManyWithoutUtilisateurNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutUtilisateurNestedInput
    Produit?: ProduitUncheckedUpdateManyWithoutUtilisateurNestedInput
    Vente?: VenteUncheckedUpdateManyWithoutUtilisateurNestedInput
    Achat?: AchatUncheckedUpdateManyWithoutUtilisateurNestedInput
    Teneur?: TeneurUncheckedUpdateManyWithoutUtilisateurNestedInput
    Devise?: DeviseUncheckedUpdateManyWithoutUtilisateurNestedInput
    Panier?: PanierUncheckedUpdateManyWithoutUtilisateurNestedInput
    Reservation?: ReservationUncheckedUpdateManyWithoutUtilisateurNestedInput
    Commande?: CommandeUncheckedUpdateManyWithoutClientNestedInput
    Caisse?: CaisseUncheckedUpdateManyWithoutUtilisateurNestedInput
    MouvementCaisse?: MouvementCaisseUncheckedUpdateManyWithoutUtilisateurNestedInput
    ClotureCaisse?: ClotureCaisseUncheckedUpdateManyWithoutUtilisateurClotureNestedInput
  }

  export type UtilisateurCreateManyInput = {
    id?: number
    email: string
    nom: string
    postnom: string
    nom_complet?: string | null
    sexe?: $Enums.Sexe | null
    role?: $Enums.Role
    poste?: $Enums.Poste | null
    picture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UtilisateurUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    postnom?: StringFieldUpdateOperationsInput | string
    nom_complet?: NullableStringFieldUpdateOperationsInput | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    poste?: NullableEnumPosteFieldUpdateOperationsInput | $Enums.Poste | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UtilisateurUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    postnom?: StringFieldUpdateOperationsInput | string
    nom_complet?: NullableStringFieldUpdateOperationsInput | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    poste?: NullableEnumPosteFieldUpdateOperationsInput | $Enums.Poste | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdresseCreateInput = {
    ville: string
    commune: string
    adresse: string
    createdAt?: Date | string
    updatedAt?: Date | string
    utilisateur?: UtilisateurCreateNestedOneWithoutAdresseInput
    fournisseur?: FournisseurCreateNestedOneWithoutAdresseInput
    Reservation?: ReservationCreateNestedManyWithoutAdresseInput
    Commande?: CommandeCreateNestedManyWithoutAdresseInput
  }

  export type AdresseUncheckedCreateInput = {
    id?: number
    ville: string
    commune: string
    adresse: string
    utilisateurId?: number | null
    fournisseurId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Reservation?: ReservationUncheckedCreateNestedManyWithoutAdresseInput
    Commande?: CommandeUncheckedCreateNestedManyWithoutAdresseInput
  }

  export type AdresseUpdateInput = {
    ville?: StringFieldUpdateOperationsInput | string
    commune?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    utilisateur?: UtilisateurUpdateOneWithoutAdresseNestedInput
    fournisseur?: FournisseurUpdateOneWithoutAdresseNestedInput
    Reservation?: ReservationUpdateManyWithoutAdresseNestedInput
    Commande?: CommandeUpdateManyWithoutAdresseNestedInput
  }

  export type AdresseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ville?: StringFieldUpdateOperationsInput | string
    commune?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    utilisateurId?: NullableIntFieldUpdateOperationsInput | number | null
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Reservation?: ReservationUncheckedUpdateManyWithoutAdresseNestedInput
    Commande?: CommandeUncheckedUpdateManyWithoutAdresseNestedInput
  }

  export type AdresseCreateManyInput = {
    id?: number
    ville: string
    commune: string
    adresse: string
    utilisateurId?: number | null
    fournisseurId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdresseUpdateManyMutationInput = {
    ville?: StringFieldUpdateOperationsInput | string
    commune?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdresseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ville?: StringFieldUpdateOperationsInput | string
    commune?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    utilisateurId?: NullableIntFieldUpdateOperationsInput | number | null
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactCreateInput = {
    tel: string
    createdAt?: Date | string
    updatedAt?: Date | string
    utilisateur?: UtilisateurCreateNestedOneWithoutContactInput
    fournisseur?: FournisseurCreateNestedOneWithoutContactInput
    Reservation?: ReservationCreateNestedManyWithoutContactInput
    Commande?: CommandeCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateInput = {
    id?: number
    tel: string
    utilisateurId?: number | null
    fournisseurId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Reservation?: ReservationUncheckedCreateNestedManyWithoutContactInput
    Commande?: CommandeUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactUpdateInput = {
    tel?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    utilisateur?: UtilisateurUpdateOneWithoutContactNestedInput
    fournisseur?: FournisseurUpdateOneWithoutContactNestedInput
    Reservation?: ReservationUpdateManyWithoutContactNestedInput
    Commande?: CommandeUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tel?: StringFieldUpdateOperationsInput | string
    utilisateurId?: NullableIntFieldUpdateOperationsInput | number | null
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Reservation?: ReservationUncheckedUpdateManyWithoutContactNestedInput
    Commande?: CommandeUncheckedUpdateManyWithoutContactNestedInput
  }

  export type ContactCreateManyInput = {
    id?: number
    tel: string
    utilisateurId?: number | null
    fournisseurId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactUpdateManyMutationInput = {
    tel?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tel?: StringFieldUpdateOperationsInput | string
    utilisateurId?: NullableIntFieldUpdateOperationsInput | number | null
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FournisseurCreateInput = {
    nom: string
    email: string
    code_postal?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Vente?: VenteCreateNestedManyWithoutFournisseurInput
    Achat?: AchatCreateNestedManyWithoutFournisseurInput
    Adresse?: AdresseCreateNestedManyWithoutFournisseurInput
    Contact?: ContactCreateNestedManyWithoutFournisseurInput
    Reservation?: ReservationCreateNestedManyWithoutFournisseurInput
    Commande?: CommandeCreateNestedManyWithoutFournisseurInput
  }

  export type FournisseurUncheckedCreateInput = {
    id?: number
    nom: string
    email: string
    code_postal?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Vente?: VenteUncheckedCreateNestedManyWithoutFournisseurInput
    Achat?: AchatUncheckedCreateNestedManyWithoutFournisseurInput
    Adresse?: AdresseUncheckedCreateNestedManyWithoutFournisseurInput
    Contact?: ContactUncheckedCreateNestedManyWithoutFournisseurInput
    Reservation?: ReservationUncheckedCreateNestedManyWithoutFournisseurInput
    Commande?: CommandeUncheckedCreateNestedManyWithoutFournisseurInput
  }

  export type FournisseurUpdateInput = {
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    code_postal?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Vente?: VenteUpdateManyWithoutFournisseurNestedInput
    Achat?: AchatUpdateManyWithoutFournisseurNestedInput
    Adresse?: AdresseUpdateManyWithoutFournisseurNestedInput
    Contact?: ContactUpdateManyWithoutFournisseurNestedInput
    Reservation?: ReservationUpdateManyWithoutFournisseurNestedInput
    Commande?: CommandeUpdateManyWithoutFournisseurNestedInput
  }

  export type FournisseurUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    code_postal?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Vente?: VenteUncheckedUpdateManyWithoutFournisseurNestedInput
    Achat?: AchatUncheckedUpdateManyWithoutFournisseurNestedInput
    Adresse?: AdresseUncheckedUpdateManyWithoutFournisseurNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutFournisseurNestedInput
    Reservation?: ReservationUncheckedUpdateManyWithoutFournisseurNestedInput
    Commande?: CommandeUncheckedUpdateManyWithoutFournisseurNestedInput
  }

  export type FournisseurCreateManyInput = {
    id?: number
    nom: string
    email: string
    code_postal?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FournisseurUpdateManyMutationInput = {
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    code_postal?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FournisseurUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    code_postal?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeneurCreateInput = {
    valeur: number
    createdAt?: Date | string
    updatedAt?: Date | string
    utilisateur: UtilisateurCreateNestedOneWithoutTeneurInput
    Produit?: ProduitCreateNestedManyWithoutTeneurInput
    DetailClotureCaisse?: DetailClotureCaisseCreateNestedManyWithoutTeneurInput
  }

  export type TeneurUncheckedCreateInput = {
    id?: number
    valeur: number
    utilisateurId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    Produit?: ProduitUncheckedCreateNestedManyWithoutTeneurInput
    DetailClotureCaisse?: DetailClotureCaisseUncheckedCreateNestedManyWithoutTeneurInput
  }

  export type TeneurUpdateInput = {
    valeur?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    utilisateur?: UtilisateurUpdateOneRequiredWithoutTeneurNestedInput
    Produit?: ProduitUpdateManyWithoutTeneurNestedInput
    DetailClotureCaisse?: DetailClotureCaisseUpdateManyWithoutTeneurNestedInput
  }

  export type TeneurUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    valeur?: FloatFieldUpdateOperationsInput | number
    utilisateurId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Produit?: ProduitUncheckedUpdateManyWithoutTeneurNestedInput
    DetailClotureCaisse?: DetailClotureCaisseUncheckedUpdateManyWithoutTeneurNestedInput
  }

  export type TeneurCreateManyInput = {
    id?: number
    valeur: number
    utilisateurId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeneurUpdateManyMutationInput = {
    valeur?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeneurUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    valeur?: FloatFieldUpdateOperationsInput | number
    utilisateurId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviseCreateInput = {
    nom: string
    code: string
    symbole: string
    createdAt?: Date | string
    updatedAt?: Date | string
    utilisateur: UtilisateurCreateNestedOneWithoutDeviseInput
    Produit?: ProduitCreateNestedManyWithoutDeviseInput
    Paiement?: PaiementCreateNestedManyWithoutDeviseInput
    Caisse?: CaisseCreateNestedManyWithoutDeviseInput
  }

  export type DeviseUncheckedCreateInput = {
    id?: number
    nom: string
    code: string
    symbole: string
    utilisateurId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    Produit?: ProduitUncheckedCreateNestedManyWithoutDeviseInput
    Paiement?: PaiementUncheckedCreateNestedManyWithoutDeviseInput
    Caisse?: CaisseUncheckedCreateNestedManyWithoutDeviseInput
  }

  export type DeviseUpdateInput = {
    nom?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    symbole?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    utilisateur?: UtilisateurUpdateOneRequiredWithoutDeviseNestedInput
    Produit?: ProduitUpdateManyWithoutDeviseNestedInput
    Paiement?: PaiementUpdateManyWithoutDeviseNestedInput
    Caisse?: CaisseUpdateManyWithoutDeviseNestedInput
  }

  export type DeviseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    symbole?: StringFieldUpdateOperationsInput | string
    utilisateurId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Produit?: ProduitUncheckedUpdateManyWithoutDeviseNestedInput
    Paiement?: PaiementUncheckedUpdateManyWithoutDeviseNestedInput
    Caisse?: CaisseUncheckedUpdateManyWithoutDeviseNestedInput
  }

  export type DeviseCreateManyInput = {
    id?: number
    nom: string
    code: string
    symbole: string
    utilisateurId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeviseUpdateManyMutationInput = {
    nom?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    symbole?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    symbole?: StringFieldUpdateOperationsInput | string
    utilisateurId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProduitCreateInput = {
    designation: string
    prix: number
    qtte?: number
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    devise: DeviseCreateNestedOneWithoutProduitInput
    teneur: TeneurCreateNestedOneWithoutProduitInput
    utilisateur: UtilisateurCreateNestedOneWithoutProduitInput
    DetailPanier?: DetailPanierCreateNestedManyWithoutProduitInput
    DetailClotureCaisse?: DetailClotureCaisseCreateNestedManyWithoutProduitInput
  }

  export type ProduitUncheckedCreateInput = {
    id?: number
    designation: string
    prix: number
    qtte?: number
    description: string
    deviseId: number
    teneurId: number
    utilisateurId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    DetailPanier?: DetailPanierUncheckedCreateNestedManyWithoutProduitInput
    DetailClotureCaisse?: DetailClotureCaisseUncheckedCreateNestedManyWithoutProduitInput
  }

  export type ProduitUpdateInput = {
    designation?: StringFieldUpdateOperationsInput | string
    prix?: FloatFieldUpdateOperationsInput | number
    qtte?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    devise?: DeviseUpdateOneRequiredWithoutProduitNestedInput
    teneur?: TeneurUpdateOneRequiredWithoutProduitNestedInput
    utilisateur?: UtilisateurUpdateOneRequiredWithoutProduitNestedInput
    DetailPanier?: DetailPanierUpdateManyWithoutProduitNestedInput
    DetailClotureCaisse?: DetailClotureCaisseUpdateManyWithoutProduitNestedInput
  }

  export type ProduitUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    designation?: StringFieldUpdateOperationsInput | string
    prix?: FloatFieldUpdateOperationsInput | number
    qtte?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    deviseId?: IntFieldUpdateOperationsInput | number
    teneurId?: IntFieldUpdateOperationsInput | number
    utilisateurId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DetailPanier?: DetailPanierUncheckedUpdateManyWithoutProduitNestedInput
    DetailClotureCaisse?: DetailClotureCaisseUncheckedUpdateManyWithoutProduitNestedInput
  }

  export type ProduitCreateManyInput = {
    id?: number
    designation: string
    prix: number
    qtte?: number
    description: string
    deviseId: number
    teneurId: number
    utilisateurId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProduitUpdateManyMutationInput = {
    designation?: StringFieldUpdateOperationsInput | string
    prix?: FloatFieldUpdateOperationsInput | number
    qtte?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProduitUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    designation?: StringFieldUpdateOperationsInput | string
    prix?: FloatFieldUpdateOperationsInput | number
    qtte?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    deviseId?: IntFieldUpdateOperationsInput | number
    teneurId?: IntFieldUpdateOperationsInput | number
    utilisateurId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaiementCreateInput = {
    montant: number
    moyen_paiement: $Enums.MoyenPaiment
    createdAt?: Date | string
    updatedAt?: Date | string
    caisse: CaisseCreateNestedOneWithoutPaiementInput
    devise: DeviseCreateNestedOneWithoutPaiementInput
    Achat?: AchatCreateNestedManyWithoutPaiementInput
    Commande?: CommandeCreateNestedManyWithoutPaiementInput
    Vente?: VenteCreateNestedManyWithoutPaiementInput
  }

  export type PaiementUncheckedCreateInput = {
    id?: number
    montant: number
    moyen_paiement: $Enums.MoyenPaiment
    deviseId: number
    caisseId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    Achat?: AchatUncheckedCreateNestedManyWithoutPaiementInput
    Commande?: CommandeUncheckedCreateNestedManyWithoutPaiementInput
    Vente?: VenteUncheckedCreateNestedManyWithoutPaiementInput
  }

  export type PaiementUpdateInput = {
    montant?: FloatFieldUpdateOperationsInput | number
    moyen_paiement?: EnumMoyenPaimentFieldUpdateOperationsInput | $Enums.MoyenPaiment
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    caisse?: CaisseUpdateOneRequiredWithoutPaiementNestedInput
    devise?: DeviseUpdateOneRequiredWithoutPaiementNestedInput
    Achat?: AchatUpdateManyWithoutPaiementNestedInput
    Commande?: CommandeUpdateManyWithoutPaiementNestedInput
    Vente?: VenteUpdateManyWithoutPaiementNestedInput
  }

  export type PaiementUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    montant?: FloatFieldUpdateOperationsInput | number
    moyen_paiement?: EnumMoyenPaimentFieldUpdateOperationsInput | $Enums.MoyenPaiment
    deviseId?: IntFieldUpdateOperationsInput | number
    caisseId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Achat?: AchatUncheckedUpdateManyWithoutPaiementNestedInput
    Commande?: CommandeUncheckedUpdateManyWithoutPaiementNestedInput
    Vente?: VenteUncheckedUpdateManyWithoutPaiementNestedInput
  }

  export type PaiementCreateManyInput = {
    id?: number
    montant: number
    moyen_paiement: $Enums.MoyenPaiment
    deviseId: number
    caisseId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaiementUpdateManyMutationInput = {
    montant?: FloatFieldUpdateOperationsInput | number
    moyen_paiement?: EnumMoyenPaimentFieldUpdateOperationsInput | $Enums.MoyenPaiment
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaiementUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    montant?: FloatFieldUpdateOperationsInput | number
    moyen_paiement?: EnumMoyenPaimentFieldUpdateOperationsInput | $Enums.MoyenPaiment
    deviseId?: IntFieldUpdateOperationsInput | number
    caisseId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CaisseCreateInput = {
    nom: string
    description?: string | null
    soldeInitial: number
    soldeActuel: number
    statut?: $Enums.StatutCaisse
    createdAt?: Date | string
    updatedAt?: Date | string
    devise: DeviseCreateNestedOneWithoutCaisseInput
    utilisateur: UtilisateurCreateNestedOneWithoutCaisseInput
    MouvementCaisse?: MouvementCaisseCreateNestedManyWithoutCaisseInput
    clotures?: ClotureCaisseCreateNestedManyWithoutCaisseInput
    Paiement?: PaiementCreateNestedManyWithoutCaisseInput
  }

  export type CaisseUncheckedCreateInput = {
    id?: number
    nom: string
    description?: string | null
    soldeInitial: number
    soldeActuel: number
    deviseId: number
    creeParId: number
    statut?: $Enums.StatutCaisse
    createdAt?: Date | string
    updatedAt?: Date | string
    MouvementCaisse?: MouvementCaisseUncheckedCreateNestedManyWithoutCaisseInput
    clotures?: ClotureCaisseUncheckedCreateNestedManyWithoutCaisseInput
    Paiement?: PaiementUncheckedCreateNestedManyWithoutCaisseInput
  }

  export type CaisseUpdateInput = {
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    soldeInitial?: FloatFieldUpdateOperationsInput | number
    soldeActuel?: FloatFieldUpdateOperationsInput | number
    statut?: EnumStatutCaisseFieldUpdateOperationsInput | $Enums.StatutCaisse
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    devise?: DeviseUpdateOneRequiredWithoutCaisseNestedInput
    utilisateur?: UtilisateurUpdateOneRequiredWithoutCaisseNestedInput
    MouvementCaisse?: MouvementCaisseUpdateManyWithoutCaisseNestedInput
    clotures?: ClotureCaisseUpdateManyWithoutCaisseNestedInput
    Paiement?: PaiementUpdateManyWithoutCaisseNestedInput
  }

  export type CaisseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    soldeInitial?: FloatFieldUpdateOperationsInput | number
    soldeActuel?: FloatFieldUpdateOperationsInput | number
    deviseId?: IntFieldUpdateOperationsInput | number
    creeParId?: IntFieldUpdateOperationsInput | number
    statut?: EnumStatutCaisseFieldUpdateOperationsInput | $Enums.StatutCaisse
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    MouvementCaisse?: MouvementCaisseUncheckedUpdateManyWithoutCaisseNestedInput
    clotures?: ClotureCaisseUncheckedUpdateManyWithoutCaisseNestedInput
    Paiement?: PaiementUncheckedUpdateManyWithoutCaisseNestedInput
  }

  export type CaisseCreateManyInput = {
    id?: number
    nom: string
    description?: string | null
    soldeInitial: number
    soldeActuel: number
    deviseId: number
    creeParId: number
    statut?: $Enums.StatutCaisse
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CaisseUpdateManyMutationInput = {
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    soldeInitial?: FloatFieldUpdateOperationsInput | number
    soldeActuel?: FloatFieldUpdateOperationsInput | number
    statut?: EnumStatutCaisseFieldUpdateOperationsInput | $Enums.StatutCaisse
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CaisseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    soldeInitial?: FloatFieldUpdateOperationsInput | number
    soldeActuel?: FloatFieldUpdateOperationsInput | number
    deviseId?: IntFieldUpdateOperationsInput | number
    creeParId?: IntFieldUpdateOperationsInput | number
    statut?: EnumStatutCaisseFieldUpdateOperationsInput | $Enums.StatutCaisse
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VenteCreateInput = {
    statut?: $Enums.StatutVente
    total_ttc: number
    total_ht: number
    type_acheteur: $Enums.TypeClient
    clientId?: number | null
    agentId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    paiement?: PaiementCreateNestedOneWithoutVenteInput
    panier: PanierCreateNestedOneWithoutVenteInput
    utilisateur: UtilisateurCreateNestedOneWithoutVenteInput
    fournisseur?: FournisseurCreateNestedOneWithoutVenteInput
  }

  export type VenteUncheckedCreateInput = {
    id?: number
    statut?: $Enums.StatutVente
    total_ttc: number
    total_ht: number
    type_acheteur: $Enums.TypeClient
    clientId?: number | null
    enregistrerParId: number
    fournisseurId?: number | null
    agentId?: number | null
    paiementId: number
    panierId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VenteUpdateInput = {
    statut?: EnumStatutVenteFieldUpdateOperationsInput | $Enums.StatutVente
    total_ttc?: FloatFieldUpdateOperationsInput | number
    total_ht?: FloatFieldUpdateOperationsInput | number
    type_acheteur?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    agentId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paiement?: PaiementUpdateOneWithoutVenteNestedInput
    panier?: PanierUpdateOneRequiredWithoutVenteNestedInput
    utilisateur?: UtilisateurUpdateOneRequiredWithoutVenteNestedInput
    fournisseur?: FournisseurUpdateOneWithoutVenteNestedInput
  }

  export type VenteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    statut?: EnumStatutVenteFieldUpdateOperationsInput | $Enums.StatutVente
    total_ttc?: FloatFieldUpdateOperationsInput | number
    total_ht?: FloatFieldUpdateOperationsInput | number
    type_acheteur?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    enregistrerParId?: IntFieldUpdateOperationsInput | number
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    agentId?: NullableIntFieldUpdateOperationsInput | number | null
    paiementId?: IntFieldUpdateOperationsInput | number
    panierId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VenteCreateManyInput = {
    id?: number
    statut?: $Enums.StatutVente
    total_ttc: number
    total_ht: number
    type_acheteur: $Enums.TypeClient
    clientId?: number | null
    enregistrerParId: number
    fournisseurId?: number | null
    agentId?: number | null
    paiementId: number
    panierId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VenteUpdateManyMutationInput = {
    statut?: EnumStatutVenteFieldUpdateOperationsInput | $Enums.StatutVente
    total_ttc?: FloatFieldUpdateOperationsInput | number
    total_ht?: FloatFieldUpdateOperationsInput | number
    type_acheteur?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    agentId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VenteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    statut?: EnumStatutVenteFieldUpdateOperationsInput | $Enums.StatutVente
    total_ttc?: FloatFieldUpdateOperationsInput | number
    total_ht?: FloatFieldUpdateOperationsInput | number
    type_acheteur?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    enregistrerParId?: IntFieldUpdateOperationsInput | number
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    agentId?: NullableIntFieldUpdateOperationsInput | number | null
    paiementId?: IntFieldUpdateOperationsInput | number
    panierId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PanierCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    utilisateur: UtilisateurCreateNestedOneWithoutPanierInput
    DetailPanier?: DetailPanierCreateNestedManyWithoutPanierInput
    Achat?: AchatCreateNestedManyWithoutPanierInput
    Vente?: VenteCreateNestedManyWithoutPanierInput
    Reservation?: ReservationCreateNestedManyWithoutPanierInput
    Commande?: CommandeCreateNestedManyWithoutPanierInput
  }

  export type PanierUncheckedCreateInput = {
    id?: number
    utilisateurId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    DetailPanier?: DetailPanierUncheckedCreateNestedManyWithoutPanierInput
    Achat?: AchatUncheckedCreateNestedManyWithoutPanierInput
    Vente?: VenteUncheckedCreateNestedManyWithoutPanierInput
    Reservation?: ReservationUncheckedCreateNestedManyWithoutPanierInput
    Commande?: CommandeUncheckedCreateNestedManyWithoutPanierInput
  }

  export type PanierUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    utilisateur?: UtilisateurUpdateOneRequiredWithoutPanierNestedInput
    DetailPanier?: DetailPanierUpdateManyWithoutPanierNestedInput
    Achat?: AchatUpdateManyWithoutPanierNestedInput
    Vente?: VenteUpdateManyWithoutPanierNestedInput
    Reservation?: ReservationUpdateManyWithoutPanierNestedInput
    Commande?: CommandeUpdateManyWithoutPanierNestedInput
  }

  export type PanierUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    utilisateurId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DetailPanier?: DetailPanierUncheckedUpdateManyWithoutPanierNestedInput
    Achat?: AchatUncheckedUpdateManyWithoutPanierNestedInput
    Vente?: VenteUncheckedUpdateManyWithoutPanierNestedInput
    Reservation?: ReservationUncheckedUpdateManyWithoutPanierNestedInput
    Commande?: CommandeUncheckedUpdateManyWithoutPanierNestedInput
  }

  export type PanierCreateManyInput = {
    id?: number
    utilisateurId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PanierUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PanierUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    utilisateurId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DetailPanierCreateInput = {
    qtte: number
    prixUnitaire: number
    prixTotal: number
    createdAt?: Date | string
    updatedAt?: Date | string
    produit: ProduitCreateNestedOneWithoutDetailPanierInput
    panier: PanierCreateNestedOneWithoutDetailPanierInput
  }

  export type DetailPanierUncheckedCreateInput = {
    id?: number
    produitId: number
    qtte: number
    prixUnitaire: number
    prixTotal: number
    panierId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DetailPanierUpdateInput = {
    qtte?: IntFieldUpdateOperationsInput | number
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    prixTotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    produit?: ProduitUpdateOneRequiredWithoutDetailPanierNestedInput
    panier?: PanierUpdateOneRequiredWithoutDetailPanierNestedInput
  }

  export type DetailPanierUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    produitId?: IntFieldUpdateOperationsInput | number
    qtte?: IntFieldUpdateOperationsInput | number
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    prixTotal?: FloatFieldUpdateOperationsInput | number
    panierId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DetailPanierCreateManyInput = {
    id?: number
    produitId: number
    qtte: number
    prixUnitaire: number
    prixTotal: number
    panierId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DetailPanierUpdateManyMutationInput = {
    qtte?: IntFieldUpdateOperationsInput | number
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    prixTotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DetailPanierUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    produitId?: IntFieldUpdateOperationsInput | number
    qtte?: IntFieldUpdateOperationsInput | number
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    prixTotal?: FloatFieldUpdateOperationsInput | number
    panierId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchatCreateInput = {
    statut?: $Enums.StatutAchat
    createdAt?: Date | string
    updatedAt?: Date | string
    panier: PanierCreateNestedOneWithoutAchatInput
    fournisseur: FournisseurCreateNestedOneWithoutAchatInput
    utilisateur: UtilisateurCreateNestedOneWithoutAchatInput
    paiement: PaiementCreateNestedOneWithoutAchatInput
  }

  export type AchatUncheckedCreateInput = {
    id?: number
    statut?: $Enums.StatutAchat
    panierId: number
    fournisseurId: number
    enregistrerParId: number
    paiementId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AchatUpdateInput = {
    statut?: EnumStatutAchatFieldUpdateOperationsInput | $Enums.StatutAchat
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    panier?: PanierUpdateOneRequiredWithoutAchatNestedInput
    fournisseur?: FournisseurUpdateOneRequiredWithoutAchatNestedInput
    utilisateur?: UtilisateurUpdateOneRequiredWithoutAchatNestedInput
    paiement?: PaiementUpdateOneRequiredWithoutAchatNestedInput
  }

  export type AchatUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    statut?: EnumStatutAchatFieldUpdateOperationsInput | $Enums.StatutAchat
    panierId?: IntFieldUpdateOperationsInput | number
    fournisseurId?: IntFieldUpdateOperationsInput | number
    enregistrerParId?: IntFieldUpdateOperationsInput | number
    paiementId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchatCreateManyInput = {
    id?: number
    statut?: $Enums.StatutAchat
    panierId: number
    fournisseurId: number
    enregistrerParId: number
    paiementId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AchatUpdateManyMutationInput = {
    statut?: EnumStatutAchatFieldUpdateOperationsInput | $Enums.StatutAchat
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchatUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    statut?: EnumStatutAchatFieldUpdateOperationsInput | $Enums.StatutAchat
    panierId?: IntFieldUpdateOperationsInput | number
    fournisseurId?: IntFieldUpdateOperationsInput | number
    enregistrerParId?: IntFieldUpdateOperationsInput | number
    paiementId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReservationCreateInput = {
    dateLivraisonSouhaitee: Date | string
    adresseLivraison?: string | null
    statut?: $Enums.StatutReservation
    notes?: string | null
    type_client?: $Enums.TypeClient
    nom?: string | null
    tel?: string | null
    enregistrerParId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    panier: PanierCreateNestedOneWithoutReservationInput
    utilisateur?: UtilisateurCreateNestedOneWithoutReservationInput
    fournisseur?: FournisseurCreateNestedOneWithoutReservationInput
    adresse?: AdresseCreateNestedOneWithoutReservationInput
    contact?: ContactCreateNestedOneWithoutReservationInput
  }

  export type ReservationUncheckedCreateInput = {
    id?: number
    dateLivraisonSouhaitee: Date | string
    adresseLivraison?: string | null
    statut?: $Enums.StatutReservation
    notes?: string | null
    type_client?: $Enums.TypeClient
    clientId?: number | null
    panierId: number
    nom?: string | null
    tel?: string | null
    adresseId?: number | null
    contactId?: number | null
    enregistrerParId?: number | null
    fournisseurId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReservationUpdateInput = {
    dateLivraisonSouhaitee?: DateTimeFieldUpdateOperationsInput | Date | string
    adresseLivraison?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: EnumStatutReservationFieldUpdateOperationsInput | $Enums.StatutReservation
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    type_client?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    enregistrerParId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    panier?: PanierUpdateOneRequiredWithoutReservationNestedInput
    utilisateur?: UtilisateurUpdateOneWithoutReservationNestedInput
    fournisseur?: FournisseurUpdateOneWithoutReservationNestedInput
    adresse?: AdresseUpdateOneWithoutReservationNestedInput
    contact?: ContactUpdateOneWithoutReservationNestedInput
  }

  export type ReservationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateLivraisonSouhaitee?: DateTimeFieldUpdateOperationsInput | Date | string
    adresseLivraison?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: EnumStatutReservationFieldUpdateOperationsInput | $Enums.StatutReservation
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    type_client?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    panierId?: IntFieldUpdateOperationsInput | number
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    adresseId?: NullableIntFieldUpdateOperationsInput | number | null
    contactId?: NullableIntFieldUpdateOperationsInput | number | null
    enregistrerParId?: NullableIntFieldUpdateOperationsInput | number | null
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReservationCreateManyInput = {
    id?: number
    dateLivraisonSouhaitee: Date | string
    adresseLivraison?: string | null
    statut?: $Enums.StatutReservation
    notes?: string | null
    type_client?: $Enums.TypeClient
    clientId?: number | null
    panierId: number
    nom?: string | null
    tel?: string | null
    adresseId?: number | null
    contactId?: number | null
    enregistrerParId?: number | null
    fournisseurId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReservationUpdateManyMutationInput = {
    dateLivraisonSouhaitee?: DateTimeFieldUpdateOperationsInput | Date | string
    adresseLivraison?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: EnumStatutReservationFieldUpdateOperationsInput | $Enums.StatutReservation
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    type_client?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    enregistrerParId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReservationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateLivraisonSouhaitee?: DateTimeFieldUpdateOperationsInput | Date | string
    adresseLivraison?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: EnumStatutReservationFieldUpdateOperationsInput | $Enums.StatutReservation
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    type_client?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    panierId?: IntFieldUpdateOperationsInput | number
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    adresseId?: NullableIntFieldUpdateOperationsInput | number | null
    contactId?: NullableIntFieldUpdateOperationsInput | number | null
    enregistrerParId?: NullableIntFieldUpdateOperationsInput | number | null
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommandeCreateInput = {
    nom?: string | null
    tel?: string | null
    type_client?: $Enums.TypeClient
    notes?: string | null
    dateLivraisonEffective?: Date | string | null
    adresseLivraison?: string | null
    enregistrerParId?: number | null
    statut?: $Enums.StatutCommande
    createdAt?: Date | string
    updatedAt?: Date | string
    panier: PanierCreateNestedOneWithoutCommandeInput
    client?: UtilisateurCreateNestedOneWithoutCommandeInput
    paiement: PaiementCreateNestedOneWithoutCommandeInput
    fournisseur?: FournisseurCreateNestedOneWithoutCommandeInput
    adresse?: AdresseCreateNestedOneWithoutCommandeInput
    contact?: ContactCreateNestedOneWithoutCommandeInput
  }

  export type CommandeUncheckedCreateInput = {
    id?: number
    panierId: number
    clientId?: number | null
    nom?: string | null
    tel?: string | null
    type_client?: $Enums.TypeClient
    paiementId: number
    adresseId?: number | null
    contactId?: number | null
    fournisseurId?: number | null
    notes?: string | null
    dateLivraisonEffective?: Date | string | null
    adresseLivraison?: string | null
    enregistrerParId?: number | null
    statut?: $Enums.StatutCommande
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommandeUpdateInput = {
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    type_client?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    dateLivraisonEffective?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adresseLivraison?: NullableStringFieldUpdateOperationsInput | string | null
    enregistrerParId?: NullableIntFieldUpdateOperationsInput | number | null
    statut?: EnumStatutCommandeFieldUpdateOperationsInput | $Enums.StatutCommande
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    panier?: PanierUpdateOneRequiredWithoutCommandeNestedInput
    client?: UtilisateurUpdateOneWithoutCommandeNestedInput
    paiement?: PaiementUpdateOneRequiredWithoutCommandeNestedInput
    fournisseur?: FournisseurUpdateOneWithoutCommandeNestedInput
    adresse?: AdresseUpdateOneWithoutCommandeNestedInput
    contact?: ContactUpdateOneWithoutCommandeNestedInput
  }

  export type CommandeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    panierId?: IntFieldUpdateOperationsInput | number
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    type_client?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    paiementId?: IntFieldUpdateOperationsInput | number
    adresseId?: NullableIntFieldUpdateOperationsInput | number | null
    contactId?: NullableIntFieldUpdateOperationsInput | number | null
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    dateLivraisonEffective?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adresseLivraison?: NullableStringFieldUpdateOperationsInput | string | null
    enregistrerParId?: NullableIntFieldUpdateOperationsInput | number | null
    statut?: EnumStatutCommandeFieldUpdateOperationsInput | $Enums.StatutCommande
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommandeCreateManyInput = {
    id?: number
    panierId: number
    clientId?: number | null
    nom?: string | null
    tel?: string | null
    type_client?: $Enums.TypeClient
    paiementId: number
    adresseId?: number | null
    contactId?: number | null
    fournisseurId?: number | null
    notes?: string | null
    dateLivraisonEffective?: Date | string | null
    adresseLivraison?: string | null
    enregistrerParId?: number | null
    statut?: $Enums.StatutCommande
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommandeUpdateManyMutationInput = {
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    type_client?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    dateLivraisonEffective?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adresseLivraison?: NullableStringFieldUpdateOperationsInput | string | null
    enregistrerParId?: NullableIntFieldUpdateOperationsInput | number | null
    statut?: EnumStatutCommandeFieldUpdateOperationsInput | $Enums.StatutCommande
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommandeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    panierId?: IntFieldUpdateOperationsInput | number
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    type_client?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    paiementId?: IntFieldUpdateOperationsInput | number
    adresseId?: NullableIntFieldUpdateOperationsInput | number | null
    contactId?: NullableIntFieldUpdateOperationsInput | number | null
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    dateLivraisonEffective?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adresseLivraison?: NullableStringFieldUpdateOperationsInput | string | null
    enregistrerParId?: NullableIntFieldUpdateOperationsInput | number | null
    statut?: EnumStatutCommandeFieldUpdateOperationsInput | $Enums.StatutCommande
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MouvementCaisseCreateInput = {
    type_mouvement?: $Enums.TypeMouvementCaisse
    categorie?: $Enums.CategorieMouvement
    montant: number
    description?: string | null
    referenceExterne?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    caisse: CaisseCreateNestedOneWithoutMouvementCaisseInput
    utilisateur: UtilisateurCreateNestedOneWithoutMouvementCaisseInput
  }

  export type MouvementCaisseUncheckedCreateInput = {
    id?: number
    caisseId: number
    type_mouvement?: $Enums.TypeMouvementCaisse
    categorie?: $Enums.CategorieMouvement
    montant: number
    description?: string | null
    enregistrerParId: number
    referenceExterne?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MouvementCaisseUpdateInput = {
    type_mouvement?: EnumTypeMouvementCaisseFieldUpdateOperationsInput | $Enums.TypeMouvementCaisse
    categorie?: EnumCategorieMouvementFieldUpdateOperationsInput | $Enums.CategorieMouvement
    montant?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    referenceExterne?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    caisse?: CaisseUpdateOneRequiredWithoutMouvementCaisseNestedInput
    utilisateur?: UtilisateurUpdateOneRequiredWithoutMouvementCaisseNestedInput
  }

  export type MouvementCaisseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    caisseId?: IntFieldUpdateOperationsInput | number
    type_mouvement?: EnumTypeMouvementCaisseFieldUpdateOperationsInput | $Enums.TypeMouvementCaisse
    categorie?: EnumCategorieMouvementFieldUpdateOperationsInput | $Enums.CategorieMouvement
    montant?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    enregistrerParId?: IntFieldUpdateOperationsInput | number
    referenceExterne?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MouvementCaisseCreateManyInput = {
    id?: number
    caisseId: number
    type_mouvement?: $Enums.TypeMouvementCaisse
    categorie?: $Enums.CategorieMouvement
    montant: number
    description?: string | null
    enregistrerParId: number
    referenceExterne?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MouvementCaisseUpdateManyMutationInput = {
    type_mouvement?: EnumTypeMouvementCaisseFieldUpdateOperationsInput | $Enums.TypeMouvementCaisse
    categorie?: EnumCategorieMouvementFieldUpdateOperationsInput | $Enums.CategorieMouvement
    montant?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    referenceExterne?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MouvementCaisseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    caisseId?: IntFieldUpdateOperationsInput | number
    type_mouvement?: EnumTypeMouvementCaisseFieldUpdateOperationsInput | $Enums.TypeMouvementCaisse
    categorie?: EnumCategorieMouvementFieldUpdateOperationsInput | $Enums.CategorieMouvement
    montant?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    enregistrerParId?: IntFieldUpdateOperationsInput | number
    referenceExterne?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DetailClotureCaisseCreateInput = {
    qtteRestante: number
    createdAt?: Date | string
    updatedAt?: Date | string
    produit: ProduitCreateNestedOneWithoutDetailClotureCaisseInput
    teneur: TeneurCreateNestedOneWithoutDetailClotureCaisseInput
    clotureCaisse: ClotureCaisseCreateNestedOneWithoutDetailClotureCaisseInput
  }

  export type DetailClotureCaisseUncheckedCreateInput = {
    id?: number
    produitId: number
    teneurId: number
    qtteRestante: number
    clotureCaisseId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DetailClotureCaisseUpdateInput = {
    qtteRestante?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    produit?: ProduitUpdateOneRequiredWithoutDetailClotureCaisseNestedInput
    teneur?: TeneurUpdateOneRequiredWithoutDetailClotureCaisseNestedInput
    clotureCaisse?: ClotureCaisseUpdateOneRequiredWithoutDetailClotureCaisseNestedInput
  }

  export type DetailClotureCaisseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    produitId?: IntFieldUpdateOperationsInput | number
    teneurId?: IntFieldUpdateOperationsInput | number
    qtteRestante?: IntFieldUpdateOperationsInput | number
    clotureCaisseId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DetailClotureCaisseCreateManyInput = {
    id?: number
    produitId: number
    teneurId: number
    qtteRestante: number
    clotureCaisseId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DetailClotureCaisseUpdateManyMutationInput = {
    qtteRestante?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DetailClotureCaisseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    produitId?: IntFieldUpdateOperationsInput | number
    teneurId?: IntFieldUpdateOperationsInput | number
    qtteRestante?: IntFieldUpdateOperationsInput | number
    clotureCaisseId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClotureCaisseCreateInput = {
    dateCloture?: Date | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    caisse: CaisseCreateNestedOneWithoutCloturesInput
    utilisateurCloture: UtilisateurCreateNestedOneWithoutClotureCaisseInput
    DetailClotureCaisse?: DetailClotureCaisseCreateNestedManyWithoutClotureCaisseInput
  }

  export type ClotureCaisseUncheckedCreateInput = {
    id?: number
    caisseId: number
    dateCloture?: Date | string
    utilisateurClotureId: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    DetailClotureCaisse?: DetailClotureCaisseUncheckedCreateNestedManyWithoutClotureCaisseInput
  }

  export type ClotureCaisseUpdateInput = {
    dateCloture?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    caisse?: CaisseUpdateOneRequiredWithoutCloturesNestedInput
    utilisateurCloture?: UtilisateurUpdateOneRequiredWithoutClotureCaisseNestedInput
    DetailClotureCaisse?: DetailClotureCaisseUpdateManyWithoutClotureCaisseNestedInput
  }

  export type ClotureCaisseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    caisseId?: IntFieldUpdateOperationsInput | number
    dateCloture?: DateTimeFieldUpdateOperationsInput | Date | string
    utilisateurClotureId?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DetailClotureCaisse?: DetailClotureCaisseUncheckedUpdateManyWithoutClotureCaisseNestedInput
  }

  export type ClotureCaisseCreateManyInput = {
    id?: number
    caisseId: number
    dateCloture?: Date | string
    utilisateurClotureId: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClotureCaisseUpdateManyMutationInput = {
    dateCloture?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClotureCaisseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    caisseId?: IntFieldUpdateOperationsInput | number
    dateCloture?: DateTimeFieldUpdateOperationsInput | Date | string
    utilisateurClotureId?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type EntrepriseCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    encronyme?: SortOrder
    code_postale?: SortOrder
    adresse?: SortOrder
    tel?: SortOrder
    site?: SortOrder
    email?: SortOrder
    description?: SortOrder
    logo?: SortOrder
  }

  export type EntrepriseAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EntrepriseMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    encronyme?: SortOrder
    code_postale?: SortOrder
    adresse?: SortOrder
    tel?: SortOrder
    site?: SortOrder
    email?: SortOrder
    description?: SortOrder
    logo?: SortOrder
  }

  export type EntrepriseMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    encronyme?: SortOrder
    code_postale?: SortOrder
    adresse?: SortOrder
    tel?: SortOrder
    site?: SortOrder
    email?: SortOrder
    description?: SortOrder
    logo?: SortOrder
  }

  export type EntrepriseSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumSexeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Sexe | EnumSexeFieldRefInput<$PrismaModel> | null
    in?: $Enums.Sexe[] | ListEnumSexeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Sexe[] | ListEnumSexeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSexeNullableFilter<$PrismaModel> | $Enums.Sexe | null
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type EnumPosteNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Poste | EnumPosteFieldRefInput<$PrismaModel> | null
    in?: $Enums.Poste[] | ListEnumPosteFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Poste[] | ListEnumPosteFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPosteNullableFilter<$PrismaModel> | $Enums.Poste | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type AdresseListRelationFilter = {
    every?: AdresseWhereInput
    some?: AdresseWhereInput
    none?: AdresseWhereInput
  }

  export type ContactListRelationFilter = {
    every?: ContactWhereInput
    some?: ContactWhereInput
    none?: ContactWhereInput
  }

  export type ProduitListRelationFilter = {
    every?: ProduitWhereInput
    some?: ProduitWhereInput
    none?: ProduitWhereInput
  }

  export type VenteListRelationFilter = {
    every?: VenteWhereInput
    some?: VenteWhereInput
    none?: VenteWhereInput
  }

  export type AchatListRelationFilter = {
    every?: AchatWhereInput
    some?: AchatWhereInput
    none?: AchatWhereInput
  }

  export type TeneurListRelationFilter = {
    every?: TeneurWhereInput
    some?: TeneurWhereInput
    none?: TeneurWhereInput
  }

  export type DeviseListRelationFilter = {
    every?: DeviseWhereInput
    some?: DeviseWhereInput
    none?: DeviseWhereInput
  }

  export type PanierListRelationFilter = {
    every?: PanierWhereInput
    some?: PanierWhereInput
    none?: PanierWhereInput
  }

  export type ReservationListRelationFilter = {
    every?: ReservationWhereInput
    some?: ReservationWhereInput
    none?: ReservationWhereInput
  }

  export type CommandeListRelationFilter = {
    every?: CommandeWhereInput
    some?: CommandeWhereInput
    none?: CommandeWhereInput
  }

  export type CaisseListRelationFilter = {
    every?: CaisseWhereInput
    some?: CaisseWhereInput
    none?: CaisseWhereInput
  }

  export type MouvementCaisseListRelationFilter = {
    every?: MouvementCaisseWhereInput
    some?: MouvementCaisseWhereInput
    none?: MouvementCaisseWhereInput
  }

  export type ClotureCaisseListRelationFilter = {
    every?: ClotureCaisseWhereInput
    some?: ClotureCaisseWhereInput
    none?: ClotureCaisseWhereInput
  }

  export type AdresseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContactOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProduitOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VenteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AchatOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeneurOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeviseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PanierOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReservationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommandeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CaisseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MouvementCaisseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClotureCaisseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UtilisateurCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    nom?: SortOrder
    postnom?: SortOrder
    nom_complet?: SortOrder
    sexe?: SortOrder
    role?: SortOrder
    poste?: SortOrder
    picture?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UtilisateurAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UtilisateurMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    nom?: SortOrder
    postnom?: SortOrder
    nom_complet?: SortOrder
    sexe?: SortOrder
    role?: SortOrder
    poste?: SortOrder
    picture?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UtilisateurMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    nom?: SortOrder
    postnom?: SortOrder
    nom_complet?: SortOrder
    sexe?: SortOrder
    role?: SortOrder
    poste?: SortOrder
    picture?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UtilisateurSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumSexeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Sexe | EnumSexeFieldRefInput<$PrismaModel> | null
    in?: $Enums.Sexe[] | ListEnumSexeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Sexe[] | ListEnumSexeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSexeNullableWithAggregatesFilter<$PrismaModel> | $Enums.Sexe | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSexeNullableFilter<$PrismaModel>
    _max?: NestedEnumSexeNullableFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type EnumPosteNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Poste | EnumPosteFieldRefInput<$PrismaModel> | null
    in?: $Enums.Poste[] | ListEnumPosteFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Poste[] | ListEnumPosteFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPosteNullableWithAggregatesFilter<$PrismaModel> | $Enums.Poste | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPosteNullableFilter<$PrismaModel>
    _max?: NestedEnumPosteNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UtilisateurNullableScalarRelationFilter = {
    is?: UtilisateurWhereInput | null
    isNot?: UtilisateurWhereInput | null
  }

  export type FournisseurNullableScalarRelationFilter = {
    is?: FournisseurWhereInput | null
    isNot?: FournisseurWhereInput | null
  }

  export type AdresseCountOrderByAggregateInput = {
    id?: SortOrder
    ville?: SortOrder
    commune?: SortOrder
    adresse?: SortOrder
    utilisateurId?: SortOrder
    fournisseurId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdresseAvgOrderByAggregateInput = {
    id?: SortOrder
    utilisateurId?: SortOrder
    fournisseurId?: SortOrder
  }

  export type AdresseMaxOrderByAggregateInput = {
    id?: SortOrder
    ville?: SortOrder
    commune?: SortOrder
    adresse?: SortOrder
    utilisateurId?: SortOrder
    fournisseurId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdresseMinOrderByAggregateInput = {
    id?: SortOrder
    ville?: SortOrder
    commune?: SortOrder
    adresse?: SortOrder
    utilisateurId?: SortOrder
    fournisseurId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdresseSumOrderByAggregateInput = {
    id?: SortOrder
    utilisateurId?: SortOrder
    fournisseurId?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type ContactCountOrderByAggregateInput = {
    id?: SortOrder
    tel?: SortOrder
    utilisateurId?: SortOrder
    fournisseurId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactAvgOrderByAggregateInput = {
    id?: SortOrder
    utilisateurId?: SortOrder
    fournisseurId?: SortOrder
  }

  export type ContactMaxOrderByAggregateInput = {
    id?: SortOrder
    tel?: SortOrder
    utilisateurId?: SortOrder
    fournisseurId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactMinOrderByAggregateInput = {
    id?: SortOrder
    tel?: SortOrder
    utilisateurId?: SortOrder
    fournisseurId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactSumOrderByAggregateInput = {
    id?: SortOrder
    utilisateurId?: SortOrder
    fournisseurId?: SortOrder
  }

  export type FournisseurCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    email?: SortOrder
    code_postal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FournisseurAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FournisseurMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    email?: SortOrder
    code_postal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FournisseurMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    email?: SortOrder
    code_postal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FournisseurSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type UtilisateurScalarRelationFilter = {
    is?: UtilisateurWhereInput
    isNot?: UtilisateurWhereInput
  }

  export type DetailClotureCaisseListRelationFilter = {
    every?: DetailClotureCaisseWhereInput
    some?: DetailClotureCaisseWhereInput
    none?: DetailClotureCaisseWhereInput
  }

  export type DetailClotureCaisseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeneurCountOrderByAggregateInput = {
    id?: SortOrder
    valeur?: SortOrder
    utilisateurId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeneurAvgOrderByAggregateInput = {
    id?: SortOrder
    valeur?: SortOrder
    utilisateurId?: SortOrder
  }

  export type TeneurMaxOrderByAggregateInput = {
    id?: SortOrder
    valeur?: SortOrder
    utilisateurId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeneurMinOrderByAggregateInput = {
    id?: SortOrder
    valeur?: SortOrder
    utilisateurId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeneurSumOrderByAggregateInput = {
    id?: SortOrder
    valeur?: SortOrder
    utilisateurId?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type PaiementListRelationFilter = {
    every?: PaiementWhereInput
    some?: PaiementWhereInput
    none?: PaiementWhereInput
  }

  export type PaiementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeviseCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    code?: SortOrder
    symbole?: SortOrder
    utilisateurId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeviseAvgOrderByAggregateInput = {
    id?: SortOrder
    utilisateurId?: SortOrder
  }

  export type DeviseMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    code?: SortOrder
    symbole?: SortOrder
    utilisateurId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeviseMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    code?: SortOrder
    symbole?: SortOrder
    utilisateurId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeviseSumOrderByAggregateInput = {
    id?: SortOrder
    utilisateurId?: SortOrder
  }

  export type DeviseScalarRelationFilter = {
    is?: DeviseWhereInput
    isNot?: DeviseWhereInput
  }

  export type TeneurScalarRelationFilter = {
    is?: TeneurWhereInput
    isNot?: TeneurWhereInput
  }

  export type DetailPanierListRelationFilter = {
    every?: DetailPanierWhereInput
    some?: DetailPanierWhereInput
    none?: DetailPanierWhereInput
  }

  export type DetailPanierOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProduitCountOrderByAggregateInput = {
    id?: SortOrder
    designation?: SortOrder
    prix?: SortOrder
    qtte?: SortOrder
    description?: SortOrder
    deviseId?: SortOrder
    teneurId?: SortOrder
    utilisateurId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProduitAvgOrderByAggregateInput = {
    id?: SortOrder
    prix?: SortOrder
    qtte?: SortOrder
    deviseId?: SortOrder
    teneurId?: SortOrder
    utilisateurId?: SortOrder
  }

  export type ProduitMaxOrderByAggregateInput = {
    id?: SortOrder
    designation?: SortOrder
    prix?: SortOrder
    qtte?: SortOrder
    description?: SortOrder
    deviseId?: SortOrder
    teneurId?: SortOrder
    utilisateurId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProduitMinOrderByAggregateInput = {
    id?: SortOrder
    designation?: SortOrder
    prix?: SortOrder
    qtte?: SortOrder
    description?: SortOrder
    deviseId?: SortOrder
    teneurId?: SortOrder
    utilisateurId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProduitSumOrderByAggregateInput = {
    id?: SortOrder
    prix?: SortOrder
    qtte?: SortOrder
    deviseId?: SortOrder
    teneurId?: SortOrder
    utilisateurId?: SortOrder
  }

  export type EnumMoyenPaimentFilter<$PrismaModel = never> = {
    equals?: $Enums.MoyenPaiment | EnumMoyenPaimentFieldRefInput<$PrismaModel>
    in?: $Enums.MoyenPaiment[] | ListEnumMoyenPaimentFieldRefInput<$PrismaModel>
    notIn?: $Enums.MoyenPaiment[] | ListEnumMoyenPaimentFieldRefInput<$PrismaModel>
    not?: NestedEnumMoyenPaimentFilter<$PrismaModel> | $Enums.MoyenPaiment
  }

  export type CaisseScalarRelationFilter = {
    is?: CaisseWhereInput
    isNot?: CaisseWhereInput
  }

  export type PaiementCountOrderByAggregateInput = {
    id?: SortOrder
    montant?: SortOrder
    moyen_paiement?: SortOrder
    deviseId?: SortOrder
    caisseId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaiementAvgOrderByAggregateInput = {
    id?: SortOrder
    montant?: SortOrder
    deviseId?: SortOrder
    caisseId?: SortOrder
  }

  export type PaiementMaxOrderByAggregateInput = {
    id?: SortOrder
    montant?: SortOrder
    moyen_paiement?: SortOrder
    deviseId?: SortOrder
    caisseId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaiementMinOrderByAggregateInput = {
    id?: SortOrder
    montant?: SortOrder
    moyen_paiement?: SortOrder
    deviseId?: SortOrder
    caisseId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaiementSumOrderByAggregateInput = {
    id?: SortOrder
    montant?: SortOrder
    deviseId?: SortOrder
    caisseId?: SortOrder
  }

  export type EnumMoyenPaimentWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MoyenPaiment | EnumMoyenPaimentFieldRefInput<$PrismaModel>
    in?: $Enums.MoyenPaiment[] | ListEnumMoyenPaimentFieldRefInput<$PrismaModel>
    notIn?: $Enums.MoyenPaiment[] | ListEnumMoyenPaimentFieldRefInput<$PrismaModel>
    not?: NestedEnumMoyenPaimentWithAggregatesFilter<$PrismaModel> | $Enums.MoyenPaiment
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMoyenPaimentFilter<$PrismaModel>
    _max?: NestedEnumMoyenPaimentFilter<$PrismaModel>
  }

  export type EnumStatutCaisseFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutCaisse | EnumStatutCaisseFieldRefInput<$PrismaModel>
    in?: $Enums.StatutCaisse[] | ListEnumStatutCaisseFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatutCaisse[] | ListEnumStatutCaisseFieldRefInput<$PrismaModel>
    not?: NestedEnumStatutCaisseFilter<$PrismaModel> | $Enums.StatutCaisse
  }

  export type CaisseCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    description?: SortOrder
    soldeInitial?: SortOrder
    soldeActuel?: SortOrder
    deviseId?: SortOrder
    creeParId?: SortOrder
    statut?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CaisseAvgOrderByAggregateInput = {
    id?: SortOrder
    soldeInitial?: SortOrder
    soldeActuel?: SortOrder
    deviseId?: SortOrder
    creeParId?: SortOrder
  }

  export type CaisseMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    description?: SortOrder
    soldeInitial?: SortOrder
    soldeActuel?: SortOrder
    deviseId?: SortOrder
    creeParId?: SortOrder
    statut?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CaisseMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    description?: SortOrder
    soldeInitial?: SortOrder
    soldeActuel?: SortOrder
    deviseId?: SortOrder
    creeParId?: SortOrder
    statut?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CaisseSumOrderByAggregateInput = {
    id?: SortOrder
    soldeInitial?: SortOrder
    soldeActuel?: SortOrder
    deviseId?: SortOrder
    creeParId?: SortOrder
  }

  export type EnumStatutCaisseWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutCaisse | EnumStatutCaisseFieldRefInput<$PrismaModel>
    in?: $Enums.StatutCaisse[] | ListEnumStatutCaisseFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatutCaisse[] | ListEnumStatutCaisseFieldRefInput<$PrismaModel>
    not?: NestedEnumStatutCaisseWithAggregatesFilter<$PrismaModel> | $Enums.StatutCaisse
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatutCaisseFilter<$PrismaModel>
    _max?: NestedEnumStatutCaisseFilter<$PrismaModel>
  }

  export type EnumStatutVenteFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutVente | EnumStatutVenteFieldRefInput<$PrismaModel>
    in?: $Enums.StatutVente[] | ListEnumStatutVenteFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatutVente[] | ListEnumStatutVenteFieldRefInput<$PrismaModel>
    not?: NestedEnumStatutVenteFilter<$PrismaModel> | $Enums.StatutVente
  }

  export type EnumTypeClientFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeClient | EnumTypeClientFieldRefInput<$PrismaModel>
    in?: $Enums.TypeClient[] | ListEnumTypeClientFieldRefInput<$PrismaModel>
    notIn?: $Enums.TypeClient[] | ListEnumTypeClientFieldRefInput<$PrismaModel>
    not?: NestedEnumTypeClientFilter<$PrismaModel> | $Enums.TypeClient
  }

  export type PaiementNullableScalarRelationFilter = {
    is?: PaiementWhereInput | null
    isNot?: PaiementWhereInput | null
  }

  export type PanierScalarRelationFilter = {
    is?: PanierWhereInput
    isNot?: PanierWhereInput
  }

  export type VenteCountOrderByAggregateInput = {
    id?: SortOrder
    statut?: SortOrder
    total_ttc?: SortOrder
    total_ht?: SortOrder
    type_acheteur?: SortOrder
    clientId?: SortOrder
    enregistrerParId?: SortOrder
    fournisseurId?: SortOrder
    agentId?: SortOrder
    paiementId?: SortOrder
    panierId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VenteAvgOrderByAggregateInput = {
    id?: SortOrder
    total_ttc?: SortOrder
    total_ht?: SortOrder
    clientId?: SortOrder
    enregistrerParId?: SortOrder
    fournisseurId?: SortOrder
    agentId?: SortOrder
    paiementId?: SortOrder
    panierId?: SortOrder
  }

  export type VenteMaxOrderByAggregateInput = {
    id?: SortOrder
    statut?: SortOrder
    total_ttc?: SortOrder
    total_ht?: SortOrder
    type_acheteur?: SortOrder
    clientId?: SortOrder
    enregistrerParId?: SortOrder
    fournisseurId?: SortOrder
    agentId?: SortOrder
    paiementId?: SortOrder
    panierId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VenteMinOrderByAggregateInput = {
    id?: SortOrder
    statut?: SortOrder
    total_ttc?: SortOrder
    total_ht?: SortOrder
    type_acheteur?: SortOrder
    clientId?: SortOrder
    enregistrerParId?: SortOrder
    fournisseurId?: SortOrder
    agentId?: SortOrder
    paiementId?: SortOrder
    panierId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VenteSumOrderByAggregateInput = {
    id?: SortOrder
    total_ttc?: SortOrder
    total_ht?: SortOrder
    clientId?: SortOrder
    enregistrerParId?: SortOrder
    fournisseurId?: SortOrder
    agentId?: SortOrder
    paiementId?: SortOrder
    panierId?: SortOrder
  }

  export type EnumStatutVenteWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutVente | EnumStatutVenteFieldRefInput<$PrismaModel>
    in?: $Enums.StatutVente[] | ListEnumStatutVenteFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatutVente[] | ListEnumStatutVenteFieldRefInput<$PrismaModel>
    not?: NestedEnumStatutVenteWithAggregatesFilter<$PrismaModel> | $Enums.StatutVente
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatutVenteFilter<$PrismaModel>
    _max?: NestedEnumStatutVenteFilter<$PrismaModel>
  }

  export type EnumTypeClientWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeClient | EnumTypeClientFieldRefInput<$PrismaModel>
    in?: $Enums.TypeClient[] | ListEnumTypeClientFieldRefInput<$PrismaModel>
    notIn?: $Enums.TypeClient[] | ListEnumTypeClientFieldRefInput<$PrismaModel>
    not?: NestedEnumTypeClientWithAggregatesFilter<$PrismaModel> | $Enums.TypeClient
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTypeClientFilter<$PrismaModel>
    _max?: NestedEnumTypeClientFilter<$PrismaModel>
  }

  export type PanierCountOrderByAggregateInput = {
    id?: SortOrder
    utilisateurId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PanierAvgOrderByAggregateInput = {
    id?: SortOrder
    utilisateurId?: SortOrder
  }

  export type PanierMaxOrderByAggregateInput = {
    id?: SortOrder
    utilisateurId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PanierMinOrderByAggregateInput = {
    id?: SortOrder
    utilisateurId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PanierSumOrderByAggregateInput = {
    id?: SortOrder
    utilisateurId?: SortOrder
  }

  export type ProduitScalarRelationFilter = {
    is?: ProduitWhereInput
    isNot?: ProduitWhereInput
  }

  export type DetailPanierCountOrderByAggregateInput = {
    id?: SortOrder
    produitId?: SortOrder
    qtte?: SortOrder
    prixUnitaire?: SortOrder
    prixTotal?: SortOrder
    panierId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DetailPanierAvgOrderByAggregateInput = {
    id?: SortOrder
    produitId?: SortOrder
    qtte?: SortOrder
    prixUnitaire?: SortOrder
    prixTotal?: SortOrder
    panierId?: SortOrder
  }

  export type DetailPanierMaxOrderByAggregateInput = {
    id?: SortOrder
    produitId?: SortOrder
    qtte?: SortOrder
    prixUnitaire?: SortOrder
    prixTotal?: SortOrder
    panierId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DetailPanierMinOrderByAggregateInput = {
    id?: SortOrder
    produitId?: SortOrder
    qtte?: SortOrder
    prixUnitaire?: SortOrder
    prixTotal?: SortOrder
    panierId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DetailPanierSumOrderByAggregateInput = {
    id?: SortOrder
    produitId?: SortOrder
    qtte?: SortOrder
    prixUnitaire?: SortOrder
    prixTotal?: SortOrder
    panierId?: SortOrder
  }

  export type EnumStatutAchatFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutAchat | EnumStatutAchatFieldRefInput<$PrismaModel>
    in?: $Enums.StatutAchat[] | ListEnumStatutAchatFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatutAchat[] | ListEnumStatutAchatFieldRefInput<$PrismaModel>
    not?: NestedEnumStatutAchatFilter<$PrismaModel> | $Enums.StatutAchat
  }

  export type FournisseurScalarRelationFilter = {
    is?: FournisseurWhereInput
    isNot?: FournisseurWhereInput
  }

  export type PaiementScalarRelationFilter = {
    is?: PaiementWhereInput
    isNot?: PaiementWhereInput
  }

  export type AchatCountOrderByAggregateInput = {
    id?: SortOrder
    statut?: SortOrder
    panierId?: SortOrder
    fournisseurId?: SortOrder
    enregistrerParId?: SortOrder
    paiementId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AchatAvgOrderByAggregateInput = {
    id?: SortOrder
    panierId?: SortOrder
    fournisseurId?: SortOrder
    enregistrerParId?: SortOrder
    paiementId?: SortOrder
  }

  export type AchatMaxOrderByAggregateInput = {
    id?: SortOrder
    statut?: SortOrder
    panierId?: SortOrder
    fournisseurId?: SortOrder
    enregistrerParId?: SortOrder
    paiementId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AchatMinOrderByAggregateInput = {
    id?: SortOrder
    statut?: SortOrder
    panierId?: SortOrder
    fournisseurId?: SortOrder
    enregistrerParId?: SortOrder
    paiementId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AchatSumOrderByAggregateInput = {
    id?: SortOrder
    panierId?: SortOrder
    fournisseurId?: SortOrder
    enregistrerParId?: SortOrder
    paiementId?: SortOrder
  }

  export type EnumStatutAchatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutAchat | EnumStatutAchatFieldRefInput<$PrismaModel>
    in?: $Enums.StatutAchat[] | ListEnumStatutAchatFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatutAchat[] | ListEnumStatutAchatFieldRefInput<$PrismaModel>
    not?: NestedEnumStatutAchatWithAggregatesFilter<$PrismaModel> | $Enums.StatutAchat
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatutAchatFilter<$PrismaModel>
    _max?: NestedEnumStatutAchatFilter<$PrismaModel>
  }

  export type EnumStatutReservationFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutReservation | EnumStatutReservationFieldRefInput<$PrismaModel>
    in?: $Enums.StatutReservation[] | ListEnumStatutReservationFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatutReservation[] | ListEnumStatutReservationFieldRefInput<$PrismaModel>
    not?: NestedEnumStatutReservationFilter<$PrismaModel> | $Enums.StatutReservation
  }

  export type AdresseNullableScalarRelationFilter = {
    is?: AdresseWhereInput | null
    isNot?: AdresseWhereInput | null
  }

  export type ContactNullableScalarRelationFilter = {
    is?: ContactWhereInput | null
    isNot?: ContactWhereInput | null
  }

  export type ReservationCountOrderByAggregateInput = {
    id?: SortOrder
    dateLivraisonSouhaitee?: SortOrder
    adresseLivraison?: SortOrder
    statut?: SortOrder
    notes?: SortOrder
    type_client?: SortOrder
    clientId?: SortOrder
    panierId?: SortOrder
    nom?: SortOrder
    tel?: SortOrder
    adresseId?: SortOrder
    contactId?: SortOrder
    enregistrerParId?: SortOrder
    fournisseurId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReservationAvgOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    panierId?: SortOrder
    adresseId?: SortOrder
    contactId?: SortOrder
    enregistrerParId?: SortOrder
    fournisseurId?: SortOrder
  }

  export type ReservationMaxOrderByAggregateInput = {
    id?: SortOrder
    dateLivraisonSouhaitee?: SortOrder
    adresseLivraison?: SortOrder
    statut?: SortOrder
    notes?: SortOrder
    type_client?: SortOrder
    clientId?: SortOrder
    panierId?: SortOrder
    nom?: SortOrder
    tel?: SortOrder
    adresseId?: SortOrder
    contactId?: SortOrder
    enregistrerParId?: SortOrder
    fournisseurId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReservationMinOrderByAggregateInput = {
    id?: SortOrder
    dateLivraisonSouhaitee?: SortOrder
    adresseLivraison?: SortOrder
    statut?: SortOrder
    notes?: SortOrder
    type_client?: SortOrder
    clientId?: SortOrder
    panierId?: SortOrder
    nom?: SortOrder
    tel?: SortOrder
    adresseId?: SortOrder
    contactId?: SortOrder
    enregistrerParId?: SortOrder
    fournisseurId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReservationSumOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    panierId?: SortOrder
    adresseId?: SortOrder
    contactId?: SortOrder
    enregistrerParId?: SortOrder
    fournisseurId?: SortOrder
  }

  export type EnumStatutReservationWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutReservation | EnumStatutReservationFieldRefInput<$PrismaModel>
    in?: $Enums.StatutReservation[] | ListEnumStatutReservationFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatutReservation[] | ListEnumStatutReservationFieldRefInput<$PrismaModel>
    not?: NestedEnumStatutReservationWithAggregatesFilter<$PrismaModel> | $Enums.StatutReservation
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatutReservationFilter<$PrismaModel>
    _max?: NestedEnumStatutReservationFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumStatutCommandeFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutCommande | EnumStatutCommandeFieldRefInput<$PrismaModel>
    in?: $Enums.StatutCommande[] | ListEnumStatutCommandeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatutCommande[] | ListEnumStatutCommandeFieldRefInput<$PrismaModel>
    not?: NestedEnumStatutCommandeFilter<$PrismaModel> | $Enums.StatutCommande
  }

  export type CommandeCountOrderByAggregateInput = {
    id?: SortOrder
    panierId?: SortOrder
    clientId?: SortOrder
    nom?: SortOrder
    tel?: SortOrder
    type_client?: SortOrder
    paiementId?: SortOrder
    adresseId?: SortOrder
    contactId?: SortOrder
    fournisseurId?: SortOrder
    notes?: SortOrder
    dateLivraisonEffective?: SortOrder
    adresseLivraison?: SortOrder
    enregistrerParId?: SortOrder
    statut?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommandeAvgOrderByAggregateInput = {
    id?: SortOrder
    panierId?: SortOrder
    clientId?: SortOrder
    paiementId?: SortOrder
    adresseId?: SortOrder
    contactId?: SortOrder
    fournisseurId?: SortOrder
    enregistrerParId?: SortOrder
  }

  export type CommandeMaxOrderByAggregateInput = {
    id?: SortOrder
    panierId?: SortOrder
    clientId?: SortOrder
    nom?: SortOrder
    tel?: SortOrder
    type_client?: SortOrder
    paiementId?: SortOrder
    adresseId?: SortOrder
    contactId?: SortOrder
    fournisseurId?: SortOrder
    notes?: SortOrder
    dateLivraisonEffective?: SortOrder
    adresseLivraison?: SortOrder
    enregistrerParId?: SortOrder
    statut?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommandeMinOrderByAggregateInput = {
    id?: SortOrder
    panierId?: SortOrder
    clientId?: SortOrder
    nom?: SortOrder
    tel?: SortOrder
    type_client?: SortOrder
    paiementId?: SortOrder
    adresseId?: SortOrder
    contactId?: SortOrder
    fournisseurId?: SortOrder
    notes?: SortOrder
    dateLivraisonEffective?: SortOrder
    adresseLivraison?: SortOrder
    enregistrerParId?: SortOrder
    statut?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommandeSumOrderByAggregateInput = {
    id?: SortOrder
    panierId?: SortOrder
    clientId?: SortOrder
    paiementId?: SortOrder
    adresseId?: SortOrder
    contactId?: SortOrder
    fournisseurId?: SortOrder
    enregistrerParId?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumStatutCommandeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutCommande | EnumStatutCommandeFieldRefInput<$PrismaModel>
    in?: $Enums.StatutCommande[] | ListEnumStatutCommandeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatutCommande[] | ListEnumStatutCommandeFieldRefInput<$PrismaModel>
    not?: NestedEnumStatutCommandeWithAggregatesFilter<$PrismaModel> | $Enums.StatutCommande
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatutCommandeFilter<$PrismaModel>
    _max?: NestedEnumStatutCommandeFilter<$PrismaModel>
  }

  export type EnumTypeMouvementCaisseFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeMouvementCaisse | EnumTypeMouvementCaisseFieldRefInput<$PrismaModel>
    in?: $Enums.TypeMouvementCaisse[] | ListEnumTypeMouvementCaisseFieldRefInput<$PrismaModel>
    notIn?: $Enums.TypeMouvementCaisse[] | ListEnumTypeMouvementCaisseFieldRefInput<$PrismaModel>
    not?: NestedEnumTypeMouvementCaisseFilter<$PrismaModel> | $Enums.TypeMouvementCaisse
  }

  export type EnumCategorieMouvementFilter<$PrismaModel = never> = {
    equals?: $Enums.CategorieMouvement | EnumCategorieMouvementFieldRefInput<$PrismaModel>
    in?: $Enums.CategorieMouvement[] | ListEnumCategorieMouvementFieldRefInput<$PrismaModel>
    notIn?: $Enums.CategorieMouvement[] | ListEnumCategorieMouvementFieldRefInput<$PrismaModel>
    not?: NestedEnumCategorieMouvementFilter<$PrismaModel> | $Enums.CategorieMouvement
  }

  export type MouvementCaisseCountOrderByAggregateInput = {
    id?: SortOrder
    caisseId?: SortOrder
    type_mouvement?: SortOrder
    categorie?: SortOrder
    montant?: SortOrder
    description?: SortOrder
    enregistrerParId?: SortOrder
    referenceExterne?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MouvementCaisseAvgOrderByAggregateInput = {
    id?: SortOrder
    caisseId?: SortOrder
    montant?: SortOrder
    enregistrerParId?: SortOrder
  }

  export type MouvementCaisseMaxOrderByAggregateInput = {
    id?: SortOrder
    caisseId?: SortOrder
    type_mouvement?: SortOrder
    categorie?: SortOrder
    montant?: SortOrder
    description?: SortOrder
    enregistrerParId?: SortOrder
    referenceExterne?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MouvementCaisseMinOrderByAggregateInput = {
    id?: SortOrder
    caisseId?: SortOrder
    type_mouvement?: SortOrder
    categorie?: SortOrder
    montant?: SortOrder
    description?: SortOrder
    enregistrerParId?: SortOrder
    referenceExterne?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MouvementCaisseSumOrderByAggregateInput = {
    id?: SortOrder
    caisseId?: SortOrder
    montant?: SortOrder
    enregistrerParId?: SortOrder
  }

  export type EnumTypeMouvementCaisseWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeMouvementCaisse | EnumTypeMouvementCaisseFieldRefInput<$PrismaModel>
    in?: $Enums.TypeMouvementCaisse[] | ListEnumTypeMouvementCaisseFieldRefInput<$PrismaModel>
    notIn?: $Enums.TypeMouvementCaisse[] | ListEnumTypeMouvementCaisseFieldRefInput<$PrismaModel>
    not?: NestedEnumTypeMouvementCaisseWithAggregatesFilter<$PrismaModel> | $Enums.TypeMouvementCaisse
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTypeMouvementCaisseFilter<$PrismaModel>
    _max?: NestedEnumTypeMouvementCaisseFilter<$PrismaModel>
  }

  export type EnumCategorieMouvementWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CategorieMouvement | EnumCategorieMouvementFieldRefInput<$PrismaModel>
    in?: $Enums.CategorieMouvement[] | ListEnumCategorieMouvementFieldRefInput<$PrismaModel>
    notIn?: $Enums.CategorieMouvement[] | ListEnumCategorieMouvementFieldRefInput<$PrismaModel>
    not?: NestedEnumCategorieMouvementWithAggregatesFilter<$PrismaModel> | $Enums.CategorieMouvement
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCategorieMouvementFilter<$PrismaModel>
    _max?: NestedEnumCategorieMouvementFilter<$PrismaModel>
  }

  export type ClotureCaisseScalarRelationFilter = {
    is?: ClotureCaisseWhereInput
    isNot?: ClotureCaisseWhereInput
  }

  export type DetailClotureCaisseCountOrderByAggregateInput = {
    id?: SortOrder
    produitId?: SortOrder
    teneurId?: SortOrder
    qtteRestante?: SortOrder
    clotureCaisseId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DetailClotureCaisseAvgOrderByAggregateInput = {
    id?: SortOrder
    produitId?: SortOrder
    teneurId?: SortOrder
    qtteRestante?: SortOrder
    clotureCaisseId?: SortOrder
  }

  export type DetailClotureCaisseMaxOrderByAggregateInput = {
    id?: SortOrder
    produitId?: SortOrder
    teneurId?: SortOrder
    qtteRestante?: SortOrder
    clotureCaisseId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DetailClotureCaisseMinOrderByAggregateInput = {
    id?: SortOrder
    produitId?: SortOrder
    teneurId?: SortOrder
    qtteRestante?: SortOrder
    clotureCaisseId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DetailClotureCaisseSumOrderByAggregateInput = {
    id?: SortOrder
    produitId?: SortOrder
    teneurId?: SortOrder
    qtteRestante?: SortOrder
    clotureCaisseId?: SortOrder
  }

  export type ClotureCaisseCountOrderByAggregateInput = {
    id?: SortOrder
    caisseId?: SortOrder
    dateCloture?: SortOrder
    utilisateurClotureId?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClotureCaisseAvgOrderByAggregateInput = {
    id?: SortOrder
    caisseId?: SortOrder
    utilisateurClotureId?: SortOrder
  }

  export type ClotureCaisseMaxOrderByAggregateInput = {
    id?: SortOrder
    caisseId?: SortOrder
    dateCloture?: SortOrder
    utilisateurClotureId?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClotureCaisseMinOrderByAggregateInput = {
    id?: SortOrder
    caisseId?: SortOrder
    dateCloture?: SortOrder
    utilisateurClotureId?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClotureCaisseSumOrderByAggregateInput = {
    id?: SortOrder
    caisseId?: SortOrder
    utilisateurClotureId?: SortOrder
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AdresseCreateNestedManyWithoutUtilisateurInput = {
    create?: XOR<AdresseCreateWithoutUtilisateurInput, AdresseUncheckedCreateWithoutUtilisateurInput> | AdresseCreateWithoutUtilisateurInput[] | AdresseUncheckedCreateWithoutUtilisateurInput[]
    connectOrCreate?: AdresseCreateOrConnectWithoutUtilisateurInput | AdresseCreateOrConnectWithoutUtilisateurInput[]
    createMany?: AdresseCreateManyUtilisateurInputEnvelope
    connect?: AdresseWhereUniqueInput | AdresseWhereUniqueInput[]
  }

  export type ContactCreateNestedManyWithoutUtilisateurInput = {
    create?: XOR<ContactCreateWithoutUtilisateurInput, ContactUncheckedCreateWithoutUtilisateurInput> | ContactCreateWithoutUtilisateurInput[] | ContactUncheckedCreateWithoutUtilisateurInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutUtilisateurInput | ContactCreateOrConnectWithoutUtilisateurInput[]
    createMany?: ContactCreateManyUtilisateurInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type ProduitCreateNestedManyWithoutUtilisateurInput = {
    create?: XOR<ProduitCreateWithoutUtilisateurInput, ProduitUncheckedCreateWithoutUtilisateurInput> | ProduitCreateWithoutUtilisateurInput[] | ProduitUncheckedCreateWithoutUtilisateurInput[]
    connectOrCreate?: ProduitCreateOrConnectWithoutUtilisateurInput | ProduitCreateOrConnectWithoutUtilisateurInput[]
    createMany?: ProduitCreateManyUtilisateurInputEnvelope
    connect?: ProduitWhereUniqueInput | ProduitWhereUniqueInput[]
  }

  export type VenteCreateNestedManyWithoutUtilisateurInput = {
    create?: XOR<VenteCreateWithoutUtilisateurInput, VenteUncheckedCreateWithoutUtilisateurInput> | VenteCreateWithoutUtilisateurInput[] | VenteUncheckedCreateWithoutUtilisateurInput[]
    connectOrCreate?: VenteCreateOrConnectWithoutUtilisateurInput | VenteCreateOrConnectWithoutUtilisateurInput[]
    createMany?: VenteCreateManyUtilisateurInputEnvelope
    connect?: VenteWhereUniqueInput | VenteWhereUniqueInput[]
  }

  export type AchatCreateNestedManyWithoutUtilisateurInput = {
    create?: XOR<AchatCreateWithoutUtilisateurInput, AchatUncheckedCreateWithoutUtilisateurInput> | AchatCreateWithoutUtilisateurInput[] | AchatUncheckedCreateWithoutUtilisateurInput[]
    connectOrCreate?: AchatCreateOrConnectWithoutUtilisateurInput | AchatCreateOrConnectWithoutUtilisateurInput[]
    createMany?: AchatCreateManyUtilisateurInputEnvelope
    connect?: AchatWhereUniqueInput | AchatWhereUniqueInput[]
  }

  export type TeneurCreateNestedManyWithoutUtilisateurInput = {
    create?: XOR<TeneurCreateWithoutUtilisateurInput, TeneurUncheckedCreateWithoutUtilisateurInput> | TeneurCreateWithoutUtilisateurInput[] | TeneurUncheckedCreateWithoutUtilisateurInput[]
    connectOrCreate?: TeneurCreateOrConnectWithoutUtilisateurInput | TeneurCreateOrConnectWithoutUtilisateurInput[]
    createMany?: TeneurCreateManyUtilisateurInputEnvelope
    connect?: TeneurWhereUniqueInput | TeneurWhereUniqueInput[]
  }

  export type DeviseCreateNestedManyWithoutUtilisateurInput = {
    create?: XOR<DeviseCreateWithoutUtilisateurInput, DeviseUncheckedCreateWithoutUtilisateurInput> | DeviseCreateWithoutUtilisateurInput[] | DeviseUncheckedCreateWithoutUtilisateurInput[]
    connectOrCreate?: DeviseCreateOrConnectWithoutUtilisateurInput | DeviseCreateOrConnectWithoutUtilisateurInput[]
    createMany?: DeviseCreateManyUtilisateurInputEnvelope
    connect?: DeviseWhereUniqueInput | DeviseWhereUniqueInput[]
  }

  export type PanierCreateNestedManyWithoutUtilisateurInput = {
    create?: XOR<PanierCreateWithoutUtilisateurInput, PanierUncheckedCreateWithoutUtilisateurInput> | PanierCreateWithoutUtilisateurInput[] | PanierUncheckedCreateWithoutUtilisateurInput[]
    connectOrCreate?: PanierCreateOrConnectWithoutUtilisateurInput | PanierCreateOrConnectWithoutUtilisateurInput[]
    createMany?: PanierCreateManyUtilisateurInputEnvelope
    connect?: PanierWhereUniqueInput | PanierWhereUniqueInput[]
  }

  export type ReservationCreateNestedManyWithoutUtilisateurInput = {
    create?: XOR<ReservationCreateWithoutUtilisateurInput, ReservationUncheckedCreateWithoutUtilisateurInput> | ReservationCreateWithoutUtilisateurInput[] | ReservationUncheckedCreateWithoutUtilisateurInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutUtilisateurInput | ReservationCreateOrConnectWithoutUtilisateurInput[]
    createMany?: ReservationCreateManyUtilisateurInputEnvelope
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
  }

  export type CommandeCreateNestedManyWithoutClientInput = {
    create?: XOR<CommandeCreateWithoutClientInput, CommandeUncheckedCreateWithoutClientInput> | CommandeCreateWithoutClientInput[] | CommandeUncheckedCreateWithoutClientInput[]
    connectOrCreate?: CommandeCreateOrConnectWithoutClientInput | CommandeCreateOrConnectWithoutClientInput[]
    createMany?: CommandeCreateManyClientInputEnvelope
    connect?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
  }

  export type CaisseCreateNestedManyWithoutUtilisateurInput = {
    create?: XOR<CaisseCreateWithoutUtilisateurInput, CaisseUncheckedCreateWithoutUtilisateurInput> | CaisseCreateWithoutUtilisateurInput[] | CaisseUncheckedCreateWithoutUtilisateurInput[]
    connectOrCreate?: CaisseCreateOrConnectWithoutUtilisateurInput | CaisseCreateOrConnectWithoutUtilisateurInput[]
    createMany?: CaisseCreateManyUtilisateurInputEnvelope
    connect?: CaisseWhereUniqueInput | CaisseWhereUniqueInput[]
  }

  export type MouvementCaisseCreateNestedManyWithoutUtilisateurInput = {
    create?: XOR<MouvementCaisseCreateWithoutUtilisateurInput, MouvementCaisseUncheckedCreateWithoutUtilisateurInput> | MouvementCaisseCreateWithoutUtilisateurInput[] | MouvementCaisseUncheckedCreateWithoutUtilisateurInput[]
    connectOrCreate?: MouvementCaisseCreateOrConnectWithoutUtilisateurInput | MouvementCaisseCreateOrConnectWithoutUtilisateurInput[]
    createMany?: MouvementCaisseCreateManyUtilisateurInputEnvelope
    connect?: MouvementCaisseWhereUniqueInput | MouvementCaisseWhereUniqueInput[]
  }

  export type ClotureCaisseCreateNestedManyWithoutUtilisateurClotureInput = {
    create?: XOR<ClotureCaisseCreateWithoutUtilisateurClotureInput, ClotureCaisseUncheckedCreateWithoutUtilisateurClotureInput> | ClotureCaisseCreateWithoutUtilisateurClotureInput[] | ClotureCaisseUncheckedCreateWithoutUtilisateurClotureInput[]
    connectOrCreate?: ClotureCaisseCreateOrConnectWithoutUtilisateurClotureInput | ClotureCaisseCreateOrConnectWithoutUtilisateurClotureInput[]
    createMany?: ClotureCaisseCreateManyUtilisateurClotureInputEnvelope
    connect?: ClotureCaisseWhereUniqueInput | ClotureCaisseWhereUniqueInput[]
  }

  export type AdresseUncheckedCreateNestedManyWithoutUtilisateurInput = {
    create?: XOR<AdresseCreateWithoutUtilisateurInput, AdresseUncheckedCreateWithoutUtilisateurInput> | AdresseCreateWithoutUtilisateurInput[] | AdresseUncheckedCreateWithoutUtilisateurInput[]
    connectOrCreate?: AdresseCreateOrConnectWithoutUtilisateurInput | AdresseCreateOrConnectWithoutUtilisateurInput[]
    createMany?: AdresseCreateManyUtilisateurInputEnvelope
    connect?: AdresseWhereUniqueInput | AdresseWhereUniqueInput[]
  }

  export type ContactUncheckedCreateNestedManyWithoutUtilisateurInput = {
    create?: XOR<ContactCreateWithoutUtilisateurInput, ContactUncheckedCreateWithoutUtilisateurInput> | ContactCreateWithoutUtilisateurInput[] | ContactUncheckedCreateWithoutUtilisateurInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutUtilisateurInput | ContactCreateOrConnectWithoutUtilisateurInput[]
    createMany?: ContactCreateManyUtilisateurInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type ProduitUncheckedCreateNestedManyWithoutUtilisateurInput = {
    create?: XOR<ProduitCreateWithoutUtilisateurInput, ProduitUncheckedCreateWithoutUtilisateurInput> | ProduitCreateWithoutUtilisateurInput[] | ProduitUncheckedCreateWithoutUtilisateurInput[]
    connectOrCreate?: ProduitCreateOrConnectWithoutUtilisateurInput | ProduitCreateOrConnectWithoutUtilisateurInput[]
    createMany?: ProduitCreateManyUtilisateurInputEnvelope
    connect?: ProduitWhereUniqueInput | ProduitWhereUniqueInput[]
  }

  export type VenteUncheckedCreateNestedManyWithoutUtilisateurInput = {
    create?: XOR<VenteCreateWithoutUtilisateurInput, VenteUncheckedCreateWithoutUtilisateurInput> | VenteCreateWithoutUtilisateurInput[] | VenteUncheckedCreateWithoutUtilisateurInput[]
    connectOrCreate?: VenteCreateOrConnectWithoutUtilisateurInput | VenteCreateOrConnectWithoutUtilisateurInput[]
    createMany?: VenteCreateManyUtilisateurInputEnvelope
    connect?: VenteWhereUniqueInput | VenteWhereUniqueInput[]
  }

  export type AchatUncheckedCreateNestedManyWithoutUtilisateurInput = {
    create?: XOR<AchatCreateWithoutUtilisateurInput, AchatUncheckedCreateWithoutUtilisateurInput> | AchatCreateWithoutUtilisateurInput[] | AchatUncheckedCreateWithoutUtilisateurInput[]
    connectOrCreate?: AchatCreateOrConnectWithoutUtilisateurInput | AchatCreateOrConnectWithoutUtilisateurInput[]
    createMany?: AchatCreateManyUtilisateurInputEnvelope
    connect?: AchatWhereUniqueInput | AchatWhereUniqueInput[]
  }

  export type TeneurUncheckedCreateNestedManyWithoutUtilisateurInput = {
    create?: XOR<TeneurCreateWithoutUtilisateurInput, TeneurUncheckedCreateWithoutUtilisateurInput> | TeneurCreateWithoutUtilisateurInput[] | TeneurUncheckedCreateWithoutUtilisateurInput[]
    connectOrCreate?: TeneurCreateOrConnectWithoutUtilisateurInput | TeneurCreateOrConnectWithoutUtilisateurInput[]
    createMany?: TeneurCreateManyUtilisateurInputEnvelope
    connect?: TeneurWhereUniqueInput | TeneurWhereUniqueInput[]
  }

  export type DeviseUncheckedCreateNestedManyWithoutUtilisateurInput = {
    create?: XOR<DeviseCreateWithoutUtilisateurInput, DeviseUncheckedCreateWithoutUtilisateurInput> | DeviseCreateWithoutUtilisateurInput[] | DeviseUncheckedCreateWithoutUtilisateurInput[]
    connectOrCreate?: DeviseCreateOrConnectWithoutUtilisateurInput | DeviseCreateOrConnectWithoutUtilisateurInput[]
    createMany?: DeviseCreateManyUtilisateurInputEnvelope
    connect?: DeviseWhereUniqueInput | DeviseWhereUniqueInput[]
  }

  export type PanierUncheckedCreateNestedManyWithoutUtilisateurInput = {
    create?: XOR<PanierCreateWithoutUtilisateurInput, PanierUncheckedCreateWithoutUtilisateurInput> | PanierCreateWithoutUtilisateurInput[] | PanierUncheckedCreateWithoutUtilisateurInput[]
    connectOrCreate?: PanierCreateOrConnectWithoutUtilisateurInput | PanierCreateOrConnectWithoutUtilisateurInput[]
    createMany?: PanierCreateManyUtilisateurInputEnvelope
    connect?: PanierWhereUniqueInput | PanierWhereUniqueInput[]
  }

  export type ReservationUncheckedCreateNestedManyWithoutUtilisateurInput = {
    create?: XOR<ReservationCreateWithoutUtilisateurInput, ReservationUncheckedCreateWithoutUtilisateurInput> | ReservationCreateWithoutUtilisateurInput[] | ReservationUncheckedCreateWithoutUtilisateurInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutUtilisateurInput | ReservationCreateOrConnectWithoutUtilisateurInput[]
    createMany?: ReservationCreateManyUtilisateurInputEnvelope
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
  }

  export type CommandeUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<CommandeCreateWithoutClientInput, CommandeUncheckedCreateWithoutClientInput> | CommandeCreateWithoutClientInput[] | CommandeUncheckedCreateWithoutClientInput[]
    connectOrCreate?: CommandeCreateOrConnectWithoutClientInput | CommandeCreateOrConnectWithoutClientInput[]
    createMany?: CommandeCreateManyClientInputEnvelope
    connect?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
  }

  export type CaisseUncheckedCreateNestedManyWithoutUtilisateurInput = {
    create?: XOR<CaisseCreateWithoutUtilisateurInput, CaisseUncheckedCreateWithoutUtilisateurInput> | CaisseCreateWithoutUtilisateurInput[] | CaisseUncheckedCreateWithoutUtilisateurInput[]
    connectOrCreate?: CaisseCreateOrConnectWithoutUtilisateurInput | CaisseCreateOrConnectWithoutUtilisateurInput[]
    createMany?: CaisseCreateManyUtilisateurInputEnvelope
    connect?: CaisseWhereUniqueInput | CaisseWhereUniqueInput[]
  }

  export type MouvementCaisseUncheckedCreateNestedManyWithoutUtilisateurInput = {
    create?: XOR<MouvementCaisseCreateWithoutUtilisateurInput, MouvementCaisseUncheckedCreateWithoutUtilisateurInput> | MouvementCaisseCreateWithoutUtilisateurInput[] | MouvementCaisseUncheckedCreateWithoutUtilisateurInput[]
    connectOrCreate?: MouvementCaisseCreateOrConnectWithoutUtilisateurInput | MouvementCaisseCreateOrConnectWithoutUtilisateurInput[]
    createMany?: MouvementCaisseCreateManyUtilisateurInputEnvelope
    connect?: MouvementCaisseWhereUniqueInput | MouvementCaisseWhereUniqueInput[]
  }

  export type ClotureCaisseUncheckedCreateNestedManyWithoutUtilisateurClotureInput = {
    create?: XOR<ClotureCaisseCreateWithoutUtilisateurClotureInput, ClotureCaisseUncheckedCreateWithoutUtilisateurClotureInput> | ClotureCaisseCreateWithoutUtilisateurClotureInput[] | ClotureCaisseUncheckedCreateWithoutUtilisateurClotureInput[]
    connectOrCreate?: ClotureCaisseCreateOrConnectWithoutUtilisateurClotureInput | ClotureCaisseCreateOrConnectWithoutUtilisateurClotureInput[]
    createMany?: ClotureCaisseCreateManyUtilisateurClotureInputEnvelope
    connect?: ClotureCaisseWhereUniqueInput | ClotureCaisseWhereUniqueInput[]
  }

  export type NullableEnumSexeFieldUpdateOperationsInput = {
    set?: $Enums.Sexe | null
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type NullableEnumPosteFieldUpdateOperationsInput = {
    set?: $Enums.Poste | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type AdresseUpdateManyWithoutUtilisateurNestedInput = {
    create?: XOR<AdresseCreateWithoutUtilisateurInput, AdresseUncheckedCreateWithoutUtilisateurInput> | AdresseCreateWithoutUtilisateurInput[] | AdresseUncheckedCreateWithoutUtilisateurInput[]
    connectOrCreate?: AdresseCreateOrConnectWithoutUtilisateurInput | AdresseCreateOrConnectWithoutUtilisateurInput[]
    upsert?: AdresseUpsertWithWhereUniqueWithoutUtilisateurInput | AdresseUpsertWithWhereUniqueWithoutUtilisateurInput[]
    createMany?: AdresseCreateManyUtilisateurInputEnvelope
    set?: AdresseWhereUniqueInput | AdresseWhereUniqueInput[]
    disconnect?: AdresseWhereUniqueInput | AdresseWhereUniqueInput[]
    delete?: AdresseWhereUniqueInput | AdresseWhereUniqueInput[]
    connect?: AdresseWhereUniqueInput | AdresseWhereUniqueInput[]
    update?: AdresseUpdateWithWhereUniqueWithoutUtilisateurInput | AdresseUpdateWithWhereUniqueWithoutUtilisateurInput[]
    updateMany?: AdresseUpdateManyWithWhereWithoutUtilisateurInput | AdresseUpdateManyWithWhereWithoutUtilisateurInput[]
    deleteMany?: AdresseScalarWhereInput | AdresseScalarWhereInput[]
  }

  export type ContactUpdateManyWithoutUtilisateurNestedInput = {
    create?: XOR<ContactCreateWithoutUtilisateurInput, ContactUncheckedCreateWithoutUtilisateurInput> | ContactCreateWithoutUtilisateurInput[] | ContactUncheckedCreateWithoutUtilisateurInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutUtilisateurInput | ContactCreateOrConnectWithoutUtilisateurInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutUtilisateurInput | ContactUpsertWithWhereUniqueWithoutUtilisateurInput[]
    createMany?: ContactCreateManyUtilisateurInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutUtilisateurInput | ContactUpdateWithWhereUniqueWithoutUtilisateurInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutUtilisateurInput | ContactUpdateManyWithWhereWithoutUtilisateurInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type ProduitUpdateManyWithoutUtilisateurNestedInput = {
    create?: XOR<ProduitCreateWithoutUtilisateurInput, ProduitUncheckedCreateWithoutUtilisateurInput> | ProduitCreateWithoutUtilisateurInput[] | ProduitUncheckedCreateWithoutUtilisateurInput[]
    connectOrCreate?: ProduitCreateOrConnectWithoutUtilisateurInput | ProduitCreateOrConnectWithoutUtilisateurInput[]
    upsert?: ProduitUpsertWithWhereUniqueWithoutUtilisateurInput | ProduitUpsertWithWhereUniqueWithoutUtilisateurInput[]
    createMany?: ProduitCreateManyUtilisateurInputEnvelope
    set?: ProduitWhereUniqueInput | ProduitWhereUniqueInput[]
    disconnect?: ProduitWhereUniqueInput | ProduitWhereUniqueInput[]
    delete?: ProduitWhereUniqueInput | ProduitWhereUniqueInput[]
    connect?: ProduitWhereUniqueInput | ProduitWhereUniqueInput[]
    update?: ProduitUpdateWithWhereUniqueWithoutUtilisateurInput | ProduitUpdateWithWhereUniqueWithoutUtilisateurInput[]
    updateMany?: ProduitUpdateManyWithWhereWithoutUtilisateurInput | ProduitUpdateManyWithWhereWithoutUtilisateurInput[]
    deleteMany?: ProduitScalarWhereInput | ProduitScalarWhereInput[]
  }

  export type VenteUpdateManyWithoutUtilisateurNestedInput = {
    create?: XOR<VenteCreateWithoutUtilisateurInput, VenteUncheckedCreateWithoutUtilisateurInput> | VenteCreateWithoutUtilisateurInput[] | VenteUncheckedCreateWithoutUtilisateurInput[]
    connectOrCreate?: VenteCreateOrConnectWithoutUtilisateurInput | VenteCreateOrConnectWithoutUtilisateurInput[]
    upsert?: VenteUpsertWithWhereUniqueWithoutUtilisateurInput | VenteUpsertWithWhereUniqueWithoutUtilisateurInput[]
    createMany?: VenteCreateManyUtilisateurInputEnvelope
    set?: VenteWhereUniqueInput | VenteWhereUniqueInput[]
    disconnect?: VenteWhereUniqueInput | VenteWhereUniqueInput[]
    delete?: VenteWhereUniqueInput | VenteWhereUniqueInput[]
    connect?: VenteWhereUniqueInput | VenteWhereUniqueInput[]
    update?: VenteUpdateWithWhereUniqueWithoutUtilisateurInput | VenteUpdateWithWhereUniqueWithoutUtilisateurInput[]
    updateMany?: VenteUpdateManyWithWhereWithoutUtilisateurInput | VenteUpdateManyWithWhereWithoutUtilisateurInput[]
    deleteMany?: VenteScalarWhereInput | VenteScalarWhereInput[]
  }

  export type AchatUpdateManyWithoutUtilisateurNestedInput = {
    create?: XOR<AchatCreateWithoutUtilisateurInput, AchatUncheckedCreateWithoutUtilisateurInput> | AchatCreateWithoutUtilisateurInput[] | AchatUncheckedCreateWithoutUtilisateurInput[]
    connectOrCreate?: AchatCreateOrConnectWithoutUtilisateurInput | AchatCreateOrConnectWithoutUtilisateurInput[]
    upsert?: AchatUpsertWithWhereUniqueWithoutUtilisateurInput | AchatUpsertWithWhereUniqueWithoutUtilisateurInput[]
    createMany?: AchatCreateManyUtilisateurInputEnvelope
    set?: AchatWhereUniqueInput | AchatWhereUniqueInput[]
    disconnect?: AchatWhereUniqueInput | AchatWhereUniqueInput[]
    delete?: AchatWhereUniqueInput | AchatWhereUniqueInput[]
    connect?: AchatWhereUniqueInput | AchatWhereUniqueInput[]
    update?: AchatUpdateWithWhereUniqueWithoutUtilisateurInput | AchatUpdateWithWhereUniqueWithoutUtilisateurInput[]
    updateMany?: AchatUpdateManyWithWhereWithoutUtilisateurInput | AchatUpdateManyWithWhereWithoutUtilisateurInput[]
    deleteMany?: AchatScalarWhereInput | AchatScalarWhereInput[]
  }

  export type TeneurUpdateManyWithoutUtilisateurNestedInput = {
    create?: XOR<TeneurCreateWithoutUtilisateurInput, TeneurUncheckedCreateWithoutUtilisateurInput> | TeneurCreateWithoutUtilisateurInput[] | TeneurUncheckedCreateWithoutUtilisateurInput[]
    connectOrCreate?: TeneurCreateOrConnectWithoutUtilisateurInput | TeneurCreateOrConnectWithoutUtilisateurInput[]
    upsert?: TeneurUpsertWithWhereUniqueWithoutUtilisateurInput | TeneurUpsertWithWhereUniqueWithoutUtilisateurInput[]
    createMany?: TeneurCreateManyUtilisateurInputEnvelope
    set?: TeneurWhereUniqueInput | TeneurWhereUniqueInput[]
    disconnect?: TeneurWhereUniqueInput | TeneurWhereUniqueInput[]
    delete?: TeneurWhereUniqueInput | TeneurWhereUniqueInput[]
    connect?: TeneurWhereUniqueInput | TeneurWhereUniqueInput[]
    update?: TeneurUpdateWithWhereUniqueWithoutUtilisateurInput | TeneurUpdateWithWhereUniqueWithoutUtilisateurInput[]
    updateMany?: TeneurUpdateManyWithWhereWithoutUtilisateurInput | TeneurUpdateManyWithWhereWithoutUtilisateurInput[]
    deleteMany?: TeneurScalarWhereInput | TeneurScalarWhereInput[]
  }

  export type DeviseUpdateManyWithoutUtilisateurNestedInput = {
    create?: XOR<DeviseCreateWithoutUtilisateurInput, DeviseUncheckedCreateWithoutUtilisateurInput> | DeviseCreateWithoutUtilisateurInput[] | DeviseUncheckedCreateWithoutUtilisateurInput[]
    connectOrCreate?: DeviseCreateOrConnectWithoutUtilisateurInput | DeviseCreateOrConnectWithoutUtilisateurInput[]
    upsert?: DeviseUpsertWithWhereUniqueWithoutUtilisateurInput | DeviseUpsertWithWhereUniqueWithoutUtilisateurInput[]
    createMany?: DeviseCreateManyUtilisateurInputEnvelope
    set?: DeviseWhereUniqueInput | DeviseWhereUniqueInput[]
    disconnect?: DeviseWhereUniqueInput | DeviseWhereUniqueInput[]
    delete?: DeviseWhereUniqueInput | DeviseWhereUniqueInput[]
    connect?: DeviseWhereUniqueInput | DeviseWhereUniqueInput[]
    update?: DeviseUpdateWithWhereUniqueWithoutUtilisateurInput | DeviseUpdateWithWhereUniqueWithoutUtilisateurInput[]
    updateMany?: DeviseUpdateManyWithWhereWithoutUtilisateurInput | DeviseUpdateManyWithWhereWithoutUtilisateurInput[]
    deleteMany?: DeviseScalarWhereInput | DeviseScalarWhereInput[]
  }

  export type PanierUpdateManyWithoutUtilisateurNestedInput = {
    create?: XOR<PanierCreateWithoutUtilisateurInput, PanierUncheckedCreateWithoutUtilisateurInput> | PanierCreateWithoutUtilisateurInput[] | PanierUncheckedCreateWithoutUtilisateurInput[]
    connectOrCreate?: PanierCreateOrConnectWithoutUtilisateurInput | PanierCreateOrConnectWithoutUtilisateurInput[]
    upsert?: PanierUpsertWithWhereUniqueWithoutUtilisateurInput | PanierUpsertWithWhereUniqueWithoutUtilisateurInput[]
    createMany?: PanierCreateManyUtilisateurInputEnvelope
    set?: PanierWhereUniqueInput | PanierWhereUniqueInput[]
    disconnect?: PanierWhereUniqueInput | PanierWhereUniqueInput[]
    delete?: PanierWhereUniqueInput | PanierWhereUniqueInput[]
    connect?: PanierWhereUniqueInput | PanierWhereUniqueInput[]
    update?: PanierUpdateWithWhereUniqueWithoutUtilisateurInput | PanierUpdateWithWhereUniqueWithoutUtilisateurInput[]
    updateMany?: PanierUpdateManyWithWhereWithoutUtilisateurInput | PanierUpdateManyWithWhereWithoutUtilisateurInput[]
    deleteMany?: PanierScalarWhereInput | PanierScalarWhereInput[]
  }

  export type ReservationUpdateManyWithoutUtilisateurNestedInput = {
    create?: XOR<ReservationCreateWithoutUtilisateurInput, ReservationUncheckedCreateWithoutUtilisateurInput> | ReservationCreateWithoutUtilisateurInput[] | ReservationUncheckedCreateWithoutUtilisateurInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutUtilisateurInput | ReservationCreateOrConnectWithoutUtilisateurInput[]
    upsert?: ReservationUpsertWithWhereUniqueWithoutUtilisateurInput | ReservationUpsertWithWhereUniqueWithoutUtilisateurInput[]
    createMany?: ReservationCreateManyUtilisateurInputEnvelope
    set?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    disconnect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    delete?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    update?: ReservationUpdateWithWhereUniqueWithoutUtilisateurInput | ReservationUpdateWithWhereUniqueWithoutUtilisateurInput[]
    updateMany?: ReservationUpdateManyWithWhereWithoutUtilisateurInput | ReservationUpdateManyWithWhereWithoutUtilisateurInput[]
    deleteMany?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
  }

  export type CommandeUpdateManyWithoutClientNestedInput = {
    create?: XOR<CommandeCreateWithoutClientInput, CommandeUncheckedCreateWithoutClientInput> | CommandeCreateWithoutClientInput[] | CommandeUncheckedCreateWithoutClientInput[]
    connectOrCreate?: CommandeCreateOrConnectWithoutClientInput | CommandeCreateOrConnectWithoutClientInput[]
    upsert?: CommandeUpsertWithWhereUniqueWithoutClientInput | CommandeUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: CommandeCreateManyClientInputEnvelope
    set?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    disconnect?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    delete?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    connect?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    update?: CommandeUpdateWithWhereUniqueWithoutClientInput | CommandeUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: CommandeUpdateManyWithWhereWithoutClientInput | CommandeUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: CommandeScalarWhereInput | CommandeScalarWhereInput[]
  }

  export type CaisseUpdateManyWithoutUtilisateurNestedInput = {
    create?: XOR<CaisseCreateWithoutUtilisateurInput, CaisseUncheckedCreateWithoutUtilisateurInput> | CaisseCreateWithoutUtilisateurInput[] | CaisseUncheckedCreateWithoutUtilisateurInput[]
    connectOrCreate?: CaisseCreateOrConnectWithoutUtilisateurInput | CaisseCreateOrConnectWithoutUtilisateurInput[]
    upsert?: CaisseUpsertWithWhereUniqueWithoutUtilisateurInput | CaisseUpsertWithWhereUniqueWithoutUtilisateurInput[]
    createMany?: CaisseCreateManyUtilisateurInputEnvelope
    set?: CaisseWhereUniqueInput | CaisseWhereUniqueInput[]
    disconnect?: CaisseWhereUniqueInput | CaisseWhereUniqueInput[]
    delete?: CaisseWhereUniqueInput | CaisseWhereUniqueInput[]
    connect?: CaisseWhereUniqueInput | CaisseWhereUniqueInput[]
    update?: CaisseUpdateWithWhereUniqueWithoutUtilisateurInput | CaisseUpdateWithWhereUniqueWithoutUtilisateurInput[]
    updateMany?: CaisseUpdateManyWithWhereWithoutUtilisateurInput | CaisseUpdateManyWithWhereWithoutUtilisateurInput[]
    deleteMany?: CaisseScalarWhereInput | CaisseScalarWhereInput[]
  }

  export type MouvementCaisseUpdateManyWithoutUtilisateurNestedInput = {
    create?: XOR<MouvementCaisseCreateWithoutUtilisateurInput, MouvementCaisseUncheckedCreateWithoutUtilisateurInput> | MouvementCaisseCreateWithoutUtilisateurInput[] | MouvementCaisseUncheckedCreateWithoutUtilisateurInput[]
    connectOrCreate?: MouvementCaisseCreateOrConnectWithoutUtilisateurInput | MouvementCaisseCreateOrConnectWithoutUtilisateurInput[]
    upsert?: MouvementCaisseUpsertWithWhereUniqueWithoutUtilisateurInput | MouvementCaisseUpsertWithWhereUniqueWithoutUtilisateurInput[]
    createMany?: MouvementCaisseCreateManyUtilisateurInputEnvelope
    set?: MouvementCaisseWhereUniqueInput | MouvementCaisseWhereUniqueInput[]
    disconnect?: MouvementCaisseWhereUniqueInput | MouvementCaisseWhereUniqueInput[]
    delete?: MouvementCaisseWhereUniqueInput | MouvementCaisseWhereUniqueInput[]
    connect?: MouvementCaisseWhereUniqueInput | MouvementCaisseWhereUniqueInput[]
    update?: MouvementCaisseUpdateWithWhereUniqueWithoutUtilisateurInput | MouvementCaisseUpdateWithWhereUniqueWithoutUtilisateurInput[]
    updateMany?: MouvementCaisseUpdateManyWithWhereWithoutUtilisateurInput | MouvementCaisseUpdateManyWithWhereWithoutUtilisateurInput[]
    deleteMany?: MouvementCaisseScalarWhereInput | MouvementCaisseScalarWhereInput[]
  }

  export type ClotureCaisseUpdateManyWithoutUtilisateurClotureNestedInput = {
    create?: XOR<ClotureCaisseCreateWithoutUtilisateurClotureInput, ClotureCaisseUncheckedCreateWithoutUtilisateurClotureInput> | ClotureCaisseCreateWithoutUtilisateurClotureInput[] | ClotureCaisseUncheckedCreateWithoutUtilisateurClotureInput[]
    connectOrCreate?: ClotureCaisseCreateOrConnectWithoutUtilisateurClotureInput | ClotureCaisseCreateOrConnectWithoutUtilisateurClotureInput[]
    upsert?: ClotureCaisseUpsertWithWhereUniqueWithoutUtilisateurClotureInput | ClotureCaisseUpsertWithWhereUniqueWithoutUtilisateurClotureInput[]
    createMany?: ClotureCaisseCreateManyUtilisateurClotureInputEnvelope
    set?: ClotureCaisseWhereUniqueInput | ClotureCaisseWhereUniqueInput[]
    disconnect?: ClotureCaisseWhereUniqueInput | ClotureCaisseWhereUniqueInput[]
    delete?: ClotureCaisseWhereUniqueInput | ClotureCaisseWhereUniqueInput[]
    connect?: ClotureCaisseWhereUniqueInput | ClotureCaisseWhereUniqueInput[]
    update?: ClotureCaisseUpdateWithWhereUniqueWithoutUtilisateurClotureInput | ClotureCaisseUpdateWithWhereUniqueWithoutUtilisateurClotureInput[]
    updateMany?: ClotureCaisseUpdateManyWithWhereWithoutUtilisateurClotureInput | ClotureCaisseUpdateManyWithWhereWithoutUtilisateurClotureInput[]
    deleteMany?: ClotureCaisseScalarWhereInput | ClotureCaisseScalarWhereInput[]
  }

  export type AdresseUncheckedUpdateManyWithoutUtilisateurNestedInput = {
    create?: XOR<AdresseCreateWithoutUtilisateurInput, AdresseUncheckedCreateWithoutUtilisateurInput> | AdresseCreateWithoutUtilisateurInput[] | AdresseUncheckedCreateWithoutUtilisateurInput[]
    connectOrCreate?: AdresseCreateOrConnectWithoutUtilisateurInput | AdresseCreateOrConnectWithoutUtilisateurInput[]
    upsert?: AdresseUpsertWithWhereUniqueWithoutUtilisateurInput | AdresseUpsertWithWhereUniqueWithoutUtilisateurInput[]
    createMany?: AdresseCreateManyUtilisateurInputEnvelope
    set?: AdresseWhereUniqueInput | AdresseWhereUniqueInput[]
    disconnect?: AdresseWhereUniqueInput | AdresseWhereUniqueInput[]
    delete?: AdresseWhereUniqueInput | AdresseWhereUniqueInput[]
    connect?: AdresseWhereUniqueInput | AdresseWhereUniqueInput[]
    update?: AdresseUpdateWithWhereUniqueWithoutUtilisateurInput | AdresseUpdateWithWhereUniqueWithoutUtilisateurInput[]
    updateMany?: AdresseUpdateManyWithWhereWithoutUtilisateurInput | AdresseUpdateManyWithWhereWithoutUtilisateurInput[]
    deleteMany?: AdresseScalarWhereInput | AdresseScalarWhereInput[]
  }

  export type ContactUncheckedUpdateManyWithoutUtilisateurNestedInput = {
    create?: XOR<ContactCreateWithoutUtilisateurInput, ContactUncheckedCreateWithoutUtilisateurInput> | ContactCreateWithoutUtilisateurInput[] | ContactUncheckedCreateWithoutUtilisateurInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutUtilisateurInput | ContactCreateOrConnectWithoutUtilisateurInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutUtilisateurInput | ContactUpsertWithWhereUniqueWithoutUtilisateurInput[]
    createMany?: ContactCreateManyUtilisateurInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutUtilisateurInput | ContactUpdateWithWhereUniqueWithoutUtilisateurInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutUtilisateurInput | ContactUpdateManyWithWhereWithoutUtilisateurInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type ProduitUncheckedUpdateManyWithoutUtilisateurNestedInput = {
    create?: XOR<ProduitCreateWithoutUtilisateurInput, ProduitUncheckedCreateWithoutUtilisateurInput> | ProduitCreateWithoutUtilisateurInput[] | ProduitUncheckedCreateWithoutUtilisateurInput[]
    connectOrCreate?: ProduitCreateOrConnectWithoutUtilisateurInput | ProduitCreateOrConnectWithoutUtilisateurInput[]
    upsert?: ProduitUpsertWithWhereUniqueWithoutUtilisateurInput | ProduitUpsertWithWhereUniqueWithoutUtilisateurInput[]
    createMany?: ProduitCreateManyUtilisateurInputEnvelope
    set?: ProduitWhereUniqueInput | ProduitWhereUniqueInput[]
    disconnect?: ProduitWhereUniqueInput | ProduitWhereUniqueInput[]
    delete?: ProduitWhereUniqueInput | ProduitWhereUniqueInput[]
    connect?: ProduitWhereUniqueInput | ProduitWhereUniqueInput[]
    update?: ProduitUpdateWithWhereUniqueWithoutUtilisateurInput | ProduitUpdateWithWhereUniqueWithoutUtilisateurInput[]
    updateMany?: ProduitUpdateManyWithWhereWithoutUtilisateurInput | ProduitUpdateManyWithWhereWithoutUtilisateurInput[]
    deleteMany?: ProduitScalarWhereInput | ProduitScalarWhereInput[]
  }

  export type VenteUncheckedUpdateManyWithoutUtilisateurNestedInput = {
    create?: XOR<VenteCreateWithoutUtilisateurInput, VenteUncheckedCreateWithoutUtilisateurInput> | VenteCreateWithoutUtilisateurInput[] | VenteUncheckedCreateWithoutUtilisateurInput[]
    connectOrCreate?: VenteCreateOrConnectWithoutUtilisateurInput | VenteCreateOrConnectWithoutUtilisateurInput[]
    upsert?: VenteUpsertWithWhereUniqueWithoutUtilisateurInput | VenteUpsertWithWhereUniqueWithoutUtilisateurInput[]
    createMany?: VenteCreateManyUtilisateurInputEnvelope
    set?: VenteWhereUniqueInput | VenteWhereUniqueInput[]
    disconnect?: VenteWhereUniqueInput | VenteWhereUniqueInput[]
    delete?: VenteWhereUniqueInput | VenteWhereUniqueInput[]
    connect?: VenteWhereUniqueInput | VenteWhereUniqueInput[]
    update?: VenteUpdateWithWhereUniqueWithoutUtilisateurInput | VenteUpdateWithWhereUniqueWithoutUtilisateurInput[]
    updateMany?: VenteUpdateManyWithWhereWithoutUtilisateurInput | VenteUpdateManyWithWhereWithoutUtilisateurInput[]
    deleteMany?: VenteScalarWhereInput | VenteScalarWhereInput[]
  }

  export type AchatUncheckedUpdateManyWithoutUtilisateurNestedInput = {
    create?: XOR<AchatCreateWithoutUtilisateurInput, AchatUncheckedCreateWithoutUtilisateurInput> | AchatCreateWithoutUtilisateurInput[] | AchatUncheckedCreateWithoutUtilisateurInput[]
    connectOrCreate?: AchatCreateOrConnectWithoutUtilisateurInput | AchatCreateOrConnectWithoutUtilisateurInput[]
    upsert?: AchatUpsertWithWhereUniqueWithoutUtilisateurInput | AchatUpsertWithWhereUniqueWithoutUtilisateurInput[]
    createMany?: AchatCreateManyUtilisateurInputEnvelope
    set?: AchatWhereUniqueInput | AchatWhereUniqueInput[]
    disconnect?: AchatWhereUniqueInput | AchatWhereUniqueInput[]
    delete?: AchatWhereUniqueInput | AchatWhereUniqueInput[]
    connect?: AchatWhereUniqueInput | AchatWhereUniqueInput[]
    update?: AchatUpdateWithWhereUniqueWithoutUtilisateurInput | AchatUpdateWithWhereUniqueWithoutUtilisateurInput[]
    updateMany?: AchatUpdateManyWithWhereWithoutUtilisateurInput | AchatUpdateManyWithWhereWithoutUtilisateurInput[]
    deleteMany?: AchatScalarWhereInput | AchatScalarWhereInput[]
  }

  export type TeneurUncheckedUpdateManyWithoutUtilisateurNestedInput = {
    create?: XOR<TeneurCreateWithoutUtilisateurInput, TeneurUncheckedCreateWithoutUtilisateurInput> | TeneurCreateWithoutUtilisateurInput[] | TeneurUncheckedCreateWithoutUtilisateurInput[]
    connectOrCreate?: TeneurCreateOrConnectWithoutUtilisateurInput | TeneurCreateOrConnectWithoutUtilisateurInput[]
    upsert?: TeneurUpsertWithWhereUniqueWithoutUtilisateurInput | TeneurUpsertWithWhereUniqueWithoutUtilisateurInput[]
    createMany?: TeneurCreateManyUtilisateurInputEnvelope
    set?: TeneurWhereUniqueInput | TeneurWhereUniqueInput[]
    disconnect?: TeneurWhereUniqueInput | TeneurWhereUniqueInput[]
    delete?: TeneurWhereUniqueInput | TeneurWhereUniqueInput[]
    connect?: TeneurWhereUniqueInput | TeneurWhereUniqueInput[]
    update?: TeneurUpdateWithWhereUniqueWithoutUtilisateurInput | TeneurUpdateWithWhereUniqueWithoutUtilisateurInput[]
    updateMany?: TeneurUpdateManyWithWhereWithoutUtilisateurInput | TeneurUpdateManyWithWhereWithoutUtilisateurInput[]
    deleteMany?: TeneurScalarWhereInput | TeneurScalarWhereInput[]
  }

  export type DeviseUncheckedUpdateManyWithoutUtilisateurNestedInput = {
    create?: XOR<DeviseCreateWithoutUtilisateurInput, DeviseUncheckedCreateWithoutUtilisateurInput> | DeviseCreateWithoutUtilisateurInput[] | DeviseUncheckedCreateWithoutUtilisateurInput[]
    connectOrCreate?: DeviseCreateOrConnectWithoutUtilisateurInput | DeviseCreateOrConnectWithoutUtilisateurInput[]
    upsert?: DeviseUpsertWithWhereUniqueWithoutUtilisateurInput | DeviseUpsertWithWhereUniqueWithoutUtilisateurInput[]
    createMany?: DeviseCreateManyUtilisateurInputEnvelope
    set?: DeviseWhereUniqueInput | DeviseWhereUniqueInput[]
    disconnect?: DeviseWhereUniqueInput | DeviseWhereUniqueInput[]
    delete?: DeviseWhereUniqueInput | DeviseWhereUniqueInput[]
    connect?: DeviseWhereUniqueInput | DeviseWhereUniqueInput[]
    update?: DeviseUpdateWithWhereUniqueWithoutUtilisateurInput | DeviseUpdateWithWhereUniqueWithoutUtilisateurInput[]
    updateMany?: DeviseUpdateManyWithWhereWithoutUtilisateurInput | DeviseUpdateManyWithWhereWithoutUtilisateurInput[]
    deleteMany?: DeviseScalarWhereInput | DeviseScalarWhereInput[]
  }

  export type PanierUncheckedUpdateManyWithoutUtilisateurNestedInput = {
    create?: XOR<PanierCreateWithoutUtilisateurInput, PanierUncheckedCreateWithoutUtilisateurInput> | PanierCreateWithoutUtilisateurInput[] | PanierUncheckedCreateWithoutUtilisateurInput[]
    connectOrCreate?: PanierCreateOrConnectWithoutUtilisateurInput | PanierCreateOrConnectWithoutUtilisateurInput[]
    upsert?: PanierUpsertWithWhereUniqueWithoutUtilisateurInput | PanierUpsertWithWhereUniqueWithoutUtilisateurInput[]
    createMany?: PanierCreateManyUtilisateurInputEnvelope
    set?: PanierWhereUniqueInput | PanierWhereUniqueInput[]
    disconnect?: PanierWhereUniqueInput | PanierWhereUniqueInput[]
    delete?: PanierWhereUniqueInput | PanierWhereUniqueInput[]
    connect?: PanierWhereUniqueInput | PanierWhereUniqueInput[]
    update?: PanierUpdateWithWhereUniqueWithoutUtilisateurInput | PanierUpdateWithWhereUniqueWithoutUtilisateurInput[]
    updateMany?: PanierUpdateManyWithWhereWithoutUtilisateurInput | PanierUpdateManyWithWhereWithoutUtilisateurInput[]
    deleteMany?: PanierScalarWhereInput | PanierScalarWhereInput[]
  }

  export type ReservationUncheckedUpdateManyWithoutUtilisateurNestedInput = {
    create?: XOR<ReservationCreateWithoutUtilisateurInput, ReservationUncheckedCreateWithoutUtilisateurInput> | ReservationCreateWithoutUtilisateurInput[] | ReservationUncheckedCreateWithoutUtilisateurInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutUtilisateurInput | ReservationCreateOrConnectWithoutUtilisateurInput[]
    upsert?: ReservationUpsertWithWhereUniqueWithoutUtilisateurInput | ReservationUpsertWithWhereUniqueWithoutUtilisateurInput[]
    createMany?: ReservationCreateManyUtilisateurInputEnvelope
    set?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    disconnect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    delete?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    update?: ReservationUpdateWithWhereUniqueWithoutUtilisateurInput | ReservationUpdateWithWhereUniqueWithoutUtilisateurInput[]
    updateMany?: ReservationUpdateManyWithWhereWithoutUtilisateurInput | ReservationUpdateManyWithWhereWithoutUtilisateurInput[]
    deleteMany?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
  }

  export type CommandeUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<CommandeCreateWithoutClientInput, CommandeUncheckedCreateWithoutClientInput> | CommandeCreateWithoutClientInput[] | CommandeUncheckedCreateWithoutClientInput[]
    connectOrCreate?: CommandeCreateOrConnectWithoutClientInput | CommandeCreateOrConnectWithoutClientInput[]
    upsert?: CommandeUpsertWithWhereUniqueWithoutClientInput | CommandeUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: CommandeCreateManyClientInputEnvelope
    set?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    disconnect?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    delete?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    connect?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    update?: CommandeUpdateWithWhereUniqueWithoutClientInput | CommandeUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: CommandeUpdateManyWithWhereWithoutClientInput | CommandeUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: CommandeScalarWhereInput | CommandeScalarWhereInput[]
  }

  export type CaisseUncheckedUpdateManyWithoutUtilisateurNestedInput = {
    create?: XOR<CaisseCreateWithoutUtilisateurInput, CaisseUncheckedCreateWithoutUtilisateurInput> | CaisseCreateWithoutUtilisateurInput[] | CaisseUncheckedCreateWithoutUtilisateurInput[]
    connectOrCreate?: CaisseCreateOrConnectWithoutUtilisateurInput | CaisseCreateOrConnectWithoutUtilisateurInput[]
    upsert?: CaisseUpsertWithWhereUniqueWithoutUtilisateurInput | CaisseUpsertWithWhereUniqueWithoutUtilisateurInput[]
    createMany?: CaisseCreateManyUtilisateurInputEnvelope
    set?: CaisseWhereUniqueInput | CaisseWhereUniqueInput[]
    disconnect?: CaisseWhereUniqueInput | CaisseWhereUniqueInput[]
    delete?: CaisseWhereUniqueInput | CaisseWhereUniqueInput[]
    connect?: CaisseWhereUniqueInput | CaisseWhereUniqueInput[]
    update?: CaisseUpdateWithWhereUniqueWithoutUtilisateurInput | CaisseUpdateWithWhereUniqueWithoutUtilisateurInput[]
    updateMany?: CaisseUpdateManyWithWhereWithoutUtilisateurInput | CaisseUpdateManyWithWhereWithoutUtilisateurInput[]
    deleteMany?: CaisseScalarWhereInput | CaisseScalarWhereInput[]
  }

  export type MouvementCaisseUncheckedUpdateManyWithoutUtilisateurNestedInput = {
    create?: XOR<MouvementCaisseCreateWithoutUtilisateurInput, MouvementCaisseUncheckedCreateWithoutUtilisateurInput> | MouvementCaisseCreateWithoutUtilisateurInput[] | MouvementCaisseUncheckedCreateWithoutUtilisateurInput[]
    connectOrCreate?: MouvementCaisseCreateOrConnectWithoutUtilisateurInput | MouvementCaisseCreateOrConnectWithoutUtilisateurInput[]
    upsert?: MouvementCaisseUpsertWithWhereUniqueWithoutUtilisateurInput | MouvementCaisseUpsertWithWhereUniqueWithoutUtilisateurInput[]
    createMany?: MouvementCaisseCreateManyUtilisateurInputEnvelope
    set?: MouvementCaisseWhereUniqueInput | MouvementCaisseWhereUniqueInput[]
    disconnect?: MouvementCaisseWhereUniqueInput | MouvementCaisseWhereUniqueInput[]
    delete?: MouvementCaisseWhereUniqueInput | MouvementCaisseWhereUniqueInput[]
    connect?: MouvementCaisseWhereUniqueInput | MouvementCaisseWhereUniqueInput[]
    update?: MouvementCaisseUpdateWithWhereUniqueWithoutUtilisateurInput | MouvementCaisseUpdateWithWhereUniqueWithoutUtilisateurInput[]
    updateMany?: MouvementCaisseUpdateManyWithWhereWithoutUtilisateurInput | MouvementCaisseUpdateManyWithWhereWithoutUtilisateurInput[]
    deleteMany?: MouvementCaisseScalarWhereInput | MouvementCaisseScalarWhereInput[]
  }

  export type ClotureCaisseUncheckedUpdateManyWithoutUtilisateurClotureNestedInput = {
    create?: XOR<ClotureCaisseCreateWithoutUtilisateurClotureInput, ClotureCaisseUncheckedCreateWithoutUtilisateurClotureInput> | ClotureCaisseCreateWithoutUtilisateurClotureInput[] | ClotureCaisseUncheckedCreateWithoutUtilisateurClotureInput[]
    connectOrCreate?: ClotureCaisseCreateOrConnectWithoutUtilisateurClotureInput | ClotureCaisseCreateOrConnectWithoutUtilisateurClotureInput[]
    upsert?: ClotureCaisseUpsertWithWhereUniqueWithoutUtilisateurClotureInput | ClotureCaisseUpsertWithWhereUniqueWithoutUtilisateurClotureInput[]
    createMany?: ClotureCaisseCreateManyUtilisateurClotureInputEnvelope
    set?: ClotureCaisseWhereUniqueInput | ClotureCaisseWhereUniqueInput[]
    disconnect?: ClotureCaisseWhereUniqueInput | ClotureCaisseWhereUniqueInput[]
    delete?: ClotureCaisseWhereUniqueInput | ClotureCaisseWhereUniqueInput[]
    connect?: ClotureCaisseWhereUniqueInput | ClotureCaisseWhereUniqueInput[]
    update?: ClotureCaisseUpdateWithWhereUniqueWithoutUtilisateurClotureInput | ClotureCaisseUpdateWithWhereUniqueWithoutUtilisateurClotureInput[]
    updateMany?: ClotureCaisseUpdateManyWithWhereWithoutUtilisateurClotureInput | ClotureCaisseUpdateManyWithWhereWithoutUtilisateurClotureInput[]
    deleteMany?: ClotureCaisseScalarWhereInput | ClotureCaisseScalarWhereInput[]
  }

  export type UtilisateurCreateNestedOneWithoutAdresseInput = {
    create?: XOR<UtilisateurCreateWithoutAdresseInput, UtilisateurUncheckedCreateWithoutAdresseInput>
    connectOrCreate?: UtilisateurCreateOrConnectWithoutAdresseInput
    connect?: UtilisateurWhereUniqueInput
  }

  export type FournisseurCreateNestedOneWithoutAdresseInput = {
    create?: XOR<FournisseurCreateWithoutAdresseInput, FournisseurUncheckedCreateWithoutAdresseInput>
    connectOrCreate?: FournisseurCreateOrConnectWithoutAdresseInput
    connect?: FournisseurWhereUniqueInput
  }

  export type ReservationCreateNestedManyWithoutAdresseInput = {
    create?: XOR<ReservationCreateWithoutAdresseInput, ReservationUncheckedCreateWithoutAdresseInput> | ReservationCreateWithoutAdresseInput[] | ReservationUncheckedCreateWithoutAdresseInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutAdresseInput | ReservationCreateOrConnectWithoutAdresseInput[]
    createMany?: ReservationCreateManyAdresseInputEnvelope
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
  }

  export type CommandeCreateNestedManyWithoutAdresseInput = {
    create?: XOR<CommandeCreateWithoutAdresseInput, CommandeUncheckedCreateWithoutAdresseInput> | CommandeCreateWithoutAdresseInput[] | CommandeUncheckedCreateWithoutAdresseInput[]
    connectOrCreate?: CommandeCreateOrConnectWithoutAdresseInput | CommandeCreateOrConnectWithoutAdresseInput[]
    createMany?: CommandeCreateManyAdresseInputEnvelope
    connect?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
  }

  export type ReservationUncheckedCreateNestedManyWithoutAdresseInput = {
    create?: XOR<ReservationCreateWithoutAdresseInput, ReservationUncheckedCreateWithoutAdresseInput> | ReservationCreateWithoutAdresseInput[] | ReservationUncheckedCreateWithoutAdresseInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutAdresseInput | ReservationCreateOrConnectWithoutAdresseInput[]
    createMany?: ReservationCreateManyAdresseInputEnvelope
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
  }

  export type CommandeUncheckedCreateNestedManyWithoutAdresseInput = {
    create?: XOR<CommandeCreateWithoutAdresseInput, CommandeUncheckedCreateWithoutAdresseInput> | CommandeCreateWithoutAdresseInput[] | CommandeUncheckedCreateWithoutAdresseInput[]
    connectOrCreate?: CommandeCreateOrConnectWithoutAdresseInput | CommandeCreateOrConnectWithoutAdresseInput[]
    createMany?: CommandeCreateManyAdresseInputEnvelope
    connect?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
  }

  export type UtilisateurUpdateOneWithoutAdresseNestedInput = {
    create?: XOR<UtilisateurCreateWithoutAdresseInput, UtilisateurUncheckedCreateWithoutAdresseInput>
    connectOrCreate?: UtilisateurCreateOrConnectWithoutAdresseInput
    upsert?: UtilisateurUpsertWithoutAdresseInput
    disconnect?: UtilisateurWhereInput | boolean
    delete?: UtilisateurWhereInput | boolean
    connect?: UtilisateurWhereUniqueInput
    update?: XOR<XOR<UtilisateurUpdateToOneWithWhereWithoutAdresseInput, UtilisateurUpdateWithoutAdresseInput>, UtilisateurUncheckedUpdateWithoutAdresseInput>
  }

  export type FournisseurUpdateOneWithoutAdresseNestedInput = {
    create?: XOR<FournisseurCreateWithoutAdresseInput, FournisseurUncheckedCreateWithoutAdresseInput>
    connectOrCreate?: FournisseurCreateOrConnectWithoutAdresseInput
    upsert?: FournisseurUpsertWithoutAdresseInput
    disconnect?: FournisseurWhereInput | boolean
    delete?: FournisseurWhereInput | boolean
    connect?: FournisseurWhereUniqueInput
    update?: XOR<XOR<FournisseurUpdateToOneWithWhereWithoutAdresseInput, FournisseurUpdateWithoutAdresseInput>, FournisseurUncheckedUpdateWithoutAdresseInput>
  }

  export type ReservationUpdateManyWithoutAdresseNestedInput = {
    create?: XOR<ReservationCreateWithoutAdresseInput, ReservationUncheckedCreateWithoutAdresseInput> | ReservationCreateWithoutAdresseInput[] | ReservationUncheckedCreateWithoutAdresseInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutAdresseInput | ReservationCreateOrConnectWithoutAdresseInput[]
    upsert?: ReservationUpsertWithWhereUniqueWithoutAdresseInput | ReservationUpsertWithWhereUniqueWithoutAdresseInput[]
    createMany?: ReservationCreateManyAdresseInputEnvelope
    set?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    disconnect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    delete?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    update?: ReservationUpdateWithWhereUniqueWithoutAdresseInput | ReservationUpdateWithWhereUniqueWithoutAdresseInput[]
    updateMany?: ReservationUpdateManyWithWhereWithoutAdresseInput | ReservationUpdateManyWithWhereWithoutAdresseInput[]
    deleteMany?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
  }

  export type CommandeUpdateManyWithoutAdresseNestedInput = {
    create?: XOR<CommandeCreateWithoutAdresseInput, CommandeUncheckedCreateWithoutAdresseInput> | CommandeCreateWithoutAdresseInput[] | CommandeUncheckedCreateWithoutAdresseInput[]
    connectOrCreate?: CommandeCreateOrConnectWithoutAdresseInput | CommandeCreateOrConnectWithoutAdresseInput[]
    upsert?: CommandeUpsertWithWhereUniqueWithoutAdresseInput | CommandeUpsertWithWhereUniqueWithoutAdresseInput[]
    createMany?: CommandeCreateManyAdresseInputEnvelope
    set?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    disconnect?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    delete?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    connect?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    update?: CommandeUpdateWithWhereUniqueWithoutAdresseInput | CommandeUpdateWithWhereUniqueWithoutAdresseInput[]
    updateMany?: CommandeUpdateManyWithWhereWithoutAdresseInput | CommandeUpdateManyWithWhereWithoutAdresseInput[]
    deleteMany?: CommandeScalarWhereInput | CommandeScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ReservationUncheckedUpdateManyWithoutAdresseNestedInput = {
    create?: XOR<ReservationCreateWithoutAdresseInput, ReservationUncheckedCreateWithoutAdresseInput> | ReservationCreateWithoutAdresseInput[] | ReservationUncheckedCreateWithoutAdresseInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutAdresseInput | ReservationCreateOrConnectWithoutAdresseInput[]
    upsert?: ReservationUpsertWithWhereUniqueWithoutAdresseInput | ReservationUpsertWithWhereUniqueWithoutAdresseInput[]
    createMany?: ReservationCreateManyAdresseInputEnvelope
    set?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    disconnect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    delete?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    update?: ReservationUpdateWithWhereUniqueWithoutAdresseInput | ReservationUpdateWithWhereUniqueWithoutAdresseInput[]
    updateMany?: ReservationUpdateManyWithWhereWithoutAdresseInput | ReservationUpdateManyWithWhereWithoutAdresseInput[]
    deleteMany?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
  }

  export type CommandeUncheckedUpdateManyWithoutAdresseNestedInput = {
    create?: XOR<CommandeCreateWithoutAdresseInput, CommandeUncheckedCreateWithoutAdresseInput> | CommandeCreateWithoutAdresseInput[] | CommandeUncheckedCreateWithoutAdresseInput[]
    connectOrCreate?: CommandeCreateOrConnectWithoutAdresseInput | CommandeCreateOrConnectWithoutAdresseInput[]
    upsert?: CommandeUpsertWithWhereUniqueWithoutAdresseInput | CommandeUpsertWithWhereUniqueWithoutAdresseInput[]
    createMany?: CommandeCreateManyAdresseInputEnvelope
    set?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    disconnect?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    delete?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    connect?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    update?: CommandeUpdateWithWhereUniqueWithoutAdresseInput | CommandeUpdateWithWhereUniqueWithoutAdresseInput[]
    updateMany?: CommandeUpdateManyWithWhereWithoutAdresseInput | CommandeUpdateManyWithWhereWithoutAdresseInput[]
    deleteMany?: CommandeScalarWhereInput | CommandeScalarWhereInput[]
  }

  export type UtilisateurCreateNestedOneWithoutContactInput = {
    create?: XOR<UtilisateurCreateWithoutContactInput, UtilisateurUncheckedCreateWithoutContactInput>
    connectOrCreate?: UtilisateurCreateOrConnectWithoutContactInput
    connect?: UtilisateurWhereUniqueInput
  }

  export type FournisseurCreateNestedOneWithoutContactInput = {
    create?: XOR<FournisseurCreateWithoutContactInput, FournisseurUncheckedCreateWithoutContactInput>
    connectOrCreate?: FournisseurCreateOrConnectWithoutContactInput
    connect?: FournisseurWhereUniqueInput
  }

  export type ReservationCreateNestedManyWithoutContactInput = {
    create?: XOR<ReservationCreateWithoutContactInput, ReservationUncheckedCreateWithoutContactInput> | ReservationCreateWithoutContactInput[] | ReservationUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutContactInput | ReservationCreateOrConnectWithoutContactInput[]
    createMany?: ReservationCreateManyContactInputEnvelope
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
  }

  export type CommandeCreateNestedManyWithoutContactInput = {
    create?: XOR<CommandeCreateWithoutContactInput, CommandeUncheckedCreateWithoutContactInput> | CommandeCreateWithoutContactInput[] | CommandeUncheckedCreateWithoutContactInput[]
    connectOrCreate?: CommandeCreateOrConnectWithoutContactInput | CommandeCreateOrConnectWithoutContactInput[]
    createMany?: CommandeCreateManyContactInputEnvelope
    connect?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
  }

  export type ReservationUncheckedCreateNestedManyWithoutContactInput = {
    create?: XOR<ReservationCreateWithoutContactInput, ReservationUncheckedCreateWithoutContactInput> | ReservationCreateWithoutContactInput[] | ReservationUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutContactInput | ReservationCreateOrConnectWithoutContactInput[]
    createMany?: ReservationCreateManyContactInputEnvelope
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
  }

  export type CommandeUncheckedCreateNestedManyWithoutContactInput = {
    create?: XOR<CommandeCreateWithoutContactInput, CommandeUncheckedCreateWithoutContactInput> | CommandeCreateWithoutContactInput[] | CommandeUncheckedCreateWithoutContactInput[]
    connectOrCreate?: CommandeCreateOrConnectWithoutContactInput | CommandeCreateOrConnectWithoutContactInput[]
    createMany?: CommandeCreateManyContactInputEnvelope
    connect?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
  }

  export type UtilisateurUpdateOneWithoutContactNestedInput = {
    create?: XOR<UtilisateurCreateWithoutContactInput, UtilisateurUncheckedCreateWithoutContactInput>
    connectOrCreate?: UtilisateurCreateOrConnectWithoutContactInput
    upsert?: UtilisateurUpsertWithoutContactInput
    disconnect?: UtilisateurWhereInput | boolean
    delete?: UtilisateurWhereInput | boolean
    connect?: UtilisateurWhereUniqueInput
    update?: XOR<XOR<UtilisateurUpdateToOneWithWhereWithoutContactInput, UtilisateurUpdateWithoutContactInput>, UtilisateurUncheckedUpdateWithoutContactInput>
  }

  export type FournisseurUpdateOneWithoutContactNestedInput = {
    create?: XOR<FournisseurCreateWithoutContactInput, FournisseurUncheckedCreateWithoutContactInput>
    connectOrCreate?: FournisseurCreateOrConnectWithoutContactInput
    upsert?: FournisseurUpsertWithoutContactInput
    disconnect?: FournisseurWhereInput | boolean
    delete?: FournisseurWhereInput | boolean
    connect?: FournisseurWhereUniqueInput
    update?: XOR<XOR<FournisseurUpdateToOneWithWhereWithoutContactInput, FournisseurUpdateWithoutContactInput>, FournisseurUncheckedUpdateWithoutContactInput>
  }

  export type ReservationUpdateManyWithoutContactNestedInput = {
    create?: XOR<ReservationCreateWithoutContactInput, ReservationUncheckedCreateWithoutContactInput> | ReservationCreateWithoutContactInput[] | ReservationUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutContactInput | ReservationCreateOrConnectWithoutContactInput[]
    upsert?: ReservationUpsertWithWhereUniqueWithoutContactInput | ReservationUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: ReservationCreateManyContactInputEnvelope
    set?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    disconnect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    delete?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    update?: ReservationUpdateWithWhereUniqueWithoutContactInput | ReservationUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: ReservationUpdateManyWithWhereWithoutContactInput | ReservationUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
  }

  export type CommandeUpdateManyWithoutContactNestedInput = {
    create?: XOR<CommandeCreateWithoutContactInput, CommandeUncheckedCreateWithoutContactInput> | CommandeCreateWithoutContactInput[] | CommandeUncheckedCreateWithoutContactInput[]
    connectOrCreate?: CommandeCreateOrConnectWithoutContactInput | CommandeCreateOrConnectWithoutContactInput[]
    upsert?: CommandeUpsertWithWhereUniqueWithoutContactInput | CommandeUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: CommandeCreateManyContactInputEnvelope
    set?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    disconnect?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    delete?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    connect?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    update?: CommandeUpdateWithWhereUniqueWithoutContactInput | CommandeUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: CommandeUpdateManyWithWhereWithoutContactInput | CommandeUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: CommandeScalarWhereInput | CommandeScalarWhereInput[]
  }

  export type ReservationUncheckedUpdateManyWithoutContactNestedInput = {
    create?: XOR<ReservationCreateWithoutContactInput, ReservationUncheckedCreateWithoutContactInput> | ReservationCreateWithoutContactInput[] | ReservationUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutContactInput | ReservationCreateOrConnectWithoutContactInput[]
    upsert?: ReservationUpsertWithWhereUniqueWithoutContactInput | ReservationUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: ReservationCreateManyContactInputEnvelope
    set?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    disconnect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    delete?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    update?: ReservationUpdateWithWhereUniqueWithoutContactInput | ReservationUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: ReservationUpdateManyWithWhereWithoutContactInput | ReservationUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
  }

  export type CommandeUncheckedUpdateManyWithoutContactNestedInput = {
    create?: XOR<CommandeCreateWithoutContactInput, CommandeUncheckedCreateWithoutContactInput> | CommandeCreateWithoutContactInput[] | CommandeUncheckedCreateWithoutContactInput[]
    connectOrCreate?: CommandeCreateOrConnectWithoutContactInput | CommandeCreateOrConnectWithoutContactInput[]
    upsert?: CommandeUpsertWithWhereUniqueWithoutContactInput | CommandeUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: CommandeCreateManyContactInputEnvelope
    set?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    disconnect?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    delete?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    connect?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    update?: CommandeUpdateWithWhereUniqueWithoutContactInput | CommandeUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: CommandeUpdateManyWithWhereWithoutContactInput | CommandeUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: CommandeScalarWhereInput | CommandeScalarWhereInput[]
  }

  export type VenteCreateNestedManyWithoutFournisseurInput = {
    create?: XOR<VenteCreateWithoutFournisseurInput, VenteUncheckedCreateWithoutFournisseurInput> | VenteCreateWithoutFournisseurInput[] | VenteUncheckedCreateWithoutFournisseurInput[]
    connectOrCreate?: VenteCreateOrConnectWithoutFournisseurInput | VenteCreateOrConnectWithoutFournisseurInput[]
    createMany?: VenteCreateManyFournisseurInputEnvelope
    connect?: VenteWhereUniqueInput | VenteWhereUniqueInput[]
  }

  export type AchatCreateNestedManyWithoutFournisseurInput = {
    create?: XOR<AchatCreateWithoutFournisseurInput, AchatUncheckedCreateWithoutFournisseurInput> | AchatCreateWithoutFournisseurInput[] | AchatUncheckedCreateWithoutFournisseurInput[]
    connectOrCreate?: AchatCreateOrConnectWithoutFournisseurInput | AchatCreateOrConnectWithoutFournisseurInput[]
    createMany?: AchatCreateManyFournisseurInputEnvelope
    connect?: AchatWhereUniqueInput | AchatWhereUniqueInput[]
  }

  export type AdresseCreateNestedManyWithoutFournisseurInput = {
    create?: XOR<AdresseCreateWithoutFournisseurInput, AdresseUncheckedCreateWithoutFournisseurInput> | AdresseCreateWithoutFournisseurInput[] | AdresseUncheckedCreateWithoutFournisseurInput[]
    connectOrCreate?: AdresseCreateOrConnectWithoutFournisseurInput | AdresseCreateOrConnectWithoutFournisseurInput[]
    createMany?: AdresseCreateManyFournisseurInputEnvelope
    connect?: AdresseWhereUniqueInput | AdresseWhereUniqueInput[]
  }

  export type ContactCreateNestedManyWithoutFournisseurInput = {
    create?: XOR<ContactCreateWithoutFournisseurInput, ContactUncheckedCreateWithoutFournisseurInput> | ContactCreateWithoutFournisseurInput[] | ContactUncheckedCreateWithoutFournisseurInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutFournisseurInput | ContactCreateOrConnectWithoutFournisseurInput[]
    createMany?: ContactCreateManyFournisseurInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type ReservationCreateNestedManyWithoutFournisseurInput = {
    create?: XOR<ReservationCreateWithoutFournisseurInput, ReservationUncheckedCreateWithoutFournisseurInput> | ReservationCreateWithoutFournisseurInput[] | ReservationUncheckedCreateWithoutFournisseurInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutFournisseurInput | ReservationCreateOrConnectWithoutFournisseurInput[]
    createMany?: ReservationCreateManyFournisseurInputEnvelope
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
  }

  export type CommandeCreateNestedManyWithoutFournisseurInput = {
    create?: XOR<CommandeCreateWithoutFournisseurInput, CommandeUncheckedCreateWithoutFournisseurInput> | CommandeCreateWithoutFournisseurInput[] | CommandeUncheckedCreateWithoutFournisseurInput[]
    connectOrCreate?: CommandeCreateOrConnectWithoutFournisseurInput | CommandeCreateOrConnectWithoutFournisseurInput[]
    createMany?: CommandeCreateManyFournisseurInputEnvelope
    connect?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
  }

  export type VenteUncheckedCreateNestedManyWithoutFournisseurInput = {
    create?: XOR<VenteCreateWithoutFournisseurInput, VenteUncheckedCreateWithoutFournisseurInput> | VenteCreateWithoutFournisseurInput[] | VenteUncheckedCreateWithoutFournisseurInput[]
    connectOrCreate?: VenteCreateOrConnectWithoutFournisseurInput | VenteCreateOrConnectWithoutFournisseurInput[]
    createMany?: VenteCreateManyFournisseurInputEnvelope
    connect?: VenteWhereUniqueInput | VenteWhereUniqueInput[]
  }

  export type AchatUncheckedCreateNestedManyWithoutFournisseurInput = {
    create?: XOR<AchatCreateWithoutFournisseurInput, AchatUncheckedCreateWithoutFournisseurInput> | AchatCreateWithoutFournisseurInput[] | AchatUncheckedCreateWithoutFournisseurInput[]
    connectOrCreate?: AchatCreateOrConnectWithoutFournisseurInput | AchatCreateOrConnectWithoutFournisseurInput[]
    createMany?: AchatCreateManyFournisseurInputEnvelope
    connect?: AchatWhereUniqueInput | AchatWhereUniqueInput[]
  }

  export type AdresseUncheckedCreateNestedManyWithoutFournisseurInput = {
    create?: XOR<AdresseCreateWithoutFournisseurInput, AdresseUncheckedCreateWithoutFournisseurInput> | AdresseCreateWithoutFournisseurInput[] | AdresseUncheckedCreateWithoutFournisseurInput[]
    connectOrCreate?: AdresseCreateOrConnectWithoutFournisseurInput | AdresseCreateOrConnectWithoutFournisseurInput[]
    createMany?: AdresseCreateManyFournisseurInputEnvelope
    connect?: AdresseWhereUniqueInput | AdresseWhereUniqueInput[]
  }

  export type ContactUncheckedCreateNestedManyWithoutFournisseurInput = {
    create?: XOR<ContactCreateWithoutFournisseurInput, ContactUncheckedCreateWithoutFournisseurInput> | ContactCreateWithoutFournisseurInput[] | ContactUncheckedCreateWithoutFournisseurInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutFournisseurInput | ContactCreateOrConnectWithoutFournisseurInput[]
    createMany?: ContactCreateManyFournisseurInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type ReservationUncheckedCreateNestedManyWithoutFournisseurInput = {
    create?: XOR<ReservationCreateWithoutFournisseurInput, ReservationUncheckedCreateWithoutFournisseurInput> | ReservationCreateWithoutFournisseurInput[] | ReservationUncheckedCreateWithoutFournisseurInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutFournisseurInput | ReservationCreateOrConnectWithoutFournisseurInput[]
    createMany?: ReservationCreateManyFournisseurInputEnvelope
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
  }

  export type CommandeUncheckedCreateNestedManyWithoutFournisseurInput = {
    create?: XOR<CommandeCreateWithoutFournisseurInput, CommandeUncheckedCreateWithoutFournisseurInput> | CommandeCreateWithoutFournisseurInput[] | CommandeUncheckedCreateWithoutFournisseurInput[]
    connectOrCreate?: CommandeCreateOrConnectWithoutFournisseurInput | CommandeCreateOrConnectWithoutFournisseurInput[]
    createMany?: CommandeCreateManyFournisseurInputEnvelope
    connect?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
  }

  export type VenteUpdateManyWithoutFournisseurNestedInput = {
    create?: XOR<VenteCreateWithoutFournisseurInput, VenteUncheckedCreateWithoutFournisseurInput> | VenteCreateWithoutFournisseurInput[] | VenteUncheckedCreateWithoutFournisseurInput[]
    connectOrCreate?: VenteCreateOrConnectWithoutFournisseurInput | VenteCreateOrConnectWithoutFournisseurInput[]
    upsert?: VenteUpsertWithWhereUniqueWithoutFournisseurInput | VenteUpsertWithWhereUniqueWithoutFournisseurInput[]
    createMany?: VenteCreateManyFournisseurInputEnvelope
    set?: VenteWhereUniqueInput | VenteWhereUniqueInput[]
    disconnect?: VenteWhereUniqueInput | VenteWhereUniqueInput[]
    delete?: VenteWhereUniqueInput | VenteWhereUniqueInput[]
    connect?: VenteWhereUniqueInput | VenteWhereUniqueInput[]
    update?: VenteUpdateWithWhereUniqueWithoutFournisseurInput | VenteUpdateWithWhereUniqueWithoutFournisseurInput[]
    updateMany?: VenteUpdateManyWithWhereWithoutFournisseurInput | VenteUpdateManyWithWhereWithoutFournisseurInput[]
    deleteMany?: VenteScalarWhereInput | VenteScalarWhereInput[]
  }

  export type AchatUpdateManyWithoutFournisseurNestedInput = {
    create?: XOR<AchatCreateWithoutFournisseurInput, AchatUncheckedCreateWithoutFournisseurInput> | AchatCreateWithoutFournisseurInput[] | AchatUncheckedCreateWithoutFournisseurInput[]
    connectOrCreate?: AchatCreateOrConnectWithoutFournisseurInput | AchatCreateOrConnectWithoutFournisseurInput[]
    upsert?: AchatUpsertWithWhereUniqueWithoutFournisseurInput | AchatUpsertWithWhereUniqueWithoutFournisseurInput[]
    createMany?: AchatCreateManyFournisseurInputEnvelope
    set?: AchatWhereUniqueInput | AchatWhereUniqueInput[]
    disconnect?: AchatWhereUniqueInput | AchatWhereUniqueInput[]
    delete?: AchatWhereUniqueInput | AchatWhereUniqueInput[]
    connect?: AchatWhereUniqueInput | AchatWhereUniqueInput[]
    update?: AchatUpdateWithWhereUniqueWithoutFournisseurInput | AchatUpdateWithWhereUniqueWithoutFournisseurInput[]
    updateMany?: AchatUpdateManyWithWhereWithoutFournisseurInput | AchatUpdateManyWithWhereWithoutFournisseurInput[]
    deleteMany?: AchatScalarWhereInput | AchatScalarWhereInput[]
  }

  export type AdresseUpdateManyWithoutFournisseurNestedInput = {
    create?: XOR<AdresseCreateWithoutFournisseurInput, AdresseUncheckedCreateWithoutFournisseurInput> | AdresseCreateWithoutFournisseurInput[] | AdresseUncheckedCreateWithoutFournisseurInput[]
    connectOrCreate?: AdresseCreateOrConnectWithoutFournisseurInput | AdresseCreateOrConnectWithoutFournisseurInput[]
    upsert?: AdresseUpsertWithWhereUniqueWithoutFournisseurInput | AdresseUpsertWithWhereUniqueWithoutFournisseurInput[]
    createMany?: AdresseCreateManyFournisseurInputEnvelope
    set?: AdresseWhereUniqueInput | AdresseWhereUniqueInput[]
    disconnect?: AdresseWhereUniqueInput | AdresseWhereUniqueInput[]
    delete?: AdresseWhereUniqueInput | AdresseWhereUniqueInput[]
    connect?: AdresseWhereUniqueInput | AdresseWhereUniqueInput[]
    update?: AdresseUpdateWithWhereUniqueWithoutFournisseurInput | AdresseUpdateWithWhereUniqueWithoutFournisseurInput[]
    updateMany?: AdresseUpdateManyWithWhereWithoutFournisseurInput | AdresseUpdateManyWithWhereWithoutFournisseurInput[]
    deleteMany?: AdresseScalarWhereInput | AdresseScalarWhereInput[]
  }

  export type ContactUpdateManyWithoutFournisseurNestedInput = {
    create?: XOR<ContactCreateWithoutFournisseurInput, ContactUncheckedCreateWithoutFournisseurInput> | ContactCreateWithoutFournisseurInput[] | ContactUncheckedCreateWithoutFournisseurInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutFournisseurInput | ContactCreateOrConnectWithoutFournisseurInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutFournisseurInput | ContactUpsertWithWhereUniqueWithoutFournisseurInput[]
    createMany?: ContactCreateManyFournisseurInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutFournisseurInput | ContactUpdateWithWhereUniqueWithoutFournisseurInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutFournisseurInput | ContactUpdateManyWithWhereWithoutFournisseurInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type ReservationUpdateManyWithoutFournisseurNestedInput = {
    create?: XOR<ReservationCreateWithoutFournisseurInput, ReservationUncheckedCreateWithoutFournisseurInput> | ReservationCreateWithoutFournisseurInput[] | ReservationUncheckedCreateWithoutFournisseurInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutFournisseurInput | ReservationCreateOrConnectWithoutFournisseurInput[]
    upsert?: ReservationUpsertWithWhereUniqueWithoutFournisseurInput | ReservationUpsertWithWhereUniqueWithoutFournisseurInput[]
    createMany?: ReservationCreateManyFournisseurInputEnvelope
    set?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    disconnect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    delete?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    update?: ReservationUpdateWithWhereUniqueWithoutFournisseurInput | ReservationUpdateWithWhereUniqueWithoutFournisseurInput[]
    updateMany?: ReservationUpdateManyWithWhereWithoutFournisseurInput | ReservationUpdateManyWithWhereWithoutFournisseurInput[]
    deleteMany?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
  }

  export type CommandeUpdateManyWithoutFournisseurNestedInput = {
    create?: XOR<CommandeCreateWithoutFournisseurInput, CommandeUncheckedCreateWithoutFournisseurInput> | CommandeCreateWithoutFournisseurInput[] | CommandeUncheckedCreateWithoutFournisseurInput[]
    connectOrCreate?: CommandeCreateOrConnectWithoutFournisseurInput | CommandeCreateOrConnectWithoutFournisseurInput[]
    upsert?: CommandeUpsertWithWhereUniqueWithoutFournisseurInput | CommandeUpsertWithWhereUniqueWithoutFournisseurInput[]
    createMany?: CommandeCreateManyFournisseurInputEnvelope
    set?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    disconnect?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    delete?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    connect?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    update?: CommandeUpdateWithWhereUniqueWithoutFournisseurInput | CommandeUpdateWithWhereUniqueWithoutFournisseurInput[]
    updateMany?: CommandeUpdateManyWithWhereWithoutFournisseurInput | CommandeUpdateManyWithWhereWithoutFournisseurInput[]
    deleteMany?: CommandeScalarWhereInput | CommandeScalarWhereInput[]
  }

  export type VenteUncheckedUpdateManyWithoutFournisseurNestedInput = {
    create?: XOR<VenteCreateWithoutFournisseurInput, VenteUncheckedCreateWithoutFournisseurInput> | VenteCreateWithoutFournisseurInput[] | VenteUncheckedCreateWithoutFournisseurInput[]
    connectOrCreate?: VenteCreateOrConnectWithoutFournisseurInput | VenteCreateOrConnectWithoutFournisseurInput[]
    upsert?: VenteUpsertWithWhereUniqueWithoutFournisseurInput | VenteUpsertWithWhereUniqueWithoutFournisseurInput[]
    createMany?: VenteCreateManyFournisseurInputEnvelope
    set?: VenteWhereUniqueInput | VenteWhereUniqueInput[]
    disconnect?: VenteWhereUniqueInput | VenteWhereUniqueInput[]
    delete?: VenteWhereUniqueInput | VenteWhereUniqueInput[]
    connect?: VenteWhereUniqueInput | VenteWhereUniqueInput[]
    update?: VenteUpdateWithWhereUniqueWithoutFournisseurInput | VenteUpdateWithWhereUniqueWithoutFournisseurInput[]
    updateMany?: VenteUpdateManyWithWhereWithoutFournisseurInput | VenteUpdateManyWithWhereWithoutFournisseurInput[]
    deleteMany?: VenteScalarWhereInput | VenteScalarWhereInput[]
  }

  export type AchatUncheckedUpdateManyWithoutFournisseurNestedInput = {
    create?: XOR<AchatCreateWithoutFournisseurInput, AchatUncheckedCreateWithoutFournisseurInput> | AchatCreateWithoutFournisseurInput[] | AchatUncheckedCreateWithoutFournisseurInput[]
    connectOrCreate?: AchatCreateOrConnectWithoutFournisseurInput | AchatCreateOrConnectWithoutFournisseurInput[]
    upsert?: AchatUpsertWithWhereUniqueWithoutFournisseurInput | AchatUpsertWithWhereUniqueWithoutFournisseurInput[]
    createMany?: AchatCreateManyFournisseurInputEnvelope
    set?: AchatWhereUniqueInput | AchatWhereUniqueInput[]
    disconnect?: AchatWhereUniqueInput | AchatWhereUniqueInput[]
    delete?: AchatWhereUniqueInput | AchatWhereUniqueInput[]
    connect?: AchatWhereUniqueInput | AchatWhereUniqueInput[]
    update?: AchatUpdateWithWhereUniqueWithoutFournisseurInput | AchatUpdateWithWhereUniqueWithoutFournisseurInput[]
    updateMany?: AchatUpdateManyWithWhereWithoutFournisseurInput | AchatUpdateManyWithWhereWithoutFournisseurInput[]
    deleteMany?: AchatScalarWhereInput | AchatScalarWhereInput[]
  }

  export type AdresseUncheckedUpdateManyWithoutFournisseurNestedInput = {
    create?: XOR<AdresseCreateWithoutFournisseurInput, AdresseUncheckedCreateWithoutFournisseurInput> | AdresseCreateWithoutFournisseurInput[] | AdresseUncheckedCreateWithoutFournisseurInput[]
    connectOrCreate?: AdresseCreateOrConnectWithoutFournisseurInput | AdresseCreateOrConnectWithoutFournisseurInput[]
    upsert?: AdresseUpsertWithWhereUniqueWithoutFournisseurInput | AdresseUpsertWithWhereUniqueWithoutFournisseurInput[]
    createMany?: AdresseCreateManyFournisseurInputEnvelope
    set?: AdresseWhereUniqueInput | AdresseWhereUniqueInput[]
    disconnect?: AdresseWhereUniqueInput | AdresseWhereUniqueInput[]
    delete?: AdresseWhereUniqueInput | AdresseWhereUniqueInput[]
    connect?: AdresseWhereUniqueInput | AdresseWhereUniqueInput[]
    update?: AdresseUpdateWithWhereUniqueWithoutFournisseurInput | AdresseUpdateWithWhereUniqueWithoutFournisseurInput[]
    updateMany?: AdresseUpdateManyWithWhereWithoutFournisseurInput | AdresseUpdateManyWithWhereWithoutFournisseurInput[]
    deleteMany?: AdresseScalarWhereInput | AdresseScalarWhereInput[]
  }

  export type ContactUncheckedUpdateManyWithoutFournisseurNestedInput = {
    create?: XOR<ContactCreateWithoutFournisseurInput, ContactUncheckedCreateWithoutFournisseurInput> | ContactCreateWithoutFournisseurInput[] | ContactUncheckedCreateWithoutFournisseurInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutFournisseurInput | ContactCreateOrConnectWithoutFournisseurInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutFournisseurInput | ContactUpsertWithWhereUniqueWithoutFournisseurInput[]
    createMany?: ContactCreateManyFournisseurInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutFournisseurInput | ContactUpdateWithWhereUniqueWithoutFournisseurInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutFournisseurInput | ContactUpdateManyWithWhereWithoutFournisseurInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type ReservationUncheckedUpdateManyWithoutFournisseurNestedInput = {
    create?: XOR<ReservationCreateWithoutFournisseurInput, ReservationUncheckedCreateWithoutFournisseurInput> | ReservationCreateWithoutFournisseurInput[] | ReservationUncheckedCreateWithoutFournisseurInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutFournisseurInput | ReservationCreateOrConnectWithoutFournisseurInput[]
    upsert?: ReservationUpsertWithWhereUniqueWithoutFournisseurInput | ReservationUpsertWithWhereUniqueWithoutFournisseurInput[]
    createMany?: ReservationCreateManyFournisseurInputEnvelope
    set?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    disconnect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    delete?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    update?: ReservationUpdateWithWhereUniqueWithoutFournisseurInput | ReservationUpdateWithWhereUniqueWithoutFournisseurInput[]
    updateMany?: ReservationUpdateManyWithWhereWithoutFournisseurInput | ReservationUpdateManyWithWhereWithoutFournisseurInput[]
    deleteMany?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
  }

  export type CommandeUncheckedUpdateManyWithoutFournisseurNestedInput = {
    create?: XOR<CommandeCreateWithoutFournisseurInput, CommandeUncheckedCreateWithoutFournisseurInput> | CommandeCreateWithoutFournisseurInput[] | CommandeUncheckedCreateWithoutFournisseurInput[]
    connectOrCreate?: CommandeCreateOrConnectWithoutFournisseurInput | CommandeCreateOrConnectWithoutFournisseurInput[]
    upsert?: CommandeUpsertWithWhereUniqueWithoutFournisseurInput | CommandeUpsertWithWhereUniqueWithoutFournisseurInput[]
    createMany?: CommandeCreateManyFournisseurInputEnvelope
    set?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    disconnect?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    delete?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    connect?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    update?: CommandeUpdateWithWhereUniqueWithoutFournisseurInput | CommandeUpdateWithWhereUniqueWithoutFournisseurInput[]
    updateMany?: CommandeUpdateManyWithWhereWithoutFournisseurInput | CommandeUpdateManyWithWhereWithoutFournisseurInput[]
    deleteMany?: CommandeScalarWhereInput | CommandeScalarWhereInput[]
  }

  export type UtilisateurCreateNestedOneWithoutTeneurInput = {
    create?: XOR<UtilisateurCreateWithoutTeneurInput, UtilisateurUncheckedCreateWithoutTeneurInput>
    connectOrCreate?: UtilisateurCreateOrConnectWithoutTeneurInput
    connect?: UtilisateurWhereUniqueInput
  }

  export type ProduitCreateNestedManyWithoutTeneurInput = {
    create?: XOR<ProduitCreateWithoutTeneurInput, ProduitUncheckedCreateWithoutTeneurInput> | ProduitCreateWithoutTeneurInput[] | ProduitUncheckedCreateWithoutTeneurInput[]
    connectOrCreate?: ProduitCreateOrConnectWithoutTeneurInput | ProduitCreateOrConnectWithoutTeneurInput[]
    createMany?: ProduitCreateManyTeneurInputEnvelope
    connect?: ProduitWhereUniqueInput | ProduitWhereUniqueInput[]
  }

  export type DetailClotureCaisseCreateNestedManyWithoutTeneurInput = {
    create?: XOR<DetailClotureCaisseCreateWithoutTeneurInput, DetailClotureCaisseUncheckedCreateWithoutTeneurInput> | DetailClotureCaisseCreateWithoutTeneurInput[] | DetailClotureCaisseUncheckedCreateWithoutTeneurInput[]
    connectOrCreate?: DetailClotureCaisseCreateOrConnectWithoutTeneurInput | DetailClotureCaisseCreateOrConnectWithoutTeneurInput[]
    createMany?: DetailClotureCaisseCreateManyTeneurInputEnvelope
    connect?: DetailClotureCaisseWhereUniqueInput | DetailClotureCaisseWhereUniqueInput[]
  }

  export type ProduitUncheckedCreateNestedManyWithoutTeneurInput = {
    create?: XOR<ProduitCreateWithoutTeneurInput, ProduitUncheckedCreateWithoutTeneurInput> | ProduitCreateWithoutTeneurInput[] | ProduitUncheckedCreateWithoutTeneurInput[]
    connectOrCreate?: ProduitCreateOrConnectWithoutTeneurInput | ProduitCreateOrConnectWithoutTeneurInput[]
    createMany?: ProduitCreateManyTeneurInputEnvelope
    connect?: ProduitWhereUniqueInput | ProduitWhereUniqueInput[]
  }

  export type DetailClotureCaisseUncheckedCreateNestedManyWithoutTeneurInput = {
    create?: XOR<DetailClotureCaisseCreateWithoutTeneurInput, DetailClotureCaisseUncheckedCreateWithoutTeneurInput> | DetailClotureCaisseCreateWithoutTeneurInput[] | DetailClotureCaisseUncheckedCreateWithoutTeneurInput[]
    connectOrCreate?: DetailClotureCaisseCreateOrConnectWithoutTeneurInput | DetailClotureCaisseCreateOrConnectWithoutTeneurInput[]
    createMany?: DetailClotureCaisseCreateManyTeneurInputEnvelope
    connect?: DetailClotureCaisseWhereUniqueInput | DetailClotureCaisseWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UtilisateurUpdateOneRequiredWithoutTeneurNestedInput = {
    create?: XOR<UtilisateurCreateWithoutTeneurInput, UtilisateurUncheckedCreateWithoutTeneurInput>
    connectOrCreate?: UtilisateurCreateOrConnectWithoutTeneurInput
    upsert?: UtilisateurUpsertWithoutTeneurInput
    connect?: UtilisateurWhereUniqueInput
    update?: XOR<XOR<UtilisateurUpdateToOneWithWhereWithoutTeneurInput, UtilisateurUpdateWithoutTeneurInput>, UtilisateurUncheckedUpdateWithoutTeneurInput>
  }

  export type ProduitUpdateManyWithoutTeneurNestedInput = {
    create?: XOR<ProduitCreateWithoutTeneurInput, ProduitUncheckedCreateWithoutTeneurInput> | ProduitCreateWithoutTeneurInput[] | ProduitUncheckedCreateWithoutTeneurInput[]
    connectOrCreate?: ProduitCreateOrConnectWithoutTeneurInput | ProduitCreateOrConnectWithoutTeneurInput[]
    upsert?: ProduitUpsertWithWhereUniqueWithoutTeneurInput | ProduitUpsertWithWhereUniqueWithoutTeneurInput[]
    createMany?: ProduitCreateManyTeneurInputEnvelope
    set?: ProduitWhereUniqueInput | ProduitWhereUniqueInput[]
    disconnect?: ProduitWhereUniqueInput | ProduitWhereUniqueInput[]
    delete?: ProduitWhereUniqueInput | ProduitWhereUniqueInput[]
    connect?: ProduitWhereUniqueInput | ProduitWhereUniqueInput[]
    update?: ProduitUpdateWithWhereUniqueWithoutTeneurInput | ProduitUpdateWithWhereUniqueWithoutTeneurInput[]
    updateMany?: ProduitUpdateManyWithWhereWithoutTeneurInput | ProduitUpdateManyWithWhereWithoutTeneurInput[]
    deleteMany?: ProduitScalarWhereInput | ProduitScalarWhereInput[]
  }

  export type DetailClotureCaisseUpdateManyWithoutTeneurNestedInput = {
    create?: XOR<DetailClotureCaisseCreateWithoutTeneurInput, DetailClotureCaisseUncheckedCreateWithoutTeneurInput> | DetailClotureCaisseCreateWithoutTeneurInput[] | DetailClotureCaisseUncheckedCreateWithoutTeneurInput[]
    connectOrCreate?: DetailClotureCaisseCreateOrConnectWithoutTeneurInput | DetailClotureCaisseCreateOrConnectWithoutTeneurInput[]
    upsert?: DetailClotureCaisseUpsertWithWhereUniqueWithoutTeneurInput | DetailClotureCaisseUpsertWithWhereUniqueWithoutTeneurInput[]
    createMany?: DetailClotureCaisseCreateManyTeneurInputEnvelope
    set?: DetailClotureCaisseWhereUniqueInput | DetailClotureCaisseWhereUniqueInput[]
    disconnect?: DetailClotureCaisseWhereUniqueInput | DetailClotureCaisseWhereUniqueInput[]
    delete?: DetailClotureCaisseWhereUniqueInput | DetailClotureCaisseWhereUniqueInput[]
    connect?: DetailClotureCaisseWhereUniqueInput | DetailClotureCaisseWhereUniqueInput[]
    update?: DetailClotureCaisseUpdateWithWhereUniqueWithoutTeneurInput | DetailClotureCaisseUpdateWithWhereUniqueWithoutTeneurInput[]
    updateMany?: DetailClotureCaisseUpdateManyWithWhereWithoutTeneurInput | DetailClotureCaisseUpdateManyWithWhereWithoutTeneurInput[]
    deleteMany?: DetailClotureCaisseScalarWhereInput | DetailClotureCaisseScalarWhereInput[]
  }

  export type ProduitUncheckedUpdateManyWithoutTeneurNestedInput = {
    create?: XOR<ProduitCreateWithoutTeneurInput, ProduitUncheckedCreateWithoutTeneurInput> | ProduitCreateWithoutTeneurInput[] | ProduitUncheckedCreateWithoutTeneurInput[]
    connectOrCreate?: ProduitCreateOrConnectWithoutTeneurInput | ProduitCreateOrConnectWithoutTeneurInput[]
    upsert?: ProduitUpsertWithWhereUniqueWithoutTeneurInput | ProduitUpsertWithWhereUniqueWithoutTeneurInput[]
    createMany?: ProduitCreateManyTeneurInputEnvelope
    set?: ProduitWhereUniqueInput | ProduitWhereUniqueInput[]
    disconnect?: ProduitWhereUniqueInput | ProduitWhereUniqueInput[]
    delete?: ProduitWhereUniqueInput | ProduitWhereUniqueInput[]
    connect?: ProduitWhereUniqueInput | ProduitWhereUniqueInput[]
    update?: ProduitUpdateWithWhereUniqueWithoutTeneurInput | ProduitUpdateWithWhereUniqueWithoutTeneurInput[]
    updateMany?: ProduitUpdateManyWithWhereWithoutTeneurInput | ProduitUpdateManyWithWhereWithoutTeneurInput[]
    deleteMany?: ProduitScalarWhereInput | ProduitScalarWhereInput[]
  }

  export type DetailClotureCaisseUncheckedUpdateManyWithoutTeneurNestedInput = {
    create?: XOR<DetailClotureCaisseCreateWithoutTeneurInput, DetailClotureCaisseUncheckedCreateWithoutTeneurInput> | DetailClotureCaisseCreateWithoutTeneurInput[] | DetailClotureCaisseUncheckedCreateWithoutTeneurInput[]
    connectOrCreate?: DetailClotureCaisseCreateOrConnectWithoutTeneurInput | DetailClotureCaisseCreateOrConnectWithoutTeneurInput[]
    upsert?: DetailClotureCaisseUpsertWithWhereUniqueWithoutTeneurInput | DetailClotureCaisseUpsertWithWhereUniqueWithoutTeneurInput[]
    createMany?: DetailClotureCaisseCreateManyTeneurInputEnvelope
    set?: DetailClotureCaisseWhereUniqueInput | DetailClotureCaisseWhereUniqueInput[]
    disconnect?: DetailClotureCaisseWhereUniqueInput | DetailClotureCaisseWhereUniqueInput[]
    delete?: DetailClotureCaisseWhereUniqueInput | DetailClotureCaisseWhereUniqueInput[]
    connect?: DetailClotureCaisseWhereUniqueInput | DetailClotureCaisseWhereUniqueInput[]
    update?: DetailClotureCaisseUpdateWithWhereUniqueWithoutTeneurInput | DetailClotureCaisseUpdateWithWhereUniqueWithoutTeneurInput[]
    updateMany?: DetailClotureCaisseUpdateManyWithWhereWithoutTeneurInput | DetailClotureCaisseUpdateManyWithWhereWithoutTeneurInput[]
    deleteMany?: DetailClotureCaisseScalarWhereInput | DetailClotureCaisseScalarWhereInput[]
  }

  export type UtilisateurCreateNestedOneWithoutDeviseInput = {
    create?: XOR<UtilisateurCreateWithoutDeviseInput, UtilisateurUncheckedCreateWithoutDeviseInput>
    connectOrCreate?: UtilisateurCreateOrConnectWithoutDeviseInput
    connect?: UtilisateurWhereUniqueInput
  }

  export type ProduitCreateNestedManyWithoutDeviseInput = {
    create?: XOR<ProduitCreateWithoutDeviseInput, ProduitUncheckedCreateWithoutDeviseInput> | ProduitCreateWithoutDeviseInput[] | ProduitUncheckedCreateWithoutDeviseInput[]
    connectOrCreate?: ProduitCreateOrConnectWithoutDeviseInput | ProduitCreateOrConnectWithoutDeviseInput[]
    createMany?: ProduitCreateManyDeviseInputEnvelope
    connect?: ProduitWhereUniqueInput | ProduitWhereUniqueInput[]
  }

  export type PaiementCreateNestedManyWithoutDeviseInput = {
    create?: XOR<PaiementCreateWithoutDeviseInput, PaiementUncheckedCreateWithoutDeviseInput> | PaiementCreateWithoutDeviseInput[] | PaiementUncheckedCreateWithoutDeviseInput[]
    connectOrCreate?: PaiementCreateOrConnectWithoutDeviseInput | PaiementCreateOrConnectWithoutDeviseInput[]
    createMany?: PaiementCreateManyDeviseInputEnvelope
    connect?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
  }

  export type CaisseCreateNestedManyWithoutDeviseInput = {
    create?: XOR<CaisseCreateWithoutDeviseInput, CaisseUncheckedCreateWithoutDeviseInput> | CaisseCreateWithoutDeviseInput[] | CaisseUncheckedCreateWithoutDeviseInput[]
    connectOrCreate?: CaisseCreateOrConnectWithoutDeviseInput | CaisseCreateOrConnectWithoutDeviseInput[]
    createMany?: CaisseCreateManyDeviseInputEnvelope
    connect?: CaisseWhereUniqueInput | CaisseWhereUniqueInput[]
  }

  export type ProduitUncheckedCreateNestedManyWithoutDeviseInput = {
    create?: XOR<ProduitCreateWithoutDeviseInput, ProduitUncheckedCreateWithoutDeviseInput> | ProduitCreateWithoutDeviseInput[] | ProduitUncheckedCreateWithoutDeviseInput[]
    connectOrCreate?: ProduitCreateOrConnectWithoutDeviseInput | ProduitCreateOrConnectWithoutDeviseInput[]
    createMany?: ProduitCreateManyDeviseInputEnvelope
    connect?: ProduitWhereUniqueInput | ProduitWhereUniqueInput[]
  }

  export type PaiementUncheckedCreateNestedManyWithoutDeviseInput = {
    create?: XOR<PaiementCreateWithoutDeviseInput, PaiementUncheckedCreateWithoutDeviseInput> | PaiementCreateWithoutDeviseInput[] | PaiementUncheckedCreateWithoutDeviseInput[]
    connectOrCreate?: PaiementCreateOrConnectWithoutDeviseInput | PaiementCreateOrConnectWithoutDeviseInput[]
    createMany?: PaiementCreateManyDeviseInputEnvelope
    connect?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
  }

  export type CaisseUncheckedCreateNestedManyWithoutDeviseInput = {
    create?: XOR<CaisseCreateWithoutDeviseInput, CaisseUncheckedCreateWithoutDeviseInput> | CaisseCreateWithoutDeviseInput[] | CaisseUncheckedCreateWithoutDeviseInput[]
    connectOrCreate?: CaisseCreateOrConnectWithoutDeviseInput | CaisseCreateOrConnectWithoutDeviseInput[]
    createMany?: CaisseCreateManyDeviseInputEnvelope
    connect?: CaisseWhereUniqueInput | CaisseWhereUniqueInput[]
  }

  export type UtilisateurUpdateOneRequiredWithoutDeviseNestedInput = {
    create?: XOR<UtilisateurCreateWithoutDeviseInput, UtilisateurUncheckedCreateWithoutDeviseInput>
    connectOrCreate?: UtilisateurCreateOrConnectWithoutDeviseInput
    upsert?: UtilisateurUpsertWithoutDeviseInput
    connect?: UtilisateurWhereUniqueInput
    update?: XOR<XOR<UtilisateurUpdateToOneWithWhereWithoutDeviseInput, UtilisateurUpdateWithoutDeviseInput>, UtilisateurUncheckedUpdateWithoutDeviseInput>
  }

  export type ProduitUpdateManyWithoutDeviseNestedInput = {
    create?: XOR<ProduitCreateWithoutDeviseInput, ProduitUncheckedCreateWithoutDeviseInput> | ProduitCreateWithoutDeviseInput[] | ProduitUncheckedCreateWithoutDeviseInput[]
    connectOrCreate?: ProduitCreateOrConnectWithoutDeviseInput | ProduitCreateOrConnectWithoutDeviseInput[]
    upsert?: ProduitUpsertWithWhereUniqueWithoutDeviseInput | ProduitUpsertWithWhereUniqueWithoutDeviseInput[]
    createMany?: ProduitCreateManyDeviseInputEnvelope
    set?: ProduitWhereUniqueInput | ProduitWhereUniqueInput[]
    disconnect?: ProduitWhereUniqueInput | ProduitWhereUniqueInput[]
    delete?: ProduitWhereUniqueInput | ProduitWhereUniqueInput[]
    connect?: ProduitWhereUniqueInput | ProduitWhereUniqueInput[]
    update?: ProduitUpdateWithWhereUniqueWithoutDeviseInput | ProduitUpdateWithWhereUniqueWithoutDeviseInput[]
    updateMany?: ProduitUpdateManyWithWhereWithoutDeviseInput | ProduitUpdateManyWithWhereWithoutDeviseInput[]
    deleteMany?: ProduitScalarWhereInput | ProduitScalarWhereInput[]
  }

  export type PaiementUpdateManyWithoutDeviseNestedInput = {
    create?: XOR<PaiementCreateWithoutDeviseInput, PaiementUncheckedCreateWithoutDeviseInput> | PaiementCreateWithoutDeviseInput[] | PaiementUncheckedCreateWithoutDeviseInput[]
    connectOrCreate?: PaiementCreateOrConnectWithoutDeviseInput | PaiementCreateOrConnectWithoutDeviseInput[]
    upsert?: PaiementUpsertWithWhereUniqueWithoutDeviseInput | PaiementUpsertWithWhereUniqueWithoutDeviseInput[]
    createMany?: PaiementCreateManyDeviseInputEnvelope
    set?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    disconnect?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    delete?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    connect?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    update?: PaiementUpdateWithWhereUniqueWithoutDeviseInput | PaiementUpdateWithWhereUniqueWithoutDeviseInput[]
    updateMany?: PaiementUpdateManyWithWhereWithoutDeviseInput | PaiementUpdateManyWithWhereWithoutDeviseInput[]
    deleteMany?: PaiementScalarWhereInput | PaiementScalarWhereInput[]
  }

  export type CaisseUpdateManyWithoutDeviseNestedInput = {
    create?: XOR<CaisseCreateWithoutDeviseInput, CaisseUncheckedCreateWithoutDeviseInput> | CaisseCreateWithoutDeviseInput[] | CaisseUncheckedCreateWithoutDeviseInput[]
    connectOrCreate?: CaisseCreateOrConnectWithoutDeviseInput | CaisseCreateOrConnectWithoutDeviseInput[]
    upsert?: CaisseUpsertWithWhereUniqueWithoutDeviseInput | CaisseUpsertWithWhereUniqueWithoutDeviseInput[]
    createMany?: CaisseCreateManyDeviseInputEnvelope
    set?: CaisseWhereUniqueInput | CaisseWhereUniqueInput[]
    disconnect?: CaisseWhereUniqueInput | CaisseWhereUniqueInput[]
    delete?: CaisseWhereUniqueInput | CaisseWhereUniqueInput[]
    connect?: CaisseWhereUniqueInput | CaisseWhereUniqueInput[]
    update?: CaisseUpdateWithWhereUniqueWithoutDeviseInput | CaisseUpdateWithWhereUniqueWithoutDeviseInput[]
    updateMany?: CaisseUpdateManyWithWhereWithoutDeviseInput | CaisseUpdateManyWithWhereWithoutDeviseInput[]
    deleteMany?: CaisseScalarWhereInput | CaisseScalarWhereInput[]
  }

  export type ProduitUncheckedUpdateManyWithoutDeviseNestedInput = {
    create?: XOR<ProduitCreateWithoutDeviseInput, ProduitUncheckedCreateWithoutDeviseInput> | ProduitCreateWithoutDeviseInput[] | ProduitUncheckedCreateWithoutDeviseInput[]
    connectOrCreate?: ProduitCreateOrConnectWithoutDeviseInput | ProduitCreateOrConnectWithoutDeviseInput[]
    upsert?: ProduitUpsertWithWhereUniqueWithoutDeviseInput | ProduitUpsertWithWhereUniqueWithoutDeviseInput[]
    createMany?: ProduitCreateManyDeviseInputEnvelope
    set?: ProduitWhereUniqueInput | ProduitWhereUniqueInput[]
    disconnect?: ProduitWhereUniqueInput | ProduitWhereUniqueInput[]
    delete?: ProduitWhereUniqueInput | ProduitWhereUniqueInput[]
    connect?: ProduitWhereUniqueInput | ProduitWhereUniqueInput[]
    update?: ProduitUpdateWithWhereUniqueWithoutDeviseInput | ProduitUpdateWithWhereUniqueWithoutDeviseInput[]
    updateMany?: ProduitUpdateManyWithWhereWithoutDeviseInput | ProduitUpdateManyWithWhereWithoutDeviseInput[]
    deleteMany?: ProduitScalarWhereInput | ProduitScalarWhereInput[]
  }

  export type PaiementUncheckedUpdateManyWithoutDeviseNestedInput = {
    create?: XOR<PaiementCreateWithoutDeviseInput, PaiementUncheckedCreateWithoutDeviseInput> | PaiementCreateWithoutDeviseInput[] | PaiementUncheckedCreateWithoutDeviseInput[]
    connectOrCreate?: PaiementCreateOrConnectWithoutDeviseInput | PaiementCreateOrConnectWithoutDeviseInput[]
    upsert?: PaiementUpsertWithWhereUniqueWithoutDeviseInput | PaiementUpsertWithWhereUniqueWithoutDeviseInput[]
    createMany?: PaiementCreateManyDeviseInputEnvelope
    set?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    disconnect?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    delete?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    connect?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    update?: PaiementUpdateWithWhereUniqueWithoutDeviseInput | PaiementUpdateWithWhereUniqueWithoutDeviseInput[]
    updateMany?: PaiementUpdateManyWithWhereWithoutDeviseInput | PaiementUpdateManyWithWhereWithoutDeviseInput[]
    deleteMany?: PaiementScalarWhereInput | PaiementScalarWhereInput[]
  }

  export type CaisseUncheckedUpdateManyWithoutDeviseNestedInput = {
    create?: XOR<CaisseCreateWithoutDeviseInput, CaisseUncheckedCreateWithoutDeviseInput> | CaisseCreateWithoutDeviseInput[] | CaisseUncheckedCreateWithoutDeviseInput[]
    connectOrCreate?: CaisseCreateOrConnectWithoutDeviseInput | CaisseCreateOrConnectWithoutDeviseInput[]
    upsert?: CaisseUpsertWithWhereUniqueWithoutDeviseInput | CaisseUpsertWithWhereUniqueWithoutDeviseInput[]
    createMany?: CaisseCreateManyDeviseInputEnvelope
    set?: CaisseWhereUniqueInput | CaisseWhereUniqueInput[]
    disconnect?: CaisseWhereUniqueInput | CaisseWhereUniqueInput[]
    delete?: CaisseWhereUniqueInput | CaisseWhereUniqueInput[]
    connect?: CaisseWhereUniqueInput | CaisseWhereUniqueInput[]
    update?: CaisseUpdateWithWhereUniqueWithoutDeviseInput | CaisseUpdateWithWhereUniqueWithoutDeviseInput[]
    updateMany?: CaisseUpdateManyWithWhereWithoutDeviseInput | CaisseUpdateManyWithWhereWithoutDeviseInput[]
    deleteMany?: CaisseScalarWhereInput | CaisseScalarWhereInput[]
  }

  export type DeviseCreateNestedOneWithoutProduitInput = {
    create?: XOR<DeviseCreateWithoutProduitInput, DeviseUncheckedCreateWithoutProduitInput>
    connectOrCreate?: DeviseCreateOrConnectWithoutProduitInput
    connect?: DeviseWhereUniqueInput
  }

  export type TeneurCreateNestedOneWithoutProduitInput = {
    create?: XOR<TeneurCreateWithoutProduitInput, TeneurUncheckedCreateWithoutProduitInput>
    connectOrCreate?: TeneurCreateOrConnectWithoutProduitInput
    connect?: TeneurWhereUniqueInput
  }

  export type UtilisateurCreateNestedOneWithoutProduitInput = {
    create?: XOR<UtilisateurCreateWithoutProduitInput, UtilisateurUncheckedCreateWithoutProduitInput>
    connectOrCreate?: UtilisateurCreateOrConnectWithoutProduitInput
    connect?: UtilisateurWhereUniqueInput
  }

  export type DetailPanierCreateNestedManyWithoutProduitInput = {
    create?: XOR<DetailPanierCreateWithoutProduitInput, DetailPanierUncheckedCreateWithoutProduitInput> | DetailPanierCreateWithoutProduitInput[] | DetailPanierUncheckedCreateWithoutProduitInput[]
    connectOrCreate?: DetailPanierCreateOrConnectWithoutProduitInput | DetailPanierCreateOrConnectWithoutProduitInput[]
    createMany?: DetailPanierCreateManyProduitInputEnvelope
    connect?: DetailPanierWhereUniqueInput | DetailPanierWhereUniqueInput[]
  }

  export type DetailClotureCaisseCreateNestedManyWithoutProduitInput = {
    create?: XOR<DetailClotureCaisseCreateWithoutProduitInput, DetailClotureCaisseUncheckedCreateWithoutProduitInput> | DetailClotureCaisseCreateWithoutProduitInput[] | DetailClotureCaisseUncheckedCreateWithoutProduitInput[]
    connectOrCreate?: DetailClotureCaisseCreateOrConnectWithoutProduitInput | DetailClotureCaisseCreateOrConnectWithoutProduitInput[]
    createMany?: DetailClotureCaisseCreateManyProduitInputEnvelope
    connect?: DetailClotureCaisseWhereUniqueInput | DetailClotureCaisseWhereUniqueInput[]
  }

  export type DetailPanierUncheckedCreateNestedManyWithoutProduitInput = {
    create?: XOR<DetailPanierCreateWithoutProduitInput, DetailPanierUncheckedCreateWithoutProduitInput> | DetailPanierCreateWithoutProduitInput[] | DetailPanierUncheckedCreateWithoutProduitInput[]
    connectOrCreate?: DetailPanierCreateOrConnectWithoutProduitInput | DetailPanierCreateOrConnectWithoutProduitInput[]
    createMany?: DetailPanierCreateManyProduitInputEnvelope
    connect?: DetailPanierWhereUniqueInput | DetailPanierWhereUniqueInput[]
  }

  export type DetailClotureCaisseUncheckedCreateNestedManyWithoutProduitInput = {
    create?: XOR<DetailClotureCaisseCreateWithoutProduitInput, DetailClotureCaisseUncheckedCreateWithoutProduitInput> | DetailClotureCaisseCreateWithoutProduitInput[] | DetailClotureCaisseUncheckedCreateWithoutProduitInput[]
    connectOrCreate?: DetailClotureCaisseCreateOrConnectWithoutProduitInput | DetailClotureCaisseCreateOrConnectWithoutProduitInput[]
    createMany?: DetailClotureCaisseCreateManyProduitInputEnvelope
    connect?: DetailClotureCaisseWhereUniqueInput | DetailClotureCaisseWhereUniqueInput[]
  }

  export type DeviseUpdateOneRequiredWithoutProduitNestedInput = {
    create?: XOR<DeviseCreateWithoutProduitInput, DeviseUncheckedCreateWithoutProduitInput>
    connectOrCreate?: DeviseCreateOrConnectWithoutProduitInput
    upsert?: DeviseUpsertWithoutProduitInput
    connect?: DeviseWhereUniqueInput
    update?: XOR<XOR<DeviseUpdateToOneWithWhereWithoutProduitInput, DeviseUpdateWithoutProduitInput>, DeviseUncheckedUpdateWithoutProduitInput>
  }

  export type TeneurUpdateOneRequiredWithoutProduitNestedInput = {
    create?: XOR<TeneurCreateWithoutProduitInput, TeneurUncheckedCreateWithoutProduitInput>
    connectOrCreate?: TeneurCreateOrConnectWithoutProduitInput
    upsert?: TeneurUpsertWithoutProduitInput
    connect?: TeneurWhereUniqueInput
    update?: XOR<XOR<TeneurUpdateToOneWithWhereWithoutProduitInput, TeneurUpdateWithoutProduitInput>, TeneurUncheckedUpdateWithoutProduitInput>
  }

  export type UtilisateurUpdateOneRequiredWithoutProduitNestedInput = {
    create?: XOR<UtilisateurCreateWithoutProduitInput, UtilisateurUncheckedCreateWithoutProduitInput>
    connectOrCreate?: UtilisateurCreateOrConnectWithoutProduitInput
    upsert?: UtilisateurUpsertWithoutProduitInput
    connect?: UtilisateurWhereUniqueInput
    update?: XOR<XOR<UtilisateurUpdateToOneWithWhereWithoutProduitInput, UtilisateurUpdateWithoutProduitInput>, UtilisateurUncheckedUpdateWithoutProduitInput>
  }

  export type DetailPanierUpdateManyWithoutProduitNestedInput = {
    create?: XOR<DetailPanierCreateWithoutProduitInput, DetailPanierUncheckedCreateWithoutProduitInput> | DetailPanierCreateWithoutProduitInput[] | DetailPanierUncheckedCreateWithoutProduitInput[]
    connectOrCreate?: DetailPanierCreateOrConnectWithoutProduitInput | DetailPanierCreateOrConnectWithoutProduitInput[]
    upsert?: DetailPanierUpsertWithWhereUniqueWithoutProduitInput | DetailPanierUpsertWithWhereUniqueWithoutProduitInput[]
    createMany?: DetailPanierCreateManyProduitInputEnvelope
    set?: DetailPanierWhereUniqueInput | DetailPanierWhereUniqueInput[]
    disconnect?: DetailPanierWhereUniqueInput | DetailPanierWhereUniqueInput[]
    delete?: DetailPanierWhereUniqueInput | DetailPanierWhereUniqueInput[]
    connect?: DetailPanierWhereUniqueInput | DetailPanierWhereUniqueInput[]
    update?: DetailPanierUpdateWithWhereUniqueWithoutProduitInput | DetailPanierUpdateWithWhereUniqueWithoutProduitInput[]
    updateMany?: DetailPanierUpdateManyWithWhereWithoutProduitInput | DetailPanierUpdateManyWithWhereWithoutProduitInput[]
    deleteMany?: DetailPanierScalarWhereInput | DetailPanierScalarWhereInput[]
  }

  export type DetailClotureCaisseUpdateManyWithoutProduitNestedInput = {
    create?: XOR<DetailClotureCaisseCreateWithoutProduitInput, DetailClotureCaisseUncheckedCreateWithoutProduitInput> | DetailClotureCaisseCreateWithoutProduitInput[] | DetailClotureCaisseUncheckedCreateWithoutProduitInput[]
    connectOrCreate?: DetailClotureCaisseCreateOrConnectWithoutProduitInput | DetailClotureCaisseCreateOrConnectWithoutProduitInput[]
    upsert?: DetailClotureCaisseUpsertWithWhereUniqueWithoutProduitInput | DetailClotureCaisseUpsertWithWhereUniqueWithoutProduitInput[]
    createMany?: DetailClotureCaisseCreateManyProduitInputEnvelope
    set?: DetailClotureCaisseWhereUniqueInput | DetailClotureCaisseWhereUniqueInput[]
    disconnect?: DetailClotureCaisseWhereUniqueInput | DetailClotureCaisseWhereUniqueInput[]
    delete?: DetailClotureCaisseWhereUniqueInput | DetailClotureCaisseWhereUniqueInput[]
    connect?: DetailClotureCaisseWhereUniqueInput | DetailClotureCaisseWhereUniqueInput[]
    update?: DetailClotureCaisseUpdateWithWhereUniqueWithoutProduitInput | DetailClotureCaisseUpdateWithWhereUniqueWithoutProduitInput[]
    updateMany?: DetailClotureCaisseUpdateManyWithWhereWithoutProduitInput | DetailClotureCaisseUpdateManyWithWhereWithoutProduitInput[]
    deleteMany?: DetailClotureCaisseScalarWhereInput | DetailClotureCaisseScalarWhereInput[]
  }

  export type DetailPanierUncheckedUpdateManyWithoutProduitNestedInput = {
    create?: XOR<DetailPanierCreateWithoutProduitInput, DetailPanierUncheckedCreateWithoutProduitInput> | DetailPanierCreateWithoutProduitInput[] | DetailPanierUncheckedCreateWithoutProduitInput[]
    connectOrCreate?: DetailPanierCreateOrConnectWithoutProduitInput | DetailPanierCreateOrConnectWithoutProduitInput[]
    upsert?: DetailPanierUpsertWithWhereUniqueWithoutProduitInput | DetailPanierUpsertWithWhereUniqueWithoutProduitInput[]
    createMany?: DetailPanierCreateManyProduitInputEnvelope
    set?: DetailPanierWhereUniqueInput | DetailPanierWhereUniqueInput[]
    disconnect?: DetailPanierWhereUniqueInput | DetailPanierWhereUniqueInput[]
    delete?: DetailPanierWhereUniqueInput | DetailPanierWhereUniqueInput[]
    connect?: DetailPanierWhereUniqueInput | DetailPanierWhereUniqueInput[]
    update?: DetailPanierUpdateWithWhereUniqueWithoutProduitInput | DetailPanierUpdateWithWhereUniqueWithoutProduitInput[]
    updateMany?: DetailPanierUpdateManyWithWhereWithoutProduitInput | DetailPanierUpdateManyWithWhereWithoutProduitInput[]
    deleteMany?: DetailPanierScalarWhereInput | DetailPanierScalarWhereInput[]
  }

  export type DetailClotureCaisseUncheckedUpdateManyWithoutProduitNestedInput = {
    create?: XOR<DetailClotureCaisseCreateWithoutProduitInput, DetailClotureCaisseUncheckedCreateWithoutProduitInput> | DetailClotureCaisseCreateWithoutProduitInput[] | DetailClotureCaisseUncheckedCreateWithoutProduitInput[]
    connectOrCreate?: DetailClotureCaisseCreateOrConnectWithoutProduitInput | DetailClotureCaisseCreateOrConnectWithoutProduitInput[]
    upsert?: DetailClotureCaisseUpsertWithWhereUniqueWithoutProduitInput | DetailClotureCaisseUpsertWithWhereUniqueWithoutProduitInput[]
    createMany?: DetailClotureCaisseCreateManyProduitInputEnvelope
    set?: DetailClotureCaisseWhereUniqueInput | DetailClotureCaisseWhereUniqueInput[]
    disconnect?: DetailClotureCaisseWhereUniqueInput | DetailClotureCaisseWhereUniqueInput[]
    delete?: DetailClotureCaisseWhereUniqueInput | DetailClotureCaisseWhereUniqueInput[]
    connect?: DetailClotureCaisseWhereUniqueInput | DetailClotureCaisseWhereUniqueInput[]
    update?: DetailClotureCaisseUpdateWithWhereUniqueWithoutProduitInput | DetailClotureCaisseUpdateWithWhereUniqueWithoutProduitInput[]
    updateMany?: DetailClotureCaisseUpdateManyWithWhereWithoutProduitInput | DetailClotureCaisseUpdateManyWithWhereWithoutProduitInput[]
    deleteMany?: DetailClotureCaisseScalarWhereInput | DetailClotureCaisseScalarWhereInput[]
  }

  export type CaisseCreateNestedOneWithoutPaiementInput = {
    create?: XOR<CaisseCreateWithoutPaiementInput, CaisseUncheckedCreateWithoutPaiementInput>
    connectOrCreate?: CaisseCreateOrConnectWithoutPaiementInput
    connect?: CaisseWhereUniqueInput
  }

  export type DeviseCreateNestedOneWithoutPaiementInput = {
    create?: XOR<DeviseCreateWithoutPaiementInput, DeviseUncheckedCreateWithoutPaiementInput>
    connectOrCreate?: DeviseCreateOrConnectWithoutPaiementInput
    connect?: DeviseWhereUniqueInput
  }

  export type AchatCreateNestedManyWithoutPaiementInput = {
    create?: XOR<AchatCreateWithoutPaiementInput, AchatUncheckedCreateWithoutPaiementInput> | AchatCreateWithoutPaiementInput[] | AchatUncheckedCreateWithoutPaiementInput[]
    connectOrCreate?: AchatCreateOrConnectWithoutPaiementInput | AchatCreateOrConnectWithoutPaiementInput[]
    createMany?: AchatCreateManyPaiementInputEnvelope
    connect?: AchatWhereUniqueInput | AchatWhereUniqueInput[]
  }

  export type CommandeCreateNestedManyWithoutPaiementInput = {
    create?: XOR<CommandeCreateWithoutPaiementInput, CommandeUncheckedCreateWithoutPaiementInput> | CommandeCreateWithoutPaiementInput[] | CommandeUncheckedCreateWithoutPaiementInput[]
    connectOrCreate?: CommandeCreateOrConnectWithoutPaiementInput | CommandeCreateOrConnectWithoutPaiementInput[]
    createMany?: CommandeCreateManyPaiementInputEnvelope
    connect?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
  }

  export type VenteCreateNestedManyWithoutPaiementInput = {
    create?: XOR<VenteCreateWithoutPaiementInput, VenteUncheckedCreateWithoutPaiementInput> | VenteCreateWithoutPaiementInput[] | VenteUncheckedCreateWithoutPaiementInput[]
    connectOrCreate?: VenteCreateOrConnectWithoutPaiementInput | VenteCreateOrConnectWithoutPaiementInput[]
    createMany?: VenteCreateManyPaiementInputEnvelope
    connect?: VenteWhereUniqueInput | VenteWhereUniqueInput[]
  }

  export type AchatUncheckedCreateNestedManyWithoutPaiementInput = {
    create?: XOR<AchatCreateWithoutPaiementInput, AchatUncheckedCreateWithoutPaiementInput> | AchatCreateWithoutPaiementInput[] | AchatUncheckedCreateWithoutPaiementInput[]
    connectOrCreate?: AchatCreateOrConnectWithoutPaiementInput | AchatCreateOrConnectWithoutPaiementInput[]
    createMany?: AchatCreateManyPaiementInputEnvelope
    connect?: AchatWhereUniqueInput | AchatWhereUniqueInput[]
  }

  export type CommandeUncheckedCreateNestedManyWithoutPaiementInput = {
    create?: XOR<CommandeCreateWithoutPaiementInput, CommandeUncheckedCreateWithoutPaiementInput> | CommandeCreateWithoutPaiementInput[] | CommandeUncheckedCreateWithoutPaiementInput[]
    connectOrCreate?: CommandeCreateOrConnectWithoutPaiementInput | CommandeCreateOrConnectWithoutPaiementInput[]
    createMany?: CommandeCreateManyPaiementInputEnvelope
    connect?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
  }

  export type VenteUncheckedCreateNestedManyWithoutPaiementInput = {
    create?: XOR<VenteCreateWithoutPaiementInput, VenteUncheckedCreateWithoutPaiementInput> | VenteCreateWithoutPaiementInput[] | VenteUncheckedCreateWithoutPaiementInput[]
    connectOrCreate?: VenteCreateOrConnectWithoutPaiementInput | VenteCreateOrConnectWithoutPaiementInput[]
    createMany?: VenteCreateManyPaiementInputEnvelope
    connect?: VenteWhereUniqueInput | VenteWhereUniqueInput[]
  }

  export type EnumMoyenPaimentFieldUpdateOperationsInput = {
    set?: $Enums.MoyenPaiment
  }

  export type CaisseUpdateOneRequiredWithoutPaiementNestedInput = {
    create?: XOR<CaisseCreateWithoutPaiementInput, CaisseUncheckedCreateWithoutPaiementInput>
    connectOrCreate?: CaisseCreateOrConnectWithoutPaiementInput
    upsert?: CaisseUpsertWithoutPaiementInput
    connect?: CaisseWhereUniqueInput
    update?: XOR<XOR<CaisseUpdateToOneWithWhereWithoutPaiementInput, CaisseUpdateWithoutPaiementInput>, CaisseUncheckedUpdateWithoutPaiementInput>
  }

  export type DeviseUpdateOneRequiredWithoutPaiementNestedInput = {
    create?: XOR<DeviseCreateWithoutPaiementInput, DeviseUncheckedCreateWithoutPaiementInput>
    connectOrCreate?: DeviseCreateOrConnectWithoutPaiementInput
    upsert?: DeviseUpsertWithoutPaiementInput
    connect?: DeviseWhereUniqueInput
    update?: XOR<XOR<DeviseUpdateToOneWithWhereWithoutPaiementInput, DeviseUpdateWithoutPaiementInput>, DeviseUncheckedUpdateWithoutPaiementInput>
  }

  export type AchatUpdateManyWithoutPaiementNestedInput = {
    create?: XOR<AchatCreateWithoutPaiementInput, AchatUncheckedCreateWithoutPaiementInput> | AchatCreateWithoutPaiementInput[] | AchatUncheckedCreateWithoutPaiementInput[]
    connectOrCreate?: AchatCreateOrConnectWithoutPaiementInput | AchatCreateOrConnectWithoutPaiementInput[]
    upsert?: AchatUpsertWithWhereUniqueWithoutPaiementInput | AchatUpsertWithWhereUniqueWithoutPaiementInput[]
    createMany?: AchatCreateManyPaiementInputEnvelope
    set?: AchatWhereUniqueInput | AchatWhereUniqueInput[]
    disconnect?: AchatWhereUniqueInput | AchatWhereUniqueInput[]
    delete?: AchatWhereUniqueInput | AchatWhereUniqueInput[]
    connect?: AchatWhereUniqueInput | AchatWhereUniqueInput[]
    update?: AchatUpdateWithWhereUniqueWithoutPaiementInput | AchatUpdateWithWhereUniqueWithoutPaiementInput[]
    updateMany?: AchatUpdateManyWithWhereWithoutPaiementInput | AchatUpdateManyWithWhereWithoutPaiementInput[]
    deleteMany?: AchatScalarWhereInput | AchatScalarWhereInput[]
  }

  export type CommandeUpdateManyWithoutPaiementNestedInput = {
    create?: XOR<CommandeCreateWithoutPaiementInput, CommandeUncheckedCreateWithoutPaiementInput> | CommandeCreateWithoutPaiementInput[] | CommandeUncheckedCreateWithoutPaiementInput[]
    connectOrCreate?: CommandeCreateOrConnectWithoutPaiementInput | CommandeCreateOrConnectWithoutPaiementInput[]
    upsert?: CommandeUpsertWithWhereUniqueWithoutPaiementInput | CommandeUpsertWithWhereUniqueWithoutPaiementInput[]
    createMany?: CommandeCreateManyPaiementInputEnvelope
    set?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    disconnect?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    delete?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    connect?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    update?: CommandeUpdateWithWhereUniqueWithoutPaiementInput | CommandeUpdateWithWhereUniqueWithoutPaiementInput[]
    updateMany?: CommandeUpdateManyWithWhereWithoutPaiementInput | CommandeUpdateManyWithWhereWithoutPaiementInput[]
    deleteMany?: CommandeScalarWhereInput | CommandeScalarWhereInput[]
  }

  export type VenteUpdateManyWithoutPaiementNestedInput = {
    create?: XOR<VenteCreateWithoutPaiementInput, VenteUncheckedCreateWithoutPaiementInput> | VenteCreateWithoutPaiementInput[] | VenteUncheckedCreateWithoutPaiementInput[]
    connectOrCreate?: VenteCreateOrConnectWithoutPaiementInput | VenteCreateOrConnectWithoutPaiementInput[]
    upsert?: VenteUpsertWithWhereUniqueWithoutPaiementInput | VenteUpsertWithWhereUniqueWithoutPaiementInput[]
    createMany?: VenteCreateManyPaiementInputEnvelope
    set?: VenteWhereUniqueInput | VenteWhereUniqueInput[]
    disconnect?: VenteWhereUniqueInput | VenteWhereUniqueInput[]
    delete?: VenteWhereUniqueInput | VenteWhereUniqueInput[]
    connect?: VenteWhereUniqueInput | VenteWhereUniqueInput[]
    update?: VenteUpdateWithWhereUniqueWithoutPaiementInput | VenteUpdateWithWhereUniqueWithoutPaiementInput[]
    updateMany?: VenteUpdateManyWithWhereWithoutPaiementInput | VenteUpdateManyWithWhereWithoutPaiementInput[]
    deleteMany?: VenteScalarWhereInput | VenteScalarWhereInput[]
  }

  export type AchatUncheckedUpdateManyWithoutPaiementNestedInput = {
    create?: XOR<AchatCreateWithoutPaiementInput, AchatUncheckedCreateWithoutPaiementInput> | AchatCreateWithoutPaiementInput[] | AchatUncheckedCreateWithoutPaiementInput[]
    connectOrCreate?: AchatCreateOrConnectWithoutPaiementInput | AchatCreateOrConnectWithoutPaiementInput[]
    upsert?: AchatUpsertWithWhereUniqueWithoutPaiementInput | AchatUpsertWithWhereUniqueWithoutPaiementInput[]
    createMany?: AchatCreateManyPaiementInputEnvelope
    set?: AchatWhereUniqueInput | AchatWhereUniqueInput[]
    disconnect?: AchatWhereUniqueInput | AchatWhereUniqueInput[]
    delete?: AchatWhereUniqueInput | AchatWhereUniqueInput[]
    connect?: AchatWhereUniqueInput | AchatWhereUniqueInput[]
    update?: AchatUpdateWithWhereUniqueWithoutPaiementInput | AchatUpdateWithWhereUniqueWithoutPaiementInput[]
    updateMany?: AchatUpdateManyWithWhereWithoutPaiementInput | AchatUpdateManyWithWhereWithoutPaiementInput[]
    deleteMany?: AchatScalarWhereInput | AchatScalarWhereInput[]
  }

  export type CommandeUncheckedUpdateManyWithoutPaiementNestedInput = {
    create?: XOR<CommandeCreateWithoutPaiementInput, CommandeUncheckedCreateWithoutPaiementInput> | CommandeCreateWithoutPaiementInput[] | CommandeUncheckedCreateWithoutPaiementInput[]
    connectOrCreate?: CommandeCreateOrConnectWithoutPaiementInput | CommandeCreateOrConnectWithoutPaiementInput[]
    upsert?: CommandeUpsertWithWhereUniqueWithoutPaiementInput | CommandeUpsertWithWhereUniqueWithoutPaiementInput[]
    createMany?: CommandeCreateManyPaiementInputEnvelope
    set?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    disconnect?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    delete?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    connect?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    update?: CommandeUpdateWithWhereUniqueWithoutPaiementInput | CommandeUpdateWithWhereUniqueWithoutPaiementInput[]
    updateMany?: CommandeUpdateManyWithWhereWithoutPaiementInput | CommandeUpdateManyWithWhereWithoutPaiementInput[]
    deleteMany?: CommandeScalarWhereInput | CommandeScalarWhereInput[]
  }

  export type VenteUncheckedUpdateManyWithoutPaiementNestedInput = {
    create?: XOR<VenteCreateWithoutPaiementInput, VenteUncheckedCreateWithoutPaiementInput> | VenteCreateWithoutPaiementInput[] | VenteUncheckedCreateWithoutPaiementInput[]
    connectOrCreate?: VenteCreateOrConnectWithoutPaiementInput | VenteCreateOrConnectWithoutPaiementInput[]
    upsert?: VenteUpsertWithWhereUniqueWithoutPaiementInput | VenteUpsertWithWhereUniqueWithoutPaiementInput[]
    createMany?: VenteCreateManyPaiementInputEnvelope
    set?: VenteWhereUniqueInput | VenteWhereUniqueInput[]
    disconnect?: VenteWhereUniqueInput | VenteWhereUniqueInput[]
    delete?: VenteWhereUniqueInput | VenteWhereUniqueInput[]
    connect?: VenteWhereUniqueInput | VenteWhereUniqueInput[]
    update?: VenteUpdateWithWhereUniqueWithoutPaiementInput | VenteUpdateWithWhereUniqueWithoutPaiementInput[]
    updateMany?: VenteUpdateManyWithWhereWithoutPaiementInput | VenteUpdateManyWithWhereWithoutPaiementInput[]
    deleteMany?: VenteScalarWhereInput | VenteScalarWhereInput[]
  }

  export type DeviseCreateNestedOneWithoutCaisseInput = {
    create?: XOR<DeviseCreateWithoutCaisseInput, DeviseUncheckedCreateWithoutCaisseInput>
    connectOrCreate?: DeviseCreateOrConnectWithoutCaisseInput
    connect?: DeviseWhereUniqueInput
  }

  export type UtilisateurCreateNestedOneWithoutCaisseInput = {
    create?: XOR<UtilisateurCreateWithoutCaisseInput, UtilisateurUncheckedCreateWithoutCaisseInput>
    connectOrCreate?: UtilisateurCreateOrConnectWithoutCaisseInput
    connect?: UtilisateurWhereUniqueInput
  }

  export type MouvementCaisseCreateNestedManyWithoutCaisseInput = {
    create?: XOR<MouvementCaisseCreateWithoutCaisseInput, MouvementCaisseUncheckedCreateWithoutCaisseInput> | MouvementCaisseCreateWithoutCaisseInput[] | MouvementCaisseUncheckedCreateWithoutCaisseInput[]
    connectOrCreate?: MouvementCaisseCreateOrConnectWithoutCaisseInput | MouvementCaisseCreateOrConnectWithoutCaisseInput[]
    createMany?: MouvementCaisseCreateManyCaisseInputEnvelope
    connect?: MouvementCaisseWhereUniqueInput | MouvementCaisseWhereUniqueInput[]
  }

  export type ClotureCaisseCreateNestedManyWithoutCaisseInput = {
    create?: XOR<ClotureCaisseCreateWithoutCaisseInput, ClotureCaisseUncheckedCreateWithoutCaisseInput> | ClotureCaisseCreateWithoutCaisseInput[] | ClotureCaisseUncheckedCreateWithoutCaisseInput[]
    connectOrCreate?: ClotureCaisseCreateOrConnectWithoutCaisseInput | ClotureCaisseCreateOrConnectWithoutCaisseInput[]
    createMany?: ClotureCaisseCreateManyCaisseInputEnvelope
    connect?: ClotureCaisseWhereUniqueInput | ClotureCaisseWhereUniqueInput[]
  }

  export type PaiementCreateNestedManyWithoutCaisseInput = {
    create?: XOR<PaiementCreateWithoutCaisseInput, PaiementUncheckedCreateWithoutCaisseInput> | PaiementCreateWithoutCaisseInput[] | PaiementUncheckedCreateWithoutCaisseInput[]
    connectOrCreate?: PaiementCreateOrConnectWithoutCaisseInput | PaiementCreateOrConnectWithoutCaisseInput[]
    createMany?: PaiementCreateManyCaisseInputEnvelope
    connect?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
  }

  export type MouvementCaisseUncheckedCreateNestedManyWithoutCaisseInput = {
    create?: XOR<MouvementCaisseCreateWithoutCaisseInput, MouvementCaisseUncheckedCreateWithoutCaisseInput> | MouvementCaisseCreateWithoutCaisseInput[] | MouvementCaisseUncheckedCreateWithoutCaisseInput[]
    connectOrCreate?: MouvementCaisseCreateOrConnectWithoutCaisseInput | MouvementCaisseCreateOrConnectWithoutCaisseInput[]
    createMany?: MouvementCaisseCreateManyCaisseInputEnvelope
    connect?: MouvementCaisseWhereUniqueInput | MouvementCaisseWhereUniqueInput[]
  }

  export type ClotureCaisseUncheckedCreateNestedManyWithoutCaisseInput = {
    create?: XOR<ClotureCaisseCreateWithoutCaisseInput, ClotureCaisseUncheckedCreateWithoutCaisseInput> | ClotureCaisseCreateWithoutCaisseInput[] | ClotureCaisseUncheckedCreateWithoutCaisseInput[]
    connectOrCreate?: ClotureCaisseCreateOrConnectWithoutCaisseInput | ClotureCaisseCreateOrConnectWithoutCaisseInput[]
    createMany?: ClotureCaisseCreateManyCaisseInputEnvelope
    connect?: ClotureCaisseWhereUniqueInput | ClotureCaisseWhereUniqueInput[]
  }

  export type PaiementUncheckedCreateNestedManyWithoutCaisseInput = {
    create?: XOR<PaiementCreateWithoutCaisseInput, PaiementUncheckedCreateWithoutCaisseInput> | PaiementCreateWithoutCaisseInput[] | PaiementUncheckedCreateWithoutCaisseInput[]
    connectOrCreate?: PaiementCreateOrConnectWithoutCaisseInput | PaiementCreateOrConnectWithoutCaisseInput[]
    createMany?: PaiementCreateManyCaisseInputEnvelope
    connect?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
  }

  export type EnumStatutCaisseFieldUpdateOperationsInput = {
    set?: $Enums.StatutCaisse
  }

  export type DeviseUpdateOneRequiredWithoutCaisseNestedInput = {
    create?: XOR<DeviseCreateWithoutCaisseInput, DeviseUncheckedCreateWithoutCaisseInput>
    connectOrCreate?: DeviseCreateOrConnectWithoutCaisseInput
    upsert?: DeviseUpsertWithoutCaisseInput
    connect?: DeviseWhereUniqueInput
    update?: XOR<XOR<DeviseUpdateToOneWithWhereWithoutCaisseInput, DeviseUpdateWithoutCaisseInput>, DeviseUncheckedUpdateWithoutCaisseInput>
  }

  export type UtilisateurUpdateOneRequiredWithoutCaisseNestedInput = {
    create?: XOR<UtilisateurCreateWithoutCaisseInput, UtilisateurUncheckedCreateWithoutCaisseInput>
    connectOrCreate?: UtilisateurCreateOrConnectWithoutCaisseInput
    upsert?: UtilisateurUpsertWithoutCaisseInput
    connect?: UtilisateurWhereUniqueInput
    update?: XOR<XOR<UtilisateurUpdateToOneWithWhereWithoutCaisseInput, UtilisateurUpdateWithoutCaisseInput>, UtilisateurUncheckedUpdateWithoutCaisseInput>
  }

  export type MouvementCaisseUpdateManyWithoutCaisseNestedInput = {
    create?: XOR<MouvementCaisseCreateWithoutCaisseInput, MouvementCaisseUncheckedCreateWithoutCaisseInput> | MouvementCaisseCreateWithoutCaisseInput[] | MouvementCaisseUncheckedCreateWithoutCaisseInput[]
    connectOrCreate?: MouvementCaisseCreateOrConnectWithoutCaisseInput | MouvementCaisseCreateOrConnectWithoutCaisseInput[]
    upsert?: MouvementCaisseUpsertWithWhereUniqueWithoutCaisseInput | MouvementCaisseUpsertWithWhereUniqueWithoutCaisseInput[]
    createMany?: MouvementCaisseCreateManyCaisseInputEnvelope
    set?: MouvementCaisseWhereUniqueInput | MouvementCaisseWhereUniqueInput[]
    disconnect?: MouvementCaisseWhereUniqueInput | MouvementCaisseWhereUniqueInput[]
    delete?: MouvementCaisseWhereUniqueInput | MouvementCaisseWhereUniqueInput[]
    connect?: MouvementCaisseWhereUniqueInput | MouvementCaisseWhereUniqueInput[]
    update?: MouvementCaisseUpdateWithWhereUniqueWithoutCaisseInput | MouvementCaisseUpdateWithWhereUniqueWithoutCaisseInput[]
    updateMany?: MouvementCaisseUpdateManyWithWhereWithoutCaisseInput | MouvementCaisseUpdateManyWithWhereWithoutCaisseInput[]
    deleteMany?: MouvementCaisseScalarWhereInput | MouvementCaisseScalarWhereInput[]
  }

  export type ClotureCaisseUpdateManyWithoutCaisseNestedInput = {
    create?: XOR<ClotureCaisseCreateWithoutCaisseInput, ClotureCaisseUncheckedCreateWithoutCaisseInput> | ClotureCaisseCreateWithoutCaisseInput[] | ClotureCaisseUncheckedCreateWithoutCaisseInput[]
    connectOrCreate?: ClotureCaisseCreateOrConnectWithoutCaisseInput | ClotureCaisseCreateOrConnectWithoutCaisseInput[]
    upsert?: ClotureCaisseUpsertWithWhereUniqueWithoutCaisseInput | ClotureCaisseUpsertWithWhereUniqueWithoutCaisseInput[]
    createMany?: ClotureCaisseCreateManyCaisseInputEnvelope
    set?: ClotureCaisseWhereUniqueInput | ClotureCaisseWhereUniqueInput[]
    disconnect?: ClotureCaisseWhereUniqueInput | ClotureCaisseWhereUniqueInput[]
    delete?: ClotureCaisseWhereUniqueInput | ClotureCaisseWhereUniqueInput[]
    connect?: ClotureCaisseWhereUniqueInput | ClotureCaisseWhereUniqueInput[]
    update?: ClotureCaisseUpdateWithWhereUniqueWithoutCaisseInput | ClotureCaisseUpdateWithWhereUniqueWithoutCaisseInput[]
    updateMany?: ClotureCaisseUpdateManyWithWhereWithoutCaisseInput | ClotureCaisseUpdateManyWithWhereWithoutCaisseInput[]
    deleteMany?: ClotureCaisseScalarWhereInput | ClotureCaisseScalarWhereInput[]
  }

  export type PaiementUpdateManyWithoutCaisseNestedInput = {
    create?: XOR<PaiementCreateWithoutCaisseInput, PaiementUncheckedCreateWithoutCaisseInput> | PaiementCreateWithoutCaisseInput[] | PaiementUncheckedCreateWithoutCaisseInput[]
    connectOrCreate?: PaiementCreateOrConnectWithoutCaisseInput | PaiementCreateOrConnectWithoutCaisseInput[]
    upsert?: PaiementUpsertWithWhereUniqueWithoutCaisseInput | PaiementUpsertWithWhereUniqueWithoutCaisseInput[]
    createMany?: PaiementCreateManyCaisseInputEnvelope
    set?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    disconnect?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    delete?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    connect?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    update?: PaiementUpdateWithWhereUniqueWithoutCaisseInput | PaiementUpdateWithWhereUniqueWithoutCaisseInput[]
    updateMany?: PaiementUpdateManyWithWhereWithoutCaisseInput | PaiementUpdateManyWithWhereWithoutCaisseInput[]
    deleteMany?: PaiementScalarWhereInput | PaiementScalarWhereInput[]
  }

  export type MouvementCaisseUncheckedUpdateManyWithoutCaisseNestedInput = {
    create?: XOR<MouvementCaisseCreateWithoutCaisseInput, MouvementCaisseUncheckedCreateWithoutCaisseInput> | MouvementCaisseCreateWithoutCaisseInput[] | MouvementCaisseUncheckedCreateWithoutCaisseInput[]
    connectOrCreate?: MouvementCaisseCreateOrConnectWithoutCaisseInput | MouvementCaisseCreateOrConnectWithoutCaisseInput[]
    upsert?: MouvementCaisseUpsertWithWhereUniqueWithoutCaisseInput | MouvementCaisseUpsertWithWhereUniqueWithoutCaisseInput[]
    createMany?: MouvementCaisseCreateManyCaisseInputEnvelope
    set?: MouvementCaisseWhereUniqueInput | MouvementCaisseWhereUniqueInput[]
    disconnect?: MouvementCaisseWhereUniqueInput | MouvementCaisseWhereUniqueInput[]
    delete?: MouvementCaisseWhereUniqueInput | MouvementCaisseWhereUniqueInput[]
    connect?: MouvementCaisseWhereUniqueInput | MouvementCaisseWhereUniqueInput[]
    update?: MouvementCaisseUpdateWithWhereUniqueWithoutCaisseInput | MouvementCaisseUpdateWithWhereUniqueWithoutCaisseInput[]
    updateMany?: MouvementCaisseUpdateManyWithWhereWithoutCaisseInput | MouvementCaisseUpdateManyWithWhereWithoutCaisseInput[]
    deleteMany?: MouvementCaisseScalarWhereInput | MouvementCaisseScalarWhereInput[]
  }

  export type ClotureCaisseUncheckedUpdateManyWithoutCaisseNestedInput = {
    create?: XOR<ClotureCaisseCreateWithoutCaisseInput, ClotureCaisseUncheckedCreateWithoutCaisseInput> | ClotureCaisseCreateWithoutCaisseInput[] | ClotureCaisseUncheckedCreateWithoutCaisseInput[]
    connectOrCreate?: ClotureCaisseCreateOrConnectWithoutCaisseInput | ClotureCaisseCreateOrConnectWithoutCaisseInput[]
    upsert?: ClotureCaisseUpsertWithWhereUniqueWithoutCaisseInput | ClotureCaisseUpsertWithWhereUniqueWithoutCaisseInput[]
    createMany?: ClotureCaisseCreateManyCaisseInputEnvelope
    set?: ClotureCaisseWhereUniqueInput | ClotureCaisseWhereUniqueInput[]
    disconnect?: ClotureCaisseWhereUniqueInput | ClotureCaisseWhereUniqueInput[]
    delete?: ClotureCaisseWhereUniqueInput | ClotureCaisseWhereUniqueInput[]
    connect?: ClotureCaisseWhereUniqueInput | ClotureCaisseWhereUniqueInput[]
    update?: ClotureCaisseUpdateWithWhereUniqueWithoutCaisseInput | ClotureCaisseUpdateWithWhereUniqueWithoutCaisseInput[]
    updateMany?: ClotureCaisseUpdateManyWithWhereWithoutCaisseInput | ClotureCaisseUpdateManyWithWhereWithoutCaisseInput[]
    deleteMany?: ClotureCaisseScalarWhereInput | ClotureCaisseScalarWhereInput[]
  }

  export type PaiementUncheckedUpdateManyWithoutCaisseNestedInput = {
    create?: XOR<PaiementCreateWithoutCaisseInput, PaiementUncheckedCreateWithoutCaisseInput> | PaiementCreateWithoutCaisseInput[] | PaiementUncheckedCreateWithoutCaisseInput[]
    connectOrCreate?: PaiementCreateOrConnectWithoutCaisseInput | PaiementCreateOrConnectWithoutCaisseInput[]
    upsert?: PaiementUpsertWithWhereUniqueWithoutCaisseInput | PaiementUpsertWithWhereUniqueWithoutCaisseInput[]
    createMany?: PaiementCreateManyCaisseInputEnvelope
    set?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    disconnect?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    delete?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    connect?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    update?: PaiementUpdateWithWhereUniqueWithoutCaisseInput | PaiementUpdateWithWhereUniqueWithoutCaisseInput[]
    updateMany?: PaiementUpdateManyWithWhereWithoutCaisseInput | PaiementUpdateManyWithWhereWithoutCaisseInput[]
    deleteMany?: PaiementScalarWhereInput | PaiementScalarWhereInput[]
  }

  export type PaiementCreateNestedOneWithoutVenteInput = {
    create?: XOR<PaiementCreateWithoutVenteInput, PaiementUncheckedCreateWithoutVenteInput>
    connectOrCreate?: PaiementCreateOrConnectWithoutVenteInput
    connect?: PaiementWhereUniqueInput
  }

  export type PanierCreateNestedOneWithoutVenteInput = {
    create?: XOR<PanierCreateWithoutVenteInput, PanierUncheckedCreateWithoutVenteInput>
    connectOrCreate?: PanierCreateOrConnectWithoutVenteInput
    connect?: PanierWhereUniqueInput
  }

  export type UtilisateurCreateNestedOneWithoutVenteInput = {
    create?: XOR<UtilisateurCreateWithoutVenteInput, UtilisateurUncheckedCreateWithoutVenteInput>
    connectOrCreate?: UtilisateurCreateOrConnectWithoutVenteInput
    connect?: UtilisateurWhereUniqueInput
  }

  export type FournisseurCreateNestedOneWithoutVenteInput = {
    create?: XOR<FournisseurCreateWithoutVenteInput, FournisseurUncheckedCreateWithoutVenteInput>
    connectOrCreate?: FournisseurCreateOrConnectWithoutVenteInput
    connect?: FournisseurWhereUniqueInput
  }

  export type EnumStatutVenteFieldUpdateOperationsInput = {
    set?: $Enums.StatutVente
  }

  export type EnumTypeClientFieldUpdateOperationsInput = {
    set?: $Enums.TypeClient
  }

  export type PaiementUpdateOneWithoutVenteNestedInput = {
    create?: XOR<PaiementCreateWithoutVenteInput, PaiementUncheckedCreateWithoutVenteInput>
    connectOrCreate?: PaiementCreateOrConnectWithoutVenteInput
    upsert?: PaiementUpsertWithoutVenteInput
    disconnect?: PaiementWhereInput | boolean
    delete?: PaiementWhereInput | boolean
    connect?: PaiementWhereUniqueInput
    update?: XOR<XOR<PaiementUpdateToOneWithWhereWithoutVenteInput, PaiementUpdateWithoutVenteInput>, PaiementUncheckedUpdateWithoutVenteInput>
  }

  export type PanierUpdateOneRequiredWithoutVenteNestedInput = {
    create?: XOR<PanierCreateWithoutVenteInput, PanierUncheckedCreateWithoutVenteInput>
    connectOrCreate?: PanierCreateOrConnectWithoutVenteInput
    upsert?: PanierUpsertWithoutVenteInput
    connect?: PanierWhereUniqueInput
    update?: XOR<XOR<PanierUpdateToOneWithWhereWithoutVenteInput, PanierUpdateWithoutVenteInput>, PanierUncheckedUpdateWithoutVenteInput>
  }

  export type UtilisateurUpdateOneRequiredWithoutVenteNestedInput = {
    create?: XOR<UtilisateurCreateWithoutVenteInput, UtilisateurUncheckedCreateWithoutVenteInput>
    connectOrCreate?: UtilisateurCreateOrConnectWithoutVenteInput
    upsert?: UtilisateurUpsertWithoutVenteInput
    connect?: UtilisateurWhereUniqueInput
    update?: XOR<XOR<UtilisateurUpdateToOneWithWhereWithoutVenteInput, UtilisateurUpdateWithoutVenteInput>, UtilisateurUncheckedUpdateWithoutVenteInput>
  }

  export type FournisseurUpdateOneWithoutVenteNestedInput = {
    create?: XOR<FournisseurCreateWithoutVenteInput, FournisseurUncheckedCreateWithoutVenteInput>
    connectOrCreate?: FournisseurCreateOrConnectWithoutVenteInput
    upsert?: FournisseurUpsertWithoutVenteInput
    disconnect?: FournisseurWhereInput | boolean
    delete?: FournisseurWhereInput | boolean
    connect?: FournisseurWhereUniqueInput
    update?: XOR<XOR<FournisseurUpdateToOneWithWhereWithoutVenteInput, FournisseurUpdateWithoutVenteInput>, FournisseurUncheckedUpdateWithoutVenteInput>
  }

  export type UtilisateurCreateNestedOneWithoutPanierInput = {
    create?: XOR<UtilisateurCreateWithoutPanierInput, UtilisateurUncheckedCreateWithoutPanierInput>
    connectOrCreate?: UtilisateurCreateOrConnectWithoutPanierInput
    connect?: UtilisateurWhereUniqueInput
  }

  export type DetailPanierCreateNestedManyWithoutPanierInput = {
    create?: XOR<DetailPanierCreateWithoutPanierInput, DetailPanierUncheckedCreateWithoutPanierInput> | DetailPanierCreateWithoutPanierInput[] | DetailPanierUncheckedCreateWithoutPanierInput[]
    connectOrCreate?: DetailPanierCreateOrConnectWithoutPanierInput | DetailPanierCreateOrConnectWithoutPanierInput[]
    createMany?: DetailPanierCreateManyPanierInputEnvelope
    connect?: DetailPanierWhereUniqueInput | DetailPanierWhereUniqueInput[]
  }

  export type AchatCreateNestedManyWithoutPanierInput = {
    create?: XOR<AchatCreateWithoutPanierInput, AchatUncheckedCreateWithoutPanierInput> | AchatCreateWithoutPanierInput[] | AchatUncheckedCreateWithoutPanierInput[]
    connectOrCreate?: AchatCreateOrConnectWithoutPanierInput | AchatCreateOrConnectWithoutPanierInput[]
    createMany?: AchatCreateManyPanierInputEnvelope
    connect?: AchatWhereUniqueInput | AchatWhereUniqueInput[]
  }

  export type VenteCreateNestedManyWithoutPanierInput = {
    create?: XOR<VenteCreateWithoutPanierInput, VenteUncheckedCreateWithoutPanierInput> | VenteCreateWithoutPanierInput[] | VenteUncheckedCreateWithoutPanierInput[]
    connectOrCreate?: VenteCreateOrConnectWithoutPanierInput | VenteCreateOrConnectWithoutPanierInput[]
    createMany?: VenteCreateManyPanierInputEnvelope
    connect?: VenteWhereUniqueInput | VenteWhereUniqueInput[]
  }

  export type ReservationCreateNestedManyWithoutPanierInput = {
    create?: XOR<ReservationCreateWithoutPanierInput, ReservationUncheckedCreateWithoutPanierInput> | ReservationCreateWithoutPanierInput[] | ReservationUncheckedCreateWithoutPanierInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutPanierInput | ReservationCreateOrConnectWithoutPanierInput[]
    createMany?: ReservationCreateManyPanierInputEnvelope
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
  }

  export type CommandeCreateNestedManyWithoutPanierInput = {
    create?: XOR<CommandeCreateWithoutPanierInput, CommandeUncheckedCreateWithoutPanierInput> | CommandeCreateWithoutPanierInput[] | CommandeUncheckedCreateWithoutPanierInput[]
    connectOrCreate?: CommandeCreateOrConnectWithoutPanierInput | CommandeCreateOrConnectWithoutPanierInput[]
    createMany?: CommandeCreateManyPanierInputEnvelope
    connect?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
  }

  export type DetailPanierUncheckedCreateNestedManyWithoutPanierInput = {
    create?: XOR<DetailPanierCreateWithoutPanierInput, DetailPanierUncheckedCreateWithoutPanierInput> | DetailPanierCreateWithoutPanierInput[] | DetailPanierUncheckedCreateWithoutPanierInput[]
    connectOrCreate?: DetailPanierCreateOrConnectWithoutPanierInput | DetailPanierCreateOrConnectWithoutPanierInput[]
    createMany?: DetailPanierCreateManyPanierInputEnvelope
    connect?: DetailPanierWhereUniqueInput | DetailPanierWhereUniqueInput[]
  }

  export type AchatUncheckedCreateNestedManyWithoutPanierInput = {
    create?: XOR<AchatCreateWithoutPanierInput, AchatUncheckedCreateWithoutPanierInput> | AchatCreateWithoutPanierInput[] | AchatUncheckedCreateWithoutPanierInput[]
    connectOrCreate?: AchatCreateOrConnectWithoutPanierInput | AchatCreateOrConnectWithoutPanierInput[]
    createMany?: AchatCreateManyPanierInputEnvelope
    connect?: AchatWhereUniqueInput | AchatWhereUniqueInput[]
  }

  export type VenteUncheckedCreateNestedManyWithoutPanierInput = {
    create?: XOR<VenteCreateWithoutPanierInput, VenteUncheckedCreateWithoutPanierInput> | VenteCreateWithoutPanierInput[] | VenteUncheckedCreateWithoutPanierInput[]
    connectOrCreate?: VenteCreateOrConnectWithoutPanierInput | VenteCreateOrConnectWithoutPanierInput[]
    createMany?: VenteCreateManyPanierInputEnvelope
    connect?: VenteWhereUniqueInput | VenteWhereUniqueInput[]
  }

  export type ReservationUncheckedCreateNestedManyWithoutPanierInput = {
    create?: XOR<ReservationCreateWithoutPanierInput, ReservationUncheckedCreateWithoutPanierInput> | ReservationCreateWithoutPanierInput[] | ReservationUncheckedCreateWithoutPanierInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutPanierInput | ReservationCreateOrConnectWithoutPanierInput[]
    createMany?: ReservationCreateManyPanierInputEnvelope
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
  }

  export type CommandeUncheckedCreateNestedManyWithoutPanierInput = {
    create?: XOR<CommandeCreateWithoutPanierInput, CommandeUncheckedCreateWithoutPanierInput> | CommandeCreateWithoutPanierInput[] | CommandeUncheckedCreateWithoutPanierInput[]
    connectOrCreate?: CommandeCreateOrConnectWithoutPanierInput | CommandeCreateOrConnectWithoutPanierInput[]
    createMany?: CommandeCreateManyPanierInputEnvelope
    connect?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
  }

  export type UtilisateurUpdateOneRequiredWithoutPanierNestedInput = {
    create?: XOR<UtilisateurCreateWithoutPanierInput, UtilisateurUncheckedCreateWithoutPanierInput>
    connectOrCreate?: UtilisateurCreateOrConnectWithoutPanierInput
    upsert?: UtilisateurUpsertWithoutPanierInput
    connect?: UtilisateurWhereUniqueInput
    update?: XOR<XOR<UtilisateurUpdateToOneWithWhereWithoutPanierInput, UtilisateurUpdateWithoutPanierInput>, UtilisateurUncheckedUpdateWithoutPanierInput>
  }

  export type DetailPanierUpdateManyWithoutPanierNestedInput = {
    create?: XOR<DetailPanierCreateWithoutPanierInput, DetailPanierUncheckedCreateWithoutPanierInput> | DetailPanierCreateWithoutPanierInput[] | DetailPanierUncheckedCreateWithoutPanierInput[]
    connectOrCreate?: DetailPanierCreateOrConnectWithoutPanierInput | DetailPanierCreateOrConnectWithoutPanierInput[]
    upsert?: DetailPanierUpsertWithWhereUniqueWithoutPanierInput | DetailPanierUpsertWithWhereUniqueWithoutPanierInput[]
    createMany?: DetailPanierCreateManyPanierInputEnvelope
    set?: DetailPanierWhereUniqueInput | DetailPanierWhereUniqueInput[]
    disconnect?: DetailPanierWhereUniqueInput | DetailPanierWhereUniqueInput[]
    delete?: DetailPanierWhereUniqueInput | DetailPanierWhereUniqueInput[]
    connect?: DetailPanierWhereUniqueInput | DetailPanierWhereUniqueInput[]
    update?: DetailPanierUpdateWithWhereUniqueWithoutPanierInput | DetailPanierUpdateWithWhereUniqueWithoutPanierInput[]
    updateMany?: DetailPanierUpdateManyWithWhereWithoutPanierInput | DetailPanierUpdateManyWithWhereWithoutPanierInput[]
    deleteMany?: DetailPanierScalarWhereInput | DetailPanierScalarWhereInput[]
  }

  export type AchatUpdateManyWithoutPanierNestedInput = {
    create?: XOR<AchatCreateWithoutPanierInput, AchatUncheckedCreateWithoutPanierInput> | AchatCreateWithoutPanierInput[] | AchatUncheckedCreateWithoutPanierInput[]
    connectOrCreate?: AchatCreateOrConnectWithoutPanierInput | AchatCreateOrConnectWithoutPanierInput[]
    upsert?: AchatUpsertWithWhereUniqueWithoutPanierInput | AchatUpsertWithWhereUniqueWithoutPanierInput[]
    createMany?: AchatCreateManyPanierInputEnvelope
    set?: AchatWhereUniqueInput | AchatWhereUniqueInput[]
    disconnect?: AchatWhereUniqueInput | AchatWhereUniqueInput[]
    delete?: AchatWhereUniqueInput | AchatWhereUniqueInput[]
    connect?: AchatWhereUniqueInput | AchatWhereUniqueInput[]
    update?: AchatUpdateWithWhereUniqueWithoutPanierInput | AchatUpdateWithWhereUniqueWithoutPanierInput[]
    updateMany?: AchatUpdateManyWithWhereWithoutPanierInput | AchatUpdateManyWithWhereWithoutPanierInput[]
    deleteMany?: AchatScalarWhereInput | AchatScalarWhereInput[]
  }

  export type VenteUpdateManyWithoutPanierNestedInput = {
    create?: XOR<VenteCreateWithoutPanierInput, VenteUncheckedCreateWithoutPanierInput> | VenteCreateWithoutPanierInput[] | VenteUncheckedCreateWithoutPanierInput[]
    connectOrCreate?: VenteCreateOrConnectWithoutPanierInput | VenteCreateOrConnectWithoutPanierInput[]
    upsert?: VenteUpsertWithWhereUniqueWithoutPanierInput | VenteUpsertWithWhereUniqueWithoutPanierInput[]
    createMany?: VenteCreateManyPanierInputEnvelope
    set?: VenteWhereUniqueInput | VenteWhereUniqueInput[]
    disconnect?: VenteWhereUniqueInput | VenteWhereUniqueInput[]
    delete?: VenteWhereUniqueInput | VenteWhereUniqueInput[]
    connect?: VenteWhereUniqueInput | VenteWhereUniqueInput[]
    update?: VenteUpdateWithWhereUniqueWithoutPanierInput | VenteUpdateWithWhereUniqueWithoutPanierInput[]
    updateMany?: VenteUpdateManyWithWhereWithoutPanierInput | VenteUpdateManyWithWhereWithoutPanierInput[]
    deleteMany?: VenteScalarWhereInput | VenteScalarWhereInput[]
  }

  export type ReservationUpdateManyWithoutPanierNestedInput = {
    create?: XOR<ReservationCreateWithoutPanierInput, ReservationUncheckedCreateWithoutPanierInput> | ReservationCreateWithoutPanierInput[] | ReservationUncheckedCreateWithoutPanierInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutPanierInput | ReservationCreateOrConnectWithoutPanierInput[]
    upsert?: ReservationUpsertWithWhereUniqueWithoutPanierInput | ReservationUpsertWithWhereUniqueWithoutPanierInput[]
    createMany?: ReservationCreateManyPanierInputEnvelope
    set?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    disconnect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    delete?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    update?: ReservationUpdateWithWhereUniqueWithoutPanierInput | ReservationUpdateWithWhereUniqueWithoutPanierInput[]
    updateMany?: ReservationUpdateManyWithWhereWithoutPanierInput | ReservationUpdateManyWithWhereWithoutPanierInput[]
    deleteMany?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
  }

  export type CommandeUpdateManyWithoutPanierNestedInput = {
    create?: XOR<CommandeCreateWithoutPanierInput, CommandeUncheckedCreateWithoutPanierInput> | CommandeCreateWithoutPanierInput[] | CommandeUncheckedCreateWithoutPanierInput[]
    connectOrCreate?: CommandeCreateOrConnectWithoutPanierInput | CommandeCreateOrConnectWithoutPanierInput[]
    upsert?: CommandeUpsertWithWhereUniqueWithoutPanierInput | CommandeUpsertWithWhereUniqueWithoutPanierInput[]
    createMany?: CommandeCreateManyPanierInputEnvelope
    set?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    disconnect?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    delete?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    connect?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    update?: CommandeUpdateWithWhereUniqueWithoutPanierInput | CommandeUpdateWithWhereUniqueWithoutPanierInput[]
    updateMany?: CommandeUpdateManyWithWhereWithoutPanierInput | CommandeUpdateManyWithWhereWithoutPanierInput[]
    deleteMany?: CommandeScalarWhereInput | CommandeScalarWhereInput[]
  }

  export type DetailPanierUncheckedUpdateManyWithoutPanierNestedInput = {
    create?: XOR<DetailPanierCreateWithoutPanierInput, DetailPanierUncheckedCreateWithoutPanierInput> | DetailPanierCreateWithoutPanierInput[] | DetailPanierUncheckedCreateWithoutPanierInput[]
    connectOrCreate?: DetailPanierCreateOrConnectWithoutPanierInput | DetailPanierCreateOrConnectWithoutPanierInput[]
    upsert?: DetailPanierUpsertWithWhereUniqueWithoutPanierInput | DetailPanierUpsertWithWhereUniqueWithoutPanierInput[]
    createMany?: DetailPanierCreateManyPanierInputEnvelope
    set?: DetailPanierWhereUniqueInput | DetailPanierWhereUniqueInput[]
    disconnect?: DetailPanierWhereUniqueInput | DetailPanierWhereUniqueInput[]
    delete?: DetailPanierWhereUniqueInput | DetailPanierWhereUniqueInput[]
    connect?: DetailPanierWhereUniqueInput | DetailPanierWhereUniqueInput[]
    update?: DetailPanierUpdateWithWhereUniqueWithoutPanierInput | DetailPanierUpdateWithWhereUniqueWithoutPanierInput[]
    updateMany?: DetailPanierUpdateManyWithWhereWithoutPanierInput | DetailPanierUpdateManyWithWhereWithoutPanierInput[]
    deleteMany?: DetailPanierScalarWhereInput | DetailPanierScalarWhereInput[]
  }

  export type AchatUncheckedUpdateManyWithoutPanierNestedInput = {
    create?: XOR<AchatCreateWithoutPanierInput, AchatUncheckedCreateWithoutPanierInput> | AchatCreateWithoutPanierInput[] | AchatUncheckedCreateWithoutPanierInput[]
    connectOrCreate?: AchatCreateOrConnectWithoutPanierInput | AchatCreateOrConnectWithoutPanierInput[]
    upsert?: AchatUpsertWithWhereUniqueWithoutPanierInput | AchatUpsertWithWhereUniqueWithoutPanierInput[]
    createMany?: AchatCreateManyPanierInputEnvelope
    set?: AchatWhereUniqueInput | AchatWhereUniqueInput[]
    disconnect?: AchatWhereUniqueInput | AchatWhereUniqueInput[]
    delete?: AchatWhereUniqueInput | AchatWhereUniqueInput[]
    connect?: AchatWhereUniqueInput | AchatWhereUniqueInput[]
    update?: AchatUpdateWithWhereUniqueWithoutPanierInput | AchatUpdateWithWhereUniqueWithoutPanierInput[]
    updateMany?: AchatUpdateManyWithWhereWithoutPanierInput | AchatUpdateManyWithWhereWithoutPanierInput[]
    deleteMany?: AchatScalarWhereInput | AchatScalarWhereInput[]
  }

  export type VenteUncheckedUpdateManyWithoutPanierNestedInput = {
    create?: XOR<VenteCreateWithoutPanierInput, VenteUncheckedCreateWithoutPanierInput> | VenteCreateWithoutPanierInput[] | VenteUncheckedCreateWithoutPanierInput[]
    connectOrCreate?: VenteCreateOrConnectWithoutPanierInput | VenteCreateOrConnectWithoutPanierInput[]
    upsert?: VenteUpsertWithWhereUniqueWithoutPanierInput | VenteUpsertWithWhereUniqueWithoutPanierInput[]
    createMany?: VenteCreateManyPanierInputEnvelope
    set?: VenteWhereUniqueInput | VenteWhereUniqueInput[]
    disconnect?: VenteWhereUniqueInput | VenteWhereUniqueInput[]
    delete?: VenteWhereUniqueInput | VenteWhereUniqueInput[]
    connect?: VenteWhereUniqueInput | VenteWhereUniqueInput[]
    update?: VenteUpdateWithWhereUniqueWithoutPanierInput | VenteUpdateWithWhereUniqueWithoutPanierInput[]
    updateMany?: VenteUpdateManyWithWhereWithoutPanierInput | VenteUpdateManyWithWhereWithoutPanierInput[]
    deleteMany?: VenteScalarWhereInput | VenteScalarWhereInput[]
  }

  export type ReservationUncheckedUpdateManyWithoutPanierNestedInput = {
    create?: XOR<ReservationCreateWithoutPanierInput, ReservationUncheckedCreateWithoutPanierInput> | ReservationCreateWithoutPanierInput[] | ReservationUncheckedCreateWithoutPanierInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutPanierInput | ReservationCreateOrConnectWithoutPanierInput[]
    upsert?: ReservationUpsertWithWhereUniqueWithoutPanierInput | ReservationUpsertWithWhereUniqueWithoutPanierInput[]
    createMany?: ReservationCreateManyPanierInputEnvelope
    set?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    disconnect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    delete?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    update?: ReservationUpdateWithWhereUniqueWithoutPanierInput | ReservationUpdateWithWhereUniqueWithoutPanierInput[]
    updateMany?: ReservationUpdateManyWithWhereWithoutPanierInput | ReservationUpdateManyWithWhereWithoutPanierInput[]
    deleteMany?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
  }

  export type CommandeUncheckedUpdateManyWithoutPanierNestedInput = {
    create?: XOR<CommandeCreateWithoutPanierInput, CommandeUncheckedCreateWithoutPanierInput> | CommandeCreateWithoutPanierInput[] | CommandeUncheckedCreateWithoutPanierInput[]
    connectOrCreate?: CommandeCreateOrConnectWithoutPanierInput | CommandeCreateOrConnectWithoutPanierInput[]
    upsert?: CommandeUpsertWithWhereUniqueWithoutPanierInput | CommandeUpsertWithWhereUniqueWithoutPanierInput[]
    createMany?: CommandeCreateManyPanierInputEnvelope
    set?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    disconnect?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    delete?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    connect?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    update?: CommandeUpdateWithWhereUniqueWithoutPanierInput | CommandeUpdateWithWhereUniqueWithoutPanierInput[]
    updateMany?: CommandeUpdateManyWithWhereWithoutPanierInput | CommandeUpdateManyWithWhereWithoutPanierInput[]
    deleteMany?: CommandeScalarWhereInput | CommandeScalarWhereInput[]
  }

  export type ProduitCreateNestedOneWithoutDetailPanierInput = {
    create?: XOR<ProduitCreateWithoutDetailPanierInput, ProduitUncheckedCreateWithoutDetailPanierInput>
    connectOrCreate?: ProduitCreateOrConnectWithoutDetailPanierInput
    connect?: ProduitWhereUniqueInput
  }

  export type PanierCreateNestedOneWithoutDetailPanierInput = {
    create?: XOR<PanierCreateWithoutDetailPanierInput, PanierUncheckedCreateWithoutDetailPanierInput>
    connectOrCreate?: PanierCreateOrConnectWithoutDetailPanierInput
    connect?: PanierWhereUniqueInput
  }

  export type ProduitUpdateOneRequiredWithoutDetailPanierNestedInput = {
    create?: XOR<ProduitCreateWithoutDetailPanierInput, ProduitUncheckedCreateWithoutDetailPanierInput>
    connectOrCreate?: ProduitCreateOrConnectWithoutDetailPanierInput
    upsert?: ProduitUpsertWithoutDetailPanierInput
    connect?: ProduitWhereUniqueInput
    update?: XOR<XOR<ProduitUpdateToOneWithWhereWithoutDetailPanierInput, ProduitUpdateWithoutDetailPanierInput>, ProduitUncheckedUpdateWithoutDetailPanierInput>
  }

  export type PanierUpdateOneRequiredWithoutDetailPanierNestedInput = {
    create?: XOR<PanierCreateWithoutDetailPanierInput, PanierUncheckedCreateWithoutDetailPanierInput>
    connectOrCreate?: PanierCreateOrConnectWithoutDetailPanierInput
    upsert?: PanierUpsertWithoutDetailPanierInput
    connect?: PanierWhereUniqueInput
    update?: XOR<XOR<PanierUpdateToOneWithWhereWithoutDetailPanierInput, PanierUpdateWithoutDetailPanierInput>, PanierUncheckedUpdateWithoutDetailPanierInput>
  }

  export type PanierCreateNestedOneWithoutAchatInput = {
    create?: XOR<PanierCreateWithoutAchatInput, PanierUncheckedCreateWithoutAchatInput>
    connectOrCreate?: PanierCreateOrConnectWithoutAchatInput
    connect?: PanierWhereUniqueInput
  }

  export type FournisseurCreateNestedOneWithoutAchatInput = {
    create?: XOR<FournisseurCreateWithoutAchatInput, FournisseurUncheckedCreateWithoutAchatInput>
    connectOrCreate?: FournisseurCreateOrConnectWithoutAchatInput
    connect?: FournisseurWhereUniqueInput
  }

  export type UtilisateurCreateNestedOneWithoutAchatInput = {
    create?: XOR<UtilisateurCreateWithoutAchatInput, UtilisateurUncheckedCreateWithoutAchatInput>
    connectOrCreate?: UtilisateurCreateOrConnectWithoutAchatInput
    connect?: UtilisateurWhereUniqueInput
  }

  export type PaiementCreateNestedOneWithoutAchatInput = {
    create?: XOR<PaiementCreateWithoutAchatInput, PaiementUncheckedCreateWithoutAchatInput>
    connectOrCreate?: PaiementCreateOrConnectWithoutAchatInput
    connect?: PaiementWhereUniqueInput
  }

  export type EnumStatutAchatFieldUpdateOperationsInput = {
    set?: $Enums.StatutAchat
  }

  export type PanierUpdateOneRequiredWithoutAchatNestedInput = {
    create?: XOR<PanierCreateWithoutAchatInput, PanierUncheckedCreateWithoutAchatInput>
    connectOrCreate?: PanierCreateOrConnectWithoutAchatInput
    upsert?: PanierUpsertWithoutAchatInput
    connect?: PanierWhereUniqueInput
    update?: XOR<XOR<PanierUpdateToOneWithWhereWithoutAchatInput, PanierUpdateWithoutAchatInput>, PanierUncheckedUpdateWithoutAchatInput>
  }

  export type FournisseurUpdateOneRequiredWithoutAchatNestedInput = {
    create?: XOR<FournisseurCreateWithoutAchatInput, FournisseurUncheckedCreateWithoutAchatInput>
    connectOrCreate?: FournisseurCreateOrConnectWithoutAchatInput
    upsert?: FournisseurUpsertWithoutAchatInput
    connect?: FournisseurWhereUniqueInput
    update?: XOR<XOR<FournisseurUpdateToOneWithWhereWithoutAchatInput, FournisseurUpdateWithoutAchatInput>, FournisseurUncheckedUpdateWithoutAchatInput>
  }

  export type UtilisateurUpdateOneRequiredWithoutAchatNestedInput = {
    create?: XOR<UtilisateurCreateWithoutAchatInput, UtilisateurUncheckedCreateWithoutAchatInput>
    connectOrCreate?: UtilisateurCreateOrConnectWithoutAchatInput
    upsert?: UtilisateurUpsertWithoutAchatInput
    connect?: UtilisateurWhereUniqueInput
    update?: XOR<XOR<UtilisateurUpdateToOneWithWhereWithoutAchatInput, UtilisateurUpdateWithoutAchatInput>, UtilisateurUncheckedUpdateWithoutAchatInput>
  }

  export type PaiementUpdateOneRequiredWithoutAchatNestedInput = {
    create?: XOR<PaiementCreateWithoutAchatInput, PaiementUncheckedCreateWithoutAchatInput>
    connectOrCreate?: PaiementCreateOrConnectWithoutAchatInput
    upsert?: PaiementUpsertWithoutAchatInput
    connect?: PaiementWhereUniqueInput
    update?: XOR<XOR<PaiementUpdateToOneWithWhereWithoutAchatInput, PaiementUpdateWithoutAchatInput>, PaiementUncheckedUpdateWithoutAchatInput>
  }

  export type PanierCreateNestedOneWithoutReservationInput = {
    create?: XOR<PanierCreateWithoutReservationInput, PanierUncheckedCreateWithoutReservationInput>
    connectOrCreate?: PanierCreateOrConnectWithoutReservationInput
    connect?: PanierWhereUniqueInput
  }

  export type UtilisateurCreateNestedOneWithoutReservationInput = {
    create?: XOR<UtilisateurCreateWithoutReservationInput, UtilisateurUncheckedCreateWithoutReservationInput>
    connectOrCreate?: UtilisateurCreateOrConnectWithoutReservationInput
    connect?: UtilisateurWhereUniqueInput
  }

  export type FournisseurCreateNestedOneWithoutReservationInput = {
    create?: XOR<FournisseurCreateWithoutReservationInput, FournisseurUncheckedCreateWithoutReservationInput>
    connectOrCreate?: FournisseurCreateOrConnectWithoutReservationInput
    connect?: FournisseurWhereUniqueInput
  }

  export type AdresseCreateNestedOneWithoutReservationInput = {
    create?: XOR<AdresseCreateWithoutReservationInput, AdresseUncheckedCreateWithoutReservationInput>
    connectOrCreate?: AdresseCreateOrConnectWithoutReservationInput
    connect?: AdresseWhereUniqueInput
  }

  export type ContactCreateNestedOneWithoutReservationInput = {
    create?: XOR<ContactCreateWithoutReservationInput, ContactUncheckedCreateWithoutReservationInput>
    connectOrCreate?: ContactCreateOrConnectWithoutReservationInput
    connect?: ContactWhereUniqueInput
  }

  export type EnumStatutReservationFieldUpdateOperationsInput = {
    set?: $Enums.StatutReservation
  }

  export type PanierUpdateOneRequiredWithoutReservationNestedInput = {
    create?: XOR<PanierCreateWithoutReservationInput, PanierUncheckedCreateWithoutReservationInput>
    connectOrCreate?: PanierCreateOrConnectWithoutReservationInput
    upsert?: PanierUpsertWithoutReservationInput
    connect?: PanierWhereUniqueInput
    update?: XOR<XOR<PanierUpdateToOneWithWhereWithoutReservationInput, PanierUpdateWithoutReservationInput>, PanierUncheckedUpdateWithoutReservationInput>
  }

  export type UtilisateurUpdateOneWithoutReservationNestedInput = {
    create?: XOR<UtilisateurCreateWithoutReservationInput, UtilisateurUncheckedCreateWithoutReservationInput>
    connectOrCreate?: UtilisateurCreateOrConnectWithoutReservationInput
    upsert?: UtilisateurUpsertWithoutReservationInput
    disconnect?: UtilisateurWhereInput | boolean
    delete?: UtilisateurWhereInput | boolean
    connect?: UtilisateurWhereUniqueInput
    update?: XOR<XOR<UtilisateurUpdateToOneWithWhereWithoutReservationInput, UtilisateurUpdateWithoutReservationInput>, UtilisateurUncheckedUpdateWithoutReservationInput>
  }

  export type FournisseurUpdateOneWithoutReservationNestedInput = {
    create?: XOR<FournisseurCreateWithoutReservationInput, FournisseurUncheckedCreateWithoutReservationInput>
    connectOrCreate?: FournisseurCreateOrConnectWithoutReservationInput
    upsert?: FournisseurUpsertWithoutReservationInput
    disconnect?: FournisseurWhereInput | boolean
    delete?: FournisseurWhereInput | boolean
    connect?: FournisseurWhereUniqueInput
    update?: XOR<XOR<FournisseurUpdateToOneWithWhereWithoutReservationInput, FournisseurUpdateWithoutReservationInput>, FournisseurUncheckedUpdateWithoutReservationInput>
  }

  export type AdresseUpdateOneWithoutReservationNestedInput = {
    create?: XOR<AdresseCreateWithoutReservationInput, AdresseUncheckedCreateWithoutReservationInput>
    connectOrCreate?: AdresseCreateOrConnectWithoutReservationInput
    upsert?: AdresseUpsertWithoutReservationInput
    disconnect?: AdresseWhereInput | boolean
    delete?: AdresseWhereInput | boolean
    connect?: AdresseWhereUniqueInput
    update?: XOR<XOR<AdresseUpdateToOneWithWhereWithoutReservationInput, AdresseUpdateWithoutReservationInput>, AdresseUncheckedUpdateWithoutReservationInput>
  }

  export type ContactUpdateOneWithoutReservationNestedInput = {
    create?: XOR<ContactCreateWithoutReservationInput, ContactUncheckedCreateWithoutReservationInput>
    connectOrCreate?: ContactCreateOrConnectWithoutReservationInput
    upsert?: ContactUpsertWithoutReservationInput
    disconnect?: ContactWhereInput | boolean
    delete?: ContactWhereInput | boolean
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutReservationInput, ContactUpdateWithoutReservationInput>, ContactUncheckedUpdateWithoutReservationInput>
  }

  export type PanierCreateNestedOneWithoutCommandeInput = {
    create?: XOR<PanierCreateWithoutCommandeInput, PanierUncheckedCreateWithoutCommandeInput>
    connectOrCreate?: PanierCreateOrConnectWithoutCommandeInput
    connect?: PanierWhereUniqueInput
  }

  export type UtilisateurCreateNestedOneWithoutCommandeInput = {
    create?: XOR<UtilisateurCreateWithoutCommandeInput, UtilisateurUncheckedCreateWithoutCommandeInput>
    connectOrCreate?: UtilisateurCreateOrConnectWithoutCommandeInput
    connect?: UtilisateurWhereUniqueInput
  }

  export type PaiementCreateNestedOneWithoutCommandeInput = {
    create?: XOR<PaiementCreateWithoutCommandeInput, PaiementUncheckedCreateWithoutCommandeInput>
    connectOrCreate?: PaiementCreateOrConnectWithoutCommandeInput
    connect?: PaiementWhereUniqueInput
  }

  export type FournisseurCreateNestedOneWithoutCommandeInput = {
    create?: XOR<FournisseurCreateWithoutCommandeInput, FournisseurUncheckedCreateWithoutCommandeInput>
    connectOrCreate?: FournisseurCreateOrConnectWithoutCommandeInput
    connect?: FournisseurWhereUniqueInput
  }

  export type AdresseCreateNestedOneWithoutCommandeInput = {
    create?: XOR<AdresseCreateWithoutCommandeInput, AdresseUncheckedCreateWithoutCommandeInput>
    connectOrCreate?: AdresseCreateOrConnectWithoutCommandeInput
    connect?: AdresseWhereUniqueInput
  }

  export type ContactCreateNestedOneWithoutCommandeInput = {
    create?: XOR<ContactCreateWithoutCommandeInput, ContactUncheckedCreateWithoutCommandeInput>
    connectOrCreate?: ContactCreateOrConnectWithoutCommandeInput
    connect?: ContactWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumStatutCommandeFieldUpdateOperationsInput = {
    set?: $Enums.StatutCommande
  }

  export type PanierUpdateOneRequiredWithoutCommandeNestedInput = {
    create?: XOR<PanierCreateWithoutCommandeInput, PanierUncheckedCreateWithoutCommandeInput>
    connectOrCreate?: PanierCreateOrConnectWithoutCommandeInput
    upsert?: PanierUpsertWithoutCommandeInput
    connect?: PanierWhereUniqueInput
    update?: XOR<XOR<PanierUpdateToOneWithWhereWithoutCommandeInput, PanierUpdateWithoutCommandeInput>, PanierUncheckedUpdateWithoutCommandeInput>
  }

  export type UtilisateurUpdateOneWithoutCommandeNestedInput = {
    create?: XOR<UtilisateurCreateWithoutCommandeInput, UtilisateurUncheckedCreateWithoutCommandeInput>
    connectOrCreate?: UtilisateurCreateOrConnectWithoutCommandeInput
    upsert?: UtilisateurUpsertWithoutCommandeInput
    disconnect?: UtilisateurWhereInput | boolean
    delete?: UtilisateurWhereInput | boolean
    connect?: UtilisateurWhereUniqueInput
    update?: XOR<XOR<UtilisateurUpdateToOneWithWhereWithoutCommandeInput, UtilisateurUpdateWithoutCommandeInput>, UtilisateurUncheckedUpdateWithoutCommandeInput>
  }

  export type PaiementUpdateOneRequiredWithoutCommandeNestedInput = {
    create?: XOR<PaiementCreateWithoutCommandeInput, PaiementUncheckedCreateWithoutCommandeInput>
    connectOrCreate?: PaiementCreateOrConnectWithoutCommandeInput
    upsert?: PaiementUpsertWithoutCommandeInput
    connect?: PaiementWhereUniqueInput
    update?: XOR<XOR<PaiementUpdateToOneWithWhereWithoutCommandeInput, PaiementUpdateWithoutCommandeInput>, PaiementUncheckedUpdateWithoutCommandeInput>
  }

  export type FournisseurUpdateOneWithoutCommandeNestedInput = {
    create?: XOR<FournisseurCreateWithoutCommandeInput, FournisseurUncheckedCreateWithoutCommandeInput>
    connectOrCreate?: FournisseurCreateOrConnectWithoutCommandeInput
    upsert?: FournisseurUpsertWithoutCommandeInput
    disconnect?: FournisseurWhereInput | boolean
    delete?: FournisseurWhereInput | boolean
    connect?: FournisseurWhereUniqueInput
    update?: XOR<XOR<FournisseurUpdateToOneWithWhereWithoutCommandeInput, FournisseurUpdateWithoutCommandeInput>, FournisseurUncheckedUpdateWithoutCommandeInput>
  }

  export type AdresseUpdateOneWithoutCommandeNestedInput = {
    create?: XOR<AdresseCreateWithoutCommandeInput, AdresseUncheckedCreateWithoutCommandeInput>
    connectOrCreate?: AdresseCreateOrConnectWithoutCommandeInput
    upsert?: AdresseUpsertWithoutCommandeInput
    disconnect?: AdresseWhereInput | boolean
    delete?: AdresseWhereInput | boolean
    connect?: AdresseWhereUniqueInput
    update?: XOR<XOR<AdresseUpdateToOneWithWhereWithoutCommandeInput, AdresseUpdateWithoutCommandeInput>, AdresseUncheckedUpdateWithoutCommandeInput>
  }

  export type ContactUpdateOneWithoutCommandeNestedInput = {
    create?: XOR<ContactCreateWithoutCommandeInput, ContactUncheckedCreateWithoutCommandeInput>
    connectOrCreate?: ContactCreateOrConnectWithoutCommandeInput
    upsert?: ContactUpsertWithoutCommandeInput
    disconnect?: ContactWhereInput | boolean
    delete?: ContactWhereInput | boolean
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutCommandeInput, ContactUpdateWithoutCommandeInput>, ContactUncheckedUpdateWithoutCommandeInput>
  }

  export type CaisseCreateNestedOneWithoutMouvementCaisseInput = {
    create?: XOR<CaisseCreateWithoutMouvementCaisseInput, CaisseUncheckedCreateWithoutMouvementCaisseInput>
    connectOrCreate?: CaisseCreateOrConnectWithoutMouvementCaisseInput
    connect?: CaisseWhereUniqueInput
  }

  export type UtilisateurCreateNestedOneWithoutMouvementCaisseInput = {
    create?: XOR<UtilisateurCreateWithoutMouvementCaisseInput, UtilisateurUncheckedCreateWithoutMouvementCaisseInput>
    connectOrCreate?: UtilisateurCreateOrConnectWithoutMouvementCaisseInput
    connect?: UtilisateurWhereUniqueInput
  }

  export type EnumTypeMouvementCaisseFieldUpdateOperationsInput = {
    set?: $Enums.TypeMouvementCaisse
  }

  export type EnumCategorieMouvementFieldUpdateOperationsInput = {
    set?: $Enums.CategorieMouvement
  }

  export type CaisseUpdateOneRequiredWithoutMouvementCaisseNestedInput = {
    create?: XOR<CaisseCreateWithoutMouvementCaisseInput, CaisseUncheckedCreateWithoutMouvementCaisseInput>
    connectOrCreate?: CaisseCreateOrConnectWithoutMouvementCaisseInput
    upsert?: CaisseUpsertWithoutMouvementCaisseInput
    connect?: CaisseWhereUniqueInput
    update?: XOR<XOR<CaisseUpdateToOneWithWhereWithoutMouvementCaisseInput, CaisseUpdateWithoutMouvementCaisseInput>, CaisseUncheckedUpdateWithoutMouvementCaisseInput>
  }

  export type UtilisateurUpdateOneRequiredWithoutMouvementCaisseNestedInput = {
    create?: XOR<UtilisateurCreateWithoutMouvementCaisseInput, UtilisateurUncheckedCreateWithoutMouvementCaisseInput>
    connectOrCreate?: UtilisateurCreateOrConnectWithoutMouvementCaisseInput
    upsert?: UtilisateurUpsertWithoutMouvementCaisseInput
    connect?: UtilisateurWhereUniqueInput
    update?: XOR<XOR<UtilisateurUpdateToOneWithWhereWithoutMouvementCaisseInput, UtilisateurUpdateWithoutMouvementCaisseInput>, UtilisateurUncheckedUpdateWithoutMouvementCaisseInput>
  }

  export type ProduitCreateNestedOneWithoutDetailClotureCaisseInput = {
    create?: XOR<ProduitCreateWithoutDetailClotureCaisseInput, ProduitUncheckedCreateWithoutDetailClotureCaisseInput>
    connectOrCreate?: ProduitCreateOrConnectWithoutDetailClotureCaisseInput
    connect?: ProduitWhereUniqueInput
  }

  export type TeneurCreateNestedOneWithoutDetailClotureCaisseInput = {
    create?: XOR<TeneurCreateWithoutDetailClotureCaisseInput, TeneurUncheckedCreateWithoutDetailClotureCaisseInput>
    connectOrCreate?: TeneurCreateOrConnectWithoutDetailClotureCaisseInput
    connect?: TeneurWhereUniqueInput
  }

  export type ClotureCaisseCreateNestedOneWithoutDetailClotureCaisseInput = {
    create?: XOR<ClotureCaisseCreateWithoutDetailClotureCaisseInput, ClotureCaisseUncheckedCreateWithoutDetailClotureCaisseInput>
    connectOrCreate?: ClotureCaisseCreateOrConnectWithoutDetailClotureCaisseInput
    connect?: ClotureCaisseWhereUniqueInput
  }

  export type ProduitUpdateOneRequiredWithoutDetailClotureCaisseNestedInput = {
    create?: XOR<ProduitCreateWithoutDetailClotureCaisseInput, ProduitUncheckedCreateWithoutDetailClotureCaisseInput>
    connectOrCreate?: ProduitCreateOrConnectWithoutDetailClotureCaisseInput
    upsert?: ProduitUpsertWithoutDetailClotureCaisseInput
    connect?: ProduitWhereUniqueInput
    update?: XOR<XOR<ProduitUpdateToOneWithWhereWithoutDetailClotureCaisseInput, ProduitUpdateWithoutDetailClotureCaisseInput>, ProduitUncheckedUpdateWithoutDetailClotureCaisseInput>
  }

  export type TeneurUpdateOneRequiredWithoutDetailClotureCaisseNestedInput = {
    create?: XOR<TeneurCreateWithoutDetailClotureCaisseInput, TeneurUncheckedCreateWithoutDetailClotureCaisseInput>
    connectOrCreate?: TeneurCreateOrConnectWithoutDetailClotureCaisseInput
    upsert?: TeneurUpsertWithoutDetailClotureCaisseInput
    connect?: TeneurWhereUniqueInput
    update?: XOR<XOR<TeneurUpdateToOneWithWhereWithoutDetailClotureCaisseInput, TeneurUpdateWithoutDetailClotureCaisseInput>, TeneurUncheckedUpdateWithoutDetailClotureCaisseInput>
  }

  export type ClotureCaisseUpdateOneRequiredWithoutDetailClotureCaisseNestedInput = {
    create?: XOR<ClotureCaisseCreateWithoutDetailClotureCaisseInput, ClotureCaisseUncheckedCreateWithoutDetailClotureCaisseInput>
    connectOrCreate?: ClotureCaisseCreateOrConnectWithoutDetailClotureCaisseInput
    upsert?: ClotureCaisseUpsertWithoutDetailClotureCaisseInput
    connect?: ClotureCaisseWhereUniqueInput
    update?: XOR<XOR<ClotureCaisseUpdateToOneWithWhereWithoutDetailClotureCaisseInput, ClotureCaisseUpdateWithoutDetailClotureCaisseInput>, ClotureCaisseUncheckedUpdateWithoutDetailClotureCaisseInput>
  }

  export type CaisseCreateNestedOneWithoutCloturesInput = {
    create?: XOR<CaisseCreateWithoutCloturesInput, CaisseUncheckedCreateWithoutCloturesInput>
    connectOrCreate?: CaisseCreateOrConnectWithoutCloturesInput
    connect?: CaisseWhereUniqueInput
  }

  export type UtilisateurCreateNestedOneWithoutClotureCaisseInput = {
    create?: XOR<UtilisateurCreateWithoutClotureCaisseInput, UtilisateurUncheckedCreateWithoutClotureCaisseInput>
    connectOrCreate?: UtilisateurCreateOrConnectWithoutClotureCaisseInput
    connect?: UtilisateurWhereUniqueInput
  }

  export type DetailClotureCaisseCreateNestedManyWithoutClotureCaisseInput = {
    create?: XOR<DetailClotureCaisseCreateWithoutClotureCaisseInput, DetailClotureCaisseUncheckedCreateWithoutClotureCaisseInput> | DetailClotureCaisseCreateWithoutClotureCaisseInput[] | DetailClotureCaisseUncheckedCreateWithoutClotureCaisseInput[]
    connectOrCreate?: DetailClotureCaisseCreateOrConnectWithoutClotureCaisseInput | DetailClotureCaisseCreateOrConnectWithoutClotureCaisseInput[]
    createMany?: DetailClotureCaisseCreateManyClotureCaisseInputEnvelope
    connect?: DetailClotureCaisseWhereUniqueInput | DetailClotureCaisseWhereUniqueInput[]
  }

  export type DetailClotureCaisseUncheckedCreateNestedManyWithoutClotureCaisseInput = {
    create?: XOR<DetailClotureCaisseCreateWithoutClotureCaisseInput, DetailClotureCaisseUncheckedCreateWithoutClotureCaisseInput> | DetailClotureCaisseCreateWithoutClotureCaisseInput[] | DetailClotureCaisseUncheckedCreateWithoutClotureCaisseInput[]
    connectOrCreate?: DetailClotureCaisseCreateOrConnectWithoutClotureCaisseInput | DetailClotureCaisseCreateOrConnectWithoutClotureCaisseInput[]
    createMany?: DetailClotureCaisseCreateManyClotureCaisseInputEnvelope
    connect?: DetailClotureCaisseWhereUniqueInput | DetailClotureCaisseWhereUniqueInput[]
  }

  export type CaisseUpdateOneRequiredWithoutCloturesNestedInput = {
    create?: XOR<CaisseCreateWithoutCloturesInput, CaisseUncheckedCreateWithoutCloturesInput>
    connectOrCreate?: CaisseCreateOrConnectWithoutCloturesInput
    upsert?: CaisseUpsertWithoutCloturesInput
    connect?: CaisseWhereUniqueInput
    update?: XOR<XOR<CaisseUpdateToOneWithWhereWithoutCloturesInput, CaisseUpdateWithoutCloturesInput>, CaisseUncheckedUpdateWithoutCloturesInput>
  }

  export type UtilisateurUpdateOneRequiredWithoutClotureCaisseNestedInput = {
    create?: XOR<UtilisateurCreateWithoutClotureCaisseInput, UtilisateurUncheckedCreateWithoutClotureCaisseInput>
    connectOrCreate?: UtilisateurCreateOrConnectWithoutClotureCaisseInput
    upsert?: UtilisateurUpsertWithoutClotureCaisseInput
    connect?: UtilisateurWhereUniqueInput
    update?: XOR<XOR<UtilisateurUpdateToOneWithWhereWithoutClotureCaisseInput, UtilisateurUpdateWithoutClotureCaisseInput>, UtilisateurUncheckedUpdateWithoutClotureCaisseInput>
  }

  export type DetailClotureCaisseUpdateManyWithoutClotureCaisseNestedInput = {
    create?: XOR<DetailClotureCaisseCreateWithoutClotureCaisseInput, DetailClotureCaisseUncheckedCreateWithoutClotureCaisseInput> | DetailClotureCaisseCreateWithoutClotureCaisseInput[] | DetailClotureCaisseUncheckedCreateWithoutClotureCaisseInput[]
    connectOrCreate?: DetailClotureCaisseCreateOrConnectWithoutClotureCaisseInput | DetailClotureCaisseCreateOrConnectWithoutClotureCaisseInput[]
    upsert?: DetailClotureCaisseUpsertWithWhereUniqueWithoutClotureCaisseInput | DetailClotureCaisseUpsertWithWhereUniqueWithoutClotureCaisseInput[]
    createMany?: DetailClotureCaisseCreateManyClotureCaisseInputEnvelope
    set?: DetailClotureCaisseWhereUniqueInput | DetailClotureCaisseWhereUniqueInput[]
    disconnect?: DetailClotureCaisseWhereUniqueInput | DetailClotureCaisseWhereUniqueInput[]
    delete?: DetailClotureCaisseWhereUniqueInput | DetailClotureCaisseWhereUniqueInput[]
    connect?: DetailClotureCaisseWhereUniqueInput | DetailClotureCaisseWhereUniqueInput[]
    update?: DetailClotureCaisseUpdateWithWhereUniqueWithoutClotureCaisseInput | DetailClotureCaisseUpdateWithWhereUniqueWithoutClotureCaisseInput[]
    updateMany?: DetailClotureCaisseUpdateManyWithWhereWithoutClotureCaisseInput | DetailClotureCaisseUpdateManyWithWhereWithoutClotureCaisseInput[]
    deleteMany?: DetailClotureCaisseScalarWhereInput | DetailClotureCaisseScalarWhereInput[]
  }

  export type DetailClotureCaisseUncheckedUpdateManyWithoutClotureCaisseNestedInput = {
    create?: XOR<DetailClotureCaisseCreateWithoutClotureCaisseInput, DetailClotureCaisseUncheckedCreateWithoutClotureCaisseInput> | DetailClotureCaisseCreateWithoutClotureCaisseInput[] | DetailClotureCaisseUncheckedCreateWithoutClotureCaisseInput[]
    connectOrCreate?: DetailClotureCaisseCreateOrConnectWithoutClotureCaisseInput | DetailClotureCaisseCreateOrConnectWithoutClotureCaisseInput[]
    upsert?: DetailClotureCaisseUpsertWithWhereUniqueWithoutClotureCaisseInput | DetailClotureCaisseUpsertWithWhereUniqueWithoutClotureCaisseInput[]
    createMany?: DetailClotureCaisseCreateManyClotureCaisseInputEnvelope
    set?: DetailClotureCaisseWhereUniqueInput | DetailClotureCaisseWhereUniqueInput[]
    disconnect?: DetailClotureCaisseWhereUniqueInput | DetailClotureCaisseWhereUniqueInput[]
    delete?: DetailClotureCaisseWhereUniqueInput | DetailClotureCaisseWhereUniqueInput[]
    connect?: DetailClotureCaisseWhereUniqueInput | DetailClotureCaisseWhereUniqueInput[]
    update?: DetailClotureCaisseUpdateWithWhereUniqueWithoutClotureCaisseInput | DetailClotureCaisseUpdateWithWhereUniqueWithoutClotureCaisseInput[]
    updateMany?: DetailClotureCaisseUpdateManyWithWhereWithoutClotureCaisseInput | DetailClotureCaisseUpdateManyWithWhereWithoutClotureCaisseInput[]
    deleteMany?: DetailClotureCaisseScalarWhereInput | DetailClotureCaisseScalarWhereInput[]
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumSexeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Sexe | EnumSexeFieldRefInput<$PrismaModel> | null
    in?: $Enums.Sexe[] | ListEnumSexeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Sexe[] | ListEnumSexeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSexeNullableFilter<$PrismaModel> | $Enums.Sexe | null
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedEnumPosteNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Poste | EnumPosteFieldRefInput<$PrismaModel> | null
    in?: $Enums.Poste[] | ListEnumPosteFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Poste[] | ListEnumPosteFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPosteNullableFilter<$PrismaModel> | $Enums.Poste | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedEnumSexeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Sexe | EnumSexeFieldRefInput<$PrismaModel> | null
    in?: $Enums.Sexe[] | ListEnumSexeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Sexe[] | ListEnumSexeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSexeNullableWithAggregatesFilter<$PrismaModel> | $Enums.Sexe | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSexeNullableFilter<$PrismaModel>
    _max?: NestedEnumSexeNullableFilter<$PrismaModel>
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedEnumPosteNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Poste | EnumPosteFieldRefInput<$PrismaModel> | null
    in?: $Enums.Poste[] | ListEnumPosteFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Poste[] | ListEnumPosteFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPosteNullableWithAggregatesFilter<$PrismaModel> | $Enums.Poste | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPosteNullableFilter<$PrismaModel>
    _max?: NestedEnumPosteNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumMoyenPaimentFilter<$PrismaModel = never> = {
    equals?: $Enums.MoyenPaiment | EnumMoyenPaimentFieldRefInput<$PrismaModel>
    in?: $Enums.MoyenPaiment[] | ListEnumMoyenPaimentFieldRefInput<$PrismaModel>
    notIn?: $Enums.MoyenPaiment[] | ListEnumMoyenPaimentFieldRefInput<$PrismaModel>
    not?: NestedEnumMoyenPaimentFilter<$PrismaModel> | $Enums.MoyenPaiment
  }

  export type NestedEnumMoyenPaimentWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MoyenPaiment | EnumMoyenPaimentFieldRefInput<$PrismaModel>
    in?: $Enums.MoyenPaiment[] | ListEnumMoyenPaimentFieldRefInput<$PrismaModel>
    notIn?: $Enums.MoyenPaiment[] | ListEnumMoyenPaimentFieldRefInput<$PrismaModel>
    not?: NestedEnumMoyenPaimentWithAggregatesFilter<$PrismaModel> | $Enums.MoyenPaiment
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMoyenPaimentFilter<$PrismaModel>
    _max?: NestedEnumMoyenPaimentFilter<$PrismaModel>
  }

  export type NestedEnumStatutCaisseFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutCaisse | EnumStatutCaisseFieldRefInput<$PrismaModel>
    in?: $Enums.StatutCaisse[] | ListEnumStatutCaisseFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatutCaisse[] | ListEnumStatutCaisseFieldRefInput<$PrismaModel>
    not?: NestedEnumStatutCaisseFilter<$PrismaModel> | $Enums.StatutCaisse
  }

  export type NestedEnumStatutCaisseWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutCaisse | EnumStatutCaisseFieldRefInput<$PrismaModel>
    in?: $Enums.StatutCaisse[] | ListEnumStatutCaisseFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatutCaisse[] | ListEnumStatutCaisseFieldRefInput<$PrismaModel>
    not?: NestedEnumStatutCaisseWithAggregatesFilter<$PrismaModel> | $Enums.StatutCaisse
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatutCaisseFilter<$PrismaModel>
    _max?: NestedEnumStatutCaisseFilter<$PrismaModel>
  }

  export type NestedEnumStatutVenteFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutVente | EnumStatutVenteFieldRefInput<$PrismaModel>
    in?: $Enums.StatutVente[] | ListEnumStatutVenteFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatutVente[] | ListEnumStatutVenteFieldRefInput<$PrismaModel>
    not?: NestedEnumStatutVenteFilter<$PrismaModel> | $Enums.StatutVente
  }

  export type NestedEnumTypeClientFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeClient | EnumTypeClientFieldRefInput<$PrismaModel>
    in?: $Enums.TypeClient[] | ListEnumTypeClientFieldRefInput<$PrismaModel>
    notIn?: $Enums.TypeClient[] | ListEnumTypeClientFieldRefInput<$PrismaModel>
    not?: NestedEnumTypeClientFilter<$PrismaModel> | $Enums.TypeClient
  }

  export type NestedEnumStatutVenteWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutVente | EnumStatutVenteFieldRefInput<$PrismaModel>
    in?: $Enums.StatutVente[] | ListEnumStatutVenteFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatutVente[] | ListEnumStatutVenteFieldRefInput<$PrismaModel>
    not?: NestedEnumStatutVenteWithAggregatesFilter<$PrismaModel> | $Enums.StatutVente
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatutVenteFilter<$PrismaModel>
    _max?: NestedEnumStatutVenteFilter<$PrismaModel>
  }

  export type NestedEnumTypeClientWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeClient | EnumTypeClientFieldRefInput<$PrismaModel>
    in?: $Enums.TypeClient[] | ListEnumTypeClientFieldRefInput<$PrismaModel>
    notIn?: $Enums.TypeClient[] | ListEnumTypeClientFieldRefInput<$PrismaModel>
    not?: NestedEnumTypeClientWithAggregatesFilter<$PrismaModel> | $Enums.TypeClient
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTypeClientFilter<$PrismaModel>
    _max?: NestedEnumTypeClientFilter<$PrismaModel>
  }

  export type NestedEnumStatutAchatFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutAchat | EnumStatutAchatFieldRefInput<$PrismaModel>
    in?: $Enums.StatutAchat[] | ListEnumStatutAchatFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatutAchat[] | ListEnumStatutAchatFieldRefInput<$PrismaModel>
    not?: NestedEnumStatutAchatFilter<$PrismaModel> | $Enums.StatutAchat
  }

  export type NestedEnumStatutAchatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutAchat | EnumStatutAchatFieldRefInput<$PrismaModel>
    in?: $Enums.StatutAchat[] | ListEnumStatutAchatFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatutAchat[] | ListEnumStatutAchatFieldRefInput<$PrismaModel>
    not?: NestedEnumStatutAchatWithAggregatesFilter<$PrismaModel> | $Enums.StatutAchat
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatutAchatFilter<$PrismaModel>
    _max?: NestedEnumStatutAchatFilter<$PrismaModel>
  }

  export type NestedEnumStatutReservationFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutReservation | EnumStatutReservationFieldRefInput<$PrismaModel>
    in?: $Enums.StatutReservation[] | ListEnumStatutReservationFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatutReservation[] | ListEnumStatutReservationFieldRefInput<$PrismaModel>
    not?: NestedEnumStatutReservationFilter<$PrismaModel> | $Enums.StatutReservation
  }

  export type NestedEnumStatutReservationWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutReservation | EnumStatutReservationFieldRefInput<$PrismaModel>
    in?: $Enums.StatutReservation[] | ListEnumStatutReservationFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatutReservation[] | ListEnumStatutReservationFieldRefInput<$PrismaModel>
    not?: NestedEnumStatutReservationWithAggregatesFilter<$PrismaModel> | $Enums.StatutReservation
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatutReservationFilter<$PrismaModel>
    _max?: NestedEnumStatutReservationFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumStatutCommandeFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutCommande | EnumStatutCommandeFieldRefInput<$PrismaModel>
    in?: $Enums.StatutCommande[] | ListEnumStatutCommandeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatutCommande[] | ListEnumStatutCommandeFieldRefInput<$PrismaModel>
    not?: NestedEnumStatutCommandeFilter<$PrismaModel> | $Enums.StatutCommande
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumStatutCommandeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutCommande | EnumStatutCommandeFieldRefInput<$PrismaModel>
    in?: $Enums.StatutCommande[] | ListEnumStatutCommandeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatutCommande[] | ListEnumStatutCommandeFieldRefInput<$PrismaModel>
    not?: NestedEnumStatutCommandeWithAggregatesFilter<$PrismaModel> | $Enums.StatutCommande
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatutCommandeFilter<$PrismaModel>
    _max?: NestedEnumStatutCommandeFilter<$PrismaModel>
  }

  export type NestedEnumTypeMouvementCaisseFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeMouvementCaisse | EnumTypeMouvementCaisseFieldRefInput<$PrismaModel>
    in?: $Enums.TypeMouvementCaisse[] | ListEnumTypeMouvementCaisseFieldRefInput<$PrismaModel>
    notIn?: $Enums.TypeMouvementCaisse[] | ListEnumTypeMouvementCaisseFieldRefInput<$PrismaModel>
    not?: NestedEnumTypeMouvementCaisseFilter<$PrismaModel> | $Enums.TypeMouvementCaisse
  }

  export type NestedEnumCategorieMouvementFilter<$PrismaModel = never> = {
    equals?: $Enums.CategorieMouvement | EnumCategorieMouvementFieldRefInput<$PrismaModel>
    in?: $Enums.CategorieMouvement[] | ListEnumCategorieMouvementFieldRefInput<$PrismaModel>
    notIn?: $Enums.CategorieMouvement[] | ListEnumCategorieMouvementFieldRefInput<$PrismaModel>
    not?: NestedEnumCategorieMouvementFilter<$PrismaModel> | $Enums.CategorieMouvement
  }

  export type NestedEnumTypeMouvementCaisseWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeMouvementCaisse | EnumTypeMouvementCaisseFieldRefInput<$PrismaModel>
    in?: $Enums.TypeMouvementCaisse[] | ListEnumTypeMouvementCaisseFieldRefInput<$PrismaModel>
    notIn?: $Enums.TypeMouvementCaisse[] | ListEnumTypeMouvementCaisseFieldRefInput<$PrismaModel>
    not?: NestedEnumTypeMouvementCaisseWithAggregatesFilter<$PrismaModel> | $Enums.TypeMouvementCaisse
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTypeMouvementCaisseFilter<$PrismaModel>
    _max?: NestedEnumTypeMouvementCaisseFilter<$PrismaModel>
  }

  export type NestedEnumCategorieMouvementWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CategorieMouvement | EnumCategorieMouvementFieldRefInput<$PrismaModel>
    in?: $Enums.CategorieMouvement[] | ListEnumCategorieMouvementFieldRefInput<$PrismaModel>
    notIn?: $Enums.CategorieMouvement[] | ListEnumCategorieMouvementFieldRefInput<$PrismaModel>
    not?: NestedEnumCategorieMouvementWithAggregatesFilter<$PrismaModel> | $Enums.CategorieMouvement
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCategorieMouvementFilter<$PrismaModel>
    _max?: NestedEnumCategorieMouvementFilter<$PrismaModel>
  }

  export type AdresseCreateWithoutUtilisateurInput = {
    ville: string
    commune: string
    adresse: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fournisseur?: FournisseurCreateNestedOneWithoutAdresseInput
    Reservation?: ReservationCreateNestedManyWithoutAdresseInput
    Commande?: CommandeCreateNestedManyWithoutAdresseInput
  }

  export type AdresseUncheckedCreateWithoutUtilisateurInput = {
    id?: number
    ville: string
    commune: string
    adresse: string
    fournisseurId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Reservation?: ReservationUncheckedCreateNestedManyWithoutAdresseInput
    Commande?: CommandeUncheckedCreateNestedManyWithoutAdresseInput
  }

  export type AdresseCreateOrConnectWithoutUtilisateurInput = {
    where: AdresseWhereUniqueInput
    create: XOR<AdresseCreateWithoutUtilisateurInput, AdresseUncheckedCreateWithoutUtilisateurInput>
  }

  export type AdresseCreateManyUtilisateurInputEnvelope = {
    data: AdresseCreateManyUtilisateurInput | AdresseCreateManyUtilisateurInput[]
    skipDuplicates?: boolean
  }

  export type ContactCreateWithoutUtilisateurInput = {
    tel: string
    createdAt?: Date | string
    updatedAt?: Date | string
    fournisseur?: FournisseurCreateNestedOneWithoutContactInput
    Reservation?: ReservationCreateNestedManyWithoutContactInput
    Commande?: CommandeCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutUtilisateurInput = {
    id?: number
    tel: string
    fournisseurId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Reservation?: ReservationUncheckedCreateNestedManyWithoutContactInput
    Commande?: CommandeUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutUtilisateurInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutUtilisateurInput, ContactUncheckedCreateWithoutUtilisateurInput>
  }

  export type ContactCreateManyUtilisateurInputEnvelope = {
    data: ContactCreateManyUtilisateurInput | ContactCreateManyUtilisateurInput[]
    skipDuplicates?: boolean
  }

  export type ProduitCreateWithoutUtilisateurInput = {
    designation: string
    prix: number
    qtte?: number
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    devise: DeviseCreateNestedOneWithoutProduitInput
    teneur: TeneurCreateNestedOneWithoutProduitInput
    DetailPanier?: DetailPanierCreateNestedManyWithoutProduitInput
    DetailClotureCaisse?: DetailClotureCaisseCreateNestedManyWithoutProduitInput
  }

  export type ProduitUncheckedCreateWithoutUtilisateurInput = {
    id?: number
    designation: string
    prix: number
    qtte?: number
    description: string
    deviseId: number
    teneurId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    DetailPanier?: DetailPanierUncheckedCreateNestedManyWithoutProduitInput
    DetailClotureCaisse?: DetailClotureCaisseUncheckedCreateNestedManyWithoutProduitInput
  }

  export type ProduitCreateOrConnectWithoutUtilisateurInput = {
    where: ProduitWhereUniqueInput
    create: XOR<ProduitCreateWithoutUtilisateurInput, ProduitUncheckedCreateWithoutUtilisateurInput>
  }

  export type ProduitCreateManyUtilisateurInputEnvelope = {
    data: ProduitCreateManyUtilisateurInput | ProduitCreateManyUtilisateurInput[]
    skipDuplicates?: boolean
  }

  export type VenteCreateWithoutUtilisateurInput = {
    statut?: $Enums.StatutVente
    total_ttc: number
    total_ht: number
    type_acheteur: $Enums.TypeClient
    clientId?: number | null
    agentId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    paiement?: PaiementCreateNestedOneWithoutVenteInput
    panier: PanierCreateNestedOneWithoutVenteInput
    fournisseur?: FournisseurCreateNestedOneWithoutVenteInput
  }

  export type VenteUncheckedCreateWithoutUtilisateurInput = {
    id?: number
    statut?: $Enums.StatutVente
    total_ttc: number
    total_ht: number
    type_acheteur: $Enums.TypeClient
    clientId?: number | null
    fournisseurId?: number | null
    agentId?: number | null
    paiementId: number
    panierId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VenteCreateOrConnectWithoutUtilisateurInput = {
    where: VenteWhereUniqueInput
    create: XOR<VenteCreateWithoutUtilisateurInput, VenteUncheckedCreateWithoutUtilisateurInput>
  }

  export type VenteCreateManyUtilisateurInputEnvelope = {
    data: VenteCreateManyUtilisateurInput | VenteCreateManyUtilisateurInput[]
    skipDuplicates?: boolean
  }

  export type AchatCreateWithoutUtilisateurInput = {
    statut?: $Enums.StatutAchat
    createdAt?: Date | string
    updatedAt?: Date | string
    panier: PanierCreateNestedOneWithoutAchatInput
    fournisseur: FournisseurCreateNestedOneWithoutAchatInput
    paiement: PaiementCreateNestedOneWithoutAchatInput
  }

  export type AchatUncheckedCreateWithoutUtilisateurInput = {
    id?: number
    statut?: $Enums.StatutAchat
    panierId: number
    fournisseurId: number
    paiementId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AchatCreateOrConnectWithoutUtilisateurInput = {
    where: AchatWhereUniqueInput
    create: XOR<AchatCreateWithoutUtilisateurInput, AchatUncheckedCreateWithoutUtilisateurInput>
  }

  export type AchatCreateManyUtilisateurInputEnvelope = {
    data: AchatCreateManyUtilisateurInput | AchatCreateManyUtilisateurInput[]
    skipDuplicates?: boolean
  }

  export type TeneurCreateWithoutUtilisateurInput = {
    valeur: number
    createdAt?: Date | string
    updatedAt?: Date | string
    Produit?: ProduitCreateNestedManyWithoutTeneurInput
    DetailClotureCaisse?: DetailClotureCaisseCreateNestedManyWithoutTeneurInput
  }

  export type TeneurUncheckedCreateWithoutUtilisateurInput = {
    id?: number
    valeur: number
    createdAt?: Date | string
    updatedAt?: Date | string
    Produit?: ProduitUncheckedCreateNestedManyWithoutTeneurInput
    DetailClotureCaisse?: DetailClotureCaisseUncheckedCreateNestedManyWithoutTeneurInput
  }

  export type TeneurCreateOrConnectWithoutUtilisateurInput = {
    where: TeneurWhereUniqueInput
    create: XOR<TeneurCreateWithoutUtilisateurInput, TeneurUncheckedCreateWithoutUtilisateurInput>
  }

  export type TeneurCreateManyUtilisateurInputEnvelope = {
    data: TeneurCreateManyUtilisateurInput | TeneurCreateManyUtilisateurInput[]
    skipDuplicates?: boolean
  }

  export type DeviseCreateWithoutUtilisateurInput = {
    nom: string
    code: string
    symbole: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Produit?: ProduitCreateNestedManyWithoutDeviseInput
    Paiement?: PaiementCreateNestedManyWithoutDeviseInput
    Caisse?: CaisseCreateNestedManyWithoutDeviseInput
  }

  export type DeviseUncheckedCreateWithoutUtilisateurInput = {
    id?: number
    nom: string
    code: string
    symbole: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Produit?: ProduitUncheckedCreateNestedManyWithoutDeviseInput
    Paiement?: PaiementUncheckedCreateNestedManyWithoutDeviseInput
    Caisse?: CaisseUncheckedCreateNestedManyWithoutDeviseInput
  }

  export type DeviseCreateOrConnectWithoutUtilisateurInput = {
    where: DeviseWhereUniqueInput
    create: XOR<DeviseCreateWithoutUtilisateurInput, DeviseUncheckedCreateWithoutUtilisateurInput>
  }

  export type DeviseCreateManyUtilisateurInputEnvelope = {
    data: DeviseCreateManyUtilisateurInput | DeviseCreateManyUtilisateurInput[]
    skipDuplicates?: boolean
  }

  export type PanierCreateWithoutUtilisateurInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    DetailPanier?: DetailPanierCreateNestedManyWithoutPanierInput
    Achat?: AchatCreateNestedManyWithoutPanierInput
    Vente?: VenteCreateNestedManyWithoutPanierInput
    Reservation?: ReservationCreateNestedManyWithoutPanierInput
    Commande?: CommandeCreateNestedManyWithoutPanierInput
  }

  export type PanierUncheckedCreateWithoutUtilisateurInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    DetailPanier?: DetailPanierUncheckedCreateNestedManyWithoutPanierInput
    Achat?: AchatUncheckedCreateNestedManyWithoutPanierInput
    Vente?: VenteUncheckedCreateNestedManyWithoutPanierInput
    Reservation?: ReservationUncheckedCreateNestedManyWithoutPanierInput
    Commande?: CommandeUncheckedCreateNestedManyWithoutPanierInput
  }

  export type PanierCreateOrConnectWithoutUtilisateurInput = {
    where: PanierWhereUniqueInput
    create: XOR<PanierCreateWithoutUtilisateurInput, PanierUncheckedCreateWithoutUtilisateurInput>
  }

  export type PanierCreateManyUtilisateurInputEnvelope = {
    data: PanierCreateManyUtilisateurInput | PanierCreateManyUtilisateurInput[]
    skipDuplicates?: boolean
  }

  export type ReservationCreateWithoutUtilisateurInput = {
    dateLivraisonSouhaitee: Date | string
    adresseLivraison?: string | null
    statut?: $Enums.StatutReservation
    notes?: string | null
    type_client?: $Enums.TypeClient
    nom?: string | null
    tel?: string | null
    enregistrerParId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    panier: PanierCreateNestedOneWithoutReservationInput
    fournisseur?: FournisseurCreateNestedOneWithoutReservationInput
    adresse?: AdresseCreateNestedOneWithoutReservationInput
    contact?: ContactCreateNestedOneWithoutReservationInput
  }

  export type ReservationUncheckedCreateWithoutUtilisateurInput = {
    id?: number
    dateLivraisonSouhaitee: Date | string
    adresseLivraison?: string | null
    statut?: $Enums.StatutReservation
    notes?: string | null
    type_client?: $Enums.TypeClient
    panierId: number
    nom?: string | null
    tel?: string | null
    adresseId?: number | null
    contactId?: number | null
    enregistrerParId?: number | null
    fournisseurId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReservationCreateOrConnectWithoutUtilisateurInput = {
    where: ReservationWhereUniqueInput
    create: XOR<ReservationCreateWithoutUtilisateurInput, ReservationUncheckedCreateWithoutUtilisateurInput>
  }

  export type ReservationCreateManyUtilisateurInputEnvelope = {
    data: ReservationCreateManyUtilisateurInput | ReservationCreateManyUtilisateurInput[]
    skipDuplicates?: boolean
  }

  export type CommandeCreateWithoutClientInput = {
    nom?: string | null
    tel?: string | null
    type_client?: $Enums.TypeClient
    notes?: string | null
    dateLivraisonEffective?: Date | string | null
    adresseLivraison?: string | null
    enregistrerParId?: number | null
    statut?: $Enums.StatutCommande
    createdAt?: Date | string
    updatedAt?: Date | string
    panier: PanierCreateNestedOneWithoutCommandeInput
    paiement: PaiementCreateNestedOneWithoutCommandeInput
    fournisseur?: FournisseurCreateNestedOneWithoutCommandeInput
    adresse?: AdresseCreateNestedOneWithoutCommandeInput
    contact?: ContactCreateNestedOneWithoutCommandeInput
  }

  export type CommandeUncheckedCreateWithoutClientInput = {
    id?: number
    panierId: number
    nom?: string | null
    tel?: string | null
    type_client?: $Enums.TypeClient
    paiementId: number
    adresseId?: number | null
    contactId?: number | null
    fournisseurId?: number | null
    notes?: string | null
    dateLivraisonEffective?: Date | string | null
    adresseLivraison?: string | null
    enregistrerParId?: number | null
    statut?: $Enums.StatutCommande
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommandeCreateOrConnectWithoutClientInput = {
    where: CommandeWhereUniqueInput
    create: XOR<CommandeCreateWithoutClientInput, CommandeUncheckedCreateWithoutClientInput>
  }

  export type CommandeCreateManyClientInputEnvelope = {
    data: CommandeCreateManyClientInput | CommandeCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type CaisseCreateWithoutUtilisateurInput = {
    nom: string
    description?: string | null
    soldeInitial: number
    soldeActuel: number
    statut?: $Enums.StatutCaisse
    createdAt?: Date | string
    updatedAt?: Date | string
    devise: DeviseCreateNestedOneWithoutCaisseInput
    MouvementCaisse?: MouvementCaisseCreateNestedManyWithoutCaisseInput
    clotures?: ClotureCaisseCreateNestedManyWithoutCaisseInput
    Paiement?: PaiementCreateNestedManyWithoutCaisseInput
  }

  export type CaisseUncheckedCreateWithoutUtilisateurInput = {
    id?: number
    nom: string
    description?: string | null
    soldeInitial: number
    soldeActuel: number
    deviseId: number
    statut?: $Enums.StatutCaisse
    createdAt?: Date | string
    updatedAt?: Date | string
    MouvementCaisse?: MouvementCaisseUncheckedCreateNestedManyWithoutCaisseInput
    clotures?: ClotureCaisseUncheckedCreateNestedManyWithoutCaisseInput
    Paiement?: PaiementUncheckedCreateNestedManyWithoutCaisseInput
  }

  export type CaisseCreateOrConnectWithoutUtilisateurInput = {
    where: CaisseWhereUniqueInput
    create: XOR<CaisseCreateWithoutUtilisateurInput, CaisseUncheckedCreateWithoutUtilisateurInput>
  }

  export type CaisseCreateManyUtilisateurInputEnvelope = {
    data: CaisseCreateManyUtilisateurInput | CaisseCreateManyUtilisateurInput[]
    skipDuplicates?: boolean
  }

  export type MouvementCaisseCreateWithoutUtilisateurInput = {
    type_mouvement?: $Enums.TypeMouvementCaisse
    categorie?: $Enums.CategorieMouvement
    montant: number
    description?: string | null
    referenceExterne?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    caisse: CaisseCreateNestedOneWithoutMouvementCaisseInput
  }

  export type MouvementCaisseUncheckedCreateWithoutUtilisateurInput = {
    id?: number
    caisseId: number
    type_mouvement?: $Enums.TypeMouvementCaisse
    categorie?: $Enums.CategorieMouvement
    montant: number
    description?: string | null
    referenceExterne?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MouvementCaisseCreateOrConnectWithoutUtilisateurInput = {
    where: MouvementCaisseWhereUniqueInput
    create: XOR<MouvementCaisseCreateWithoutUtilisateurInput, MouvementCaisseUncheckedCreateWithoutUtilisateurInput>
  }

  export type MouvementCaisseCreateManyUtilisateurInputEnvelope = {
    data: MouvementCaisseCreateManyUtilisateurInput | MouvementCaisseCreateManyUtilisateurInput[]
    skipDuplicates?: boolean
  }

  export type ClotureCaisseCreateWithoutUtilisateurClotureInput = {
    dateCloture?: Date | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    caisse: CaisseCreateNestedOneWithoutCloturesInput
    DetailClotureCaisse?: DetailClotureCaisseCreateNestedManyWithoutClotureCaisseInput
  }

  export type ClotureCaisseUncheckedCreateWithoutUtilisateurClotureInput = {
    id?: number
    caisseId: number
    dateCloture?: Date | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    DetailClotureCaisse?: DetailClotureCaisseUncheckedCreateNestedManyWithoutClotureCaisseInput
  }

  export type ClotureCaisseCreateOrConnectWithoutUtilisateurClotureInput = {
    where: ClotureCaisseWhereUniqueInput
    create: XOR<ClotureCaisseCreateWithoutUtilisateurClotureInput, ClotureCaisseUncheckedCreateWithoutUtilisateurClotureInput>
  }

  export type ClotureCaisseCreateManyUtilisateurClotureInputEnvelope = {
    data: ClotureCaisseCreateManyUtilisateurClotureInput | ClotureCaisseCreateManyUtilisateurClotureInput[]
    skipDuplicates?: boolean
  }

  export type AdresseUpsertWithWhereUniqueWithoutUtilisateurInput = {
    where: AdresseWhereUniqueInput
    update: XOR<AdresseUpdateWithoutUtilisateurInput, AdresseUncheckedUpdateWithoutUtilisateurInput>
    create: XOR<AdresseCreateWithoutUtilisateurInput, AdresseUncheckedCreateWithoutUtilisateurInput>
  }

  export type AdresseUpdateWithWhereUniqueWithoutUtilisateurInput = {
    where: AdresseWhereUniqueInput
    data: XOR<AdresseUpdateWithoutUtilisateurInput, AdresseUncheckedUpdateWithoutUtilisateurInput>
  }

  export type AdresseUpdateManyWithWhereWithoutUtilisateurInput = {
    where: AdresseScalarWhereInput
    data: XOR<AdresseUpdateManyMutationInput, AdresseUncheckedUpdateManyWithoutUtilisateurInput>
  }

  export type AdresseScalarWhereInput = {
    AND?: AdresseScalarWhereInput | AdresseScalarWhereInput[]
    OR?: AdresseScalarWhereInput[]
    NOT?: AdresseScalarWhereInput | AdresseScalarWhereInput[]
    id?: IntFilter<"Adresse"> | number
    ville?: StringFilter<"Adresse"> | string
    commune?: StringFilter<"Adresse"> | string
    adresse?: StringFilter<"Adresse"> | string
    utilisateurId?: IntNullableFilter<"Adresse"> | number | null
    fournisseurId?: IntNullableFilter<"Adresse"> | number | null
    createdAt?: DateTimeFilter<"Adresse"> | Date | string
    updatedAt?: DateTimeFilter<"Adresse"> | Date | string
  }

  export type ContactUpsertWithWhereUniqueWithoutUtilisateurInput = {
    where: ContactWhereUniqueInput
    update: XOR<ContactUpdateWithoutUtilisateurInput, ContactUncheckedUpdateWithoutUtilisateurInput>
    create: XOR<ContactCreateWithoutUtilisateurInput, ContactUncheckedCreateWithoutUtilisateurInput>
  }

  export type ContactUpdateWithWhereUniqueWithoutUtilisateurInput = {
    where: ContactWhereUniqueInput
    data: XOR<ContactUpdateWithoutUtilisateurInput, ContactUncheckedUpdateWithoutUtilisateurInput>
  }

  export type ContactUpdateManyWithWhereWithoutUtilisateurInput = {
    where: ContactScalarWhereInput
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyWithoutUtilisateurInput>
  }

  export type ContactScalarWhereInput = {
    AND?: ContactScalarWhereInput | ContactScalarWhereInput[]
    OR?: ContactScalarWhereInput[]
    NOT?: ContactScalarWhereInput | ContactScalarWhereInput[]
    id?: IntFilter<"Contact"> | number
    tel?: StringFilter<"Contact"> | string
    utilisateurId?: IntNullableFilter<"Contact"> | number | null
    fournisseurId?: IntNullableFilter<"Contact"> | number | null
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    updatedAt?: DateTimeFilter<"Contact"> | Date | string
  }

  export type ProduitUpsertWithWhereUniqueWithoutUtilisateurInput = {
    where: ProduitWhereUniqueInput
    update: XOR<ProduitUpdateWithoutUtilisateurInput, ProduitUncheckedUpdateWithoutUtilisateurInput>
    create: XOR<ProduitCreateWithoutUtilisateurInput, ProduitUncheckedCreateWithoutUtilisateurInput>
  }

  export type ProduitUpdateWithWhereUniqueWithoutUtilisateurInput = {
    where: ProduitWhereUniqueInput
    data: XOR<ProduitUpdateWithoutUtilisateurInput, ProduitUncheckedUpdateWithoutUtilisateurInput>
  }

  export type ProduitUpdateManyWithWhereWithoutUtilisateurInput = {
    where: ProduitScalarWhereInput
    data: XOR<ProduitUpdateManyMutationInput, ProduitUncheckedUpdateManyWithoutUtilisateurInput>
  }

  export type ProduitScalarWhereInput = {
    AND?: ProduitScalarWhereInput | ProduitScalarWhereInput[]
    OR?: ProduitScalarWhereInput[]
    NOT?: ProduitScalarWhereInput | ProduitScalarWhereInput[]
    id?: IntFilter<"Produit"> | number
    designation?: StringFilter<"Produit"> | string
    prix?: FloatFilter<"Produit"> | number
    qtte?: IntFilter<"Produit"> | number
    description?: StringFilter<"Produit"> | string
    deviseId?: IntFilter<"Produit"> | number
    teneurId?: IntFilter<"Produit"> | number
    utilisateurId?: IntFilter<"Produit"> | number
    createdAt?: DateTimeFilter<"Produit"> | Date | string
    updatedAt?: DateTimeFilter<"Produit"> | Date | string
  }

  export type VenteUpsertWithWhereUniqueWithoutUtilisateurInput = {
    where: VenteWhereUniqueInput
    update: XOR<VenteUpdateWithoutUtilisateurInput, VenteUncheckedUpdateWithoutUtilisateurInput>
    create: XOR<VenteCreateWithoutUtilisateurInput, VenteUncheckedCreateWithoutUtilisateurInput>
  }

  export type VenteUpdateWithWhereUniqueWithoutUtilisateurInput = {
    where: VenteWhereUniqueInput
    data: XOR<VenteUpdateWithoutUtilisateurInput, VenteUncheckedUpdateWithoutUtilisateurInput>
  }

  export type VenteUpdateManyWithWhereWithoutUtilisateurInput = {
    where: VenteScalarWhereInput
    data: XOR<VenteUpdateManyMutationInput, VenteUncheckedUpdateManyWithoutUtilisateurInput>
  }

  export type VenteScalarWhereInput = {
    AND?: VenteScalarWhereInput | VenteScalarWhereInput[]
    OR?: VenteScalarWhereInput[]
    NOT?: VenteScalarWhereInput | VenteScalarWhereInput[]
    id?: IntFilter<"Vente"> | number
    statut?: EnumStatutVenteFilter<"Vente"> | $Enums.StatutVente
    total_ttc?: FloatFilter<"Vente"> | number
    total_ht?: FloatFilter<"Vente"> | number
    type_acheteur?: EnumTypeClientFilter<"Vente"> | $Enums.TypeClient
    clientId?: IntNullableFilter<"Vente"> | number | null
    enregistrerParId?: IntFilter<"Vente"> | number
    fournisseurId?: IntNullableFilter<"Vente"> | number | null
    agentId?: IntNullableFilter<"Vente"> | number | null
    paiementId?: IntFilter<"Vente"> | number
    panierId?: IntFilter<"Vente"> | number
    createdAt?: DateTimeFilter<"Vente"> | Date | string
    updatedAt?: DateTimeFilter<"Vente"> | Date | string
  }

  export type AchatUpsertWithWhereUniqueWithoutUtilisateurInput = {
    where: AchatWhereUniqueInput
    update: XOR<AchatUpdateWithoutUtilisateurInput, AchatUncheckedUpdateWithoutUtilisateurInput>
    create: XOR<AchatCreateWithoutUtilisateurInput, AchatUncheckedCreateWithoutUtilisateurInput>
  }

  export type AchatUpdateWithWhereUniqueWithoutUtilisateurInput = {
    where: AchatWhereUniqueInput
    data: XOR<AchatUpdateWithoutUtilisateurInput, AchatUncheckedUpdateWithoutUtilisateurInput>
  }

  export type AchatUpdateManyWithWhereWithoutUtilisateurInput = {
    where: AchatScalarWhereInput
    data: XOR<AchatUpdateManyMutationInput, AchatUncheckedUpdateManyWithoutUtilisateurInput>
  }

  export type AchatScalarWhereInput = {
    AND?: AchatScalarWhereInput | AchatScalarWhereInput[]
    OR?: AchatScalarWhereInput[]
    NOT?: AchatScalarWhereInput | AchatScalarWhereInput[]
    id?: IntFilter<"Achat"> | number
    statut?: EnumStatutAchatFilter<"Achat"> | $Enums.StatutAchat
    panierId?: IntFilter<"Achat"> | number
    fournisseurId?: IntFilter<"Achat"> | number
    enregistrerParId?: IntFilter<"Achat"> | number
    paiementId?: IntFilter<"Achat"> | number
    createdAt?: DateTimeFilter<"Achat"> | Date | string
    updatedAt?: DateTimeFilter<"Achat"> | Date | string
  }

  export type TeneurUpsertWithWhereUniqueWithoutUtilisateurInput = {
    where: TeneurWhereUniqueInput
    update: XOR<TeneurUpdateWithoutUtilisateurInput, TeneurUncheckedUpdateWithoutUtilisateurInput>
    create: XOR<TeneurCreateWithoutUtilisateurInput, TeneurUncheckedCreateWithoutUtilisateurInput>
  }

  export type TeneurUpdateWithWhereUniqueWithoutUtilisateurInput = {
    where: TeneurWhereUniqueInput
    data: XOR<TeneurUpdateWithoutUtilisateurInput, TeneurUncheckedUpdateWithoutUtilisateurInput>
  }

  export type TeneurUpdateManyWithWhereWithoutUtilisateurInput = {
    where: TeneurScalarWhereInput
    data: XOR<TeneurUpdateManyMutationInput, TeneurUncheckedUpdateManyWithoutUtilisateurInput>
  }

  export type TeneurScalarWhereInput = {
    AND?: TeneurScalarWhereInput | TeneurScalarWhereInput[]
    OR?: TeneurScalarWhereInput[]
    NOT?: TeneurScalarWhereInput | TeneurScalarWhereInput[]
    id?: IntFilter<"Teneur"> | number
    valeur?: FloatFilter<"Teneur"> | number
    utilisateurId?: IntFilter<"Teneur"> | number
    createdAt?: DateTimeFilter<"Teneur"> | Date | string
    updatedAt?: DateTimeFilter<"Teneur"> | Date | string
  }

  export type DeviseUpsertWithWhereUniqueWithoutUtilisateurInput = {
    where: DeviseWhereUniqueInput
    update: XOR<DeviseUpdateWithoutUtilisateurInput, DeviseUncheckedUpdateWithoutUtilisateurInput>
    create: XOR<DeviseCreateWithoutUtilisateurInput, DeviseUncheckedCreateWithoutUtilisateurInput>
  }

  export type DeviseUpdateWithWhereUniqueWithoutUtilisateurInput = {
    where: DeviseWhereUniqueInput
    data: XOR<DeviseUpdateWithoutUtilisateurInput, DeviseUncheckedUpdateWithoutUtilisateurInput>
  }

  export type DeviseUpdateManyWithWhereWithoutUtilisateurInput = {
    where: DeviseScalarWhereInput
    data: XOR<DeviseUpdateManyMutationInput, DeviseUncheckedUpdateManyWithoutUtilisateurInput>
  }

  export type DeviseScalarWhereInput = {
    AND?: DeviseScalarWhereInput | DeviseScalarWhereInput[]
    OR?: DeviseScalarWhereInput[]
    NOT?: DeviseScalarWhereInput | DeviseScalarWhereInput[]
    id?: IntFilter<"Devise"> | number
    nom?: StringFilter<"Devise"> | string
    code?: StringFilter<"Devise"> | string
    symbole?: StringFilter<"Devise"> | string
    utilisateurId?: IntFilter<"Devise"> | number
    createdAt?: DateTimeFilter<"Devise"> | Date | string
    updatedAt?: DateTimeFilter<"Devise"> | Date | string
  }

  export type PanierUpsertWithWhereUniqueWithoutUtilisateurInput = {
    where: PanierWhereUniqueInput
    update: XOR<PanierUpdateWithoutUtilisateurInput, PanierUncheckedUpdateWithoutUtilisateurInput>
    create: XOR<PanierCreateWithoutUtilisateurInput, PanierUncheckedCreateWithoutUtilisateurInput>
  }

  export type PanierUpdateWithWhereUniqueWithoutUtilisateurInput = {
    where: PanierWhereUniqueInput
    data: XOR<PanierUpdateWithoutUtilisateurInput, PanierUncheckedUpdateWithoutUtilisateurInput>
  }

  export type PanierUpdateManyWithWhereWithoutUtilisateurInput = {
    where: PanierScalarWhereInput
    data: XOR<PanierUpdateManyMutationInput, PanierUncheckedUpdateManyWithoutUtilisateurInput>
  }

  export type PanierScalarWhereInput = {
    AND?: PanierScalarWhereInput | PanierScalarWhereInput[]
    OR?: PanierScalarWhereInput[]
    NOT?: PanierScalarWhereInput | PanierScalarWhereInput[]
    id?: IntFilter<"Panier"> | number
    utilisateurId?: IntFilter<"Panier"> | number
    createdAt?: DateTimeFilter<"Panier"> | Date | string
    updatedAt?: DateTimeFilter<"Panier"> | Date | string
  }

  export type ReservationUpsertWithWhereUniqueWithoutUtilisateurInput = {
    where: ReservationWhereUniqueInput
    update: XOR<ReservationUpdateWithoutUtilisateurInput, ReservationUncheckedUpdateWithoutUtilisateurInput>
    create: XOR<ReservationCreateWithoutUtilisateurInput, ReservationUncheckedCreateWithoutUtilisateurInput>
  }

  export type ReservationUpdateWithWhereUniqueWithoutUtilisateurInput = {
    where: ReservationWhereUniqueInput
    data: XOR<ReservationUpdateWithoutUtilisateurInput, ReservationUncheckedUpdateWithoutUtilisateurInput>
  }

  export type ReservationUpdateManyWithWhereWithoutUtilisateurInput = {
    where: ReservationScalarWhereInput
    data: XOR<ReservationUpdateManyMutationInput, ReservationUncheckedUpdateManyWithoutUtilisateurInput>
  }

  export type ReservationScalarWhereInput = {
    AND?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
    OR?: ReservationScalarWhereInput[]
    NOT?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
    id?: IntFilter<"Reservation"> | number
    dateLivraisonSouhaitee?: DateTimeFilter<"Reservation"> | Date | string
    adresseLivraison?: StringNullableFilter<"Reservation"> | string | null
    statut?: EnumStatutReservationFilter<"Reservation"> | $Enums.StatutReservation
    notes?: StringNullableFilter<"Reservation"> | string | null
    type_client?: EnumTypeClientFilter<"Reservation"> | $Enums.TypeClient
    clientId?: IntNullableFilter<"Reservation"> | number | null
    panierId?: IntFilter<"Reservation"> | number
    nom?: StringNullableFilter<"Reservation"> | string | null
    tel?: StringNullableFilter<"Reservation"> | string | null
    adresseId?: IntNullableFilter<"Reservation"> | number | null
    contactId?: IntNullableFilter<"Reservation"> | number | null
    enregistrerParId?: IntNullableFilter<"Reservation"> | number | null
    fournisseurId?: IntNullableFilter<"Reservation"> | number | null
    createdAt?: DateTimeFilter<"Reservation"> | Date | string
    updatedAt?: DateTimeFilter<"Reservation"> | Date | string
  }

  export type CommandeUpsertWithWhereUniqueWithoutClientInput = {
    where: CommandeWhereUniqueInput
    update: XOR<CommandeUpdateWithoutClientInput, CommandeUncheckedUpdateWithoutClientInput>
    create: XOR<CommandeCreateWithoutClientInput, CommandeUncheckedCreateWithoutClientInput>
  }

  export type CommandeUpdateWithWhereUniqueWithoutClientInput = {
    where: CommandeWhereUniqueInput
    data: XOR<CommandeUpdateWithoutClientInput, CommandeUncheckedUpdateWithoutClientInput>
  }

  export type CommandeUpdateManyWithWhereWithoutClientInput = {
    where: CommandeScalarWhereInput
    data: XOR<CommandeUpdateManyMutationInput, CommandeUncheckedUpdateManyWithoutClientInput>
  }

  export type CommandeScalarWhereInput = {
    AND?: CommandeScalarWhereInput | CommandeScalarWhereInput[]
    OR?: CommandeScalarWhereInput[]
    NOT?: CommandeScalarWhereInput | CommandeScalarWhereInput[]
    id?: IntFilter<"Commande"> | number
    panierId?: IntFilter<"Commande"> | number
    clientId?: IntNullableFilter<"Commande"> | number | null
    nom?: StringNullableFilter<"Commande"> | string | null
    tel?: StringNullableFilter<"Commande"> | string | null
    type_client?: EnumTypeClientFilter<"Commande"> | $Enums.TypeClient
    paiementId?: IntFilter<"Commande"> | number
    adresseId?: IntNullableFilter<"Commande"> | number | null
    contactId?: IntNullableFilter<"Commande"> | number | null
    fournisseurId?: IntNullableFilter<"Commande"> | number | null
    notes?: StringNullableFilter<"Commande"> | string | null
    dateLivraisonEffective?: DateTimeNullableFilter<"Commande"> | Date | string | null
    adresseLivraison?: StringNullableFilter<"Commande"> | string | null
    enregistrerParId?: IntNullableFilter<"Commande"> | number | null
    statut?: EnumStatutCommandeFilter<"Commande"> | $Enums.StatutCommande
    createdAt?: DateTimeFilter<"Commande"> | Date | string
    updatedAt?: DateTimeFilter<"Commande"> | Date | string
  }

  export type CaisseUpsertWithWhereUniqueWithoutUtilisateurInput = {
    where: CaisseWhereUniqueInput
    update: XOR<CaisseUpdateWithoutUtilisateurInput, CaisseUncheckedUpdateWithoutUtilisateurInput>
    create: XOR<CaisseCreateWithoutUtilisateurInput, CaisseUncheckedCreateWithoutUtilisateurInput>
  }

  export type CaisseUpdateWithWhereUniqueWithoutUtilisateurInput = {
    where: CaisseWhereUniqueInput
    data: XOR<CaisseUpdateWithoutUtilisateurInput, CaisseUncheckedUpdateWithoutUtilisateurInput>
  }

  export type CaisseUpdateManyWithWhereWithoutUtilisateurInput = {
    where: CaisseScalarWhereInput
    data: XOR<CaisseUpdateManyMutationInput, CaisseUncheckedUpdateManyWithoutUtilisateurInput>
  }

  export type CaisseScalarWhereInput = {
    AND?: CaisseScalarWhereInput | CaisseScalarWhereInput[]
    OR?: CaisseScalarWhereInput[]
    NOT?: CaisseScalarWhereInput | CaisseScalarWhereInput[]
    id?: IntFilter<"Caisse"> | number
    nom?: StringFilter<"Caisse"> | string
    description?: StringNullableFilter<"Caisse"> | string | null
    soldeInitial?: FloatFilter<"Caisse"> | number
    soldeActuel?: FloatFilter<"Caisse"> | number
    deviseId?: IntFilter<"Caisse"> | number
    creeParId?: IntFilter<"Caisse"> | number
    statut?: EnumStatutCaisseFilter<"Caisse"> | $Enums.StatutCaisse
    createdAt?: DateTimeFilter<"Caisse"> | Date | string
    updatedAt?: DateTimeFilter<"Caisse"> | Date | string
  }

  export type MouvementCaisseUpsertWithWhereUniqueWithoutUtilisateurInput = {
    where: MouvementCaisseWhereUniqueInput
    update: XOR<MouvementCaisseUpdateWithoutUtilisateurInput, MouvementCaisseUncheckedUpdateWithoutUtilisateurInput>
    create: XOR<MouvementCaisseCreateWithoutUtilisateurInput, MouvementCaisseUncheckedCreateWithoutUtilisateurInput>
  }

  export type MouvementCaisseUpdateWithWhereUniqueWithoutUtilisateurInput = {
    where: MouvementCaisseWhereUniqueInput
    data: XOR<MouvementCaisseUpdateWithoutUtilisateurInput, MouvementCaisseUncheckedUpdateWithoutUtilisateurInput>
  }

  export type MouvementCaisseUpdateManyWithWhereWithoutUtilisateurInput = {
    where: MouvementCaisseScalarWhereInput
    data: XOR<MouvementCaisseUpdateManyMutationInput, MouvementCaisseUncheckedUpdateManyWithoutUtilisateurInput>
  }

  export type MouvementCaisseScalarWhereInput = {
    AND?: MouvementCaisseScalarWhereInput | MouvementCaisseScalarWhereInput[]
    OR?: MouvementCaisseScalarWhereInput[]
    NOT?: MouvementCaisseScalarWhereInput | MouvementCaisseScalarWhereInput[]
    id?: IntFilter<"MouvementCaisse"> | number
    caisseId?: IntFilter<"MouvementCaisse"> | number
    type_mouvement?: EnumTypeMouvementCaisseFilter<"MouvementCaisse"> | $Enums.TypeMouvementCaisse
    categorie?: EnumCategorieMouvementFilter<"MouvementCaisse"> | $Enums.CategorieMouvement
    montant?: FloatFilter<"MouvementCaisse"> | number
    description?: StringNullableFilter<"MouvementCaisse"> | string | null
    enregistrerParId?: IntFilter<"MouvementCaisse"> | number
    referenceExterne?: StringNullableFilter<"MouvementCaisse"> | string | null
    createdAt?: DateTimeFilter<"MouvementCaisse"> | Date | string
    updatedAt?: DateTimeFilter<"MouvementCaisse"> | Date | string
  }

  export type ClotureCaisseUpsertWithWhereUniqueWithoutUtilisateurClotureInput = {
    where: ClotureCaisseWhereUniqueInput
    update: XOR<ClotureCaisseUpdateWithoutUtilisateurClotureInput, ClotureCaisseUncheckedUpdateWithoutUtilisateurClotureInput>
    create: XOR<ClotureCaisseCreateWithoutUtilisateurClotureInput, ClotureCaisseUncheckedCreateWithoutUtilisateurClotureInput>
  }

  export type ClotureCaisseUpdateWithWhereUniqueWithoutUtilisateurClotureInput = {
    where: ClotureCaisseWhereUniqueInput
    data: XOR<ClotureCaisseUpdateWithoutUtilisateurClotureInput, ClotureCaisseUncheckedUpdateWithoutUtilisateurClotureInput>
  }

  export type ClotureCaisseUpdateManyWithWhereWithoutUtilisateurClotureInput = {
    where: ClotureCaisseScalarWhereInput
    data: XOR<ClotureCaisseUpdateManyMutationInput, ClotureCaisseUncheckedUpdateManyWithoutUtilisateurClotureInput>
  }

  export type ClotureCaisseScalarWhereInput = {
    AND?: ClotureCaisseScalarWhereInput | ClotureCaisseScalarWhereInput[]
    OR?: ClotureCaisseScalarWhereInput[]
    NOT?: ClotureCaisseScalarWhereInput | ClotureCaisseScalarWhereInput[]
    id?: IntFilter<"ClotureCaisse"> | number
    caisseId?: IntFilter<"ClotureCaisse"> | number
    dateCloture?: DateTimeFilter<"ClotureCaisse"> | Date | string
    utilisateurClotureId?: IntFilter<"ClotureCaisse"> | number
    notes?: StringNullableFilter<"ClotureCaisse"> | string | null
    createdAt?: DateTimeFilter<"ClotureCaisse"> | Date | string
    updatedAt?: DateTimeFilter<"ClotureCaisse"> | Date | string
  }

  export type UtilisateurCreateWithoutAdresseInput = {
    email: string
    nom: string
    postnom: string
    nom_complet?: string | null
    sexe?: $Enums.Sexe | null
    role?: $Enums.Role
    poste?: $Enums.Poste | null
    picture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Contact?: ContactCreateNestedManyWithoutUtilisateurInput
    Produit?: ProduitCreateNestedManyWithoutUtilisateurInput
    Vente?: VenteCreateNestedManyWithoutUtilisateurInput
    Achat?: AchatCreateNestedManyWithoutUtilisateurInput
    Teneur?: TeneurCreateNestedManyWithoutUtilisateurInput
    Devise?: DeviseCreateNestedManyWithoutUtilisateurInput
    Panier?: PanierCreateNestedManyWithoutUtilisateurInput
    Reservation?: ReservationCreateNestedManyWithoutUtilisateurInput
    Commande?: CommandeCreateNestedManyWithoutClientInput
    Caisse?: CaisseCreateNestedManyWithoutUtilisateurInput
    MouvementCaisse?: MouvementCaisseCreateNestedManyWithoutUtilisateurInput
    ClotureCaisse?: ClotureCaisseCreateNestedManyWithoutUtilisateurClotureInput
  }

  export type UtilisateurUncheckedCreateWithoutAdresseInput = {
    id?: number
    email: string
    nom: string
    postnom: string
    nom_complet?: string | null
    sexe?: $Enums.Sexe | null
    role?: $Enums.Role
    poste?: $Enums.Poste | null
    picture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Contact?: ContactUncheckedCreateNestedManyWithoutUtilisateurInput
    Produit?: ProduitUncheckedCreateNestedManyWithoutUtilisateurInput
    Vente?: VenteUncheckedCreateNestedManyWithoutUtilisateurInput
    Achat?: AchatUncheckedCreateNestedManyWithoutUtilisateurInput
    Teneur?: TeneurUncheckedCreateNestedManyWithoutUtilisateurInput
    Devise?: DeviseUncheckedCreateNestedManyWithoutUtilisateurInput
    Panier?: PanierUncheckedCreateNestedManyWithoutUtilisateurInput
    Reservation?: ReservationUncheckedCreateNestedManyWithoutUtilisateurInput
    Commande?: CommandeUncheckedCreateNestedManyWithoutClientInput
    Caisse?: CaisseUncheckedCreateNestedManyWithoutUtilisateurInput
    MouvementCaisse?: MouvementCaisseUncheckedCreateNestedManyWithoutUtilisateurInput
    ClotureCaisse?: ClotureCaisseUncheckedCreateNestedManyWithoutUtilisateurClotureInput
  }

  export type UtilisateurCreateOrConnectWithoutAdresseInput = {
    where: UtilisateurWhereUniqueInput
    create: XOR<UtilisateurCreateWithoutAdresseInput, UtilisateurUncheckedCreateWithoutAdresseInput>
  }

  export type FournisseurCreateWithoutAdresseInput = {
    nom: string
    email: string
    code_postal?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Vente?: VenteCreateNestedManyWithoutFournisseurInput
    Achat?: AchatCreateNestedManyWithoutFournisseurInput
    Contact?: ContactCreateNestedManyWithoutFournisseurInput
    Reservation?: ReservationCreateNestedManyWithoutFournisseurInput
    Commande?: CommandeCreateNestedManyWithoutFournisseurInput
  }

  export type FournisseurUncheckedCreateWithoutAdresseInput = {
    id?: number
    nom: string
    email: string
    code_postal?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Vente?: VenteUncheckedCreateNestedManyWithoutFournisseurInput
    Achat?: AchatUncheckedCreateNestedManyWithoutFournisseurInput
    Contact?: ContactUncheckedCreateNestedManyWithoutFournisseurInput
    Reservation?: ReservationUncheckedCreateNestedManyWithoutFournisseurInput
    Commande?: CommandeUncheckedCreateNestedManyWithoutFournisseurInput
  }

  export type FournisseurCreateOrConnectWithoutAdresseInput = {
    where: FournisseurWhereUniqueInput
    create: XOR<FournisseurCreateWithoutAdresseInput, FournisseurUncheckedCreateWithoutAdresseInput>
  }

  export type ReservationCreateWithoutAdresseInput = {
    dateLivraisonSouhaitee: Date | string
    adresseLivraison?: string | null
    statut?: $Enums.StatutReservation
    notes?: string | null
    type_client?: $Enums.TypeClient
    nom?: string | null
    tel?: string | null
    enregistrerParId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    panier: PanierCreateNestedOneWithoutReservationInput
    utilisateur?: UtilisateurCreateNestedOneWithoutReservationInput
    fournisseur?: FournisseurCreateNestedOneWithoutReservationInput
    contact?: ContactCreateNestedOneWithoutReservationInput
  }

  export type ReservationUncheckedCreateWithoutAdresseInput = {
    id?: number
    dateLivraisonSouhaitee: Date | string
    adresseLivraison?: string | null
    statut?: $Enums.StatutReservation
    notes?: string | null
    type_client?: $Enums.TypeClient
    clientId?: number | null
    panierId: number
    nom?: string | null
    tel?: string | null
    contactId?: number | null
    enregistrerParId?: number | null
    fournisseurId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReservationCreateOrConnectWithoutAdresseInput = {
    where: ReservationWhereUniqueInput
    create: XOR<ReservationCreateWithoutAdresseInput, ReservationUncheckedCreateWithoutAdresseInput>
  }

  export type ReservationCreateManyAdresseInputEnvelope = {
    data: ReservationCreateManyAdresseInput | ReservationCreateManyAdresseInput[]
    skipDuplicates?: boolean
  }

  export type CommandeCreateWithoutAdresseInput = {
    nom?: string | null
    tel?: string | null
    type_client?: $Enums.TypeClient
    notes?: string | null
    dateLivraisonEffective?: Date | string | null
    adresseLivraison?: string | null
    enregistrerParId?: number | null
    statut?: $Enums.StatutCommande
    createdAt?: Date | string
    updatedAt?: Date | string
    panier: PanierCreateNestedOneWithoutCommandeInput
    client?: UtilisateurCreateNestedOneWithoutCommandeInput
    paiement: PaiementCreateNestedOneWithoutCommandeInput
    fournisseur?: FournisseurCreateNestedOneWithoutCommandeInput
    contact?: ContactCreateNestedOneWithoutCommandeInput
  }

  export type CommandeUncheckedCreateWithoutAdresseInput = {
    id?: number
    panierId: number
    clientId?: number | null
    nom?: string | null
    tel?: string | null
    type_client?: $Enums.TypeClient
    paiementId: number
    contactId?: number | null
    fournisseurId?: number | null
    notes?: string | null
    dateLivraisonEffective?: Date | string | null
    adresseLivraison?: string | null
    enregistrerParId?: number | null
    statut?: $Enums.StatutCommande
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommandeCreateOrConnectWithoutAdresseInput = {
    where: CommandeWhereUniqueInput
    create: XOR<CommandeCreateWithoutAdresseInput, CommandeUncheckedCreateWithoutAdresseInput>
  }

  export type CommandeCreateManyAdresseInputEnvelope = {
    data: CommandeCreateManyAdresseInput | CommandeCreateManyAdresseInput[]
    skipDuplicates?: boolean
  }

  export type UtilisateurUpsertWithoutAdresseInput = {
    update: XOR<UtilisateurUpdateWithoutAdresseInput, UtilisateurUncheckedUpdateWithoutAdresseInput>
    create: XOR<UtilisateurCreateWithoutAdresseInput, UtilisateurUncheckedCreateWithoutAdresseInput>
    where?: UtilisateurWhereInput
  }

  export type UtilisateurUpdateToOneWithWhereWithoutAdresseInput = {
    where?: UtilisateurWhereInput
    data: XOR<UtilisateurUpdateWithoutAdresseInput, UtilisateurUncheckedUpdateWithoutAdresseInput>
  }

  export type UtilisateurUpdateWithoutAdresseInput = {
    email?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    postnom?: StringFieldUpdateOperationsInput | string
    nom_complet?: NullableStringFieldUpdateOperationsInput | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    poste?: NullableEnumPosteFieldUpdateOperationsInput | $Enums.Poste | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Contact?: ContactUpdateManyWithoutUtilisateurNestedInput
    Produit?: ProduitUpdateManyWithoutUtilisateurNestedInput
    Vente?: VenteUpdateManyWithoutUtilisateurNestedInput
    Achat?: AchatUpdateManyWithoutUtilisateurNestedInput
    Teneur?: TeneurUpdateManyWithoutUtilisateurNestedInput
    Devise?: DeviseUpdateManyWithoutUtilisateurNestedInput
    Panier?: PanierUpdateManyWithoutUtilisateurNestedInput
    Reservation?: ReservationUpdateManyWithoutUtilisateurNestedInput
    Commande?: CommandeUpdateManyWithoutClientNestedInput
    Caisse?: CaisseUpdateManyWithoutUtilisateurNestedInput
    MouvementCaisse?: MouvementCaisseUpdateManyWithoutUtilisateurNestedInput
    ClotureCaisse?: ClotureCaisseUpdateManyWithoutUtilisateurClotureNestedInput
  }

  export type UtilisateurUncheckedUpdateWithoutAdresseInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    postnom?: StringFieldUpdateOperationsInput | string
    nom_complet?: NullableStringFieldUpdateOperationsInput | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    poste?: NullableEnumPosteFieldUpdateOperationsInput | $Enums.Poste | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Contact?: ContactUncheckedUpdateManyWithoutUtilisateurNestedInput
    Produit?: ProduitUncheckedUpdateManyWithoutUtilisateurNestedInput
    Vente?: VenteUncheckedUpdateManyWithoutUtilisateurNestedInput
    Achat?: AchatUncheckedUpdateManyWithoutUtilisateurNestedInput
    Teneur?: TeneurUncheckedUpdateManyWithoutUtilisateurNestedInput
    Devise?: DeviseUncheckedUpdateManyWithoutUtilisateurNestedInput
    Panier?: PanierUncheckedUpdateManyWithoutUtilisateurNestedInput
    Reservation?: ReservationUncheckedUpdateManyWithoutUtilisateurNestedInput
    Commande?: CommandeUncheckedUpdateManyWithoutClientNestedInput
    Caisse?: CaisseUncheckedUpdateManyWithoutUtilisateurNestedInput
    MouvementCaisse?: MouvementCaisseUncheckedUpdateManyWithoutUtilisateurNestedInput
    ClotureCaisse?: ClotureCaisseUncheckedUpdateManyWithoutUtilisateurClotureNestedInput
  }

  export type FournisseurUpsertWithoutAdresseInput = {
    update: XOR<FournisseurUpdateWithoutAdresseInput, FournisseurUncheckedUpdateWithoutAdresseInput>
    create: XOR<FournisseurCreateWithoutAdresseInput, FournisseurUncheckedCreateWithoutAdresseInput>
    where?: FournisseurWhereInput
  }

  export type FournisseurUpdateToOneWithWhereWithoutAdresseInput = {
    where?: FournisseurWhereInput
    data: XOR<FournisseurUpdateWithoutAdresseInput, FournisseurUncheckedUpdateWithoutAdresseInput>
  }

  export type FournisseurUpdateWithoutAdresseInput = {
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    code_postal?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Vente?: VenteUpdateManyWithoutFournisseurNestedInput
    Achat?: AchatUpdateManyWithoutFournisseurNestedInput
    Contact?: ContactUpdateManyWithoutFournisseurNestedInput
    Reservation?: ReservationUpdateManyWithoutFournisseurNestedInput
    Commande?: CommandeUpdateManyWithoutFournisseurNestedInput
  }

  export type FournisseurUncheckedUpdateWithoutAdresseInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    code_postal?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Vente?: VenteUncheckedUpdateManyWithoutFournisseurNestedInput
    Achat?: AchatUncheckedUpdateManyWithoutFournisseurNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutFournisseurNestedInput
    Reservation?: ReservationUncheckedUpdateManyWithoutFournisseurNestedInput
    Commande?: CommandeUncheckedUpdateManyWithoutFournisseurNestedInput
  }

  export type ReservationUpsertWithWhereUniqueWithoutAdresseInput = {
    where: ReservationWhereUniqueInput
    update: XOR<ReservationUpdateWithoutAdresseInput, ReservationUncheckedUpdateWithoutAdresseInput>
    create: XOR<ReservationCreateWithoutAdresseInput, ReservationUncheckedCreateWithoutAdresseInput>
  }

  export type ReservationUpdateWithWhereUniqueWithoutAdresseInput = {
    where: ReservationWhereUniqueInput
    data: XOR<ReservationUpdateWithoutAdresseInput, ReservationUncheckedUpdateWithoutAdresseInput>
  }

  export type ReservationUpdateManyWithWhereWithoutAdresseInput = {
    where: ReservationScalarWhereInput
    data: XOR<ReservationUpdateManyMutationInput, ReservationUncheckedUpdateManyWithoutAdresseInput>
  }

  export type CommandeUpsertWithWhereUniqueWithoutAdresseInput = {
    where: CommandeWhereUniqueInput
    update: XOR<CommandeUpdateWithoutAdresseInput, CommandeUncheckedUpdateWithoutAdresseInput>
    create: XOR<CommandeCreateWithoutAdresseInput, CommandeUncheckedCreateWithoutAdresseInput>
  }

  export type CommandeUpdateWithWhereUniqueWithoutAdresseInput = {
    where: CommandeWhereUniqueInput
    data: XOR<CommandeUpdateWithoutAdresseInput, CommandeUncheckedUpdateWithoutAdresseInput>
  }

  export type CommandeUpdateManyWithWhereWithoutAdresseInput = {
    where: CommandeScalarWhereInput
    data: XOR<CommandeUpdateManyMutationInput, CommandeUncheckedUpdateManyWithoutAdresseInput>
  }

  export type UtilisateurCreateWithoutContactInput = {
    email: string
    nom: string
    postnom: string
    nom_complet?: string | null
    sexe?: $Enums.Sexe | null
    role?: $Enums.Role
    poste?: $Enums.Poste | null
    picture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Adresse?: AdresseCreateNestedManyWithoutUtilisateurInput
    Produit?: ProduitCreateNestedManyWithoutUtilisateurInput
    Vente?: VenteCreateNestedManyWithoutUtilisateurInput
    Achat?: AchatCreateNestedManyWithoutUtilisateurInput
    Teneur?: TeneurCreateNestedManyWithoutUtilisateurInput
    Devise?: DeviseCreateNestedManyWithoutUtilisateurInput
    Panier?: PanierCreateNestedManyWithoutUtilisateurInput
    Reservation?: ReservationCreateNestedManyWithoutUtilisateurInput
    Commande?: CommandeCreateNestedManyWithoutClientInput
    Caisse?: CaisseCreateNestedManyWithoutUtilisateurInput
    MouvementCaisse?: MouvementCaisseCreateNestedManyWithoutUtilisateurInput
    ClotureCaisse?: ClotureCaisseCreateNestedManyWithoutUtilisateurClotureInput
  }

  export type UtilisateurUncheckedCreateWithoutContactInput = {
    id?: number
    email: string
    nom: string
    postnom: string
    nom_complet?: string | null
    sexe?: $Enums.Sexe | null
    role?: $Enums.Role
    poste?: $Enums.Poste | null
    picture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Adresse?: AdresseUncheckedCreateNestedManyWithoutUtilisateurInput
    Produit?: ProduitUncheckedCreateNestedManyWithoutUtilisateurInput
    Vente?: VenteUncheckedCreateNestedManyWithoutUtilisateurInput
    Achat?: AchatUncheckedCreateNestedManyWithoutUtilisateurInput
    Teneur?: TeneurUncheckedCreateNestedManyWithoutUtilisateurInput
    Devise?: DeviseUncheckedCreateNestedManyWithoutUtilisateurInput
    Panier?: PanierUncheckedCreateNestedManyWithoutUtilisateurInput
    Reservation?: ReservationUncheckedCreateNestedManyWithoutUtilisateurInput
    Commande?: CommandeUncheckedCreateNestedManyWithoutClientInput
    Caisse?: CaisseUncheckedCreateNestedManyWithoutUtilisateurInput
    MouvementCaisse?: MouvementCaisseUncheckedCreateNestedManyWithoutUtilisateurInput
    ClotureCaisse?: ClotureCaisseUncheckedCreateNestedManyWithoutUtilisateurClotureInput
  }

  export type UtilisateurCreateOrConnectWithoutContactInput = {
    where: UtilisateurWhereUniqueInput
    create: XOR<UtilisateurCreateWithoutContactInput, UtilisateurUncheckedCreateWithoutContactInput>
  }

  export type FournisseurCreateWithoutContactInput = {
    nom: string
    email: string
    code_postal?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Vente?: VenteCreateNestedManyWithoutFournisseurInput
    Achat?: AchatCreateNestedManyWithoutFournisseurInput
    Adresse?: AdresseCreateNestedManyWithoutFournisseurInput
    Reservation?: ReservationCreateNestedManyWithoutFournisseurInput
    Commande?: CommandeCreateNestedManyWithoutFournisseurInput
  }

  export type FournisseurUncheckedCreateWithoutContactInput = {
    id?: number
    nom: string
    email: string
    code_postal?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Vente?: VenteUncheckedCreateNestedManyWithoutFournisseurInput
    Achat?: AchatUncheckedCreateNestedManyWithoutFournisseurInput
    Adresse?: AdresseUncheckedCreateNestedManyWithoutFournisseurInput
    Reservation?: ReservationUncheckedCreateNestedManyWithoutFournisseurInput
    Commande?: CommandeUncheckedCreateNestedManyWithoutFournisseurInput
  }

  export type FournisseurCreateOrConnectWithoutContactInput = {
    where: FournisseurWhereUniqueInput
    create: XOR<FournisseurCreateWithoutContactInput, FournisseurUncheckedCreateWithoutContactInput>
  }

  export type ReservationCreateWithoutContactInput = {
    dateLivraisonSouhaitee: Date | string
    adresseLivraison?: string | null
    statut?: $Enums.StatutReservation
    notes?: string | null
    type_client?: $Enums.TypeClient
    nom?: string | null
    tel?: string | null
    enregistrerParId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    panier: PanierCreateNestedOneWithoutReservationInput
    utilisateur?: UtilisateurCreateNestedOneWithoutReservationInput
    fournisseur?: FournisseurCreateNestedOneWithoutReservationInput
    adresse?: AdresseCreateNestedOneWithoutReservationInput
  }

  export type ReservationUncheckedCreateWithoutContactInput = {
    id?: number
    dateLivraisonSouhaitee: Date | string
    adresseLivraison?: string | null
    statut?: $Enums.StatutReservation
    notes?: string | null
    type_client?: $Enums.TypeClient
    clientId?: number | null
    panierId: number
    nom?: string | null
    tel?: string | null
    adresseId?: number | null
    enregistrerParId?: number | null
    fournisseurId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReservationCreateOrConnectWithoutContactInput = {
    where: ReservationWhereUniqueInput
    create: XOR<ReservationCreateWithoutContactInput, ReservationUncheckedCreateWithoutContactInput>
  }

  export type ReservationCreateManyContactInputEnvelope = {
    data: ReservationCreateManyContactInput | ReservationCreateManyContactInput[]
    skipDuplicates?: boolean
  }

  export type CommandeCreateWithoutContactInput = {
    nom?: string | null
    tel?: string | null
    type_client?: $Enums.TypeClient
    notes?: string | null
    dateLivraisonEffective?: Date | string | null
    adresseLivraison?: string | null
    enregistrerParId?: number | null
    statut?: $Enums.StatutCommande
    createdAt?: Date | string
    updatedAt?: Date | string
    panier: PanierCreateNestedOneWithoutCommandeInput
    client?: UtilisateurCreateNestedOneWithoutCommandeInput
    paiement: PaiementCreateNestedOneWithoutCommandeInput
    fournisseur?: FournisseurCreateNestedOneWithoutCommandeInput
    adresse?: AdresseCreateNestedOneWithoutCommandeInput
  }

  export type CommandeUncheckedCreateWithoutContactInput = {
    id?: number
    panierId: number
    clientId?: number | null
    nom?: string | null
    tel?: string | null
    type_client?: $Enums.TypeClient
    paiementId: number
    adresseId?: number | null
    fournisseurId?: number | null
    notes?: string | null
    dateLivraisonEffective?: Date | string | null
    adresseLivraison?: string | null
    enregistrerParId?: number | null
    statut?: $Enums.StatutCommande
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommandeCreateOrConnectWithoutContactInput = {
    where: CommandeWhereUniqueInput
    create: XOR<CommandeCreateWithoutContactInput, CommandeUncheckedCreateWithoutContactInput>
  }

  export type CommandeCreateManyContactInputEnvelope = {
    data: CommandeCreateManyContactInput | CommandeCreateManyContactInput[]
    skipDuplicates?: boolean
  }

  export type UtilisateurUpsertWithoutContactInput = {
    update: XOR<UtilisateurUpdateWithoutContactInput, UtilisateurUncheckedUpdateWithoutContactInput>
    create: XOR<UtilisateurCreateWithoutContactInput, UtilisateurUncheckedCreateWithoutContactInput>
    where?: UtilisateurWhereInput
  }

  export type UtilisateurUpdateToOneWithWhereWithoutContactInput = {
    where?: UtilisateurWhereInput
    data: XOR<UtilisateurUpdateWithoutContactInput, UtilisateurUncheckedUpdateWithoutContactInput>
  }

  export type UtilisateurUpdateWithoutContactInput = {
    email?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    postnom?: StringFieldUpdateOperationsInput | string
    nom_complet?: NullableStringFieldUpdateOperationsInput | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    poste?: NullableEnumPosteFieldUpdateOperationsInput | $Enums.Poste | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Adresse?: AdresseUpdateManyWithoutUtilisateurNestedInput
    Produit?: ProduitUpdateManyWithoutUtilisateurNestedInput
    Vente?: VenteUpdateManyWithoutUtilisateurNestedInput
    Achat?: AchatUpdateManyWithoutUtilisateurNestedInput
    Teneur?: TeneurUpdateManyWithoutUtilisateurNestedInput
    Devise?: DeviseUpdateManyWithoutUtilisateurNestedInput
    Panier?: PanierUpdateManyWithoutUtilisateurNestedInput
    Reservation?: ReservationUpdateManyWithoutUtilisateurNestedInput
    Commande?: CommandeUpdateManyWithoutClientNestedInput
    Caisse?: CaisseUpdateManyWithoutUtilisateurNestedInput
    MouvementCaisse?: MouvementCaisseUpdateManyWithoutUtilisateurNestedInput
    ClotureCaisse?: ClotureCaisseUpdateManyWithoutUtilisateurClotureNestedInput
  }

  export type UtilisateurUncheckedUpdateWithoutContactInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    postnom?: StringFieldUpdateOperationsInput | string
    nom_complet?: NullableStringFieldUpdateOperationsInput | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    poste?: NullableEnumPosteFieldUpdateOperationsInput | $Enums.Poste | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Adresse?: AdresseUncheckedUpdateManyWithoutUtilisateurNestedInput
    Produit?: ProduitUncheckedUpdateManyWithoutUtilisateurNestedInput
    Vente?: VenteUncheckedUpdateManyWithoutUtilisateurNestedInput
    Achat?: AchatUncheckedUpdateManyWithoutUtilisateurNestedInput
    Teneur?: TeneurUncheckedUpdateManyWithoutUtilisateurNestedInput
    Devise?: DeviseUncheckedUpdateManyWithoutUtilisateurNestedInput
    Panier?: PanierUncheckedUpdateManyWithoutUtilisateurNestedInput
    Reservation?: ReservationUncheckedUpdateManyWithoutUtilisateurNestedInput
    Commande?: CommandeUncheckedUpdateManyWithoutClientNestedInput
    Caisse?: CaisseUncheckedUpdateManyWithoutUtilisateurNestedInput
    MouvementCaisse?: MouvementCaisseUncheckedUpdateManyWithoutUtilisateurNestedInput
    ClotureCaisse?: ClotureCaisseUncheckedUpdateManyWithoutUtilisateurClotureNestedInput
  }

  export type FournisseurUpsertWithoutContactInput = {
    update: XOR<FournisseurUpdateWithoutContactInput, FournisseurUncheckedUpdateWithoutContactInput>
    create: XOR<FournisseurCreateWithoutContactInput, FournisseurUncheckedCreateWithoutContactInput>
    where?: FournisseurWhereInput
  }

  export type FournisseurUpdateToOneWithWhereWithoutContactInput = {
    where?: FournisseurWhereInput
    data: XOR<FournisseurUpdateWithoutContactInput, FournisseurUncheckedUpdateWithoutContactInput>
  }

  export type FournisseurUpdateWithoutContactInput = {
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    code_postal?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Vente?: VenteUpdateManyWithoutFournisseurNestedInput
    Achat?: AchatUpdateManyWithoutFournisseurNestedInput
    Adresse?: AdresseUpdateManyWithoutFournisseurNestedInput
    Reservation?: ReservationUpdateManyWithoutFournisseurNestedInput
    Commande?: CommandeUpdateManyWithoutFournisseurNestedInput
  }

  export type FournisseurUncheckedUpdateWithoutContactInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    code_postal?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Vente?: VenteUncheckedUpdateManyWithoutFournisseurNestedInput
    Achat?: AchatUncheckedUpdateManyWithoutFournisseurNestedInput
    Adresse?: AdresseUncheckedUpdateManyWithoutFournisseurNestedInput
    Reservation?: ReservationUncheckedUpdateManyWithoutFournisseurNestedInput
    Commande?: CommandeUncheckedUpdateManyWithoutFournisseurNestedInput
  }

  export type ReservationUpsertWithWhereUniqueWithoutContactInput = {
    where: ReservationWhereUniqueInput
    update: XOR<ReservationUpdateWithoutContactInput, ReservationUncheckedUpdateWithoutContactInput>
    create: XOR<ReservationCreateWithoutContactInput, ReservationUncheckedCreateWithoutContactInput>
  }

  export type ReservationUpdateWithWhereUniqueWithoutContactInput = {
    where: ReservationWhereUniqueInput
    data: XOR<ReservationUpdateWithoutContactInput, ReservationUncheckedUpdateWithoutContactInput>
  }

  export type ReservationUpdateManyWithWhereWithoutContactInput = {
    where: ReservationScalarWhereInput
    data: XOR<ReservationUpdateManyMutationInput, ReservationUncheckedUpdateManyWithoutContactInput>
  }

  export type CommandeUpsertWithWhereUniqueWithoutContactInput = {
    where: CommandeWhereUniqueInput
    update: XOR<CommandeUpdateWithoutContactInput, CommandeUncheckedUpdateWithoutContactInput>
    create: XOR<CommandeCreateWithoutContactInput, CommandeUncheckedCreateWithoutContactInput>
  }

  export type CommandeUpdateWithWhereUniqueWithoutContactInput = {
    where: CommandeWhereUniqueInput
    data: XOR<CommandeUpdateWithoutContactInput, CommandeUncheckedUpdateWithoutContactInput>
  }

  export type CommandeUpdateManyWithWhereWithoutContactInput = {
    where: CommandeScalarWhereInput
    data: XOR<CommandeUpdateManyMutationInput, CommandeUncheckedUpdateManyWithoutContactInput>
  }

  export type VenteCreateWithoutFournisseurInput = {
    statut?: $Enums.StatutVente
    total_ttc: number
    total_ht: number
    type_acheteur: $Enums.TypeClient
    clientId?: number | null
    agentId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    paiement?: PaiementCreateNestedOneWithoutVenteInput
    panier: PanierCreateNestedOneWithoutVenteInput
    utilisateur: UtilisateurCreateNestedOneWithoutVenteInput
  }

  export type VenteUncheckedCreateWithoutFournisseurInput = {
    id?: number
    statut?: $Enums.StatutVente
    total_ttc: number
    total_ht: number
    type_acheteur: $Enums.TypeClient
    clientId?: number | null
    enregistrerParId: number
    agentId?: number | null
    paiementId: number
    panierId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VenteCreateOrConnectWithoutFournisseurInput = {
    where: VenteWhereUniqueInput
    create: XOR<VenteCreateWithoutFournisseurInput, VenteUncheckedCreateWithoutFournisseurInput>
  }

  export type VenteCreateManyFournisseurInputEnvelope = {
    data: VenteCreateManyFournisseurInput | VenteCreateManyFournisseurInput[]
    skipDuplicates?: boolean
  }

  export type AchatCreateWithoutFournisseurInput = {
    statut?: $Enums.StatutAchat
    createdAt?: Date | string
    updatedAt?: Date | string
    panier: PanierCreateNestedOneWithoutAchatInput
    utilisateur: UtilisateurCreateNestedOneWithoutAchatInput
    paiement: PaiementCreateNestedOneWithoutAchatInput
  }

  export type AchatUncheckedCreateWithoutFournisseurInput = {
    id?: number
    statut?: $Enums.StatutAchat
    panierId: number
    enregistrerParId: number
    paiementId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AchatCreateOrConnectWithoutFournisseurInput = {
    where: AchatWhereUniqueInput
    create: XOR<AchatCreateWithoutFournisseurInput, AchatUncheckedCreateWithoutFournisseurInput>
  }

  export type AchatCreateManyFournisseurInputEnvelope = {
    data: AchatCreateManyFournisseurInput | AchatCreateManyFournisseurInput[]
    skipDuplicates?: boolean
  }

  export type AdresseCreateWithoutFournisseurInput = {
    ville: string
    commune: string
    adresse: string
    createdAt?: Date | string
    updatedAt?: Date | string
    utilisateur?: UtilisateurCreateNestedOneWithoutAdresseInput
    Reservation?: ReservationCreateNestedManyWithoutAdresseInput
    Commande?: CommandeCreateNestedManyWithoutAdresseInput
  }

  export type AdresseUncheckedCreateWithoutFournisseurInput = {
    id?: number
    ville: string
    commune: string
    adresse: string
    utilisateurId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Reservation?: ReservationUncheckedCreateNestedManyWithoutAdresseInput
    Commande?: CommandeUncheckedCreateNestedManyWithoutAdresseInput
  }

  export type AdresseCreateOrConnectWithoutFournisseurInput = {
    where: AdresseWhereUniqueInput
    create: XOR<AdresseCreateWithoutFournisseurInput, AdresseUncheckedCreateWithoutFournisseurInput>
  }

  export type AdresseCreateManyFournisseurInputEnvelope = {
    data: AdresseCreateManyFournisseurInput | AdresseCreateManyFournisseurInput[]
    skipDuplicates?: boolean
  }

  export type ContactCreateWithoutFournisseurInput = {
    tel: string
    createdAt?: Date | string
    updatedAt?: Date | string
    utilisateur?: UtilisateurCreateNestedOneWithoutContactInput
    Reservation?: ReservationCreateNestedManyWithoutContactInput
    Commande?: CommandeCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutFournisseurInput = {
    id?: number
    tel: string
    utilisateurId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Reservation?: ReservationUncheckedCreateNestedManyWithoutContactInput
    Commande?: CommandeUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutFournisseurInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutFournisseurInput, ContactUncheckedCreateWithoutFournisseurInput>
  }

  export type ContactCreateManyFournisseurInputEnvelope = {
    data: ContactCreateManyFournisseurInput | ContactCreateManyFournisseurInput[]
    skipDuplicates?: boolean
  }

  export type ReservationCreateWithoutFournisseurInput = {
    dateLivraisonSouhaitee: Date | string
    adresseLivraison?: string | null
    statut?: $Enums.StatutReservation
    notes?: string | null
    type_client?: $Enums.TypeClient
    nom?: string | null
    tel?: string | null
    enregistrerParId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    panier: PanierCreateNestedOneWithoutReservationInput
    utilisateur?: UtilisateurCreateNestedOneWithoutReservationInput
    adresse?: AdresseCreateNestedOneWithoutReservationInput
    contact?: ContactCreateNestedOneWithoutReservationInput
  }

  export type ReservationUncheckedCreateWithoutFournisseurInput = {
    id?: number
    dateLivraisonSouhaitee: Date | string
    adresseLivraison?: string | null
    statut?: $Enums.StatutReservation
    notes?: string | null
    type_client?: $Enums.TypeClient
    clientId?: number | null
    panierId: number
    nom?: string | null
    tel?: string | null
    adresseId?: number | null
    contactId?: number | null
    enregistrerParId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReservationCreateOrConnectWithoutFournisseurInput = {
    where: ReservationWhereUniqueInput
    create: XOR<ReservationCreateWithoutFournisseurInput, ReservationUncheckedCreateWithoutFournisseurInput>
  }

  export type ReservationCreateManyFournisseurInputEnvelope = {
    data: ReservationCreateManyFournisseurInput | ReservationCreateManyFournisseurInput[]
    skipDuplicates?: boolean
  }

  export type CommandeCreateWithoutFournisseurInput = {
    nom?: string | null
    tel?: string | null
    type_client?: $Enums.TypeClient
    notes?: string | null
    dateLivraisonEffective?: Date | string | null
    adresseLivraison?: string | null
    enregistrerParId?: number | null
    statut?: $Enums.StatutCommande
    createdAt?: Date | string
    updatedAt?: Date | string
    panier: PanierCreateNestedOneWithoutCommandeInput
    client?: UtilisateurCreateNestedOneWithoutCommandeInput
    paiement: PaiementCreateNestedOneWithoutCommandeInput
    adresse?: AdresseCreateNestedOneWithoutCommandeInput
    contact?: ContactCreateNestedOneWithoutCommandeInput
  }

  export type CommandeUncheckedCreateWithoutFournisseurInput = {
    id?: number
    panierId: number
    clientId?: number | null
    nom?: string | null
    tel?: string | null
    type_client?: $Enums.TypeClient
    paiementId: number
    adresseId?: number | null
    contactId?: number | null
    notes?: string | null
    dateLivraisonEffective?: Date | string | null
    adresseLivraison?: string | null
    enregistrerParId?: number | null
    statut?: $Enums.StatutCommande
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommandeCreateOrConnectWithoutFournisseurInput = {
    where: CommandeWhereUniqueInput
    create: XOR<CommandeCreateWithoutFournisseurInput, CommandeUncheckedCreateWithoutFournisseurInput>
  }

  export type CommandeCreateManyFournisseurInputEnvelope = {
    data: CommandeCreateManyFournisseurInput | CommandeCreateManyFournisseurInput[]
    skipDuplicates?: boolean
  }

  export type VenteUpsertWithWhereUniqueWithoutFournisseurInput = {
    where: VenteWhereUniqueInput
    update: XOR<VenteUpdateWithoutFournisseurInput, VenteUncheckedUpdateWithoutFournisseurInput>
    create: XOR<VenteCreateWithoutFournisseurInput, VenteUncheckedCreateWithoutFournisseurInput>
  }

  export type VenteUpdateWithWhereUniqueWithoutFournisseurInput = {
    where: VenteWhereUniqueInput
    data: XOR<VenteUpdateWithoutFournisseurInput, VenteUncheckedUpdateWithoutFournisseurInput>
  }

  export type VenteUpdateManyWithWhereWithoutFournisseurInput = {
    where: VenteScalarWhereInput
    data: XOR<VenteUpdateManyMutationInput, VenteUncheckedUpdateManyWithoutFournisseurInput>
  }

  export type AchatUpsertWithWhereUniqueWithoutFournisseurInput = {
    where: AchatWhereUniqueInput
    update: XOR<AchatUpdateWithoutFournisseurInput, AchatUncheckedUpdateWithoutFournisseurInput>
    create: XOR<AchatCreateWithoutFournisseurInput, AchatUncheckedCreateWithoutFournisseurInput>
  }

  export type AchatUpdateWithWhereUniqueWithoutFournisseurInput = {
    where: AchatWhereUniqueInput
    data: XOR<AchatUpdateWithoutFournisseurInput, AchatUncheckedUpdateWithoutFournisseurInput>
  }

  export type AchatUpdateManyWithWhereWithoutFournisseurInput = {
    where: AchatScalarWhereInput
    data: XOR<AchatUpdateManyMutationInput, AchatUncheckedUpdateManyWithoutFournisseurInput>
  }

  export type AdresseUpsertWithWhereUniqueWithoutFournisseurInput = {
    where: AdresseWhereUniqueInput
    update: XOR<AdresseUpdateWithoutFournisseurInput, AdresseUncheckedUpdateWithoutFournisseurInput>
    create: XOR<AdresseCreateWithoutFournisseurInput, AdresseUncheckedCreateWithoutFournisseurInput>
  }

  export type AdresseUpdateWithWhereUniqueWithoutFournisseurInput = {
    where: AdresseWhereUniqueInput
    data: XOR<AdresseUpdateWithoutFournisseurInput, AdresseUncheckedUpdateWithoutFournisseurInput>
  }

  export type AdresseUpdateManyWithWhereWithoutFournisseurInput = {
    where: AdresseScalarWhereInput
    data: XOR<AdresseUpdateManyMutationInput, AdresseUncheckedUpdateManyWithoutFournisseurInput>
  }

  export type ContactUpsertWithWhereUniqueWithoutFournisseurInput = {
    where: ContactWhereUniqueInput
    update: XOR<ContactUpdateWithoutFournisseurInput, ContactUncheckedUpdateWithoutFournisseurInput>
    create: XOR<ContactCreateWithoutFournisseurInput, ContactUncheckedCreateWithoutFournisseurInput>
  }

  export type ContactUpdateWithWhereUniqueWithoutFournisseurInput = {
    where: ContactWhereUniqueInput
    data: XOR<ContactUpdateWithoutFournisseurInput, ContactUncheckedUpdateWithoutFournisseurInput>
  }

  export type ContactUpdateManyWithWhereWithoutFournisseurInput = {
    where: ContactScalarWhereInput
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyWithoutFournisseurInput>
  }

  export type ReservationUpsertWithWhereUniqueWithoutFournisseurInput = {
    where: ReservationWhereUniqueInput
    update: XOR<ReservationUpdateWithoutFournisseurInput, ReservationUncheckedUpdateWithoutFournisseurInput>
    create: XOR<ReservationCreateWithoutFournisseurInput, ReservationUncheckedCreateWithoutFournisseurInput>
  }

  export type ReservationUpdateWithWhereUniqueWithoutFournisseurInput = {
    where: ReservationWhereUniqueInput
    data: XOR<ReservationUpdateWithoutFournisseurInput, ReservationUncheckedUpdateWithoutFournisseurInput>
  }

  export type ReservationUpdateManyWithWhereWithoutFournisseurInput = {
    where: ReservationScalarWhereInput
    data: XOR<ReservationUpdateManyMutationInput, ReservationUncheckedUpdateManyWithoutFournisseurInput>
  }

  export type CommandeUpsertWithWhereUniqueWithoutFournisseurInput = {
    where: CommandeWhereUniqueInput
    update: XOR<CommandeUpdateWithoutFournisseurInput, CommandeUncheckedUpdateWithoutFournisseurInput>
    create: XOR<CommandeCreateWithoutFournisseurInput, CommandeUncheckedCreateWithoutFournisseurInput>
  }

  export type CommandeUpdateWithWhereUniqueWithoutFournisseurInput = {
    where: CommandeWhereUniqueInput
    data: XOR<CommandeUpdateWithoutFournisseurInput, CommandeUncheckedUpdateWithoutFournisseurInput>
  }

  export type CommandeUpdateManyWithWhereWithoutFournisseurInput = {
    where: CommandeScalarWhereInput
    data: XOR<CommandeUpdateManyMutationInput, CommandeUncheckedUpdateManyWithoutFournisseurInput>
  }

  export type UtilisateurCreateWithoutTeneurInput = {
    email: string
    nom: string
    postnom: string
    nom_complet?: string | null
    sexe?: $Enums.Sexe | null
    role?: $Enums.Role
    poste?: $Enums.Poste | null
    picture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Adresse?: AdresseCreateNestedManyWithoutUtilisateurInput
    Contact?: ContactCreateNestedManyWithoutUtilisateurInput
    Produit?: ProduitCreateNestedManyWithoutUtilisateurInput
    Vente?: VenteCreateNestedManyWithoutUtilisateurInput
    Achat?: AchatCreateNestedManyWithoutUtilisateurInput
    Devise?: DeviseCreateNestedManyWithoutUtilisateurInput
    Panier?: PanierCreateNestedManyWithoutUtilisateurInput
    Reservation?: ReservationCreateNestedManyWithoutUtilisateurInput
    Commande?: CommandeCreateNestedManyWithoutClientInput
    Caisse?: CaisseCreateNestedManyWithoutUtilisateurInput
    MouvementCaisse?: MouvementCaisseCreateNestedManyWithoutUtilisateurInput
    ClotureCaisse?: ClotureCaisseCreateNestedManyWithoutUtilisateurClotureInput
  }

  export type UtilisateurUncheckedCreateWithoutTeneurInput = {
    id?: number
    email: string
    nom: string
    postnom: string
    nom_complet?: string | null
    sexe?: $Enums.Sexe | null
    role?: $Enums.Role
    poste?: $Enums.Poste | null
    picture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Adresse?: AdresseUncheckedCreateNestedManyWithoutUtilisateurInput
    Contact?: ContactUncheckedCreateNestedManyWithoutUtilisateurInput
    Produit?: ProduitUncheckedCreateNestedManyWithoutUtilisateurInput
    Vente?: VenteUncheckedCreateNestedManyWithoutUtilisateurInput
    Achat?: AchatUncheckedCreateNestedManyWithoutUtilisateurInput
    Devise?: DeviseUncheckedCreateNestedManyWithoutUtilisateurInput
    Panier?: PanierUncheckedCreateNestedManyWithoutUtilisateurInput
    Reservation?: ReservationUncheckedCreateNestedManyWithoutUtilisateurInput
    Commande?: CommandeUncheckedCreateNestedManyWithoutClientInput
    Caisse?: CaisseUncheckedCreateNestedManyWithoutUtilisateurInput
    MouvementCaisse?: MouvementCaisseUncheckedCreateNestedManyWithoutUtilisateurInput
    ClotureCaisse?: ClotureCaisseUncheckedCreateNestedManyWithoutUtilisateurClotureInput
  }

  export type UtilisateurCreateOrConnectWithoutTeneurInput = {
    where: UtilisateurWhereUniqueInput
    create: XOR<UtilisateurCreateWithoutTeneurInput, UtilisateurUncheckedCreateWithoutTeneurInput>
  }

  export type ProduitCreateWithoutTeneurInput = {
    designation: string
    prix: number
    qtte?: number
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    devise: DeviseCreateNestedOneWithoutProduitInput
    utilisateur: UtilisateurCreateNestedOneWithoutProduitInput
    DetailPanier?: DetailPanierCreateNestedManyWithoutProduitInput
    DetailClotureCaisse?: DetailClotureCaisseCreateNestedManyWithoutProduitInput
  }

  export type ProduitUncheckedCreateWithoutTeneurInput = {
    id?: number
    designation: string
    prix: number
    qtte?: number
    description: string
    deviseId: number
    utilisateurId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    DetailPanier?: DetailPanierUncheckedCreateNestedManyWithoutProduitInput
    DetailClotureCaisse?: DetailClotureCaisseUncheckedCreateNestedManyWithoutProduitInput
  }

  export type ProduitCreateOrConnectWithoutTeneurInput = {
    where: ProduitWhereUniqueInput
    create: XOR<ProduitCreateWithoutTeneurInput, ProduitUncheckedCreateWithoutTeneurInput>
  }

  export type ProduitCreateManyTeneurInputEnvelope = {
    data: ProduitCreateManyTeneurInput | ProduitCreateManyTeneurInput[]
    skipDuplicates?: boolean
  }

  export type DetailClotureCaisseCreateWithoutTeneurInput = {
    qtteRestante: number
    createdAt?: Date | string
    updatedAt?: Date | string
    produit: ProduitCreateNestedOneWithoutDetailClotureCaisseInput
    clotureCaisse: ClotureCaisseCreateNestedOneWithoutDetailClotureCaisseInput
  }

  export type DetailClotureCaisseUncheckedCreateWithoutTeneurInput = {
    id?: number
    produitId: number
    qtteRestante: number
    clotureCaisseId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DetailClotureCaisseCreateOrConnectWithoutTeneurInput = {
    where: DetailClotureCaisseWhereUniqueInput
    create: XOR<DetailClotureCaisseCreateWithoutTeneurInput, DetailClotureCaisseUncheckedCreateWithoutTeneurInput>
  }

  export type DetailClotureCaisseCreateManyTeneurInputEnvelope = {
    data: DetailClotureCaisseCreateManyTeneurInput | DetailClotureCaisseCreateManyTeneurInput[]
    skipDuplicates?: boolean
  }

  export type UtilisateurUpsertWithoutTeneurInput = {
    update: XOR<UtilisateurUpdateWithoutTeneurInput, UtilisateurUncheckedUpdateWithoutTeneurInput>
    create: XOR<UtilisateurCreateWithoutTeneurInput, UtilisateurUncheckedCreateWithoutTeneurInput>
    where?: UtilisateurWhereInput
  }

  export type UtilisateurUpdateToOneWithWhereWithoutTeneurInput = {
    where?: UtilisateurWhereInput
    data: XOR<UtilisateurUpdateWithoutTeneurInput, UtilisateurUncheckedUpdateWithoutTeneurInput>
  }

  export type UtilisateurUpdateWithoutTeneurInput = {
    email?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    postnom?: StringFieldUpdateOperationsInput | string
    nom_complet?: NullableStringFieldUpdateOperationsInput | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    poste?: NullableEnumPosteFieldUpdateOperationsInput | $Enums.Poste | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Adresse?: AdresseUpdateManyWithoutUtilisateurNestedInput
    Contact?: ContactUpdateManyWithoutUtilisateurNestedInput
    Produit?: ProduitUpdateManyWithoutUtilisateurNestedInput
    Vente?: VenteUpdateManyWithoutUtilisateurNestedInput
    Achat?: AchatUpdateManyWithoutUtilisateurNestedInput
    Devise?: DeviseUpdateManyWithoutUtilisateurNestedInput
    Panier?: PanierUpdateManyWithoutUtilisateurNestedInput
    Reservation?: ReservationUpdateManyWithoutUtilisateurNestedInput
    Commande?: CommandeUpdateManyWithoutClientNestedInput
    Caisse?: CaisseUpdateManyWithoutUtilisateurNestedInput
    MouvementCaisse?: MouvementCaisseUpdateManyWithoutUtilisateurNestedInput
    ClotureCaisse?: ClotureCaisseUpdateManyWithoutUtilisateurClotureNestedInput
  }

  export type UtilisateurUncheckedUpdateWithoutTeneurInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    postnom?: StringFieldUpdateOperationsInput | string
    nom_complet?: NullableStringFieldUpdateOperationsInput | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    poste?: NullableEnumPosteFieldUpdateOperationsInput | $Enums.Poste | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Adresse?: AdresseUncheckedUpdateManyWithoutUtilisateurNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutUtilisateurNestedInput
    Produit?: ProduitUncheckedUpdateManyWithoutUtilisateurNestedInput
    Vente?: VenteUncheckedUpdateManyWithoutUtilisateurNestedInput
    Achat?: AchatUncheckedUpdateManyWithoutUtilisateurNestedInput
    Devise?: DeviseUncheckedUpdateManyWithoutUtilisateurNestedInput
    Panier?: PanierUncheckedUpdateManyWithoutUtilisateurNestedInput
    Reservation?: ReservationUncheckedUpdateManyWithoutUtilisateurNestedInput
    Commande?: CommandeUncheckedUpdateManyWithoutClientNestedInput
    Caisse?: CaisseUncheckedUpdateManyWithoutUtilisateurNestedInput
    MouvementCaisse?: MouvementCaisseUncheckedUpdateManyWithoutUtilisateurNestedInput
    ClotureCaisse?: ClotureCaisseUncheckedUpdateManyWithoutUtilisateurClotureNestedInput
  }

  export type ProduitUpsertWithWhereUniqueWithoutTeneurInput = {
    where: ProduitWhereUniqueInput
    update: XOR<ProduitUpdateWithoutTeneurInput, ProduitUncheckedUpdateWithoutTeneurInput>
    create: XOR<ProduitCreateWithoutTeneurInput, ProduitUncheckedCreateWithoutTeneurInput>
  }

  export type ProduitUpdateWithWhereUniqueWithoutTeneurInput = {
    where: ProduitWhereUniqueInput
    data: XOR<ProduitUpdateWithoutTeneurInput, ProduitUncheckedUpdateWithoutTeneurInput>
  }

  export type ProduitUpdateManyWithWhereWithoutTeneurInput = {
    where: ProduitScalarWhereInput
    data: XOR<ProduitUpdateManyMutationInput, ProduitUncheckedUpdateManyWithoutTeneurInput>
  }

  export type DetailClotureCaisseUpsertWithWhereUniqueWithoutTeneurInput = {
    where: DetailClotureCaisseWhereUniqueInput
    update: XOR<DetailClotureCaisseUpdateWithoutTeneurInput, DetailClotureCaisseUncheckedUpdateWithoutTeneurInput>
    create: XOR<DetailClotureCaisseCreateWithoutTeneurInput, DetailClotureCaisseUncheckedCreateWithoutTeneurInput>
  }

  export type DetailClotureCaisseUpdateWithWhereUniqueWithoutTeneurInput = {
    where: DetailClotureCaisseWhereUniqueInput
    data: XOR<DetailClotureCaisseUpdateWithoutTeneurInput, DetailClotureCaisseUncheckedUpdateWithoutTeneurInput>
  }

  export type DetailClotureCaisseUpdateManyWithWhereWithoutTeneurInput = {
    where: DetailClotureCaisseScalarWhereInput
    data: XOR<DetailClotureCaisseUpdateManyMutationInput, DetailClotureCaisseUncheckedUpdateManyWithoutTeneurInput>
  }

  export type DetailClotureCaisseScalarWhereInput = {
    AND?: DetailClotureCaisseScalarWhereInput | DetailClotureCaisseScalarWhereInput[]
    OR?: DetailClotureCaisseScalarWhereInput[]
    NOT?: DetailClotureCaisseScalarWhereInput | DetailClotureCaisseScalarWhereInput[]
    id?: IntFilter<"DetailClotureCaisse"> | number
    produitId?: IntFilter<"DetailClotureCaisse"> | number
    teneurId?: IntFilter<"DetailClotureCaisse"> | number
    qtteRestante?: IntFilter<"DetailClotureCaisse"> | number
    clotureCaisseId?: IntFilter<"DetailClotureCaisse"> | number
    createdAt?: DateTimeFilter<"DetailClotureCaisse"> | Date | string
    updatedAt?: DateTimeFilter<"DetailClotureCaisse"> | Date | string
  }

  export type UtilisateurCreateWithoutDeviseInput = {
    email: string
    nom: string
    postnom: string
    nom_complet?: string | null
    sexe?: $Enums.Sexe | null
    role?: $Enums.Role
    poste?: $Enums.Poste | null
    picture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Adresse?: AdresseCreateNestedManyWithoutUtilisateurInput
    Contact?: ContactCreateNestedManyWithoutUtilisateurInput
    Produit?: ProduitCreateNestedManyWithoutUtilisateurInput
    Vente?: VenteCreateNestedManyWithoutUtilisateurInput
    Achat?: AchatCreateNestedManyWithoutUtilisateurInput
    Teneur?: TeneurCreateNestedManyWithoutUtilisateurInput
    Panier?: PanierCreateNestedManyWithoutUtilisateurInput
    Reservation?: ReservationCreateNestedManyWithoutUtilisateurInput
    Commande?: CommandeCreateNestedManyWithoutClientInput
    Caisse?: CaisseCreateNestedManyWithoutUtilisateurInput
    MouvementCaisse?: MouvementCaisseCreateNestedManyWithoutUtilisateurInput
    ClotureCaisse?: ClotureCaisseCreateNestedManyWithoutUtilisateurClotureInput
  }

  export type UtilisateurUncheckedCreateWithoutDeviseInput = {
    id?: number
    email: string
    nom: string
    postnom: string
    nom_complet?: string | null
    sexe?: $Enums.Sexe | null
    role?: $Enums.Role
    poste?: $Enums.Poste | null
    picture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Adresse?: AdresseUncheckedCreateNestedManyWithoutUtilisateurInput
    Contact?: ContactUncheckedCreateNestedManyWithoutUtilisateurInput
    Produit?: ProduitUncheckedCreateNestedManyWithoutUtilisateurInput
    Vente?: VenteUncheckedCreateNestedManyWithoutUtilisateurInput
    Achat?: AchatUncheckedCreateNestedManyWithoutUtilisateurInput
    Teneur?: TeneurUncheckedCreateNestedManyWithoutUtilisateurInput
    Panier?: PanierUncheckedCreateNestedManyWithoutUtilisateurInput
    Reservation?: ReservationUncheckedCreateNestedManyWithoutUtilisateurInput
    Commande?: CommandeUncheckedCreateNestedManyWithoutClientInput
    Caisse?: CaisseUncheckedCreateNestedManyWithoutUtilisateurInput
    MouvementCaisse?: MouvementCaisseUncheckedCreateNestedManyWithoutUtilisateurInput
    ClotureCaisse?: ClotureCaisseUncheckedCreateNestedManyWithoutUtilisateurClotureInput
  }

  export type UtilisateurCreateOrConnectWithoutDeviseInput = {
    where: UtilisateurWhereUniqueInput
    create: XOR<UtilisateurCreateWithoutDeviseInput, UtilisateurUncheckedCreateWithoutDeviseInput>
  }

  export type ProduitCreateWithoutDeviseInput = {
    designation: string
    prix: number
    qtte?: number
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    teneur: TeneurCreateNestedOneWithoutProduitInput
    utilisateur: UtilisateurCreateNestedOneWithoutProduitInput
    DetailPanier?: DetailPanierCreateNestedManyWithoutProduitInput
    DetailClotureCaisse?: DetailClotureCaisseCreateNestedManyWithoutProduitInput
  }

  export type ProduitUncheckedCreateWithoutDeviseInput = {
    id?: number
    designation: string
    prix: number
    qtte?: number
    description: string
    teneurId: number
    utilisateurId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    DetailPanier?: DetailPanierUncheckedCreateNestedManyWithoutProduitInput
    DetailClotureCaisse?: DetailClotureCaisseUncheckedCreateNestedManyWithoutProduitInput
  }

  export type ProduitCreateOrConnectWithoutDeviseInput = {
    where: ProduitWhereUniqueInput
    create: XOR<ProduitCreateWithoutDeviseInput, ProduitUncheckedCreateWithoutDeviseInput>
  }

  export type ProduitCreateManyDeviseInputEnvelope = {
    data: ProduitCreateManyDeviseInput | ProduitCreateManyDeviseInput[]
    skipDuplicates?: boolean
  }

  export type PaiementCreateWithoutDeviseInput = {
    montant: number
    moyen_paiement: $Enums.MoyenPaiment
    createdAt?: Date | string
    updatedAt?: Date | string
    caisse: CaisseCreateNestedOneWithoutPaiementInput
    Achat?: AchatCreateNestedManyWithoutPaiementInput
    Commande?: CommandeCreateNestedManyWithoutPaiementInput
    Vente?: VenteCreateNestedManyWithoutPaiementInput
  }

  export type PaiementUncheckedCreateWithoutDeviseInput = {
    id?: number
    montant: number
    moyen_paiement: $Enums.MoyenPaiment
    caisseId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    Achat?: AchatUncheckedCreateNestedManyWithoutPaiementInput
    Commande?: CommandeUncheckedCreateNestedManyWithoutPaiementInput
    Vente?: VenteUncheckedCreateNestedManyWithoutPaiementInput
  }

  export type PaiementCreateOrConnectWithoutDeviseInput = {
    where: PaiementWhereUniqueInput
    create: XOR<PaiementCreateWithoutDeviseInput, PaiementUncheckedCreateWithoutDeviseInput>
  }

  export type PaiementCreateManyDeviseInputEnvelope = {
    data: PaiementCreateManyDeviseInput | PaiementCreateManyDeviseInput[]
    skipDuplicates?: boolean
  }

  export type CaisseCreateWithoutDeviseInput = {
    nom: string
    description?: string | null
    soldeInitial: number
    soldeActuel: number
    statut?: $Enums.StatutCaisse
    createdAt?: Date | string
    updatedAt?: Date | string
    utilisateur: UtilisateurCreateNestedOneWithoutCaisseInput
    MouvementCaisse?: MouvementCaisseCreateNestedManyWithoutCaisseInput
    clotures?: ClotureCaisseCreateNestedManyWithoutCaisseInput
    Paiement?: PaiementCreateNestedManyWithoutCaisseInput
  }

  export type CaisseUncheckedCreateWithoutDeviseInput = {
    id?: number
    nom: string
    description?: string | null
    soldeInitial: number
    soldeActuel: number
    creeParId: number
    statut?: $Enums.StatutCaisse
    createdAt?: Date | string
    updatedAt?: Date | string
    MouvementCaisse?: MouvementCaisseUncheckedCreateNestedManyWithoutCaisseInput
    clotures?: ClotureCaisseUncheckedCreateNestedManyWithoutCaisseInput
    Paiement?: PaiementUncheckedCreateNestedManyWithoutCaisseInput
  }

  export type CaisseCreateOrConnectWithoutDeviseInput = {
    where: CaisseWhereUniqueInput
    create: XOR<CaisseCreateWithoutDeviseInput, CaisseUncheckedCreateWithoutDeviseInput>
  }

  export type CaisseCreateManyDeviseInputEnvelope = {
    data: CaisseCreateManyDeviseInput | CaisseCreateManyDeviseInput[]
    skipDuplicates?: boolean
  }

  export type UtilisateurUpsertWithoutDeviseInput = {
    update: XOR<UtilisateurUpdateWithoutDeviseInput, UtilisateurUncheckedUpdateWithoutDeviseInput>
    create: XOR<UtilisateurCreateWithoutDeviseInput, UtilisateurUncheckedCreateWithoutDeviseInput>
    where?: UtilisateurWhereInput
  }

  export type UtilisateurUpdateToOneWithWhereWithoutDeviseInput = {
    where?: UtilisateurWhereInput
    data: XOR<UtilisateurUpdateWithoutDeviseInput, UtilisateurUncheckedUpdateWithoutDeviseInput>
  }

  export type UtilisateurUpdateWithoutDeviseInput = {
    email?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    postnom?: StringFieldUpdateOperationsInput | string
    nom_complet?: NullableStringFieldUpdateOperationsInput | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    poste?: NullableEnumPosteFieldUpdateOperationsInput | $Enums.Poste | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Adresse?: AdresseUpdateManyWithoutUtilisateurNestedInput
    Contact?: ContactUpdateManyWithoutUtilisateurNestedInput
    Produit?: ProduitUpdateManyWithoutUtilisateurNestedInput
    Vente?: VenteUpdateManyWithoutUtilisateurNestedInput
    Achat?: AchatUpdateManyWithoutUtilisateurNestedInput
    Teneur?: TeneurUpdateManyWithoutUtilisateurNestedInput
    Panier?: PanierUpdateManyWithoutUtilisateurNestedInput
    Reservation?: ReservationUpdateManyWithoutUtilisateurNestedInput
    Commande?: CommandeUpdateManyWithoutClientNestedInput
    Caisse?: CaisseUpdateManyWithoutUtilisateurNestedInput
    MouvementCaisse?: MouvementCaisseUpdateManyWithoutUtilisateurNestedInput
    ClotureCaisse?: ClotureCaisseUpdateManyWithoutUtilisateurClotureNestedInput
  }

  export type UtilisateurUncheckedUpdateWithoutDeviseInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    postnom?: StringFieldUpdateOperationsInput | string
    nom_complet?: NullableStringFieldUpdateOperationsInput | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    poste?: NullableEnumPosteFieldUpdateOperationsInput | $Enums.Poste | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Adresse?: AdresseUncheckedUpdateManyWithoutUtilisateurNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutUtilisateurNestedInput
    Produit?: ProduitUncheckedUpdateManyWithoutUtilisateurNestedInput
    Vente?: VenteUncheckedUpdateManyWithoutUtilisateurNestedInput
    Achat?: AchatUncheckedUpdateManyWithoutUtilisateurNestedInput
    Teneur?: TeneurUncheckedUpdateManyWithoutUtilisateurNestedInput
    Panier?: PanierUncheckedUpdateManyWithoutUtilisateurNestedInput
    Reservation?: ReservationUncheckedUpdateManyWithoutUtilisateurNestedInput
    Commande?: CommandeUncheckedUpdateManyWithoutClientNestedInput
    Caisse?: CaisseUncheckedUpdateManyWithoutUtilisateurNestedInput
    MouvementCaisse?: MouvementCaisseUncheckedUpdateManyWithoutUtilisateurNestedInput
    ClotureCaisse?: ClotureCaisseUncheckedUpdateManyWithoutUtilisateurClotureNestedInput
  }

  export type ProduitUpsertWithWhereUniqueWithoutDeviseInput = {
    where: ProduitWhereUniqueInput
    update: XOR<ProduitUpdateWithoutDeviseInput, ProduitUncheckedUpdateWithoutDeviseInput>
    create: XOR<ProduitCreateWithoutDeviseInput, ProduitUncheckedCreateWithoutDeviseInput>
  }

  export type ProduitUpdateWithWhereUniqueWithoutDeviseInput = {
    where: ProduitWhereUniqueInput
    data: XOR<ProduitUpdateWithoutDeviseInput, ProduitUncheckedUpdateWithoutDeviseInput>
  }

  export type ProduitUpdateManyWithWhereWithoutDeviseInput = {
    where: ProduitScalarWhereInput
    data: XOR<ProduitUpdateManyMutationInput, ProduitUncheckedUpdateManyWithoutDeviseInput>
  }

  export type PaiementUpsertWithWhereUniqueWithoutDeviseInput = {
    where: PaiementWhereUniqueInput
    update: XOR<PaiementUpdateWithoutDeviseInput, PaiementUncheckedUpdateWithoutDeviseInput>
    create: XOR<PaiementCreateWithoutDeviseInput, PaiementUncheckedCreateWithoutDeviseInput>
  }

  export type PaiementUpdateWithWhereUniqueWithoutDeviseInput = {
    where: PaiementWhereUniqueInput
    data: XOR<PaiementUpdateWithoutDeviseInput, PaiementUncheckedUpdateWithoutDeviseInput>
  }

  export type PaiementUpdateManyWithWhereWithoutDeviseInput = {
    where: PaiementScalarWhereInput
    data: XOR<PaiementUpdateManyMutationInput, PaiementUncheckedUpdateManyWithoutDeviseInput>
  }

  export type PaiementScalarWhereInput = {
    AND?: PaiementScalarWhereInput | PaiementScalarWhereInput[]
    OR?: PaiementScalarWhereInput[]
    NOT?: PaiementScalarWhereInput | PaiementScalarWhereInput[]
    id?: IntFilter<"Paiement"> | number
    montant?: FloatFilter<"Paiement"> | number
    moyen_paiement?: EnumMoyenPaimentFilter<"Paiement"> | $Enums.MoyenPaiment
    deviseId?: IntFilter<"Paiement"> | number
    caisseId?: IntFilter<"Paiement"> | number
    createdAt?: DateTimeFilter<"Paiement"> | Date | string
    updatedAt?: DateTimeFilter<"Paiement"> | Date | string
  }

  export type CaisseUpsertWithWhereUniqueWithoutDeviseInput = {
    where: CaisseWhereUniqueInput
    update: XOR<CaisseUpdateWithoutDeviseInput, CaisseUncheckedUpdateWithoutDeviseInput>
    create: XOR<CaisseCreateWithoutDeviseInput, CaisseUncheckedCreateWithoutDeviseInput>
  }

  export type CaisseUpdateWithWhereUniqueWithoutDeviseInput = {
    where: CaisseWhereUniqueInput
    data: XOR<CaisseUpdateWithoutDeviseInput, CaisseUncheckedUpdateWithoutDeviseInput>
  }

  export type CaisseUpdateManyWithWhereWithoutDeviseInput = {
    where: CaisseScalarWhereInput
    data: XOR<CaisseUpdateManyMutationInput, CaisseUncheckedUpdateManyWithoutDeviseInput>
  }

  export type DeviseCreateWithoutProduitInput = {
    nom: string
    code: string
    symbole: string
    createdAt?: Date | string
    updatedAt?: Date | string
    utilisateur: UtilisateurCreateNestedOneWithoutDeviseInput
    Paiement?: PaiementCreateNestedManyWithoutDeviseInput
    Caisse?: CaisseCreateNestedManyWithoutDeviseInput
  }

  export type DeviseUncheckedCreateWithoutProduitInput = {
    id?: number
    nom: string
    code: string
    symbole: string
    utilisateurId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    Paiement?: PaiementUncheckedCreateNestedManyWithoutDeviseInput
    Caisse?: CaisseUncheckedCreateNestedManyWithoutDeviseInput
  }

  export type DeviseCreateOrConnectWithoutProduitInput = {
    where: DeviseWhereUniqueInput
    create: XOR<DeviseCreateWithoutProduitInput, DeviseUncheckedCreateWithoutProduitInput>
  }

  export type TeneurCreateWithoutProduitInput = {
    valeur: number
    createdAt?: Date | string
    updatedAt?: Date | string
    utilisateur: UtilisateurCreateNestedOneWithoutTeneurInput
    DetailClotureCaisse?: DetailClotureCaisseCreateNestedManyWithoutTeneurInput
  }

  export type TeneurUncheckedCreateWithoutProduitInput = {
    id?: number
    valeur: number
    utilisateurId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    DetailClotureCaisse?: DetailClotureCaisseUncheckedCreateNestedManyWithoutTeneurInput
  }

  export type TeneurCreateOrConnectWithoutProduitInput = {
    where: TeneurWhereUniqueInput
    create: XOR<TeneurCreateWithoutProduitInput, TeneurUncheckedCreateWithoutProduitInput>
  }

  export type UtilisateurCreateWithoutProduitInput = {
    email: string
    nom: string
    postnom: string
    nom_complet?: string | null
    sexe?: $Enums.Sexe | null
    role?: $Enums.Role
    poste?: $Enums.Poste | null
    picture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Adresse?: AdresseCreateNestedManyWithoutUtilisateurInput
    Contact?: ContactCreateNestedManyWithoutUtilisateurInput
    Vente?: VenteCreateNestedManyWithoutUtilisateurInput
    Achat?: AchatCreateNestedManyWithoutUtilisateurInput
    Teneur?: TeneurCreateNestedManyWithoutUtilisateurInput
    Devise?: DeviseCreateNestedManyWithoutUtilisateurInput
    Panier?: PanierCreateNestedManyWithoutUtilisateurInput
    Reservation?: ReservationCreateNestedManyWithoutUtilisateurInput
    Commande?: CommandeCreateNestedManyWithoutClientInput
    Caisse?: CaisseCreateNestedManyWithoutUtilisateurInput
    MouvementCaisse?: MouvementCaisseCreateNestedManyWithoutUtilisateurInput
    ClotureCaisse?: ClotureCaisseCreateNestedManyWithoutUtilisateurClotureInput
  }

  export type UtilisateurUncheckedCreateWithoutProduitInput = {
    id?: number
    email: string
    nom: string
    postnom: string
    nom_complet?: string | null
    sexe?: $Enums.Sexe | null
    role?: $Enums.Role
    poste?: $Enums.Poste | null
    picture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Adresse?: AdresseUncheckedCreateNestedManyWithoutUtilisateurInput
    Contact?: ContactUncheckedCreateNestedManyWithoutUtilisateurInput
    Vente?: VenteUncheckedCreateNestedManyWithoutUtilisateurInput
    Achat?: AchatUncheckedCreateNestedManyWithoutUtilisateurInput
    Teneur?: TeneurUncheckedCreateNestedManyWithoutUtilisateurInput
    Devise?: DeviseUncheckedCreateNestedManyWithoutUtilisateurInput
    Panier?: PanierUncheckedCreateNestedManyWithoutUtilisateurInput
    Reservation?: ReservationUncheckedCreateNestedManyWithoutUtilisateurInput
    Commande?: CommandeUncheckedCreateNestedManyWithoutClientInput
    Caisse?: CaisseUncheckedCreateNestedManyWithoutUtilisateurInput
    MouvementCaisse?: MouvementCaisseUncheckedCreateNestedManyWithoutUtilisateurInput
    ClotureCaisse?: ClotureCaisseUncheckedCreateNestedManyWithoutUtilisateurClotureInput
  }

  export type UtilisateurCreateOrConnectWithoutProduitInput = {
    where: UtilisateurWhereUniqueInput
    create: XOR<UtilisateurCreateWithoutProduitInput, UtilisateurUncheckedCreateWithoutProduitInput>
  }

  export type DetailPanierCreateWithoutProduitInput = {
    qtte: number
    prixUnitaire: number
    prixTotal: number
    createdAt?: Date | string
    updatedAt?: Date | string
    panier: PanierCreateNestedOneWithoutDetailPanierInput
  }

  export type DetailPanierUncheckedCreateWithoutProduitInput = {
    id?: number
    qtte: number
    prixUnitaire: number
    prixTotal: number
    panierId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DetailPanierCreateOrConnectWithoutProduitInput = {
    where: DetailPanierWhereUniqueInput
    create: XOR<DetailPanierCreateWithoutProduitInput, DetailPanierUncheckedCreateWithoutProduitInput>
  }

  export type DetailPanierCreateManyProduitInputEnvelope = {
    data: DetailPanierCreateManyProduitInput | DetailPanierCreateManyProduitInput[]
    skipDuplicates?: boolean
  }

  export type DetailClotureCaisseCreateWithoutProduitInput = {
    qtteRestante: number
    createdAt?: Date | string
    updatedAt?: Date | string
    teneur: TeneurCreateNestedOneWithoutDetailClotureCaisseInput
    clotureCaisse: ClotureCaisseCreateNestedOneWithoutDetailClotureCaisseInput
  }

  export type DetailClotureCaisseUncheckedCreateWithoutProduitInput = {
    id?: number
    teneurId: number
    qtteRestante: number
    clotureCaisseId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DetailClotureCaisseCreateOrConnectWithoutProduitInput = {
    where: DetailClotureCaisseWhereUniqueInput
    create: XOR<DetailClotureCaisseCreateWithoutProduitInput, DetailClotureCaisseUncheckedCreateWithoutProduitInput>
  }

  export type DetailClotureCaisseCreateManyProduitInputEnvelope = {
    data: DetailClotureCaisseCreateManyProduitInput | DetailClotureCaisseCreateManyProduitInput[]
    skipDuplicates?: boolean
  }

  export type DeviseUpsertWithoutProduitInput = {
    update: XOR<DeviseUpdateWithoutProduitInput, DeviseUncheckedUpdateWithoutProduitInput>
    create: XOR<DeviseCreateWithoutProduitInput, DeviseUncheckedCreateWithoutProduitInput>
    where?: DeviseWhereInput
  }

  export type DeviseUpdateToOneWithWhereWithoutProduitInput = {
    where?: DeviseWhereInput
    data: XOR<DeviseUpdateWithoutProduitInput, DeviseUncheckedUpdateWithoutProduitInput>
  }

  export type DeviseUpdateWithoutProduitInput = {
    nom?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    symbole?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    utilisateur?: UtilisateurUpdateOneRequiredWithoutDeviseNestedInput
    Paiement?: PaiementUpdateManyWithoutDeviseNestedInput
    Caisse?: CaisseUpdateManyWithoutDeviseNestedInput
  }

  export type DeviseUncheckedUpdateWithoutProduitInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    symbole?: StringFieldUpdateOperationsInput | string
    utilisateurId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Paiement?: PaiementUncheckedUpdateManyWithoutDeviseNestedInput
    Caisse?: CaisseUncheckedUpdateManyWithoutDeviseNestedInput
  }

  export type TeneurUpsertWithoutProduitInput = {
    update: XOR<TeneurUpdateWithoutProduitInput, TeneurUncheckedUpdateWithoutProduitInput>
    create: XOR<TeneurCreateWithoutProduitInput, TeneurUncheckedCreateWithoutProduitInput>
    where?: TeneurWhereInput
  }

  export type TeneurUpdateToOneWithWhereWithoutProduitInput = {
    where?: TeneurWhereInput
    data: XOR<TeneurUpdateWithoutProduitInput, TeneurUncheckedUpdateWithoutProduitInput>
  }

  export type TeneurUpdateWithoutProduitInput = {
    valeur?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    utilisateur?: UtilisateurUpdateOneRequiredWithoutTeneurNestedInput
    DetailClotureCaisse?: DetailClotureCaisseUpdateManyWithoutTeneurNestedInput
  }

  export type TeneurUncheckedUpdateWithoutProduitInput = {
    id?: IntFieldUpdateOperationsInput | number
    valeur?: FloatFieldUpdateOperationsInput | number
    utilisateurId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DetailClotureCaisse?: DetailClotureCaisseUncheckedUpdateManyWithoutTeneurNestedInput
  }

  export type UtilisateurUpsertWithoutProduitInput = {
    update: XOR<UtilisateurUpdateWithoutProduitInput, UtilisateurUncheckedUpdateWithoutProduitInput>
    create: XOR<UtilisateurCreateWithoutProduitInput, UtilisateurUncheckedCreateWithoutProduitInput>
    where?: UtilisateurWhereInput
  }

  export type UtilisateurUpdateToOneWithWhereWithoutProduitInput = {
    where?: UtilisateurWhereInput
    data: XOR<UtilisateurUpdateWithoutProduitInput, UtilisateurUncheckedUpdateWithoutProduitInput>
  }

  export type UtilisateurUpdateWithoutProduitInput = {
    email?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    postnom?: StringFieldUpdateOperationsInput | string
    nom_complet?: NullableStringFieldUpdateOperationsInput | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    poste?: NullableEnumPosteFieldUpdateOperationsInput | $Enums.Poste | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Adresse?: AdresseUpdateManyWithoutUtilisateurNestedInput
    Contact?: ContactUpdateManyWithoutUtilisateurNestedInput
    Vente?: VenteUpdateManyWithoutUtilisateurNestedInput
    Achat?: AchatUpdateManyWithoutUtilisateurNestedInput
    Teneur?: TeneurUpdateManyWithoutUtilisateurNestedInput
    Devise?: DeviseUpdateManyWithoutUtilisateurNestedInput
    Panier?: PanierUpdateManyWithoutUtilisateurNestedInput
    Reservation?: ReservationUpdateManyWithoutUtilisateurNestedInput
    Commande?: CommandeUpdateManyWithoutClientNestedInput
    Caisse?: CaisseUpdateManyWithoutUtilisateurNestedInput
    MouvementCaisse?: MouvementCaisseUpdateManyWithoutUtilisateurNestedInput
    ClotureCaisse?: ClotureCaisseUpdateManyWithoutUtilisateurClotureNestedInput
  }

  export type UtilisateurUncheckedUpdateWithoutProduitInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    postnom?: StringFieldUpdateOperationsInput | string
    nom_complet?: NullableStringFieldUpdateOperationsInput | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    poste?: NullableEnumPosteFieldUpdateOperationsInput | $Enums.Poste | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Adresse?: AdresseUncheckedUpdateManyWithoutUtilisateurNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutUtilisateurNestedInput
    Vente?: VenteUncheckedUpdateManyWithoutUtilisateurNestedInput
    Achat?: AchatUncheckedUpdateManyWithoutUtilisateurNestedInput
    Teneur?: TeneurUncheckedUpdateManyWithoutUtilisateurNestedInput
    Devise?: DeviseUncheckedUpdateManyWithoutUtilisateurNestedInput
    Panier?: PanierUncheckedUpdateManyWithoutUtilisateurNestedInput
    Reservation?: ReservationUncheckedUpdateManyWithoutUtilisateurNestedInput
    Commande?: CommandeUncheckedUpdateManyWithoutClientNestedInput
    Caisse?: CaisseUncheckedUpdateManyWithoutUtilisateurNestedInput
    MouvementCaisse?: MouvementCaisseUncheckedUpdateManyWithoutUtilisateurNestedInput
    ClotureCaisse?: ClotureCaisseUncheckedUpdateManyWithoutUtilisateurClotureNestedInput
  }

  export type DetailPanierUpsertWithWhereUniqueWithoutProduitInput = {
    where: DetailPanierWhereUniqueInput
    update: XOR<DetailPanierUpdateWithoutProduitInput, DetailPanierUncheckedUpdateWithoutProduitInput>
    create: XOR<DetailPanierCreateWithoutProduitInput, DetailPanierUncheckedCreateWithoutProduitInput>
  }

  export type DetailPanierUpdateWithWhereUniqueWithoutProduitInput = {
    where: DetailPanierWhereUniqueInput
    data: XOR<DetailPanierUpdateWithoutProduitInput, DetailPanierUncheckedUpdateWithoutProduitInput>
  }

  export type DetailPanierUpdateManyWithWhereWithoutProduitInput = {
    where: DetailPanierScalarWhereInput
    data: XOR<DetailPanierUpdateManyMutationInput, DetailPanierUncheckedUpdateManyWithoutProduitInput>
  }

  export type DetailPanierScalarWhereInput = {
    AND?: DetailPanierScalarWhereInput | DetailPanierScalarWhereInput[]
    OR?: DetailPanierScalarWhereInput[]
    NOT?: DetailPanierScalarWhereInput | DetailPanierScalarWhereInput[]
    id?: IntFilter<"DetailPanier"> | number
    produitId?: IntFilter<"DetailPanier"> | number
    qtte?: IntFilter<"DetailPanier"> | number
    prixUnitaire?: FloatFilter<"DetailPanier"> | number
    prixTotal?: FloatFilter<"DetailPanier"> | number
    panierId?: IntFilter<"DetailPanier"> | number
    createdAt?: DateTimeFilter<"DetailPanier"> | Date | string
    updatedAt?: DateTimeFilter<"DetailPanier"> | Date | string
  }

  export type DetailClotureCaisseUpsertWithWhereUniqueWithoutProduitInput = {
    where: DetailClotureCaisseWhereUniqueInput
    update: XOR<DetailClotureCaisseUpdateWithoutProduitInput, DetailClotureCaisseUncheckedUpdateWithoutProduitInput>
    create: XOR<DetailClotureCaisseCreateWithoutProduitInput, DetailClotureCaisseUncheckedCreateWithoutProduitInput>
  }

  export type DetailClotureCaisseUpdateWithWhereUniqueWithoutProduitInput = {
    where: DetailClotureCaisseWhereUniqueInput
    data: XOR<DetailClotureCaisseUpdateWithoutProduitInput, DetailClotureCaisseUncheckedUpdateWithoutProduitInput>
  }

  export type DetailClotureCaisseUpdateManyWithWhereWithoutProduitInput = {
    where: DetailClotureCaisseScalarWhereInput
    data: XOR<DetailClotureCaisseUpdateManyMutationInput, DetailClotureCaisseUncheckedUpdateManyWithoutProduitInput>
  }

  export type CaisseCreateWithoutPaiementInput = {
    nom: string
    description?: string | null
    soldeInitial: number
    soldeActuel: number
    statut?: $Enums.StatutCaisse
    createdAt?: Date | string
    updatedAt?: Date | string
    devise: DeviseCreateNestedOneWithoutCaisseInput
    utilisateur: UtilisateurCreateNestedOneWithoutCaisseInput
    MouvementCaisse?: MouvementCaisseCreateNestedManyWithoutCaisseInput
    clotures?: ClotureCaisseCreateNestedManyWithoutCaisseInput
  }

  export type CaisseUncheckedCreateWithoutPaiementInput = {
    id?: number
    nom: string
    description?: string | null
    soldeInitial: number
    soldeActuel: number
    deviseId: number
    creeParId: number
    statut?: $Enums.StatutCaisse
    createdAt?: Date | string
    updatedAt?: Date | string
    MouvementCaisse?: MouvementCaisseUncheckedCreateNestedManyWithoutCaisseInput
    clotures?: ClotureCaisseUncheckedCreateNestedManyWithoutCaisseInput
  }

  export type CaisseCreateOrConnectWithoutPaiementInput = {
    where: CaisseWhereUniqueInput
    create: XOR<CaisseCreateWithoutPaiementInput, CaisseUncheckedCreateWithoutPaiementInput>
  }

  export type DeviseCreateWithoutPaiementInput = {
    nom: string
    code: string
    symbole: string
    createdAt?: Date | string
    updatedAt?: Date | string
    utilisateur: UtilisateurCreateNestedOneWithoutDeviseInput
    Produit?: ProduitCreateNestedManyWithoutDeviseInput
    Caisse?: CaisseCreateNestedManyWithoutDeviseInput
  }

  export type DeviseUncheckedCreateWithoutPaiementInput = {
    id?: number
    nom: string
    code: string
    symbole: string
    utilisateurId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    Produit?: ProduitUncheckedCreateNestedManyWithoutDeviseInput
    Caisse?: CaisseUncheckedCreateNestedManyWithoutDeviseInput
  }

  export type DeviseCreateOrConnectWithoutPaiementInput = {
    where: DeviseWhereUniqueInput
    create: XOR<DeviseCreateWithoutPaiementInput, DeviseUncheckedCreateWithoutPaiementInput>
  }

  export type AchatCreateWithoutPaiementInput = {
    statut?: $Enums.StatutAchat
    createdAt?: Date | string
    updatedAt?: Date | string
    panier: PanierCreateNestedOneWithoutAchatInput
    fournisseur: FournisseurCreateNestedOneWithoutAchatInput
    utilisateur: UtilisateurCreateNestedOneWithoutAchatInput
  }

  export type AchatUncheckedCreateWithoutPaiementInput = {
    id?: number
    statut?: $Enums.StatutAchat
    panierId: number
    fournisseurId: number
    enregistrerParId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AchatCreateOrConnectWithoutPaiementInput = {
    where: AchatWhereUniqueInput
    create: XOR<AchatCreateWithoutPaiementInput, AchatUncheckedCreateWithoutPaiementInput>
  }

  export type AchatCreateManyPaiementInputEnvelope = {
    data: AchatCreateManyPaiementInput | AchatCreateManyPaiementInput[]
    skipDuplicates?: boolean
  }

  export type CommandeCreateWithoutPaiementInput = {
    nom?: string | null
    tel?: string | null
    type_client?: $Enums.TypeClient
    notes?: string | null
    dateLivraisonEffective?: Date | string | null
    adresseLivraison?: string | null
    enregistrerParId?: number | null
    statut?: $Enums.StatutCommande
    createdAt?: Date | string
    updatedAt?: Date | string
    panier: PanierCreateNestedOneWithoutCommandeInput
    client?: UtilisateurCreateNestedOneWithoutCommandeInput
    fournisseur?: FournisseurCreateNestedOneWithoutCommandeInput
    adresse?: AdresseCreateNestedOneWithoutCommandeInput
    contact?: ContactCreateNestedOneWithoutCommandeInput
  }

  export type CommandeUncheckedCreateWithoutPaiementInput = {
    id?: number
    panierId: number
    clientId?: number | null
    nom?: string | null
    tel?: string | null
    type_client?: $Enums.TypeClient
    adresseId?: number | null
    contactId?: number | null
    fournisseurId?: number | null
    notes?: string | null
    dateLivraisonEffective?: Date | string | null
    adresseLivraison?: string | null
    enregistrerParId?: number | null
    statut?: $Enums.StatutCommande
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommandeCreateOrConnectWithoutPaiementInput = {
    where: CommandeWhereUniqueInput
    create: XOR<CommandeCreateWithoutPaiementInput, CommandeUncheckedCreateWithoutPaiementInput>
  }

  export type CommandeCreateManyPaiementInputEnvelope = {
    data: CommandeCreateManyPaiementInput | CommandeCreateManyPaiementInput[]
    skipDuplicates?: boolean
  }

  export type VenteCreateWithoutPaiementInput = {
    statut?: $Enums.StatutVente
    total_ttc: number
    total_ht: number
    type_acheteur: $Enums.TypeClient
    clientId?: number | null
    agentId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    panier: PanierCreateNestedOneWithoutVenteInput
    utilisateur: UtilisateurCreateNestedOneWithoutVenteInput
    fournisseur?: FournisseurCreateNestedOneWithoutVenteInput
  }

  export type VenteUncheckedCreateWithoutPaiementInput = {
    id?: number
    statut?: $Enums.StatutVente
    total_ttc: number
    total_ht: number
    type_acheteur: $Enums.TypeClient
    clientId?: number | null
    enregistrerParId: number
    fournisseurId?: number | null
    agentId?: number | null
    panierId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VenteCreateOrConnectWithoutPaiementInput = {
    where: VenteWhereUniqueInput
    create: XOR<VenteCreateWithoutPaiementInput, VenteUncheckedCreateWithoutPaiementInput>
  }

  export type VenteCreateManyPaiementInputEnvelope = {
    data: VenteCreateManyPaiementInput | VenteCreateManyPaiementInput[]
    skipDuplicates?: boolean
  }

  export type CaisseUpsertWithoutPaiementInput = {
    update: XOR<CaisseUpdateWithoutPaiementInput, CaisseUncheckedUpdateWithoutPaiementInput>
    create: XOR<CaisseCreateWithoutPaiementInput, CaisseUncheckedCreateWithoutPaiementInput>
    where?: CaisseWhereInput
  }

  export type CaisseUpdateToOneWithWhereWithoutPaiementInput = {
    where?: CaisseWhereInput
    data: XOR<CaisseUpdateWithoutPaiementInput, CaisseUncheckedUpdateWithoutPaiementInput>
  }

  export type CaisseUpdateWithoutPaiementInput = {
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    soldeInitial?: FloatFieldUpdateOperationsInput | number
    soldeActuel?: FloatFieldUpdateOperationsInput | number
    statut?: EnumStatutCaisseFieldUpdateOperationsInput | $Enums.StatutCaisse
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    devise?: DeviseUpdateOneRequiredWithoutCaisseNestedInput
    utilisateur?: UtilisateurUpdateOneRequiredWithoutCaisseNestedInput
    MouvementCaisse?: MouvementCaisseUpdateManyWithoutCaisseNestedInput
    clotures?: ClotureCaisseUpdateManyWithoutCaisseNestedInput
  }

  export type CaisseUncheckedUpdateWithoutPaiementInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    soldeInitial?: FloatFieldUpdateOperationsInput | number
    soldeActuel?: FloatFieldUpdateOperationsInput | number
    deviseId?: IntFieldUpdateOperationsInput | number
    creeParId?: IntFieldUpdateOperationsInput | number
    statut?: EnumStatutCaisseFieldUpdateOperationsInput | $Enums.StatutCaisse
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    MouvementCaisse?: MouvementCaisseUncheckedUpdateManyWithoutCaisseNestedInput
    clotures?: ClotureCaisseUncheckedUpdateManyWithoutCaisseNestedInput
  }

  export type DeviseUpsertWithoutPaiementInput = {
    update: XOR<DeviseUpdateWithoutPaiementInput, DeviseUncheckedUpdateWithoutPaiementInput>
    create: XOR<DeviseCreateWithoutPaiementInput, DeviseUncheckedCreateWithoutPaiementInput>
    where?: DeviseWhereInput
  }

  export type DeviseUpdateToOneWithWhereWithoutPaiementInput = {
    where?: DeviseWhereInput
    data: XOR<DeviseUpdateWithoutPaiementInput, DeviseUncheckedUpdateWithoutPaiementInput>
  }

  export type DeviseUpdateWithoutPaiementInput = {
    nom?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    symbole?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    utilisateur?: UtilisateurUpdateOneRequiredWithoutDeviseNestedInput
    Produit?: ProduitUpdateManyWithoutDeviseNestedInput
    Caisse?: CaisseUpdateManyWithoutDeviseNestedInput
  }

  export type DeviseUncheckedUpdateWithoutPaiementInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    symbole?: StringFieldUpdateOperationsInput | string
    utilisateurId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Produit?: ProduitUncheckedUpdateManyWithoutDeviseNestedInput
    Caisse?: CaisseUncheckedUpdateManyWithoutDeviseNestedInput
  }

  export type AchatUpsertWithWhereUniqueWithoutPaiementInput = {
    where: AchatWhereUniqueInput
    update: XOR<AchatUpdateWithoutPaiementInput, AchatUncheckedUpdateWithoutPaiementInput>
    create: XOR<AchatCreateWithoutPaiementInput, AchatUncheckedCreateWithoutPaiementInput>
  }

  export type AchatUpdateWithWhereUniqueWithoutPaiementInput = {
    where: AchatWhereUniqueInput
    data: XOR<AchatUpdateWithoutPaiementInput, AchatUncheckedUpdateWithoutPaiementInput>
  }

  export type AchatUpdateManyWithWhereWithoutPaiementInput = {
    where: AchatScalarWhereInput
    data: XOR<AchatUpdateManyMutationInput, AchatUncheckedUpdateManyWithoutPaiementInput>
  }

  export type CommandeUpsertWithWhereUniqueWithoutPaiementInput = {
    where: CommandeWhereUniqueInput
    update: XOR<CommandeUpdateWithoutPaiementInput, CommandeUncheckedUpdateWithoutPaiementInput>
    create: XOR<CommandeCreateWithoutPaiementInput, CommandeUncheckedCreateWithoutPaiementInput>
  }

  export type CommandeUpdateWithWhereUniqueWithoutPaiementInput = {
    where: CommandeWhereUniqueInput
    data: XOR<CommandeUpdateWithoutPaiementInput, CommandeUncheckedUpdateWithoutPaiementInput>
  }

  export type CommandeUpdateManyWithWhereWithoutPaiementInput = {
    where: CommandeScalarWhereInput
    data: XOR<CommandeUpdateManyMutationInput, CommandeUncheckedUpdateManyWithoutPaiementInput>
  }

  export type VenteUpsertWithWhereUniqueWithoutPaiementInput = {
    where: VenteWhereUniqueInput
    update: XOR<VenteUpdateWithoutPaiementInput, VenteUncheckedUpdateWithoutPaiementInput>
    create: XOR<VenteCreateWithoutPaiementInput, VenteUncheckedCreateWithoutPaiementInput>
  }

  export type VenteUpdateWithWhereUniqueWithoutPaiementInput = {
    where: VenteWhereUniqueInput
    data: XOR<VenteUpdateWithoutPaiementInput, VenteUncheckedUpdateWithoutPaiementInput>
  }

  export type VenteUpdateManyWithWhereWithoutPaiementInput = {
    where: VenteScalarWhereInput
    data: XOR<VenteUpdateManyMutationInput, VenteUncheckedUpdateManyWithoutPaiementInput>
  }

  export type DeviseCreateWithoutCaisseInput = {
    nom: string
    code: string
    symbole: string
    createdAt?: Date | string
    updatedAt?: Date | string
    utilisateur: UtilisateurCreateNestedOneWithoutDeviseInput
    Produit?: ProduitCreateNestedManyWithoutDeviseInput
    Paiement?: PaiementCreateNestedManyWithoutDeviseInput
  }

  export type DeviseUncheckedCreateWithoutCaisseInput = {
    id?: number
    nom: string
    code: string
    symbole: string
    utilisateurId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    Produit?: ProduitUncheckedCreateNestedManyWithoutDeviseInput
    Paiement?: PaiementUncheckedCreateNestedManyWithoutDeviseInput
  }

  export type DeviseCreateOrConnectWithoutCaisseInput = {
    where: DeviseWhereUniqueInput
    create: XOR<DeviseCreateWithoutCaisseInput, DeviseUncheckedCreateWithoutCaisseInput>
  }

  export type UtilisateurCreateWithoutCaisseInput = {
    email: string
    nom: string
    postnom: string
    nom_complet?: string | null
    sexe?: $Enums.Sexe | null
    role?: $Enums.Role
    poste?: $Enums.Poste | null
    picture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Adresse?: AdresseCreateNestedManyWithoutUtilisateurInput
    Contact?: ContactCreateNestedManyWithoutUtilisateurInput
    Produit?: ProduitCreateNestedManyWithoutUtilisateurInput
    Vente?: VenteCreateNestedManyWithoutUtilisateurInput
    Achat?: AchatCreateNestedManyWithoutUtilisateurInput
    Teneur?: TeneurCreateNestedManyWithoutUtilisateurInput
    Devise?: DeviseCreateNestedManyWithoutUtilisateurInput
    Panier?: PanierCreateNestedManyWithoutUtilisateurInput
    Reservation?: ReservationCreateNestedManyWithoutUtilisateurInput
    Commande?: CommandeCreateNestedManyWithoutClientInput
    MouvementCaisse?: MouvementCaisseCreateNestedManyWithoutUtilisateurInput
    ClotureCaisse?: ClotureCaisseCreateNestedManyWithoutUtilisateurClotureInput
  }

  export type UtilisateurUncheckedCreateWithoutCaisseInput = {
    id?: number
    email: string
    nom: string
    postnom: string
    nom_complet?: string | null
    sexe?: $Enums.Sexe | null
    role?: $Enums.Role
    poste?: $Enums.Poste | null
    picture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Adresse?: AdresseUncheckedCreateNestedManyWithoutUtilisateurInput
    Contact?: ContactUncheckedCreateNestedManyWithoutUtilisateurInput
    Produit?: ProduitUncheckedCreateNestedManyWithoutUtilisateurInput
    Vente?: VenteUncheckedCreateNestedManyWithoutUtilisateurInput
    Achat?: AchatUncheckedCreateNestedManyWithoutUtilisateurInput
    Teneur?: TeneurUncheckedCreateNestedManyWithoutUtilisateurInput
    Devise?: DeviseUncheckedCreateNestedManyWithoutUtilisateurInput
    Panier?: PanierUncheckedCreateNestedManyWithoutUtilisateurInput
    Reservation?: ReservationUncheckedCreateNestedManyWithoutUtilisateurInput
    Commande?: CommandeUncheckedCreateNestedManyWithoutClientInput
    MouvementCaisse?: MouvementCaisseUncheckedCreateNestedManyWithoutUtilisateurInput
    ClotureCaisse?: ClotureCaisseUncheckedCreateNestedManyWithoutUtilisateurClotureInput
  }

  export type UtilisateurCreateOrConnectWithoutCaisseInput = {
    where: UtilisateurWhereUniqueInput
    create: XOR<UtilisateurCreateWithoutCaisseInput, UtilisateurUncheckedCreateWithoutCaisseInput>
  }

  export type MouvementCaisseCreateWithoutCaisseInput = {
    type_mouvement?: $Enums.TypeMouvementCaisse
    categorie?: $Enums.CategorieMouvement
    montant: number
    description?: string | null
    referenceExterne?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    utilisateur: UtilisateurCreateNestedOneWithoutMouvementCaisseInput
  }

  export type MouvementCaisseUncheckedCreateWithoutCaisseInput = {
    id?: number
    type_mouvement?: $Enums.TypeMouvementCaisse
    categorie?: $Enums.CategorieMouvement
    montant: number
    description?: string | null
    enregistrerParId: number
    referenceExterne?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MouvementCaisseCreateOrConnectWithoutCaisseInput = {
    where: MouvementCaisseWhereUniqueInput
    create: XOR<MouvementCaisseCreateWithoutCaisseInput, MouvementCaisseUncheckedCreateWithoutCaisseInput>
  }

  export type MouvementCaisseCreateManyCaisseInputEnvelope = {
    data: MouvementCaisseCreateManyCaisseInput | MouvementCaisseCreateManyCaisseInput[]
    skipDuplicates?: boolean
  }

  export type ClotureCaisseCreateWithoutCaisseInput = {
    dateCloture?: Date | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    utilisateurCloture: UtilisateurCreateNestedOneWithoutClotureCaisseInput
    DetailClotureCaisse?: DetailClotureCaisseCreateNestedManyWithoutClotureCaisseInput
  }

  export type ClotureCaisseUncheckedCreateWithoutCaisseInput = {
    id?: number
    dateCloture?: Date | string
    utilisateurClotureId: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    DetailClotureCaisse?: DetailClotureCaisseUncheckedCreateNestedManyWithoutClotureCaisseInput
  }

  export type ClotureCaisseCreateOrConnectWithoutCaisseInput = {
    where: ClotureCaisseWhereUniqueInput
    create: XOR<ClotureCaisseCreateWithoutCaisseInput, ClotureCaisseUncheckedCreateWithoutCaisseInput>
  }

  export type ClotureCaisseCreateManyCaisseInputEnvelope = {
    data: ClotureCaisseCreateManyCaisseInput | ClotureCaisseCreateManyCaisseInput[]
    skipDuplicates?: boolean
  }

  export type PaiementCreateWithoutCaisseInput = {
    montant: number
    moyen_paiement: $Enums.MoyenPaiment
    createdAt?: Date | string
    updatedAt?: Date | string
    devise: DeviseCreateNestedOneWithoutPaiementInput
    Achat?: AchatCreateNestedManyWithoutPaiementInput
    Commande?: CommandeCreateNestedManyWithoutPaiementInput
    Vente?: VenteCreateNestedManyWithoutPaiementInput
  }

  export type PaiementUncheckedCreateWithoutCaisseInput = {
    id?: number
    montant: number
    moyen_paiement: $Enums.MoyenPaiment
    deviseId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    Achat?: AchatUncheckedCreateNestedManyWithoutPaiementInput
    Commande?: CommandeUncheckedCreateNestedManyWithoutPaiementInput
    Vente?: VenteUncheckedCreateNestedManyWithoutPaiementInput
  }

  export type PaiementCreateOrConnectWithoutCaisseInput = {
    where: PaiementWhereUniqueInput
    create: XOR<PaiementCreateWithoutCaisseInput, PaiementUncheckedCreateWithoutCaisseInput>
  }

  export type PaiementCreateManyCaisseInputEnvelope = {
    data: PaiementCreateManyCaisseInput | PaiementCreateManyCaisseInput[]
    skipDuplicates?: boolean
  }

  export type DeviseUpsertWithoutCaisseInput = {
    update: XOR<DeviseUpdateWithoutCaisseInput, DeviseUncheckedUpdateWithoutCaisseInput>
    create: XOR<DeviseCreateWithoutCaisseInput, DeviseUncheckedCreateWithoutCaisseInput>
    where?: DeviseWhereInput
  }

  export type DeviseUpdateToOneWithWhereWithoutCaisseInput = {
    where?: DeviseWhereInput
    data: XOR<DeviseUpdateWithoutCaisseInput, DeviseUncheckedUpdateWithoutCaisseInput>
  }

  export type DeviseUpdateWithoutCaisseInput = {
    nom?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    symbole?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    utilisateur?: UtilisateurUpdateOneRequiredWithoutDeviseNestedInput
    Produit?: ProduitUpdateManyWithoutDeviseNestedInput
    Paiement?: PaiementUpdateManyWithoutDeviseNestedInput
  }

  export type DeviseUncheckedUpdateWithoutCaisseInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    symbole?: StringFieldUpdateOperationsInput | string
    utilisateurId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Produit?: ProduitUncheckedUpdateManyWithoutDeviseNestedInput
    Paiement?: PaiementUncheckedUpdateManyWithoutDeviseNestedInput
  }

  export type UtilisateurUpsertWithoutCaisseInput = {
    update: XOR<UtilisateurUpdateWithoutCaisseInput, UtilisateurUncheckedUpdateWithoutCaisseInput>
    create: XOR<UtilisateurCreateWithoutCaisseInput, UtilisateurUncheckedCreateWithoutCaisseInput>
    where?: UtilisateurWhereInput
  }

  export type UtilisateurUpdateToOneWithWhereWithoutCaisseInput = {
    where?: UtilisateurWhereInput
    data: XOR<UtilisateurUpdateWithoutCaisseInput, UtilisateurUncheckedUpdateWithoutCaisseInput>
  }

  export type UtilisateurUpdateWithoutCaisseInput = {
    email?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    postnom?: StringFieldUpdateOperationsInput | string
    nom_complet?: NullableStringFieldUpdateOperationsInput | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    poste?: NullableEnumPosteFieldUpdateOperationsInput | $Enums.Poste | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Adresse?: AdresseUpdateManyWithoutUtilisateurNestedInput
    Contact?: ContactUpdateManyWithoutUtilisateurNestedInput
    Produit?: ProduitUpdateManyWithoutUtilisateurNestedInput
    Vente?: VenteUpdateManyWithoutUtilisateurNestedInput
    Achat?: AchatUpdateManyWithoutUtilisateurNestedInput
    Teneur?: TeneurUpdateManyWithoutUtilisateurNestedInput
    Devise?: DeviseUpdateManyWithoutUtilisateurNestedInput
    Panier?: PanierUpdateManyWithoutUtilisateurNestedInput
    Reservation?: ReservationUpdateManyWithoutUtilisateurNestedInput
    Commande?: CommandeUpdateManyWithoutClientNestedInput
    MouvementCaisse?: MouvementCaisseUpdateManyWithoutUtilisateurNestedInput
    ClotureCaisse?: ClotureCaisseUpdateManyWithoutUtilisateurClotureNestedInput
  }

  export type UtilisateurUncheckedUpdateWithoutCaisseInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    postnom?: StringFieldUpdateOperationsInput | string
    nom_complet?: NullableStringFieldUpdateOperationsInput | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    poste?: NullableEnumPosteFieldUpdateOperationsInput | $Enums.Poste | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Adresse?: AdresseUncheckedUpdateManyWithoutUtilisateurNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutUtilisateurNestedInput
    Produit?: ProduitUncheckedUpdateManyWithoutUtilisateurNestedInput
    Vente?: VenteUncheckedUpdateManyWithoutUtilisateurNestedInput
    Achat?: AchatUncheckedUpdateManyWithoutUtilisateurNestedInput
    Teneur?: TeneurUncheckedUpdateManyWithoutUtilisateurNestedInput
    Devise?: DeviseUncheckedUpdateManyWithoutUtilisateurNestedInput
    Panier?: PanierUncheckedUpdateManyWithoutUtilisateurNestedInput
    Reservation?: ReservationUncheckedUpdateManyWithoutUtilisateurNestedInput
    Commande?: CommandeUncheckedUpdateManyWithoutClientNestedInput
    MouvementCaisse?: MouvementCaisseUncheckedUpdateManyWithoutUtilisateurNestedInput
    ClotureCaisse?: ClotureCaisseUncheckedUpdateManyWithoutUtilisateurClotureNestedInput
  }

  export type MouvementCaisseUpsertWithWhereUniqueWithoutCaisseInput = {
    where: MouvementCaisseWhereUniqueInput
    update: XOR<MouvementCaisseUpdateWithoutCaisseInput, MouvementCaisseUncheckedUpdateWithoutCaisseInput>
    create: XOR<MouvementCaisseCreateWithoutCaisseInput, MouvementCaisseUncheckedCreateWithoutCaisseInput>
  }

  export type MouvementCaisseUpdateWithWhereUniqueWithoutCaisseInput = {
    where: MouvementCaisseWhereUniqueInput
    data: XOR<MouvementCaisseUpdateWithoutCaisseInput, MouvementCaisseUncheckedUpdateWithoutCaisseInput>
  }

  export type MouvementCaisseUpdateManyWithWhereWithoutCaisseInput = {
    where: MouvementCaisseScalarWhereInput
    data: XOR<MouvementCaisseUpdateManyMutationInput, MouvementCaisseUncheckedUpdateManyWithoutCaisseInput>
  }

  export type ClotureCaisseUpsertWithWhereUniqueWithoutCaisseInput = {
    where: ClotureCaisseWhereUniqueInput
    update: XOR<ClotureCaisseUpdateWithoutCaisseInput, ClotureCaisseUncheckedUpdateWithoutCaisseInput>
    create: XOR<ClotureCaisseCreateWithoutCaisseInput, ClotureCaisseUncheckedCreateWithoutCaisseInput>
  }

  export type ClotureCaisseUpdateWithWhereUniqueWithoutCaisseInput = {
    where: ClotureCaisseWhereUniqueInput
    data: XOR<ClotureCaisseUpdateWithoutCaisseInput, ClotureCaisseUncheckedUpdateWithoutCaisseInput>
  }

  export type ClotureCaisseUpdateManyWithWhereWithoutCaisseInput = {
    where: ClotureCaisseScalarWhereInput
    data: XOR<ClotureCaisseUpdateManyMutationInput, ClotureCaisseUncheckedUpdateManyWithoutCaisseInput>
  }

  export type PaiementUpsertWithWhereUniqueWithoutCaisseInput = {
    where: PaiementWhereUniqueInput
    update: XOR<PaiementUpdateWithoutCaisseInput, PaiementUncheckedUpdateWithoutCaisseInput>
    create: XOR<PaiementCreateWithoutCaisseInput, PaiementUncheckedCreateWithoutCaisseInput>
  }

  export type PaiementUpdateWithWhereUniqueWithoutCaisseInput = {
    where: PaiementWhereUniqueInput
    data: XOR<PaiementUpdateWithoutCaisseInput, PaiementUncheckedUpdateWithoutCaisseInput>
  }

  export type PaiementUpdateManyWithWhereWithoutCaisseInput = {
    where: PaiementScalarWhereInput
    data: XOR<PaiementUpdateManyMutationInput, PaiementUncheckedUpdateManyWithoutCaisseInput>
  }

  export type PaiementCreateWithoutVenteInput = {
    montant: number
    moyen_paiement: $Enums.MoyenPaiment
    createdAt?: Date | string
    updatedAt?: Date | string
    caisse: CaisseCreateNestedOneWithoutPaiementInput
    devise: DeviseCreateNestedOneWithoutPaiementInput
    Achat?: AchatCreateNestedManyWithoutPaiementInput
    Commande?: CommandeCreateNestedManyWithoutPaiementInput
  }

  export type PaiementUncheckedCreateWithoutVenteInput = {
    id?: number
    montant: number
    moyen_paiement: $Enums.MoyenPaiment
    deviseId: number
    caisseId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    Achat?: AchatUncheckedCreateNestedManyWithoutPaiementInput
    Commande?: CommandeUncheckedCreateNestedManyWithoutPaiementInput
  }

  export type PaiementCreateOrConnectWithoutVenteInput = {
    where: PaiementWhereUniqueInput
    create: XOR<PaiementCreateWithoutVenteInput, PaiementUncheckedCreateWithoutVenteInput>
  }

  export type PanierCreateWithoutVenteInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    utilisateur: UtilisateurCreateNestedOneWithoutPanierInput
    DetailPanier?: DetailPanierCreateNestedManyWithoutPanierInput
    Achat?: AchatCreateNestedManyWithoutPanierInput
    Reservation?: ReservationCreateNestedManyWithoutPanierInput
    Commande?: CommandeCreateNestedManyWithoutPanierInput
  }

  export type PanierUncheckedCreateWithoutVenteInput = {
    id?: number
    utilisateurId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    DetailPanier?: DetailPanierUncheckedCreateNestedManyWithoutPanierInput
    Achat?: AchatUncheckedCreateNestedManyWithoutPanierInput
    Reservation?: ReservationUncheckedCreateNestedManyWithoutPanierInput
    Commande?: CommandeUncheckedCreateNestedManyWithoutPanierInput
  }

  export type PanierCreateOrConnectWithoutVenteInput = {
    where: PanierWhereUniqueInput
    create: XOR<PanierCreateWithoutVenteInput, PanierUncheckedCreateWithoutVenteInput>
  }

  export type UtilisateurCreateWithoutVenteInput = {
    email: string
    nom: string
    postnom: string
    nom_complet?: string | null
    sexe?: $Enums.Sexe | null
    role?: $Enums.Role
    poste?: $Enums.Poste | null
    picture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Adresse?: AdresseCreateNestedManyWithoutUtilisateurInput
    Contact?: ContactCreateNestedManyWithoutUtilisateurInput
    Produit?: ProduitCreateNestedManyWithoutUtilisateurInput
    Achat?: AchatCreateNestedManyWithoutUtilisateurInput
    Teneur?: TeneurCreateNestedManyWithoutUtilisateurInput
    Devise?: DeviseCreateNestedManyWithoutUtilisateurInput
    Panier?: PanierCreateNestedManyWithoutUtilisateurInput
    Reservation?: ReservationCreateNestedManyWithoutUtilisateurInput
    Commande?: CommandeCreateNestedManyWithoutClientInput
    Caisse?: CaisseCreateNestedManyWithoutUtilisateurInput
    MouvementCaisse?: MouvementCaisseCreateNestedManyWithoutUtilisateurInput
    ClotureCaisse?: ClotureCaisseCreateNestedManyWithoutUtilisateurClotureInput
  }

  export type UtilisateurUncheckedCreateWithoutVenteInput = {
    id?: number
    email: string
    nom: string
    postnom: string
    nom_complet?: string | null
    sexe?: $Enums.Sexe | null
    role?: $Enums.Role
    poste?: $Enums.Poste | null
    picture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Adresse?: AdresseUncheckedCreateNestedManyWithoutUtilisateurInput
    Contact?: ContactUncheckedCreateNestedManyWithoutUtilisateurInput
    Produit?: ProduitUncheckedCreateNestedManyWithoutUtilisateurInput
    Achat?: AchatUncheckedCreateNestedManyWithoutUtilisateurInput
    Teneur?: TeneurUncheckedCreateNestedManyWithoutUtilisateurInput
    Devise?: DeviseUncheckedCreateNestedManyWithoutUtilisateurInput
    Panier?: PanierUncheckedCreateNestedManyWithoutUtilisateurInput
    Reservation?: ReservationUncheckedCreateNestedManyWithoutUtilisateurInput
    Commande?: CommandeUncheckedCreateNestedManyWithoutClientInput
    Caisse?: CaisseUncheckedCreateNestedManyWithoutUtilisateurInput
    MouvementCaisse?: MouvementCaisseUncheckedCreateNestedManyWithoutUtilisateurInput
    ClotureCaisse?: ClotureCaisseUncheckedCreateNestedManyWithoutUtilisateurClotureInput
  }

  export type UtilisateurCreateOrConnectWithoutVenteInput = {
    where: UtilisateurWhereUniqueInput
    create: XOR<UtilisateurCreateWithoutVenteInput, UtilisateurUncheckedCreateWithoutVenteInput>
  }

  export type FournisseurCreateWithoutVenteInput = {
    nom: string
    email: string
    code_postal?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Achat?: AchatCreateNestedManyWithoutFournisseurInput
    Adresse?: AdresseCreateNestedManyWithoutFournisseurInput
    Contact?: ContactCreateNestedManyWithoutFournisseurInput
    Reservation?: ReservationCreateNestedManyWithoutFournisseurInput
    Commande?: CommandeCreateNestedManyWithoutFournisseurInput
  }

  export type FournisseurUncheckedCreateWithoutVenteInput = {
    id?: number
    nom: string
    email: string
    code_postal?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Achat?: AchatUncheckedCreateNestedManyWithoutFournisseurInput
    Adresse?: AdresseUncheckedCreateNestedManyWithoutFournisseurInput
    Contact?: ContactUncheckedCreateNestedManyWithoutFournisseurInput
    Reservation?: ReservationUncheckedCreateNestedManyWithoutFournisseurInput
    Commande?: CommandeUncheckedCreateNestedManyWithoutFournisseurInput
  }

  export type FournisseurCreateOrConnectWithoutVenteInput = {
    where: FournisseurWhereUniqueInput
    create: XOR<FournisseurCreateWithoutVenteInput, FournisseurUncheckedCreateWithoutVenteInput>
  }

  export type PaiementUpsertWithoutVenteInput = {
    update: XOR<PaiementUpdateWithoutVenteInput, PaiementUncheckedUpdateWithoutVenteInput>
    create: XOR<PaiementCreateWithoutVenteInput, PaiementUncheckedCreateWithoutVenteInput>
    where?: PaiementWhereInput
  }

  export type PaiementUpdateToOneWithWhereWithoutVenteInput = {
    where?: PaiementWhereInput
    data: XOR<PaiementUpdateWithoutVenteInput, PaiementUncheckedUpdateWithoutVenteInput>
  }

  export type PaiementUpdateWithoutVenteInput = {
    montant?: FloatFieldUpdateOperationsInput | number
    moyen_paiement?: EnumMoyenPaimentFieldUpdateOperationsInput | $Enums.MoyenPaiment
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    caisse?: CaisseUpdateOneRequiredWithoutPaiementNestedInput
    devise?: DeviseUpdateOneRequiredWithoutPaiementNestedInput
    Achat?: AchatUpdateManyWithoutPaiementNestedInput
    Commande?: CommandeUpdateManyWithoutPaiementNestedInput
  }

  export type PaiementUncheckedUpdateWithoutVenteInput = {
    id?: IntFieldUpdateOperationsInput | number
    montant?: FloatFieldUpdateOperationsInput | number
    moyen_paiement?: EnumMoyenPaimentFieldUpdateOperationsInput | $Enums.MoyenPaiment
    deviseId?: IntFieldUpdateOperationsInput | number
    caisseId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Achat?: AchatUncheckedUpdateManyWithoutPaiementNestedInput
    Commande?: CommandeUncheckedUpdateManyWithoutPaiementNestedInput
  }

  export type PanierUpsertWithoutVenteInput = {
    update: XOR<PanierUpdateWithoutVenteInput, PanierUncheckedUpdateWithoutVenteInput>
    create: XOR<PanierCreateWithoutVenteInput, PanierUncheckedCreateWithoutVenteInput>
    where?: PanierWhereInput
  }

  export type PanierUpdateToOneWithWhereWithoutVenteInput = {
    where?: PanierWhereInput
    data: XOR<PanierUpdateWithoutVenteInput, PanierUncheckedUpdateWithoutVenteInput>
  }

  export type PanierUpdateWithoutVenteInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    utilisateur?: UtilisateurUpdateOneRequiredWithoutPanierNestedInput
    DetailPanier?: DetailPanierUpdateManyWithoutPanierNestedInput
    Achat?: AchatUpdateManyWithoutPanierNestedInput
    Reservation?: ReservationUpdateManyWithoutPanierNestedInput
    Commande?: CommandeUpdateManyWithoutPanierNestedInput
  }

  export type PanierUncheckedUpdateWithoutVenteInput = {
    id?: IntFieldUpdateOperationsInput | number
    utilisateurId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DetailPanier?: DetailPanierUncheckedUpdateManyWithoutPanierNestedInput
    Achat?: AchatUncheckedUpdateManyWithoutPanierNestedInput
    Reservation?: ReservationUncheckedUpdateManyWithoutPanierNestedInput
    Commande?: CommandeUncheckedUpdateManyWithoutPanierNestedInput
  }

  export type UtilisateurUpsertWithoutVenteInput = {
    update: XOR<UtilisateurUpdateWithoutVenteInput, UtilisateurUncheckedUpdateWithoutVenteInput>
    create: XOR<UtilisateurCreateWithoutVenteInput, UtilisateurUncheckedCreateWithoutVenteInput>
    where?: UtilisateurWhereInput
  }

  export type UtilisateurUpdateToOneWithWhereWithoutVenteInput = {
    where?: UtilisateurWhereInput
    data: XOR<UtilisateurUpdateWithoutVenteInput, UtilisateurUncheckedUpdateWithoutVenteInput>
  }

  export type UtilisateurUpdateWithoutVenteInput = {
    email?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    postnom?: StringFieldUpdateOperationsInput | string
    nom_complet?: NullableStringFieldUpdateOperationsInput | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    poste?: NullableEnumPosteFieldUpdateOperationsInput | $Enums.Poste | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Adresse?: AdresseUpdateManyWithoutUtilisateurNestedInput
    Contact?: ContactUpdateManyWithoutUtilisateurNestedInput
    Produit?: ProduitUpdateManyWithoutUtilisateurNestedInput
    Achat?: AchatUpdateManyWithoutUtilisateurNestedInput
    Teneur?: TeneurUpdateManyWithoutUtilisateurNestedInput
    Devise?: DeviseUpdateManyWithoutUtilisateurNestedInput
    Panier?: PanierUpdateManyWithoutUtilisateurNestedInput
    Reservation?: ReservationUpdateManyWithoutUtilisateurNestedInput
    Commande?: CommandeUpdateManyWithoutClientNestedInput
    Caisse?: CaisseUpdateManyWithoutUtilisateurNestedInput
    MouvementCaisse?: MouvementCaisseUpdateManyWithoutUtilisateurNestedInput
    ClotureCaisse?: ClotureCaisseUpdateManyWithoutUtilisateurClotureNestedInput
  }

  export type UtilisateurUncheckedUpdateWithoutVenteInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    postnom?: StringFieldUpdateOperationsInput | string
    nom_complet?: NullableStringFieldUpdateOperationsInput | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    poste?: NullableEnumPosteFieldUpdateOperationsInput | $Enums.Poste | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Adresse?: AdresseUncheckedUpdateManyWithoutUtilisateurNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutUtilisateurNestedInput
    Produit?: ProduitUncheckedUpdateManyWithoutUtilisateurNestedInput
    Achat?: AchatUncheckedUpdateManyWithoutUtilisateurNestedInput
    Teneur?: TeneurUncheckedUpdateManyWithoutUtilisateurNestedInput
    Devise?: DeviseUncheckedUpdateManyWithoutUtilisateurNestedInput
    Panier?: PanierUncheckedUpdateManyWithoutUtilisateurNestedInput
    Reservation?: ReservationUncheckedUpdateManyWithoutUtilisateurNestedInput
    Commande?: CommandeUncheckedUpdateManyWithoutClientNestedInput
    Caisse?: CaisseUncheckedUpdateManyWithoutUtilisateurNestedInput
    MouvementCaisse?: MouvementCaisseUncheckedUpdateManyWithoutUtilisateurNestedInput
    ClotureCaisse?: ClotureCaisseUncheckedUpdateManyWithoutUtilisateurClotureNestedInput
  }

  export type FournisseurUpsertWithoutVenteInput = {
    update: XOR<FournisseurUpdateWithoutVenteInput, FournisseurUncheckedUpdateWithoutVenteInput>
    create: XOR<FournisseurCreateWithoutVenteInput, FournisseurUncheckedCreateWithoutVenteInput>
    where?: FournisseurWhereInput
  }

  export type FournisseurUpdateToOneWithWhereWithoutVenteInput = {
    where?: FournisseurWhereInput
    data: XOR<FournisseurUpdateWithoutVenteInput, FournisseurUncheckedUpdateWithoutVenteInput>
  }

  export type FournisseurUpdateWithoutVenteInput = {
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    code_postal?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Achat?: AchatUpdateManyWithoutFournisseurNestedInput
    Adresse?: AdresseUpdateManyWithoutFournisseurNestedInput
    Contact?: ContactUpdateManyWithoutFournisseurNestedInput
    Reservation?: ReservationUpdateManyWithoutFournisseurNestedInput
    Commande?: CommandeUpdateManyWithoutFournisseurNestedInput
  }

  export type FournisseurUncheckedUpdateWithoutVenteInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    code_postal?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Achat?: AchatUncheckedUpdateManyWithoutFournisseurNestedInput
    Adresse?: AdresseUncheckedUpdateManyWithoutFournisseurNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutFournisseurNestedInput
    Reservation?: ReservationUncheckedUpdateManyWithoutFournisseurNestedInput
    Commande?: CommandeUncheckedUpdateManyWithoutFournisseurNestedInput
  }

  export type UtilisateurCreateWithoutPanierInput = {
    email: string
    nom: string
    postnom: string
    nom_complet?: string | null
    sexe?: $Enums.Sexe | null
    role?: $Enums.Role
    poste?: $Enums.Poste | null
    picture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Adresse?: AdresseCreateNestedManyWithoutUtilisateurInput
    Contact?: ContactCreateNestedManyWithoutUtilisateurInput
    Produit?: ProduitCreateNestedManyWithoutUtilisateurInput
    Vente?: VenteCreateNestedManyWithoutUtilisateurInput
    Achat?: AchatCreateNestedManyWithoutUtilisateurInput
    Teneur?: TeneurCreateNestedManyWithoutUtilisateurInput
    Devise?: DeviseCreateNestedManyWithoutUtilisateurInput
    Reservation?: ReservationCreateNestedManyWithoutUtilisateurInput
    Commande?: CommandeCreateNestedManyWithoutClientInput
    Caisse?: CaisseCreateNestedManyWithoutUtilisateurInput
    MouvementCaisse?: MouvementCaisseCreateNestedManyWithoutUtilisateurInput
    ClotureCaisse?: ClotureCaisseCreateNestedManyWithoutUtilisateurClotureInput
  }

  export type UtilisateurUncheckedCreateWithoutPanierInput = {
    id?: number
    email: string
    nom: string
    postnom: string
    nom_complet?: string | null
    sexe?: $Enums.Sexe | null
    role?: $Enums.Role
    poste?: $Enums.Poste | null
    picture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Adresse?: AdresseUncheckedCreateNestedManyWithoutUtilisateurInput
    Contact?: ContactUncheckedCreateNestedManyWithoutUtilisateurInput
    Produit?: ProduitUncheckedCreateNestedManyWithoutUtilisateurInput
    Vente?: VenteUncheckedCreateNestedManyWithoutUtilisateurInput
    Achat?: AchatUncheckedCreateNestedManyWithoutUtilisateurInput
    Teneur?: TeneurUncheckedCreateNestedManyWithoutUtilisateurInput
    Devise?: DeviseUncheckedCreateNestedManyWithoutUtilisateurInput
    Reservation?: ReservationUncheckedCreateNestedManyWithoutUtilisateurInput
    Commande?: CommandeUncheckedCreateNestedManyWithoutClientInput
    Caisse?: CaisseUncheckedCreateNestedManyWithoutUtilisateurInput
    MouvementCaisse?: MouvementCaisseUncheckedCreateNestedManyWithoutUtilisateurInput
    ClotureCaisse?: ClotureCaisseUncheckedCreateNestedManyWithoutUtilisateurClotureInput
  }

  export type UtilisateurCreateOrConnectWithoutPanierInput = {
    where: UtilisateurWhereUniqueInput
    create: XOR<UtilisateurCreateWithoutPanierInput, UtilisateurUncheckedCreateWithoutPanierInput>
  }

  export type DetailPanierCreateWithoutPanierInput = {
    qtte: number
    prixUnitaire: number
    prixTotal: number
    createdAt?: Date | string
    updatedAt?: Date | string
    produit: ProduitCreateNestedOneWithoutDetailPanierInput
  }

  export type DetailPanierUncheckedCreateWithoutPanierInput = {
    id?: number
    produitId: number
    qtte: number
    prixUnitaire: number
    prixTotal: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DetailPanierCreateOrConnectWithoutPanierInput = {
    where: DetailPanierWhereUniqueInput
    create: XOR<DetailPanierCreateWithoutPanierInput, DetailPanierUncheckedCreateWithoutPanierInput>
  }

  export type DetailPanierCreateManyPanierInputEnvelope = {
    data: DetailPanierCreateManyPanierInput | DetailPanierCreateManyPanierInput[]
    skipDuplicates?: boolean
  }

  export type AchatCreateWithoutPanierInput = {
    statut?: $Enums.StatutAchat
    createdAt?: Date | string
    updatedAt?: Date | string
    fournisseur: FournisseurCreateNestedOneWithoutAchatInput
    utilisateur: UtilisateurCreateNestedOneWithoutAchatInput
    paiement: PaiementCreateNestedOneWithoutAchatInput
  }

  export type AchatUncheckedCreateWithoutPanierInput = {
    id?: number
    statut?: $Enums.StatutAchat
    fournisseurId: number
    enregistrerParId: number
    paiementId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AchatCreateOrConnectWithoutPanierInput = {
    where: AchatWhereUniqueInput
    create: XOR<AchatCreateWithoutPanierInput, AchatUncheckedCreateWithoutPanierInput>
  }

  export type AchatCreateManyPanierInputEnvelope = {
    data: AchatCreateManyPanierInput | AchatCreateManyPanierInput[]
    skipDuplicates?: boolean
  }

  export type VenteCreateWithoutPanierInput = {
    statut?: $Enums.StatutVente
    total_ttc: number
    total_ht: number
    type_acheteur: $Enums.TypeClient
    clientId?: number | null
    agentId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    paiement?: PaiementCreateNestedOneWithoutVenteInput
    utilisateur: UtilisateurCreateNestedOneWithoutVenteInput
    fournisseur?: FournisseurCreateNestedOneWithoutVenteInput
  }

  export type VenteUncheckedCreateWithoutPanierInput = {
    id?: number
    statut?: $Enums.StatutVente
    total_ttc: number
    total_ht: number
    type_acheteur: $Enums.TypeClient
    clientId?: number | null
    enregistrerParId: number
    fournisseurId?: number | null
    agentId?: number | null
    paiementId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VenteCreateOrConnectWithoutPanierInput = {
    where: VenteWhereUniqueInput
    create: XOR<VenteCreateWithoutPanierInput, VenteUncheckedCreateWithoutPanierInput>
  }

  export type VenteCreateManyPanierInputEnvelope = {
    data: VenteCreateManyPanierInput | VenteCreateManyPanierInput[]
    skipDuplicates?: boolean
  }

  export type ReservationCreateWithoutPanierInput = {
    dateLivraisonSouhaitee: Date | string
    adresseLivraison?: string | null
    statut?: $Enums.StatutReservation
    notes?: string | null
    type_client?: $Enums.TypeClient
    nom?: string | null
    tel?: string | null
    enregistrerParId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    utilisateur?: UtilisateurCreateNestedOneWithoutReservationInput
    fournisseur?: FournisseurCreateNestedOneWithoutReservationInput
    adresse?: AdresseCreateNestedOneWithoutReservationInput
    contact?: ContactCreateNestedOneWithoutReservationInput
  }

  export type ReservationUncheckedCreateWithoutPanierInput = {
    id?: number
    dateLivraisonSouhaitee: Date | string
    adresseLivraison?: string | null
    statut?: $Enums.StatutReservation
    notes?: string | null
    type_client?: $Enums.TypeClient
    clientId?: number | null
    nom?: string | null
    tel?: string | null
    adresseId?: number | null
    contactId?: number | null
    enregistrerParId?: number | null
    fournisseurId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReservationCreateOrConnectWithoutPanierInput = {
    where: ReservationWhereUniqueInput
    create: XOR<ReservationCreateWithoutPanierInput, ReservationUncheckedCreateWithoutPanierInput>
  }

  export type ReservationCreateManyPanierInputEnvelope = {
    data: ReservationCreateManyPanierInput | ReservationCreateManyPanierInput[]
    skipDuplicates?: boolean
  }

  export type CommandeCreateWithoutPanierInput = {
    nom?: string | null
    tel?: string | null
    type_client?: $Enums.TypeClient
    notes?: string | null
    dateLivraisonEffective?: Date | string | null
    adresseLivraison?: string | null
    enregistrerParId?: number | null
    statut?: $Enums.StatutCommande
    createdAt?: Date | string
    updatedAt?: Date | string
    client?: UtilisateurCreateNestedOneWithoutCommandeInput
    paiement: PaiementCreateNestedOneWithoutCommandeInput
    fournisseur?: FournisseurCreateNestedOneWithoutCommandeInput
    adresse?: AdresseCreateNestedOneWithoutCommandeInput
    contact?: ContactCreateNestedOneWithoutCommandeInput
  }

  export type CommandeUncheckedCreateWithoutPanierInput = {
    id?: number
    clientId?: number | null
    nom?: string | null
    tel?: string | null
    type_client?: $Enums.TypeClient
    paiementId: number
    adresseId?: number | null
    contactId?: number | null
    fournisseurId?: number | null
    notes?: string | null
    dateLivraisonEffective?: Date | string | null
    adresseLivraison?: string | null
    enregistrerParId?: number | null
    statut?: $Enums.StatutCommande
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommandeCreateOrConnectWithoutPanierInput = {
    where: CommandeWhereUniqueInput
    create: XOR<CommandeCreateWithoutPanierInput, CommandeUncheckedCreateWithoutPanierInput>
  }

  export type CommandeCreateManyPanierInputEnvelope = {
    data: CommandeCreateManyPanierInput | CommandeCreateManyPanierInput[]
    skipDuplicates?: boolean
  }

  export type UtilisateurUpsertWithoutPanierInput = {
    update: XOR<UtilisateurUpdateWithoutPanierInput, UtilisateurUncheckedUpdateWithoutPanierInput>
    create: XOR<UtilisateurCreateWithoutPanierInput, UtilisateurUncheckedCreateWithoutPanierInput>
    where?: UtilisateurWhereInput
  }

  export type UtilisateurUpdateToOneWithWhereWithoutPanierInput = {
    where?: UtilisateurWhereInput
    data: XOR<UtilisateurUpdateWithoutPanierInput, UtilisateurUncheckedUpdateWithoutPanierInput>
  }

  export type UtilisateurUpdateWithoutPanierInput = {
    email?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    postnom?: StringFieldUpdateOperationsInput | string
    nom_complet?: NullableStringFieldUpdateOperationsInput | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    poste?: NullableEnumPosteFieldUpdateOperationsInput | $Enums.Poste | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Adresse?: AdresseUpdateManyWithoutUtilisateurNestedInput
    Contact?: ContactUpdateManyWithoutUtilisateurNestedInput
    Produit?: ProduitUpdateManyWithoutUtilisateurNestedInput
    Vente?: VenteUpdateManyWithoutUtilisateurNestedInput
    Achat?: AchatUpdateManyWithoutUtilisateurNestedInput
    Teneur?: TeneurUpdateManyWithoutUtilisateurNestedInput
    Devise?: DeviseUpdateManyWithoutUtilisateurNestedInput
    Reservation?: ReservationUpdateManyWithoutUtilisateurNestedInput
    Commande?: CommandeUpdateManyWithoutClientNestedInput
    Caisse?: CaisseUpdateManyWithoutUtilisateurNestedInput
    MouvementCaisse?: MouvementCaisseUpdateManyWithoutUtilisateurNestedInput
    ClotureCaisse?: ClotureCaisseUpdateManyWithoutUtilisateurClotureNestedInput
  }

  export type UtilisateurUncheckedUpdateWithoutPanierInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    postnom?: StringFieldUpdateOperationsInput | string
    nom_complet?: NullableStringFieldUpdateOperationsInput | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    poste?: NullableEnumPosteFieldUpdateOperationsInput | $Enums.Poste | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Adresse?: AdresseUncheckedUpdateManyWithoutUtilisateurNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutUtilisateurNestedInput
    Produit?: ProduitUncheckedUpdateManyWithoutUtilisateurNestedInput
    Vente?: VenteUncheckedUpdateManyWithoutUtilisateurNestedInput
    Achat?: AchatUncheckedUpdateManyWithoutUtilisateurNestedInput
    Teneur?: TeneurUncheckedUpdateManyWithoutUtilisateurNestedInput
    Devise?: DeviseUncheckedUpdateManyWithoutUtilisateurNestedInput
    Reservation?: ReservationUncheckedUpdateManyWithoutUtilisateurNestedInput
    Commande?: CommandeUncheckedUpdateManyWithoutClientNestedInput
    Caisse?: CaisseUncheckedUpdateManyWithoutUtilisateurNestedInput
    MouvementCaisse?: MouvementCaisseUncheckedUpdateManyWithoutUtilisateurNestedInput
    ClotureCaisse?: ClotureCaisseUncheckedUpdateManyWithoutUtilisateurClotureNestedInput
  }

  export type DetailPanierUpsertWithWhereUniqueWithoutPanierInput = {
    where: DetailPanierWhereUniqueInput
    update: XOR<DetailPanierUpdateWithoutPanierInput, DetailPanierUncheckedUpdateWithoutPanierInput>
    create: XOR<DetailPanierCreateWithoutPanierInput, DetailPanierUncheckedCreateWithoutPanierInput>
  }

  export type DetailPanierUpdateWithWhereUniqueWithoutPanierInput = {
    where: DetailPanierWhereUniqueInput
    data: XOR<DetailPanierUpdateWithoutPanierInput, DetailPanierUncheckedUpdateWithoutPanierInput>
  }

  export type DetailPanierUpdateManyWithWhereWithoutPanierInput = {
    where: DetailPanierScalarWhereInput
    data: XOR<DetailPanierUpdateManyMutationInput, DetailPanierUncheckedUpdateManyWithoutPanierInput>
  }

  export type AchatUpsertWithWhereUniqueWithoutPanierInput = {
    where: AchatWhereUniqueInput
    update: XOR<AchatUpdateWithoutPanierInput, AchatUncheckedUpdateWithoutPanierInput>
    create: XOR<AchatCreateWithoutPanierInput, AchatUncheckedCreateWithoutPanierInput>
  }

  export type AchatUpdateWithWhereUniqueWithoutPanierInput = {
    where: AchatWhereUniqueInput
    data: XOR<AchatUpdateWithoutPanierInput, AchatUncheckedUpdateWithoutPanierInput>
  }

  export type AchatUpdateManyWithWhereWithoutPanierInput = {
    where: AchatScalarWhereInput
    data: XOR<AchatUpdateManyMutationInput, AchatUncheckedUpdateManyWithoutPanierInput>
  }

  export type VenteUpsertWithWhereUniqueWithoutPanierInput = {
    where: VenteWhereUniqueInput
    update: XOR<VenteUpdateWithoutPanierInput, VenteUncheckedUpdateWithoutPanierInput>
    create: XOR<VenteCreateWithoutPanierInput, VenteUncheckedCreateWithoutPanierInput>
  }

  export type VenteUpdateWithWhereUniqueWithoutPanierInput = {
    where: VenteWhereUniqueInput
    data: XOR<VenteUpdateWithoutPanierInput, VenteUncheckedUpdateWithoutPanierInput>
  }

  export type VenteUpdateManyWithWhereWithoutPanierInput = {
    where: VenteScalarWhereInput
    data: XOR<VenteUpdateManyMutationInput, VenteUncheckedUpdateManyWithoutPanierInput>
  }

  export type ReservationUpsertWithWhereUniqueWithoutPanierInput = {
    where: ReservationWhereUniqueInput
    update: XOR<ReservationUpdateWithoutPanierInput, ReservationUncheckedUpdateWithoutPanierInput>
    create: XOR<ReservationCreateWithoutPanierInput, ReservationUncheckedCreateWithoutPanierInput>
  }

  export type ReservationUpdateWithWhereUniqueWithoutPanierInput = {
    where: ReservationWhereUniqueInput
    data: XOR<ReservationUpdateWithoutPanierInput, ReservationUncheckedUpdateWithoutPanierInput>
  }

  export type ReservationUpdateManyWithWhereWithoutPanierInput = {
    where: ReservationScalarWhereInput
    data: XOR<ReservationUpdateManyMutationInput, ReservationUncheckedUpdateManyWithoutPanierInput>
  }

  export type CommandeUpsertWithWhereUniqueWithoutPanierInput = {
    where: CommandeWhereUniqueInput
    update: XOR<CommandeUpdateWithoutPanierInput, CommandeUncheckedUpdateWithoutPanierInput>
    create: XOR<CommandeCreateWithoutPanierInput, CommandeUncheckedCreateWithoutPanierInput>
  }

  export type CommandeUpdateWithWhereUniqueWithoutPanierInput = {
    where: CommandeWhereUniqueInput
    data: XOR<CommandeUpdateWithoutPanierInput, CommandeUncheckedUpdateWithoutPanierInput>
  }

  export type CommandeUpdateManyWithWhereWithoutPanierInput = {
    where: CommandeScalarWhereInput
    data: XOR<CommandeUpdateManyMutationInput, CommandeUncheckedUpdateManyWithoutPanierInput>
  }

  export type ProduitCreateWithoutDetailPanierInput = {
    designation: string
    prix: number
    qtte?: number
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    devise: DeviseCreateNestedOneWithoutProduitInput
    teneur: TeneurCreateNestedOneWithoutProduitInput
    utilisateur: UtilisateurCreateNestedOneWithoutProduitInput
    DetailClotureCaisse?: DetailClotureCaisseCreateNestedManyWithoutProduitInput
  }

  export type ProduitUncheckedCreateWithoutDetailPanierInput = {
    id?: number
    designation: string
    prix: number
    qtte?: number
    description: string
    deviseId: number
    teneurId: number
    utilisateurId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    DetailClotureCaisse?: DetailClotureCaisseUncheckedCreateNestedManyWithoutProduitInput
  }

  export type ProduitCreateOrConnectWithoutDetailPanierInput = {
    where: ProduitWhereUniqueInput
    create: XOR<ProduitCreateWithoutDetailPanierInput, ProduitUncheckedCreateWithoutDetailPanierInput>
  }

  export type PanierCreateWithoutDetailPanierInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    utilisateur: UtilisateurCreateNestedOneWithoutPanierInput
    Achat?: AchatCreateNestedManyWithoutPanierInput
    Vente?: VenteCreateNestedManyWithoutPanierInput
    Reservation?: ReservationCreateNestedManyWithoutPanierInput
    Commande?: CommandeCreateNestedManyWithoutPanierInput
  }

  export type PanierUncheckedCreateWithoutDetailPanierInput = {
    id?: number
    utilisateurId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    Achat?: AchatUncheckedCreateNestedManyWithoutPanierInput
    Vente?: VenteUncheckedCreateNestedManyWithoutPanierInput
    Reservation?: ReservationUncheckedCreateNestedManyWithoutPanierInput
    Commande?: CommandeUncheckedCreateNestedManyWithoutPanierInput
  }

  export type PanierCreateOrConnectWithoutDetailPanierInput = {
    where: PanierWhereUniqueInput
    create: XOR<PanierCreateWithoutDetailPanierInput, PanierUncheckedCreateWithoutDetailPanierInput>
  }

  export type ProduitUpsertWithoutDetailPanierInput = {
    update: XOR<ProduitUpdateWithoutDetailPanierInput, ProduitUncheckedUpdateWithoutDetailPanierInput>
    create: XOR<ProduitCreateWithoutDetailPanierInput, ProduitUncheckedCreateWithoutDetailPanierInput>
    where?: ProduitWhereInput
  }

  export type ProduitUpdateToOneWithWhereWithoutDetailPanierInput = {
    where?: ProduitWhereInput
    data: XOR<ProduitUpdateWithoutDetailPanierInput, ProduitUncheckedUpdateWithoutDetailPanierInput>
  }

  export type ProduitUpdateWithoutDetailPanierInput = {
    designation?: StringFieldUpdateOperationsInput | string
    prix?: FloatFieldUpdateOperationsInput | number
    qtte?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    devise?: DeviseUpdateOneRequiredWithoutProduitNestedInput
    teneur?: TeneurUpdateOneRequiredWithoutProduitNestedInput
    utilisateur?: UtilisateurUpdateOneRequiredWithoutProduitNestedInput
    DetailClotureCaisse?: DetailClotureCaisseUpdateManyWithoutProduitNestedInput
  }

  export type ProduitUncheckedUpdateWithoutDetailPanierInput = {
    id?: IntFieldUpdateOperationsInput | number
    designation?: StringFieldUpdateOperationsInput | string
    prix?: FloatFieldUpdateOperationsInput | number
    qtte?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    deviseId?: IntFieldUpdateOperationsInput | number
    teneurId?: IntFieldUpdateOperationsInput | number
    utilisateurId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DetailClotureCaisse?: DetailClotureCaisseUncheckedUpdateManyWithoutProduitNestedInput
  }

  export type PanierUpsertWithoutDetailPanierInput = {
    update: XOR<PanierUpdateWithoutDetailPanierInput, PanierUncheckedUpdateWithoutDetailPanierInput>
    create: XOR<PanierCreateWithoutDetailPanierInput, PanierUncheckedCreateWithoutDetailPanierInput>
    where?: PanierWhereInput
  }

  export type PanierUpdateToOneWithWhereWithoutDetailPanierInput = {
    where?: PanierWhereInput
    data: XOR<PanierUpdateWithoutDetailPanierInput, PanierUncheckedUpdateWithoutDetailPanierInput>
  }

  export type PanierUpdateWithoutDetailPanierInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    utilisateur?: UtilisateurUpdateOneRequiredWithoutPanierNestedInput
    Achat?: AchatUpdateManyWithoutPanierNestedInput
    Vente?: VenteUpdateManyWithoutPanierNestedInput
    Reservation?: ReservationUpdateManyWithoutPanierNestedInput
    Commande?: CommandeUpdateManyWithoutPanierNestedInput
  }

  export type PanierUncheckedUpdateWithoutDetailPanierInput = {
    id?: IntFieldUpdateOperationsInput | number
    utilisateurId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Achat?: AchatUncheckedUpdateManyWithoutPanierNestedInput
    Vente?: VenteUncheckedUpdateManyWithoutPanierNestedInput
    Reservation?: ReservationUncheckedUpdateManyWithoutPanierNestedInput
    Commande?: CommandeUncheckedUpdateManyWithoutPanierNestedInput
  }

  export type PanierCreateWithoutAchatInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    utilisateur: UtilisateurCreateNestedOneWithoutPanierInput
    DetailPanier?: DetailPanierCreateNestedManyWithoutPanierInput
    Vente?: VenteCreateNestedManyWithoutPanierInput
    Reservation?: ReservationCreateNestedManyWithoutPanierInput
    Commande?: CommandeCreateNestedManyWithoutPanierInput
  }

  export type PanierUncheckedCreateWithoutAchatInput = {
    id?: number
    utilisateurId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    DetailPanier?: DetailPanierUncheckedCreateNestedManyWithoutPanierInput
    Vente?: VenteUncheckedCreateNestedManyWithoutPanierInput
    Reservation?: ReservationUncheckedCreateNestedManyWithoutPanierInput
    Commande?: CommandeUncheckedCreateNestedManyWithoutPanierInput
  }

  export type PanierCreateOrConnectWithoutAchatInput = {
    where: PanierWhereUniqueInput
    create: XOR<PanierCreateWithoutAchatInput, PanierUncheckedCreateWithoutAchatInput>
  }

  export type FournisseurCreateWithoutAchatInput = {
    nom: string
    email: string
    code_postal?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Vente?: VenteCreateNestedManyWithoutFournisseurInput
    Adresse?: AdresseCreateNestedManyWithoutFournisseurInput
    Contact?: ContactCreateNestedManyWithoutFournisseurInput
    Reservation?: ReservationCreateNestedManyWithoutFournisseurInput
    Commande?: CommandeCreateNestedManyWithoutFournisseurInput
  }

  export type FournisseurUncheckedCreateWithoutAchatInput = {
    id?: number
    nom: string
    email: string
    code_postal?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Vente?: VenteUncheckedCreateNestedManyWithoutFournisseurInput
    Adresse?: AdresseUncheckedCreateNestedManyWithoutFournisseurInput
    Contact?: ContactUncheckedCreateNestedManyWithoutFournisseurInput
    Reservation?: ReservationUncheckedCreateNestedManyWithoutFournisseurInput
    Commande?: CommandeUncheckedCreateNestedManyWithoutFournisseurInput
  }

  export type FournisseurCreateOrConnectWithoutAchatInput = {
    where: FournisseurWhereUniqueInput
    create: XOR<FournisseurCreateWithoutAchatInput, FournisseurUncheckedCreateWithoutAchatInput>
  }

  export type UtilisateurCreateWithoutAchatInput = {
    email: string
    nom: string
    postnom: string
    nom_complet?: string | null
    sexe?: $Enums.Sexe | null
    role?: $Enums.Role
    poste?: $Enums.Poste | null
    picture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Adresse?: AdresseCreateNestedManyWithoutUtilisateurInput
    Contact?: ContactCreateNestedManyWithoutUtilisateurInput
    Produit?: ProduitCreateNestedManyWithoutUtilisateurInput
    Vente?: VenteCreateNestedManyWithoutUtilisateurInput
    Teneur?: TeneurCreateNestedManyWithoutUtilisateurInput
    Devise?: DeviseCreateNestedManyWithoutUtilisateurInput
    Panier?: PanierCreateNestedManyWithoutUtilisateurInput
    Reservation?: ReservationCreateNestedManyWithoutUtilisateurInput
    Commande?: CommandeCreateNestedManyWithoutClientInput
    Caisse?: CaisseCreateNestedManyWithoutUtilisateurInput
    MouvementCaisse?: MouvementCaisseCreateNestedManyWithoutUtilisateurInput
    ClotureCaisse?: ClotureCaisseCreateNestedManyWithoutUtilisateurClotureInput
  }

  export type UtilisateurUncheckedCreateWithoutAchatInput = {
    id?: number
    email: string
    nom: string
    postnom: string
    nom_complet?: string | null
    sexe?: $Enums.Sexe | null
    role?: $Enums.Role
    poste?: $Enums.Poste | null
    picture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Adresse?: AdresseUncheckedCreateNestedManyWithoutUtilisateurInput
    Contact?: ContactUncheckedCreateNestedManyWithoutUtilisateurInput
    Produit?: ProduitUncheckedCreateNestedManyWithoutUtilisateurInput
    Vente?: VenteUncheckedCreateNestedManyWithoutUtilisateurInput
    Teneur?: TeneurUncheckedCreateNestedManyWithoutUtilisateurInput
    Devise?: DeviseUncheckedCreateNestedManyWithoutUtilisateurInput
    Panier?: PanierUncheckedCreateNestedManyWithoutUtilisateurInput
    Reservation?: ReservationUncheckedCreateNestedManyWithoutUtilisateurInput
    Commande?: CommandeUncheckedCreateNestedManyWithoutClientInput
    Caisse?: CaisseUncheckedCreateNestedManyWithoutUtilisateurInput
    MouvementCaisse?: MouvementCaisseUncheckedCreateNestedManyWithoutUtilisateurInput
    ClotureCaisse?: ClotureCaisseUncheckedCreateNestedManyWithoutUtilisateurClotureInput
  }

  export type UtilisateurCreateOrConnectWithoutAchatInput = {
    where: UtilisateurWhereUniqueInput
    create: XOR<UtilisateurCreateWithoutAchatInput, UtilisateurUncheckedCreateWithoutAchatInput>
  }

  export type PaiementCreateWithoutAchatInput = {
    montant: number
    moyen_paiement: $Enums.MoyenPaiment
    createdAt?: Date | string
    updatedAt?: Date | string
    caisse: CaisseCreateNestedOneWithoutPaiementInput
    devise: DeviseCreateNestedOneWithoutPaiementInput
    Commande?: CommandeCreateNestedManyWithoutPaiementInput
    Vente?: VenteCreateNestedManyWithoutPaiementInput
  }

  export type PaiementUncheckedCreateWithoutAchatInput = {
    id?: number
    montant: number
    moyen_paiement: $Enums.MoyenPaiment
    deviseId: number
    caisseId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    Commande?: CommandeUncheckedCreateNestedManyWithoutPaiementInput
    Vente?: VenteUncheckedCreateNestedManyWithoutPaiementInput
  }

  export type PaiementCreateOrConnectWithoutAchatInput = {
    where: PaiementWhereUniqueInput
    create: XOR<PaiementCreateWithoutAchatInput, PaiementUncheckedCreateWithoutAchatInput>
  }

  export type PanierUpsertWithoutAchatInput = {
    update: XOR<PanierUpdateWithoutAchatInput, PanierUncheckedUpdateWithoutAchatInput>
    create: XOR<PanierCreateWithoutAchatInput, PanierUncheckedCreateWithoutAchatInput>
    where?: PanierWhereInput
  }

  export type PanierUpdateToOneWithWhereWithoutAchatInput = {
    where?: PanierWhereInput
    data: XOR<PanierUpdateWithoutAchatInput, PanierUncheckedUpdateWithoutAchatInput>
  }

  export type PanierUpdateWithoutAchatInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    utilisateur?: UtilisateurUpdateOneRequiredWithoutPanierNestedInput
    DetailPanier?: DetailPanierUpdateManyWithoutPanierNestedInput
    Vente?: VenteUpdateManyWithoutPanierNestedInput
    Reservation?: ReservationUpdateManyWithoutPanierNestedInput
    Commande?: CommandeUpdateManyWithoutPanierNestedInput
  }

  export type PanierUncheckedUpdateWithoutAchatInput = {
    id?: IntFieldUpdateOperationsInput | number
    utilisateurId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DetailPanier?: DetailPanierUncheckedUpdateManyWithoutPanierNestedInput
    Vente?: VenteUncheckedUpdateManyWithoutPanierNestedInput
    Reservation?: ReservationUncheckedUpdateManyWithoutPanierNestedInput
    Commande?: CommandeUncheckedUpdateManyWithoutPanierNestedInput
  }

  export type FournisseurUpsertWithoutAchatInput = {
    update: XOR<FournisseurUpdateWithoutAchatInput, FournisseurUncheckedUpdateWithoutAchatInput>
    create: XOR<FournisseurCreateWithoutAchatInput, FournisseurUncheckedCreateWithoutAchatInput>
    where?: FournisseurWhereInput
  }

  export type FournisseurUpdateToOneWithWhereWithoutAchatInput = {
    where?: FournisseurWhereInput
    data: XOR<FournisseurUpdateWithoutAchatInput, FournisseurUncheckedUpdateWithoutAchatInput>
  }

  export type FournisseurUpdateWithoutAchatInput = {
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    code_postal?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Vente?: VenteUpdateManyWithoutFournisseurNestedInput
    Adresse?: AdresseUpdateManyWithoutFournisseurNestedInput
    Contact?: ContactUpdateManyWithoutFournisseurNestedInput
    Reservation?: ReservationUpdateManyWithoutFournisseurNestedInput
    Commande?: CommandeUpdateManyWithoutFournisseurNestedInput
  }

  export type FournisseurUncheckedUpdateWithoutAchatInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    code_postal?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Vente?: VenteUncheckedUpdateManyWithoutFournisseurNestedInput
    Adresse?: AdresseUncheckedUpdateManyWithoutFournisseurNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutFournisseurNestedInput
    Reservation?: ReservationUncheckedUpdateManyWithoutFournisseurNestedInput
    Commande?: CommandeUncheckedUpdateManyWithoutFournisseurNestedInput
  }

  export type UtilisateurUpsertWithoutAchatInput = {
    update: XOR<UtilisateurUpdateWithoutAchatInput, UtilisateurUncheckedUpdateWithoutAchatInput>
    create: XOR<UtilisateurCreateWithoutAchatInput, UtilisateurUncheckedCreateWithoutAchatInput>
    where?: UtilisateurWhereInput
  }

  export type UtilisateurUpdateToOneWithWhereWithoutAchatInput = {
    where?: UtilisateurWhereInput
    data: XOR<UtilisateurUpdateWithoutAchatInput, UtilisateurUncheckedUpdateWithoutAchatInput>
  }

  export type UtilisateurUpdateWithoutAchatInput = {
    email?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    postnom?: StringFieldUpdateOperationsInput | string
    nom_complet?: NullableStringFieldUpdateOperationsInput | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    poste?: NullableEnumPosteFieldUpdateOperationsInput | $Enums.Poste | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Adresse?: AdresseUpdateManyWithoutUtilisateurNestedInput
    Contact?: ContactUpdateManyWithoutUtilisateurNestedInput
    Produit?: ProduitUpdateManyWithoutUtilisateurNestedInput
    Vente?: VenteUpdateManyWithoutUtilisateurNestedInput
    Teneur?: TeneurUpdateManyWithoutUtilisateurNestedInput
    Devise?: DeviseUpdateManyWithoutUtilisateurNestedInput
    Panier?: PanierUpdateManyWithoutUtilisateurNestedInput
    Reservation?: ReservationUpdateManyWithoutUtilisateurNestedInput
    Commande?: CommandeUpdateManyWithoutClientNestedInput
    Caisse?: CaisseUpdateManyWithoutUtilisateurNestedInput
    MouvementCaisse?: MouvementCaisseUpdateManyWithoutUtilisateurNestedInput
    ClotureCaisse?: ClotureCaisseUpdateManyWithoutUtilisateurClotureNestedInput
  }

  export type UtilisateurUncheckedUpdateWithoutAchatInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    postnom?: StringFieldUpdateOperationsInput | string
    nom_complet?: NullableStringFieldUpdateOperationsInput | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    poste?: NullableEnumPosteFieldUpdateOperationsInput | $Enums.Poste | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Adresse?: AdresseUncheckedUpdateManyWithoutUtilisateurNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutUtilisateurNestedInput
    Produit?: ProduitUncheckedUpdateManyWithoutUtilisateurNestedInput
    Vente?: VenteUncheckedUpdateManyWithoutUtilisateurNestedInput
    Teneur?: TeneurUncheckedUpdateManyWithoutUtilisateurNestedInput
    Devise?: DeviseUncheckedUpdateManyWithoutUtilisateurNestedInput
    Panier?: PanierUncheckedUpdateManyWithoutUtilisateurNestedInput
    Reservation?: ReservationUncheckedUpdateManyWithoutUtilisateurNestedInput
    Commande?: CommandeUncheckedUpdateManyWithoutClientNestedInput
    Caisse?: CaisseUncheckedUpdateManyWithoutUtilisateurNestedInput
    MouvementCaisse?: MouvementCaisseUncheckedUpdateManyWithoutUtilisateurNestedInput
    ClotureCaisse?: ClotureCaisseUncheckedUpdateManyWithoutUtilisateurClotureNestedInput
  }

  export type PaiementUpsertWithoutAchatInput = {
    update: XOR<PaiementUpdateWithoutAchatInput, PaiementUncheckedUpdateWithoutAchatInput>
    create: XOR<PaiementCreateWithoutAchatInput, PaiementUncheckedCreateWithoutAchatInput>
    where?: PaiementWhereInput
  }

  export type PaiementUpdateToOneWithWhereWithoutAchatInput = {
    where?: PaiementWhereInput
    data: XOR<PaiementUpdateWithoutAchatInput, PaiementUncheckedUpdateWithoutAchatInput>
  }

  export type PaiementUpdateWithoutAchatInput = {
    montant?: FloatFieldUpdateOperationsInput | number
    moyen_paiement?: EnumMoyenPaimentFieldUpdateOperationsInput | $Enums.MoyenPaiment
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    caisse?: CaisseUpdateOneRequiredWithoutPaiementNestedInput
    devise?: DeviseUpdateOneRequiredWithoutPaiementNestedInput
    Commande?: CommandeUpdateManyWithoutPaiementNestedInput
    Vente?: VenteUpdateManyWithoutPaiementNestedInput
  }

  export type PaiementUncheckedUpdateWithoutAchatInput = {
    id?: IntFieldUpdateOperationsInput | number
    montant?: FloatFieldUpdateOperationsInput | number
    moyen_paiement?: EnumMoyenPaimentFieldUpdateOperationsInput | $Enums.MoyenPaiment
    deviseId?: IntFieldUpdateOperationsInput | number
    caisseId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Commande?: CommandeUncheckedUpdateManyWithoutPaiementNestedInput
    Vente?: VenteUncheckedUpdateManyWithoutPaiementNestedInput
  }

  export type PanierCreateWithoutReservationInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    utilisateur: UtilisateurCreateNestedOneWithoutPanierInput
    DetailPanier?: DetailPanierCreateNestedManyWithoutPanierInput
    Achat?: AchatCreateNestedManyWithoutPanierInput
    Vente?: VenteCreateNestedManyWithoutPanierInput
    Commande?: CommandeCreateNestedManyWithoutPanierInput
  }

  export type PanierUncheckedCreateWithoutReservationInput = {
    id?: number
    utilisateurId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    DetailPanier?: DetailPanierUncheckedCreateNestedManyWithoutPanierInput
    Achat?: AchatUncheckedCreateNestedManyWithoutPanierInput
    Vente?: VenteUncheckedCreateNestedManyWithoutPanierInput
    Commande?: CommandeUncheckedCreateNestedManyWithoutPanierInput
  }

  export type PanierCreateOrConnectWithoutReservationInput = {
    where: PanierWhereUniqueInput
    create: XOR<PanierCreateWithoutReservationInput, PanierUncheckedCreateWithoutReservationInput>
  }

  export type UtilisateurCreateWithoutReservationInput = {
    email: string
    nom: string
    postnom: string
    nom_complet?: string | null
    sexe?: $Enums.Sexe | null
    role?: $Enums.Role
    poste?: $Enums.Poste | null
    picture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Adresse?: AdresseCreateNestedManyWithoutUtilisateurInput
    Contact?: ContactCreateNestedManyWithoutUtilisateurInput
    Produit?: ProduitCreateNestedManyWithoutUtilisateurInput
    Vente?: VenteCreateNestedManyWithoutUtilisateurInput
    Achat?: AchatCreateNestedManyWithoutUtilisateurInput
    Teneur?: TeneurCreateNestedManyWithoutUtilisateurInput
    Devise?: DeviseCreateNestedManyWithoutUtilisateurInput
    Panier?: PanierCreateNestedManyWithoutUtilisateurInput
    Commande?: CommandeCreateNestedManyWithoutClientInput
    Caisse?: CaisseCreateNestedManyWithoutUtilisateurInput
    MouvementCaisse?: MouvementCaisseCreateNestedManyWithoutUtilisateurInput
    ClotureCaisse?: ClotureCaisseCreateNestedManyWithoutUtilisateurClotureInput
  }

  export type UtilisateurUncheckedCreateWithoutReservationInput = {
    id?: number
    email: string
    nom: string
    postnom: string
    nom_complet?: string | null
    sexe?: $Enums.Sexe | null
    role?: $Enums.Role
    poste?: $Enums.Poste | null
    picture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Adresse?: AdresseUncheckedCreateNestedManyWithoutUtilisateurInput
    Contact?: ContactUncheckedCreateNestedManyWithoutUtilisateurInput
    Produit?: ProduitUncheckedCreateNestedManyWithoutUtilisateurInput
    Vente?: VenteUncheckedCreateNestedManyWithoutUtilisateurInput
    Achat?: AchatUncheckedCreateNestedManyWithoutUtilisateurInput
    Teneur?: TeneurUncheckedCreateNestedManyWithoutUtilisateurInput
    Devise?: DeviseUncheckedCreateNestedManyWithoutUtilisateurInput
    Panier?: PanierUncheckedCreateNestedManyWithoutUtilisateurInput
    Commande?: CommandeUncheckedCreateNestedManyWithoutClientInput
    Caisse?: CaisseUncheckedCreateNestedManyWithoutUtilisateurInput
    MouvementCaisse?: MouvementCaisseUncheckedCreateNestedManyWithoutUtilisateurInput
    ClotureCaisse?: ClotureCaisseUncheckedCreateNestedManyWithoutUtilisateurClotureInput
  }

  export type UtilisateurCreateOrConnectWithoutReservationInput = {
    where: UtilisateurWhereUniqueInput
    create: XOR<UtilisateurCreateWithoutReservationInput, UtilisateurUncheckedCreateWithoutReservationInput>
  }

  export type FournisseurCreateWithoutReservationInput = {
    nom: string
    email: string
    code_postal?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Vente?: VenteCreateNestedManyWithoutFournisseurInput
    Achat?: AchatCreateNestedManyWithoutFournisseurInput
    Adresse?: AdresseCreateNestedManyWithoutFournisseurInput
    Contact?: ContactCreateNestedManyWithoutFournisseurInput
    Commande?: CommandeCreateNestedManyWithoutFournisseurInput
  }

  export type FournisseurUncheckedCreateWithoutReservationInput = {
    id?: number
    nom: string
    email: string
    code_postal?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Vente?: VenteUncheckedCreateNestedManyWithoutFournisseurInput
    Achat?: AchatUncheckedCreateNestedManyWithoutFournisseurInput
    Adresse?: AdresseUncheckedCreateNestedManyWithoutFournisseurInput
    Contact?: ContactUncheckedCreateNestedManyWithoutFournisseurInput
    Commande?: CommandeUncheckedCreateNestedManyWithoutFournisseurInput
  }

  export type FournisseurCreateOrConnectWithoutReservationInput = {
    where: FournisseurWhereUniqueInput
    create: XOR<FournisseurCreateWithoutReservationInput, FournisseurUncheckedCreateWithoutReservationInput>
  }

  export type AdresseCreateWithoutReservationInput = {
    ville: string
    commune: string
    adresse: string
    createdAt?: Date | string
    updatedAt?: Date | string
    utilisateur?: UtilisateurCreateNestedOneWithoutAdresseInput
    fournisseur?: FournisseurCreateNestedOneWithoutAdresseInput
    Commande?: CommandeCreateNestedManyWithoutAdresseInput
  }

  export type AdresseUncheckedCreateWithoutReservationInput = {
    id?: number
    ville: string
    commune: string
    adresse: string
    utilisateurId?: number | null
    fournisseurId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Commande?: CommandeUncheckedCreateNestedManyWithoutAdresseInput
  }

  export type AdresseCreateOrConnectWithoutReservationInput = {
    where: AdresseWhereUniqueInput
    create: XOR<AdresseCreateWithoutReservationInput, AdresseUncheckedCreateWithoutReservationInput>
  }

  export type ContactCreateWithoutReservationInput = {
    tel: string
    createdAt?: Date | string
    updatedAt?: Date | string
    utilisateur?: UtilisateurCreateNestedOneWithoutContactInput
    fournisseur?: FournisseurCreateNestedOneWithoutContactInput
    Commande?: CommandeCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutReservationInput = {
    id?: number
    tel: string
    utilisateurId?: number | null
    fournisseurId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Commande?: CommandeUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutReservationInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutReservationInput, ContactUncheckedCreateWithoutReservationInput>
  }

  export type PanierUpsertWithoutReservationInput = {
    update: XOR<PanierUpdateWithoutReservationInput, PanierUncheckedUpdateWithoutReservationInput>
    create: XOR<PanierCreateWithoutReservationInput, PanierUncheckedCreateWithoutReservationInput>
    where?: PanierWhereInput
  }

  export type PanierUpdateToOneWithWhereWithoutReservationInput = {
    where?: PanierWhereInput
    data: XOR<PanierUpdateWithoutReservationInput, PanierUncheckedUpdateWithoutReservationInput>
  }

  export type PanierUpdateWithoutReservationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    utilisateur?: UtilisateurUpdateOneRequiredWithoutPanierNestedInput
    DetailPanier?: DetailPanierUpdateManyWithoutPanierNestedInput
    Achat?: AchatUpdateManyWithoutPanierNestedInput
    Vente?: VenteUpdateManyWithoutPanierNestedInput
    Commande?: CommandeUpdateManyWithoutPanierNestedInput
  }

  export type PanierUncheckedUpdateWithoutReservationInput = {
    id?: IntFieldUpdateOperationsInput | number
    utilisateurId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DetailPanier?: DetailPanierUncheckedUpdateManyWithoutPanierNestedInput
    Achat?: AchatUncheckedUpdateManyWithoutPanierNestedInput
    Vente?: VenteUncheckedUpdateManyWithoutPanierNestedInput
    Commande?: CommandeUncheckedUpdateManyWithoutPanierNestedInput
  }

  export type UtilisateurUpsertWithoutReservationInput = {
    update: XOR<UtilisateurUpdateWithoutReservationInput, UtilisateurUncheckedUpdateWithoutReservationInput>
    create: XOR<UtilisateurCreateWithoutReservationInput, UtilisateurUncheckedCreateWithoutReservationInput>
    where?: UtilisateurWhereInput
  }

  export type UtilisateurUpdateToOneWithWhereWithoutReservationInput = {
    where?: UtilisateurWhereInput
    data: XOR<UtilisateurUpdateWithoutReservationInput, UtilisateurUncheckedUpdateWithoutReservationInput>
  }

  export type UtilisateurUpdateWithoutReservationInput = {
    email?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    postnom?: StringFieldUpdateOperationsInput | string
    nom_complet?: NullableStringFieldUpdateOperationsInput | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    poste?: NullableEnumPosteFieldUpdateOperationsInput | $Enums.Poste | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Adresse?: AdresseUpdateManyWithoutUtilisateurNestedInput
    Contact?: ContactUpdateManyWithoutUtilisateurNestedInput
    Produit?: ProduitUpdateManyWithoutUtilisateurNestedInput
    Vente?: VenteUpdateManyWithoutUtilisateurNestedInput
    Achat?: AchatUpdateManyWithoutUtilisateurNestedInput
    Teneur?: TeneurUpdateManyWithoutUtilisateurNestedInput
    Devise?: DeviseUpdateManyWithoutUtilisateurNestedInput
    Panier?: PanierUpdateManyWithoutUtilisateurNestedInput
    Commande?: CommandeUpdateManyWithoutClientNestedInput
    Caisse?: CaisseUpdateManyWithoutUtilisateurNestedInput
    MouvementCaisse?: MouvementCaisseUpdateManyWithoutUtilisateurNestedInput
    ClotureCaisse?: ClotureCaisseUpdateManyWithoutUtilisateurClotureNestedInput
  }

  export type UtilisateurUncheckedUpdateWithoutReservationInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    postnom?: StringFieldUpdateOperationsInput | string
    nom_complet?: NullableStringFieldUpdateOperationsInput | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    poste?: NullableEnumPosteFieldUpdateOperationsInput | $Enums.Poste | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Adresse?: AdresseUncheckedUpdateManyWithoutUtilisateurNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutUtilisateurNestedInput
    Produit?: ProduitUncheckedUpdateManyWithoutUtilisateurNestedInput
    Vente?: VenteUncheckedUpdateManyWithoutUtilisateurNestedInput
    Achat?: AchatUncheckedUpdateManyWithoutUtilisateurNestedInput
    Teneur?: TeneurUncheckedUpdateManyWithoutUtilisateurNestedInput
    Devise?: DeviseUncheckedUpdateManyWithoutUtilisateurNestedInput
    Panier?: PanierUncheckedUpdateManyWithoutUtilisateurNestedInput
    Commande?: CommandeUncheckedUpdateManyWithoutClientNestedInput
    Caisse?: CaisseUncheckedUpdateManyWithoutUtilisateurNestedInput
    MouvementCaisse?: MouvementCaisseUncheckedUpdateManyWithoutUtilisateurNestedInput
    ClotureCaisse?: ClotureCaisseUncheckedUpdateManyWithoutUtilisateurClotureNestedInput
  }

  export type FournisseurUpsertWithoutReservationInput = {
    update: XOR<FournisseurUpdateWithoutReservationInput, FournisseurUncheckedUpdateWithoutReservationInput>
    create: XOR<FournisseurCreateWithoutReservationInput, FournisseurUncheckedCreateWithoutReservationInput>
    where?: FournisseurWhereInput
  }

  export type FournisseurUpdateToOneWithWhereWithoutReservationInput = {
    where?: FournisseurWhereInput
    data: XOR<FournisseurUpdateWithoutReservationInput, FournisseurUncheckedUpdateWithoutReservationInput>
  }

  export type FournisseurUpdateWithoutReservationInput = {
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    code_postal?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Vente?: VenteUpdateManyWithoutFournisseurNestedInput
    Achat?: AchatUpdateManyWithoutFournisseurNestedInput
    Adresse?: AdresseUpdateManyWithoutFournisseurNestedInput
    Contact?: ContactUpdateManyWithoutFournisseurNestedInput
    Commande?: CommandeUpdateManyWithoutFournisseurNestedInput
  }

  export type FournisseurUncheckedUpdateWithoutReservationInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    code_postal?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Vente?: VenteUncheckedUpdateManyWithoutFournisseurNestedInput
    Achat?: AchatUncheckedUpdateManyWithoutFournisseurNestedInput
    Adresse?: AdresseUncheckedUpdateManyWithoutFournisseurNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutFournisseurNestedInput
    Commande?: CommandeUncheckedUpdateManyWithoutFournisseurNestedInput
  }

  export type AdresseUpsertWithoutReservationInput = {
    update: XOR<AdresseUpdateWithoutReservationInput, AdresseUncheckedUpdateWithoutReservationInput>
    create: XOR<AdresseCreateWithoutReservationInput, AdresseUncheckedCreateWithoutReservationInput>
    where?: AdresseWhereInput
  }

  export type AdresseUpdateToOneWithWhereWithoutReservationInput = {
    where?: AdresseWhereInput
    data: XOR<AdresseUpdateWithoutReservationInput, AdresseUncheckedUpdateWithoutReservationInput>
  }

  export type AdresseUpdateWithoutReservationInput = {
    ville?: StringFieldUpdateOperationsInput | string
    commune?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    utilisateur?: UtilisateurUpdateOneWithoutAdresseNestedInput
    fournisseur?: FournisseurUpdateOneWithoutAdresseNestedInput
    Commande?: CommandeUpdateManyWithoutAdresseNestedInput
  }

  export type AdresseUncheckedUpdateWithoutReservationInput = {
    id?: IntFieldUpdateOperationsInput | number
    ville?: StringFieldUpdateOperationsInput | string
    commune?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    utilisateurId?: NullableIntFieldUpdateOperationsInput | number | null
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Commande?: CommandeUncheckedUpdateManyWithoutAdresseNestedInput
  }

  export type ContactUpsertWithoutReservationInput = {
    update: XOR<ContactUpdateWithoutReservationInput, ContactUncheckedUpdateWithoutReservationInput>
    create: XOR<ContactCreateWithoutReservationInput, ContactUncheckedCreateWithoutReservationInput>
    where?: ContactWhereInput
  }

  export type ContactUpdateToOneWithWhereWithoutReservationInput = {
    where?: ContactWhereInput
    data: XOR<ContactUpdateWithoutReservationInput, ContactUncheckedUpdateWithoutReservationInput>
  }

  export type ContactUpdateWithoutReservationInput = {
    tel?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    utilisateur?: UtilisateurUpdateOneWithoutContactNestedInput
    fournisseur?: FournisseurUpdateOneWithoutContactNestedInput
    Commande?: CommandeUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutReservationInput = {
    id?: IntFieldUpdateOperationsInput | number
    tel?: StringFieldUpdateOperationsInput | string
    utilisateurId?: NullableIntFieldUpdateOperationsInput | number | null
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Commande?: CommandeUncheckedUpdateManyWithoutContactNestedInput
  }

  export type PanierCreateWithoutCommandeInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    utilisateur: UtilisateurCreateNestedOneWithoutPanierInput
    DetailPanier?: DetailPanierCreateNestedManyWithoutPanierInput
    Achat?: AchatCreateNestedManyWithoutPanierInput
    Vente?: VenteCreateNestedManyWithoutPanierInput
    Reservation?: ReservationCreateNestedManyWithoutPanierInput
  }

  export type PanierUncheckedCreateWithoutCommandeInput = {
    id?: number
    utilisateurId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    DetailPanier?: DetailPanierUncheckedCreateNestedManyWithoutPanierInput
    Achat?: AchatUncheckedCreateNestedManyWithoutPanierInput
    Vente?: VenteUncheckedCreateNestedManyWithoutPanierInput
    Reservation?: ReservationUncheckedCreateNestedManyWithoutPanierInput
  }

  export type PanierCreateOrConnectWithoutCommandeInput = {
    where: PanierWhereUniqueInput
    create: XOR<PanierCreateWithoutCommandeInput, PanierUncheckedCreateWithoutCommandeInput>
  }

  export type UtilisateurCreateWithoutCommandeInput = {
    email: string
    nom: string
    postnom: string
    nom_complet?: string | null
    sexe?: $Enums.Sexe | null
    role?: $Enums.Role
    poste?: $Enums.Poste | null
    picture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Adresse?: AdresseCreateNestedManyWithoutUtilisateurInput
    Contact?: ContactCreateNestedManyWithoutUtilisateurInput
    Produit?: ProduitCreateNestedManyWithoutUtilisateurInput
    Vente?: VenteCreateNestedManyWithoutUtilisateurInput
    Achat?: AchatCreateNestedManyWithoutUtilisateurInput
    Teneur?: TeneurCreateNestedManyWithoutUtilisateurInput
    Devise?: DeviseCreateNestedManyWithoutUtilisateurInput
    Panier?: PanierCreateNestedManyWithoutUtilisateurInput
    Reservation?: ReservationCreateNestedManyWithoutUtilisateurInput
    Caisse?: CaisseCreateNestedManyWithoutUtilisateurInput
    MouvementCaisse?: MouvementCaisseCreateNestedManyWithoutUtilisateurInput
    ClotureCaisse?: ClotureCaisseCreateNestedManyWithoutUtilisateurClotureInput
  }

  export type UtilisateurUncheckedCreateWithoutCommandeInput = {
    id?: number
    email: string
    nom: string
    postnom: string
    nom_complet?: string | null
    sexe?: $Enums.Sexe | null
    role?: $Enums.Role
    poste?: $Enums.Poste | null
    picture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Adresse?: AdresseUncheckedCreateNestedManyWithoutUtilisateurInput
    Contact?: ContactUncheckedCreateNestedManyWithoutUtilisateurInput
    Produit?: ProduitUncheckedCreateNestedManyWithoutUtilisateurInput
    Vente?: VenteUncheckedCreateNestedManyWithoutUtilisateurInput
    Achat?: AchatUncheckedCreateNestedManyWithoutUtilisateurInput
    Teneur?: TeneurUncheckedCreateNestedManyWithoutUtilisateurInput
    Devise?: DeviseUncheckedCreateNestedManyWithoutUtilisateurInput
    Panier?: PanierUncheckedCreateNestedManyWithoutUtilisateurInput
    Reservation?: ReservationUncheckedCreateNestedManyWithoutUtilisateurInput
    Caisse?: CaisseUncheckedCreateNestedManyWithoutUtilisateurInput
    MouvementCaisse?: MouvementCaisseUncheckedCreateNestedManyWithoutUtilisateurInput
    ClotureCaisse?: ClotureCaisseUncheckedCreateNestedManyWithoutUtilisateurClotureInput
  }

  export type UtilisateurCreateOrConnectWithoutCommandeInput = {
    where: UtilisateurWhereUniqueInput
    create: XOR<UtilisateurCreateWithoutCommandeInput, UtilisateurUncheckedCreateWithoutCommandeInput>
  }

  export type PaiementCreateWithoutCommandeInput = {
    montant: number
    moyen_paiement: $Enums.MoyenPaiment
    createdAt?: Date | string
    updatedAt?: Date | string
    caisse: CaisseCreateNestedOneWithoutPaiementInput
    devise: DeviseCreateNestedOneWithoutPaiementInput
    Achat?: AchatCreateNestedManyWithoutPaiementInput
    Vente?: VenteCreateNestedManyWithoutPaiementInput
  }

  export type PaiementUncheckedCreateWithoutCommandeInput = {
    id?: number
    montant: number
    moyen_paiement: $Enums.MoyenPaiment
    deviseId: number
    caisseId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    Achat?: AchatUncheckedCreateNestedManyWithoutPaiementInput
    Vente?: VenteUncheckedCreateNestedManyWithoutPaiementInput
  }

  export type PaiementCreateOrConnectWithoutCommandeInput = {
    where: PaiementWhereUniqueInput
    create: XOR<PaiementCreateWithoutCommandeInput, PaiementUncheckedCreateWithoutCommandeInput>
  }

  export type FournisseurCreateWithoutCommandeInput = {
    nom: string
    email: string
    code_postal?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Vente?: VenteCreateNestedManyWithoutFournisseurInput
    Achat?: AchatCreateNestedManyWithoutFournisseurInput
    Adresse?: AdresseCreateNestedManyWithoutFournisseurInput
    Contact?: ContactCreateNestedManyWithoutFournisseurInput
    Reservation?: ReservationCreateNestedManyWithoutFournisseurInput
  }

  export type FournisseurUncheckedCreateWithoutCommandeInput = {
    id?: number
    nom: string
    email: string
    code_postal?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Vente?: VenteUncheckedCreateNestedManyWithoutFournisseurInput
    Achat?: AchatUncheckedCreateNestedManyWithoutFournisseurInput
    Adresse?: AdresseUncheckedCreateNestedManyWithoutFournisseurInput
    Contact?: ContactUncheckedCreateNestedManyWithoutFournisseurInput
    Reservation?: ReservationUncheckedCreateNestedManyWithoutFournisseurInput
  }

  export type FournisseurCreateOrConnectWithoutCommandeInput = {
    where: FournisseurWhereUniqueInput
    create: XOR<FournisseurCreateWithoutCommandeInput, FournisseurUncheckedCreateWithoutCommandeInput>
  }

  export type AdresseCreateWithoutCommandeInput = {
    ville: string
    commune: string
    adresse: string
    createdAt?: Date | string
    updatedAt?: Date | string
    utilisateur?: UtilisateurCreateNestedOneWithoutAdresseInput
    fournisseur?: FournisseurCreateNestedOneWithoutAdresseInput
    Reservation?: ReservationCreateNestedManyWithoutAdresseInput
  }

  export type AdresseUncheckedCreateWithoutCommandeInput = {
    id?: number
    ville: string
    commune: string
    adresse: string
    utilisateurId?: number | null
    fournisseurId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Reservation?: ReservationUncheckedCreateNestedManyWithoutAdresseInput
  }

  export type AdresseCreateOrConnectWithoutCommandeInput = {
    where: AdresseWhereUniqueInput
    create: XOR<AdresseCreateWithoutCommandeInput, AdresseUncheckedCreateWithoutCommandeInput>
  }

  export type ContactCreateWithoutCommandeInput = {
    tel: string
    createdAt?: Date | string
    updatedAt?: Date | string
    utilisateur?: UtilisateurCreateNestedOneWithoutContactInput
    fournisseur?: FournisseurCreateNestedOneWithoutContactInput
    Reservation?: ReservationCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutCommandeInput = {
    id?: number
    tel: string
    utilisateurId?: number | null
    fournisseurId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Reservation?: ReservationUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutCommandeInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutCommandeInput, ContactUncheckedCreateWithoutCommandeInput>
  }

  export type PanierUpsertWithoutCommandeInput = {
    update: XOR<PanierUpdateWithoutCommandeInput, PanierUncheckedUpdateWithoutCommandeInput>
    create: XOR<PanierCreateWithoutCommandeInput, PanierUncheckedCreateWithoutCommandeInput>
    where?: PanierWhereInput
  }

  export type PanierUpdateToOneWithWhereWithoutCommandeInput = {
    where?: PanierWhereInput
    data: XOR<PanierUpdateWithoutCommandeInput, PanierUncheckedUpdateWithoutCommandeInput>
  }

  export type PanierUpdateWithoutCommandeInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    utilisateur?: UtilisateurUpdateOneRequiredWithoutPanierNestedInput
    DetailPanier?: DetailPanierUpdateManyWithoutPanierNestedInput
    Achat?: AchatUpdateManyWithoutPanierNestedInput
    Vente?: VenteUpdateManyWithoutPanierNestedInput
    Reservation?: ReservationUpdateManyWithoutPanierNestedInput
  }

  export type PanierUncheckedUpdateWithoutCommandeInput = {
    id?: IntFieldUpdateOperationsInput | number
    utilisateurId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DetailPanier?: DetailPanierUncheckedUpdateManyWithoutPanierNestedInput
    Achat?: AchatUncheckedUpdateManyWithoutPanierNestedInput
    Vente?: VenteUncheckedUpdateManyWithoutPanierNestedInput
    Reservation?: ReservationUncheckedUpdateManyWithoutPanierNestedInput
  }

  export type UtilisateurUpsertWithoutCommandeInput = {
    update: XOR<UtilisateurUpdateWithoutCommandeInput, UtilisateurUncheckedUpdateWithoutCommandeInput>
    create: XOR<UtilisateurCreateWithoutCommandeInput, UtilisateurUncheckedCreateWithoutCommandeInput>
    where?: UtilisateurWhereInput
  }

  export type UtilisateurUpdateToOneWithWhereWithoutCommandeInput = {
    where?: UtilisateurWhereInput
    data: XOR<UtilisateurUpdateWithoutCommandeInput, UtilisateurUncheckedUpdateWithoutCommandeInput>
  }

  export type UtilisateurUpdateWithoutCommandeInput = {
    email?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    postnom?: StringFieldUpdateOperationsInput | string
    nom_complet?: NullableStringFieldUpdateOperationsInput | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    poste?: NullableEnumPosteFieldUpdateOperationsInput | $Enums.Poste | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Adresse?: AdresseUpdateManyWithoutUtilisateurNestedInput
    Contact?: ContactUpdateManyWithoutUtilisateurNestedInput
    Produit?: ProduitUpdateManyWithoutUtilisateurNestedInput
    Vente?: VenteUpdateManyWithoutUtilisateurNestedInput
    Achat?: AchatUpdateManyWithoutUtilisateurNestedInput
    Teneur?: TeneurUpdateManyWithoutUtilisateurNestedInput
    Devise?: DeviseUpdateManyWithoutUtilisateurNestedInput
    Panier?: PanierUpdateManyWithoutUtilisateurNestedInput
    Reservation?: ReservationUpdateManyWithoutUtilisateurNestedInput
    Caisse?: CaisseUpdateManyWithoutUtilisateurNestedInput
    MouvementCaisse?: MouvementCaisseUpdateManyWithoutUtilisateurNestedInput
    ClotureCaisse?: ClotureCaisseUpdateManyWithoutUtilisateurClotureNestedInput
  }

  export type UtilisateurUncheckedUpdateWithoutCommandeInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    postnom?: StringFieldUpdateOperationsInput | string
    nom_complet?: NullableStringFieldUpdateOperationsInput | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    poste?: NullableEnumPosteFieldUpdateOperationsInput | $Enums.Poste | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Adresse?: AdresseUncheckedUpdateManyWithoutUtilisateurNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutUtilisateurNestedInput
    Produit?: ProduitUncheckedUpdateManyWithoutUtilisateurNestedInput
    Vente?: VenteUncheckedUpdateManyWithoutUtilisateurNestedInput
    Achat?: AchatUncheckedUpdateManyWithoutUtilisateurNestedInput
    Teneur?: TeneurUncheckedUpdateManyWithoutUtilisateurNestedInput
    Devise?: DeviseUncheckedUpdateManyWithoutUtilisateurNestedInput
    Panier?: PanierUncheckedUpdateManyWithoutUtilisateurNestedInput
    Reservation?: ReservationUncheckedUpdateManyWithoutUtilisateurNestedInput
    Caisse?: CaisseUncheckedUpdateManyWithoutUtilisateurNestedInput
    MouvementCaisse?: MouvementCaisseUncheckedUpdateManyWithoutUtilisateurNestedInput
    ClotureCaisse?: ClotureCaisseUncheckedUpdateManyWithoutUtilisateurClotureNestedInput
  }

  export type PaiementUpsertWithoutCommandeInput = {
    update: XOR<PaiementUpdateWithoutCommandeInput, PaiementUncheckedUpdateWithoutCommandeInput>
    create: XOR<PaiementCreateWithoutCommandeInput, PaiementUncheckedCreateWithoutCommandeInput>
    where?: PaiementWhereInput
  }

  export type PaiementUpdateToOneWithWhereWithoutCommandeInput = {
    where?: PaiementWhereInput
    data: XOR<PaiementUpdateWithoutCommandeInput, PaiementUncheckedUpdateWithoutCommandeInput>
  }

  export type PaiementUpdateWithoutCommandeInput = {
    montant?: FloatFieldUpdateOperationsInput | number
    moyen_paiement?: EnumMoyenPaimentFieldUpdateOperationsInput | $Enums.MoyenPaiment
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    caisse?: CaisseUpdateOneRequiredWithoutPaiementNestedInput
    devise?: DeviseUpdateOneRequiredWithoutPaiementNestedInput
    Achat?: AchatUpdateManyWithoutPaiementNestedInput
    Vente?: VenteUpdateManyWithoutPaiementNestedInput
  }

  export type PaiementUncheckedUpdateWithoutCommandeInput = {
    id?: IntFieldUpdateOperationsInput | number
    montant?: FloatFieldUpdateOperationsInput | number
    moyen_paiement?: EnumMoyenPaimentFieldUpdateOperationsInput | $Enums.MoyenPaiment
    deviseId?: IntFieldUpdateOperationsInput | number
    caisseId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Achat?: AchatUncheckedUpdateManyWithoutPaiementNestedInput
    Vente?: VenteUncheckedUpdateManyWithoutPaiementNestedInput
  }

  export type FournisseurUpsertWithoutCommandeInput = {
    update: XOR<FournisseurUpdateWithoutCommandeInput, FournisseurUncheckedUpdateWithoutCommandeInput>
    create: XOR<FournisseurCreateWithoutCommandeInput, FournisseurUncheckedCreateWithoutCommandeInput>
    where?: FournisseurWhereInput
  }

  export type FournisseurUpdateToOneWithWhereWithoutCommandeInput = {
    where?: FournisseurWhereInput
    data: XOR<FournisseurUpdateWithoutCommandeInput, FournisseurUncheckedUpdateWithoutCommandeInput>
  }

  export type FournisseurUpdateWithoutCommandeInput = {
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    code_postal?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Vente?: VenteUpdateManyWithoutFournisseurNestedInput
    Achat?: AchatUpdateManyWithoutFournisseurNestedInput
    Adresse?: AdresseUpdateManyWithoutFournisseurNestedInput
    Contact?: ContactUpdateManyWithoutFournisseurNestedInput
    Reservation?: ReservationUpdateManyWithoutFournisseurNestedInput
  }

  export type FournisseurUncheckedUpdateWithoutCommandeInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    code_postal?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Vente?: VenteUncheckedUpdateManyWithoutFournisseurNestedInput
    Achat?: AchatUncheckedUpdateManyWithoutFournisseurNestedInput
    Adresse?: AdresseUncheckedUpdateManyWithoutFournisseurNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutFournisseurNestedInput
    Reservation?: ReservationUncheckedUpdateManyWithoutFournisseurNestedInput
  }

  export type AdresseUpsertWithoutCommandeInput = {
    update: XOR<AdresseUpdateWithoutCommandeInput, AdresseUncheckedUpdateWithoutCommandeInput>
    create: XOR<AdresseCreateWithoutCommandeInput, AdresseUncheckedCreateWithoutCommandeInput>
    where?: AdresseWhereInput
  }

  export type AdresseUpdateToOneWithWhereWithoutCommandeInput = {
    where?: AdresseWhereInput
    data: XOR<AdresseUpdateWithoutCommandeInput, AdresseUncheckedUpdateWithoutCommandeInput>
  }

  export type AdresseUpdateWithoutCommandeInput = {
    ville?: StringFieldUpdateOperationsInput | string
    commune?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    utilisateur?: UtilisateurUpdateOneWithoutAdresseNestedInput
    fournisseur?: FournisseurUpdateOneWithoutAdresseNestedInput
    Reservation?: ReservationUpdateManyWithoutAdresseNestedInput
  }

  export type AdresseUncheckedUpdateWithoutCommandeInput = {
    id?: IntFieldUpdateOperationsInput | number
    ville?: StringFieldUpdateOperationsInput | string
    commune?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    utilisateurId?: NullableIntFieldUpdateOperationsInput | number | null
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Reservation?: ReservationUncheckedUpdateManyWithoutAdresseNestedInput
  }

  export type ContactUpsertWithoutCommandeInput = {
    update: XOR<ContactUpdateWithoutCommandeInput, ContactUncheckedUpdateWithoutCommandeInput>
    create: XOR<ContactCreateWithoutCommandeInput, ContactUncheckedCreateWithoutCommandeInput>
    where?: ContactWhereInput
  }

  export type ContactUpdateToOneWithWhereWithoutCommandeInput = {
    where?: ContactWhereInput
    data: XOR<ContactUpdateWithoutCommandeInput, ContactUncheckedUpdateWithoutCommandeInput>
  }

  export type ContactUpdateWithoutCommandeInput = {
    tel?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    utilisateur?: UtilisateurUpdateOneWithoutContactNestedInput
    fournisseur?: FournisseurUpdateOneWithoutContactNestedInput
    Reservation?: ReservationUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutCommandeInput = {
    id?: IntFieldUpdateOperationsInput | number
    tel?: StringFieldUpdateOperationsInput | string
    utilisateurId?: NullableIntFieldUpdateOperationsInput | number | null
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Reservation?: ReservationUncheckedUpdateManyWithoutContactNestedInput
  }

  export type CaisseCreateWithoutMouvementCaisseInput = {
    nom: string
    description?: string | null
    soldeInitial: number
    soldeActuel: number
    statut?: $Enums.StatutCaisse
    createdAt?: Date | string
    updatedAt?: Date | string
    devise: DeviseCreateNestedOneWithoutCaisseInput
    utilisateur: UtilisateurCreateNestedOneWithoutCaisseInput
    clotures?: ClotureCaisseCreateNestedManyWithoutCaisseInput
    Paiement?: PaiementCreateNestedManyWithoutCaisseInput
  }

  export type CaisseUncheckedCreateWithoutMouvementCaisseInput = {
    id?: number
    nom: string
    description?: string | null
    soldeInitial: number
    soldeActuel: number
    deviseId: number
    creeParId: number
    statut?: $Enums.StatutCaisse
    createdAt?: Date | string
    updatedAt?: Date | string
    clotures?: ClotureCaisseUncheckedCreateNestedManyWithoutCaisseInput
    Paiement?: PaiementUncheckedCreateNestedManyWithoutCaisseInput
  }

  export type CaisseCreateOrConnectWithoutMouvementCaisseInput = {
    where: CaisseWhereUniqueInput
    create: XOR<CaisseCreateWithoutMouvementCaisseInput, CaisseUncheckedCreateWithoutMouvementCaisseInput>
  }

  export type UtilisateurCreateWithoutMouvementCaisseInput = {
    email: string
    nom: string
    postnom: string
    nom_complet?: string | null
    sexe?: $Enums.Sexe | null
    role?: $Enums.Role
    poste?: $Enums.Poste | null
    picture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Adresse?: AdresseCreateNestedManyWithoutUtilisateurInput
    Contact?: ContactCreateNestedManyWithoutUtilisateurInput
    Produit?: ProduitCreateNestedManyWithoutUtilisateurInput
    Vente?: VenteCreateNestedManyWithoutUtilisateurInput
    Achat?: AchatCreateNestedManyWithoutUtilisateurInput
    Teneur?: TeneurCreateNestedManyWithoutUtilisateurInput
    Devise?: DeviseCreateNestedManyWithoutUtilisateurInput
    Panier?: PanierCreateNestedManyWithoutUtilisateurInput
    Reservation?: ReservationCreateNestedManyWithoutUtilisateurInput
    Commande?: CommandeCreateNestedManyWithoutClientInput
    Caisse?: CaisseCreateNestedManyWithoutUtilisateurInput
    ClotureCaisse?: ClotureCaisseCreateNestedManyWithoutUtilisateurClotureInput
  }

  export type UtilisateurUncheckedCreateWithoutMouvementCaisseInput = {
    id?: number
    email: string
    nom: string
    postnom: string
    nom_complet?: string | null
    sexe?: $Enums.Sexe | null
    role?: $Enums.Role
    poste?: $Enums.Poste | null
    picture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Adresse?: AdresseUncheckedCreateNestedManyWithoutUtilisateurInput
    Contact?: ContactUncheckedCreateNestedManyWithoutUtilisateurInput
    Produit?: ProduitUncheckedCreateNestedManyWithoutUtilisateurInput
    Vente?: VenteUncheckedCreateNestedManyWithoutUtilisateurInput
    Achat?: AchatUncheckedCreateNestedManyWithoutUtilisateurInput
    Teneur?: TeneurUncheckedCreateNestedManyWithoutUtilisateurInput
    Devise?: DeviseUncheckedCreateNestedManyWithoutUtilisateurInput
    Panier?: PanierUncheckedCreateNestedManyWithoutUtilisateurInput
    Reservation?: ReservationUncheckedCreateNestedManyWithoutUtilisateurInput
    Commande?: CommandeUncheckedCreateNestedManyWithoutClientInput
    Caisse?: CaisseUncheckedCreateNestedManyWithoutUtilisateurInput
    ClotureCaisse?: ClotureCaisseUncheckedCreateNestedManyWithoutUtilisateurClotureInput
  }

  export type UtilisateurCreateOrConnectWithoutMouvementCaisseInput = {
    where: UtilisateurWhereUniqueInput
    create: XOR<UtilisateurCreateWithoutMouvementCaisseInput, UtilisateurUncheckedCreateWithoutMouvementCaisseInput>
  }

  export type CaisseUpsertWithoutMouvementCaisseInput = {
    update: XOR<CaisseUpdateWithoutMouvementCaisseInput, CaisseUncheckedUpdateWithoutMouvementCaisseInput>
    create: XOR<CaisseCreateWithoutMouvementCaisseInput, CaisseUncheckedCreateWithoutMouvementCaisseInput>
    where?: CaisseWhereInput
  }

  export type CaisseUpdateToOneWithWhereWithoutMouvementCaisseInput = {
    where?: CaisseWhereInput
    data: XOR<CaisseUpdateWithoutMouvementCaisseInput, CaisseUncheckedUpdateWithoutMouvementCaisseInput>
  }

  export type CaisseUpdateWithoutMouvementCaisseInput = {
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    soldeInitial?: FloatFieldUpdateOperationsInput | number
    soldeActuel?: FloatFieldUpdateOperationsInput | number
    statut?: EnumStatutCaisseFieldUpdateOperationsInput | $Enums.StatutCaisse
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    devise?: DeviseUpdateOneRequiredWithoutCaisseNestedInput
    utilisateur?: UtilisateurUpdateOneRequiredWithoutCaisseNestedInput
    clotures?: ClotureCaisseUpdateManyWithoutCaisseNestedInput
    Paiement?: PaiementUpdateManyWithoutCaisseNestedInput
  }

  export type CaisseUncheckedUpdateWithoutMouvementCaisseInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    soldeInitial?: FloatFieldUpdateOperationsInput | number
    soldeActuel?: FloatFieldUpdateOperationsInput | number
    deviseId?: IntFieldUpdateOperationsInput | number
    creeParId?: IntFieldUpdateOperationsInput | number
    statut?: EnumStatutCaisseFieldUpdateOperationsInput | $Enums.StatutCaisse
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clotures?: ClotureCaisseUncheckedUpdateManyWithoutCaisseNestedInput
    Paiement?: PaiementUncheckedUpdateManyWithoutCaisseNestedInput
  }

  export type UtilisateurUpsertWithoutMouvementCaisseInput = {
    update: XOR<UtilisateurUpdateWithoutMouvementCaisseInput, UtilisateurUncheckedUpdateWithoutMouvementCaisseInput>
    create: XOR<UtilisateurCreateWithoutMouvementCaisseInput, UtilisateurUncheckedCreateWithoutMouvementCaisseInput>
    where?: UtilisateurWhereInput
  }

  export type UtilisateurUpdateToOneWithWhereWithoutMouvementCaisseInput = {
    where?: UtilisateurWhereInput
    data: XOR<UtilisateurUpdateWithoutMouvementCaisseInput, UtilisateurUncheckedUpdateWithoutMouvementCaisseInput>
  }

  export type UtilisateurUpdateWithoutMouvementCaisseInput = {
    email?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    postnom?: StringFieldUpdateOperationsInput | string
    nom_complet?: NullableStringFieldUpdateOperationsInput | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    poste?: NullableEnumPosteFieldUpdateOperationsInput | $Enums.Poste | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Adresse?: AdresseUpdateManyWithoutUtilisateurNestedInput
    Contact?: ContactUpdateManyWithoutUtilisateurNestedInput
    Produit?: ProduitUpdateManyWithoutUtilisateurNestedInput
    Vente?: VenteUpdateManyWithoutUtilisateurNestedInput
    Achat?: AchatUpdateManyWithoutUtilisateurNestedInput
    Teneur?: TeneurUpdateManyWithoutUtilisateurNestedInput
    Devise?: DeviseUpdateManyWithoutUtilisateurNestedInput
    Panier?: PanierUpdateManyWithoutUtilisateurNestedInput
    Reservation?: ReservationUpdateManyWithoutUtilisateurNestedInput
    Commande?: CommandeUpdateManyWithoutClientNestedInput
    Caisse?: CaisseUpdateManyWithoutUtilisateurNestedInput
    ClotureCaisse?: ClotureCaisseUpdateManyWithoutUtilisateurClotureNestedInput
  }

  export type UtilisateurUncheckedUpdateWithoutMouvementCaisseInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    postnom?: StringFieldUpdateOperationsInput | string
    nom_complet?: NullableStringFieldUpdateOperationsInput | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    poste?: NullableEnumPosteFieldUpdateOperationsInput | $Enums.Poste | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Adresse?: AdresseUncheckedUpdateManyWithoutUtilisateurNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutUtilisateurNestedInput
    Produit?: ProduitUncheckedUpdateManyWithoutUtilisateurNestedInput
    Vente?: VenteUncheckedUpdateManyWithoutUtilisateurNestedInput
    Achat?: AchatUncheckedUpdateManyWithoutUtilisateurNestedInput
    Teneur?: TeneurUncheckedUpdateManyWithoutUtilisateurNestedInput
    Devise?: DeviseUncheckedUpdateManyWithoutUtilisateurNestedInput
    Panier?: PanierUncheckedUpdateManyWithoutUtilisateurNestedInput
    Reservation?: ReservationUncheckedUpdateManyWithoutUtilisateurNestedInput
    Commande?: CommandeUncheckedUpdateManyWithoutClientNestedInput
    Caisse?: CaisseUncheckedUpdateManyWithoutUtilisateurNestedInput
    ClotureCaisse?: ClotureCaisseUncheckedUpdateManyWithoutUtilisateurClotureNestedInput
  }

  export type ProduitCreateWithoutDetailClotureCaisseInput = {
    designation: string
    prix: number
    qtte?: number
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    devise: DeviseCreateNestedOneWithoutProduitInput
    teneur: TeneurCreateNestedOneWithoutProduitInput
    utilisateur: UtilisateurCreateNestedOneWithoutProduitInput
    DetailPanier?: DetailPanierCreateNestedManyWithoutProduitInput
  }

  export type ProduitUncheckedCreateWithoutDetailClotureCaisseInput = {
    id?: number
    designation: string
    prix: number
    qtte?: number
    description: string
    deviseId: number
    teneurId: number
    utilisateurId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    DetailPanier?: DetailPanierUncheckedCreateNestedManyWithoutProduitInput
  }

  export type ProduitCreateOrConnectWithoutDetailClotureCaisseInput = {
    where: ProduitWhereUniqueInput
    create: XOR<ProduitCreateWithoutDetailClotureCaisseInput, ProduitUncheckedCreateWithoutDetailClotureCaisseInput>
  }

  export type TeneurCreateWithoutDetailClotureCaisseInput = {
    valeur: number
    createdAt?: Date | string
    updatedAt?: Date | string
    utilisateur: UtilisateurCreateNestedOneWithoutTeneurInput
    Produit?: ProduitCreateNestedManyWithoutTeneurInput
  }

  export type TeneurUncheckedCreateWithoutDetailClotureCaisseInput = {
    id?: number
    valeur: number
    utilisateurId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    Produit?: ProduitUncheckedCreateNestedManyWithoutTeneurInput
  }

  export type TeneurCreateOrConnectWithoutDetailClotureCaisseInput = {
    where: TeneurWhereUniqueInput
    create: XOR<TeneurCreateWithoutDetailClotureCaisseInput, TeneurUncheckedCreateWithoutDetailClotureCaisseInput>
  }

  export type ClotureCaisseCreateWithoutDetailClotureCaisseInput = {
    dateCloture?: Date | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    caisse: CaisseCreateNestedOneWithoutCloturesInput
    utilisateurCloture: UtilisateurCreateNestedOneWithoutClotureCaisseInput
  }

  export type ClotureCaisseUncheckedCreateWithoutDetailClotureCaisseInput = {
    id?: number
    caisseId: number
    dateCloture?: Date | string
    utilisateurClotureId: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClotureCaisseCreateOrConnectWithoutDetailClotureCaisseInput = {
    where: ClotureCaisseWhereUniqueInput
    create: XOR<ClotureCaisseCreateWithoutDetailClotureCaisseInput, ClotureCaisseUncheckedCreateWithoutDetailClotureCaisseInput>
  }

  export type ProduitUpsertWithoutDetailClotureCaisseInput = {
    update: XOR<ProduitUpdateWithoutDetailClotureCaisseInput, ProduitUncheckedUpdateWithoutDetailClotureCaisseInput>
    create: XOR<ProduitCreateWithoutDetailClotureCaisseInput, ProduitUncheckedCreateWithoutDetailClotureCaisseInput>
    where?: ProduitWhereInput
  }

  export type ProduitUpdateToOneWithWhereWithoutDetailClotureCaisseInput = {
    where?: ProduitWhereInput
    data: XOR<ProduitUpdateWithoutDetailClotureCaisseInput, ProduitUncheckedUpdateWithoutDetailClotureCaisseInput>
  }

  export type ProduitUpdateWithoutDetailClotureCaisseInput = {
    designation?: StringFieldUpdateOperationsInput | string
    prix?: FloatFieldUpdateOperationsInput | number
    qtte?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    devise?: DeviseUpdateOneRequiredWithoutProduitNestedInput
    teneur?: TeneurUpdateOneRequiredWithoutProduitNestedInput
    utilisateur?: UtilisateurUpdateOneRequiredWithoutProduitNestedInput
    DetailPanier?: DetailPanierUpdateManyWithoutProduitNestedInput
  }

  export type ProduitUncheckedUpdateWithoutDetailClotureCaisseInput = {
    id?: IntFieldUpdateOperationsInput | number
    designation?: StringFieldUpdateOperationsInput | string
    prix?: FloatFieldUpdateOperationsInput | number
    qtte?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    deviseId?: IntFieldUpdateOperationsInput | number
    teneurId?: IntFieldUpdateOperationsInput | number
    utilisateurId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DetailPanier?: DetailPanierUncheckedUpdateManyWithoutProduitNestedInput
  }

  export type TeneurUpsertWithoutDetailClotureCaisseInput = {
    update: XOR<TeneurUpdateWithoutDetailClotureCaisseInput, TeneurUncheckedUpdateWithoutDetailClotureCaisseInput>
    create: XOR<TeneurCreateWithoutDetailClotureCaisseInput, TeneurUncheckedCreateWithoutDetailClotureCaisseInput>
    where?: TeneurWhereInput
  }

  export type TeneurUpdateToOneWithWhereWithoutDetailClotureCaisseInput = {
    where?: TeneurWhereInput
    data: XOR<TeneurUpdateWithoutDetailClotureCaisseInput, TeneurUncheckedUpdateWithoutDetailClotureCaisseInput>
  }

  export type TeneurUpdateWithoutDetailClotureCaisseInput = {
    valeur?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    utilisateur?: UtilisateurUpdateOneRequiredWithoutTeneurNestedInput
    Produit?: ProduitUpdateManyWithoutTeneurNestedInput
  }

  export type TeneurUncheckedUpdateWithoutDetailClotureCaisseInput = {
    id?: IntFieldUpdateOperationsInput | number
    valeur?: FloatFieldUpdateOperationsInput | number
    utilisateurId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Produit?: ProduitUncheckedUpdateManyWithoutTeneurNestedInput
  }

  export type ClotureCaisseUpsertWithoutDetailClotureCaisseInput = {
    update: XOR<ClotureCaisseUpdateWithoutDetailClotureCaisseInput, ClotureCaisseUncheckedUpdateWithoutDetailClotureCaisseInput>
    create: XOR<ClotureCaisseCreateWithoutDetailClotureCaisseInput, ClotureCaisseUncheckedCreateWithoutDetailClotureCaisseInput>
    where?: ClotureCaisseWhereInput
  }

  export type ClotureCaisseUpdateToOneWithWhereWithoutDetailClotureCaisseInput = {
    where?: ClotureCaisseWhereInput
    data: XOR<ClotureCaisseUpdateWithoutDetailClotureCaisseInput, ClotureCaisseUncheckedUpdateWithoutDetailClotureCaisseInput>
  }

  export type ClotureCaisseUpdateWithoutDetailClotureCaisseInput = {
    dateCloture?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    caisse?: CaisseUpdateOneRequiredWithoutCloturesNestedInput
    utilisateurCloture?: UtilisateurUpdateOneRequiredWithoutClotureCaisseNestedInput
  }

  export type ClotureCaisseUncheckedUpdateWithoutDetailClotureCaisseInput = {
    id?: IntFieldUpdateOperationsInput | number
    caisseId?: IntFieldUpdateOperationsInput | number
    dateCloture?: DateTimeFieldUpdateOperationsInput | Date | string
    utilisateurClotureId?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CaisseCreateWithoutCloturesInput = {
    nom: string
    description?: string | null
    soldeInitial: number
    soldeActuel: number
    statut?: $Enums.StatutCaisse
    createdAt?: Date | string
    updatedAt?: Date | string
    devise: DeviseCreateNestedOneWithoutCaisseInput
    utilisateur: UtilisateurCreateNestedOneWithoutCaisseInput
    MouvementCaisse?: MouvementCaisseCreateNestedManyWithoutCaisseInput
    Paiement?: PaiementCreateNestedManyWithoutCaisseInput
  }

  export type CaisseUncheckedCreateWithoutCloturesInput = {
    id?: number
    nom: string
    description?: string | null
    soldeInitial: number
    soldeActuel: number
    deviseId: number
    creeParId: number
    statut?: $Enums.StatutCaisse
    createdAt?: Date | string
    updatedAt?: Date | string
    MouvementCaisse?: MouvementCaisseUncheckedCreateNestedManyWithoutCaisseInput
    Paiement?: PaiementUncheckedCreateNestedManyWithoutCaisseInput
  }

  export type CaisseCreateOrConnectWithoutCloturesInput = {
    where: CaisseWhereUniqueInput
    create: XOR<CaisseCreateWithoutCloturesInput, CaisseUncheckedCreateWithoutCloturesInput>
  }

  export type UtilisateurCreateWithoutClotureCaisseInput = {
    email: string
    nom: string
    postnom: string
    nom_complet?: string | null
    sexe?: $Enums.Sexe | null
    role?: $Enums.Role
    poste?: $Enums.Poste | null
    picture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Adresse?: AdresseCreateNestedManyWithoutUtilisateurInput
    Contact?: ContactCreateNestedManyWithoutUtilisateurInput
    Produit?: ProduitCreateNestedManyWithoutUtilisateurInput
    Vente?: VenteCreateNestedManyWithoutUtilisateurInput
    Achat?: AchatCreateNestedManyWithoutUtilisateurInput
    Teneur?: TeneurCreateNestedManyWithoutUtilisateurInput
    Devise?: DeviseCreateNestedManyWithoutUtilisateurInput
    Panier?: PanierCreateNestedManyWithoutUtilisateurInput
    Reservation?: ReservationCreateNestedManyWithoutUtilisateurInput
    Commande?: CommandeCreateNestedManyWithoutClientInput
    Caisse?: CaisseCreateNestedManyWithoutUtilisateurInput
    MouvementCaisse?: MouvementCaisseCreateNestedManyWithoutUtilisateurInput
  }

  export type UtilisateurUncheckedCreateWithoutClotureCaisseInput = {
    id?: number
    email: string
    nom: string
    postnom: string
    nom_complet?: string | null
    sexe?: $Enums.Sexe | null
    role?: $Enums.Role
    poste?: $Enums.Poste | null
    picture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Adresse?: AdresseUncheckedCreateNestedManyWithoutUtilisateurInput
    Contact?: ContactUncheckedCreateNestedManyWithoutUtilisateurInput
    Produit?: ProduitUncheckedCreateNestedManyWithoutUtilisateurInput
    Vente?: VenteUncheckedCreateNestedManyWithoutUtilisateurInput
    Achat?: AchatUncheckedCreateNestedManyWithoutUtilisateurInput
    Teneur?: TeneurUncheckedCreateNestedManyWithoutUtilisateurInput
    Devise?: DeviseUncheckedCreateNestedManyWithoutUtilisateurInput
    Panier?: PanierUncheckedCreateNestedManyWithoutUtilisateurInput
    Reservation?: ReservationUncheckedCreateNestedManyWithoutUtilisateurInput
    Commande?: CommandeUncheckedCreateNestedManyWithoutClientInput
    Caisse?: CaisseUncheckedCreateNestedManyWithoutUtilisateurInput
    MouvementCaisse?: MouvementCaisseUncheckedCreateNestedManyWithoutUtilisateurInput
  }

  export type UtilisateurCreateOrConnectWithoutClotureCaisseInput = {
    where: UtilisateurWhereUniqueInput
    create: XOR<UtilisateurCreateWithoutClotureCaisseInput, UtilisateurUncheckedCreateWithoutClotureCaisseInput>
  }

  export type DetailClotureCaisseCreateWithoutClotureCaisseInput = {
    qtteRestante: number
    createdAt?: Date | string
    updatedAt?: Date | string
    produit: ProduitCreateNestedOneWithoutDetailClotureCaisseInput
    teneur: TeneurCreateNestedOneWithoutDetailClotureCaisseInput
  }

  export type DetailClotureCaisseUncheckedCreateWithoutClotureCaisseInput = {
    id?: number
    produitId: number
    teneurId: number
    qtteRestante: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DetailClotureCaisseCreateOrConnectWithoutClotureCaisseInput = {
    where: DetailClotureCaisseWhereUniqueInput
    create: XOR<DetailClotureCaisseCreateWithoutClotureCaisseInput, DetailClotureCaisseUncheckedCreateWithoutClotureCaisseInput>
  }

  export type DetailClotureCaisseCreateManyClotureCaisseInputEnvelope = {
    data: DetailClotureCaisseCreateManyClotureCaisseInput | DetailClotureCaisseCreateManyClotureCaisseInput[]
    skipDuplicates?: boolean
  }

  export type CaisseUpsertWithoutCloturesInput = {
    update: XOR<CaisseUpdateWithoutCloturesInput, CaisseUncheckedUpdateWithoutCloturesInput>
    create: XOR<CaisseCreateWithoutCloturesInput, CaisseUncheckedCreateWithoutCloturesInput>
    where?: CaisseWhereInput
  }

  export type CaisseUpdateToOneWithWhereWithoutCloturesInput = {
    where?: CaisseWhereInput
    data: XOR<CaisseUpdateWithoutCloturesInput, CaisseUncheckedUpdateWithoutCloturesInput>
  }

  export type CaisseUpdateWithoutCloturesInput = {
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    soldeInitial?: FloatFieldUpdateOperationsInput | number
    soldeActuel?: FloatFieldUpdateOperationsInput | number
    statut?: EnumStatutCaisseFieldUpdateOperationsInput | $Enums.StatutCaisse
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    devise?: DeviseUpdateOneRequiredWithoutCaisseNestedInput
    utilisateur?: UtilisateurUpdateOneRequiredWithoutCaisseNestedInput
    MouvementCaisse?: MouvementCaisseUpdateManyWithoutCaisseNestedInput
    Paiement?: PaiementUpdateManyWithoutCaisseNestedInput
  }

  export type CaisseUncheckedUpdateWithoutCloturesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    soldeInitial?: FloatFieldUpdateOperationsInput | number
    soldeActuel?: FloatFieldUpdateOperationsInput | number
    deviseId?: IntFieldUpdateOperationsInput | number
    creeParId?: IntFieldUpdateOperationsInput | number
    statut?: EnumStatutCaisseFieldUpdateOperationsInput | $Enums.StatutCaisse
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    MouvementCaisse?: MouvementCaisseUncheckedUpdateManyWithoutCaisseNestedInput
    Paiement?: PaiementUncheckedUpdateManyWithoutCaisseNestedInput
  }

  export type UtilisateurUpsertWithoutClotureCaisseInput = {
    update: XOR<UtilisateurUpdateWithoutClotureCaisseInput, UtilisateurUncheckedUpdateWithoutClotureCaisseInput>
    create: XOR<UtilisateurCreateWithoutClotureCaisseInput, UtilisateurUncheckedCreateWithoutClotureCaisseInput>
    where?: UtilisateurWhereInput
  }

  export type UtilisateurUpdateToOneWithWhereWithoutClotureCaisseInput = {
    where?: UtilisateurWhereInput
    data: XOR<UtilisateurUpdateWithoutClotureCaisseInput, UtilisateurUncheckedUpdateWithoutClotureCaisseInput>
  }

  export type UtilisateurUpdateWithoutClotureCaisseInput = {
    email?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    postnom?: StringFieldUpdateOperationsInput | string
    nom_complet?: NullableStringFieldUpdateOperationsInput | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    poste?: NullableEnumPosteFieldUpdateOperationsInput | $Enums.Poste | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Adresse?: AdresseUpdateManyWithoutUtilisateurNestedInput
    Contact?: ContactUpdateManyWithoutUtilisateurNestedInput
    Produit?: ProduitUpdateManyWithoutUtilisateurNestedInput
    Vente?: VenteUpdateManyWithoutUtilisateurNestedInput
    Achat?: AchatUpdateManyWithoutUtilisateurNestedInput
    Teneur?: TeneurUpdateManyWithoutUtilisateurNestedInput
    Devise?: DeviseUpdateManyWithoutUtilisateurNestedInput
    Panier?: PanierUpdateManyWithoutUtilisateurNestedInput
    Reservation?: ReservationUpdateManyWithoutUtilisateurNestedInput
    Commande?: CommandeUpdateManyWithoutClientNestedInput
    Caisse?: CaisseUpdateManyWithoutUtilisateurNestedInput
    MouvementCaisse?: MouvementCaisseUpdateManyWithoutUtilisateurNestedInput
  }

  export type UtilisateurUncheckedUpdateWithoutClotureCaisseInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    postnom?: StringFieldUpdateOperationsInput | string
    nom_complet?: NullableStringFieldUpdateOperationsInput | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    poste?: NullableEnumPosteFieldUpdateOperationsInput | $Enums.Poste | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Adresse?: AdresseUncheckedUpdateManyWithoutUtilisateurNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutUtilisateurNestedInput
    Produit?: ProduitUncheckedUpdateManyWithoutUtilisateurNestedInput
    Vente?: VenteUncheckedUpdateManyWithoutUtilisateurNestedInput
    Achat?: AchatUncheckedUpdateManyWithoutUtilisateurNestedInput
    Teneur?: TeneurUncheckedUpdateManyWithoutUtilisateurNestedInput
    Devise?: DeviseUncheckedUpdateManyWithoutUtilisateurNestedInput
    Panier?: PanierUncheckedUpdateManyWithoutUtilisateurNestedInput
    Reservation?: ReservationUncheckedUpdateManyWithoutUtilisateurNestedInput
    Commande?: CommandeUncheckedUpdateManyWithoutClientNestedInput
    Caisse?: CaisseUncheckedUpdateManyWithoutUtilisateurNestedInput
    MouvementCaisse?: MouvementCaisseUncheckedUpdateManyWithoutUtilisateurNestedInput
  }

  export type DetailClotureCaisseUpsertWithWhereUniqueWithoutClotureCaisseInput = {
    where: DetailClotureCaisseWhereUniqueInput
    update: XOR<DetailClotureCaisseUpdateWithoutClotureCaisseInput, DetailClotureCaisseUncheckedUpdateWithoutClotureCaisseInput>
    create: XOR<DetailClotureCaisseCreateWithoutClotureCaisseInput, DetailClotureCaisseUncheckedCreateWithoutClotureCaisseInput>
  }

  export type DetailClotureCaisseUpdateWithWhereUniqueWithoutClotureCaisseInput = {
    where: DetailClotureCaisseWhereUniqueInput
    data: XOR<DetailClotureCaisseUpdateWithoutClotureCaisseInput, DetailClotureCaisseUncheckedUpdateWithoutClotureCaisseInput>
  }

  export type DetailClotureCaisseUpdateManyWithWhereWithoutClotureCaisseInput = {
    where: DetailClotureCaisseScalarWhereInput
    data: XOR<DetailClotureCaisseUpdateManyMutationInput, DetailClotureCaisseUncheckedUpdateManyWithoutClotureCaisseInput>
  }

  export type AdresseCreateManyUtilisateurInput = {
    id?: number
    ville: string
    commune: string
    adresse: string
    fournisseurId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactCreateManyUtilisateurInput = {
    id?: number
    tel: string
    fournisseurId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProduitCreateManyUtilisateurInput = {
    id?: number
    designation: string
    prix: number
    qtte?: number
    description: string
    deviseId: number
    teneurId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VenteCreateManyUtilisateurInput = {
    id?: number
    statut?: $Enums.StatutVente
    total_ttc: number
    total_ht: number
    type_acheteur: $Enums.TypeClient
    clientId?: number | null
    fournisseurId?: number | null
    agentId?: number | null
    paiementId: number
    panierId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AchatCreateManyUtilisateurInput = {
    id?: number
    statut?: $Enums.StatutAchat
    panierId: number
    fournisseurId: number
    paiementId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeneurCreateManyUtilisateurInput = {
    id?: number
    valeur: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeviseCreateManyUtilisateurInput = {
    id?: number
    nom: string
    code: string
    symbole: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PanierCreateManyUtilisateurInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReservationCreateManyUtilisateurInput = {
    id?: number
    dateLivraisonSouhaitee: Date | string
    adresseLivraison?: string | null
    statut?: $Enums.StatutReservation
    notes?: string | null
    type_client?: $Enums.TypeClient
    panierId: number
    nom?: string | null
    tel?: string | null
    adresseId?: number | null
    contactId?: number | null
    enregistrerParId?: number | null
    fournisseurId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommandeCreateManyClientInput = {
    id?: number
    panierId: number
    nom?: string | null
    tel?: string | null
    type_client?: $Enums.TypeClient
    paiementId: number
    adresseId?: number | null
    contactId?: number | null
    fournisseurId?: number | null
    notes?: string | null
    dateLivraisonEffective?: Date | string | null
    adresseLivraison?: string | null
    enregistrerParId?: number | null
    statut?: $Enums.StatutCommande
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CaisseCreateManyUtilisateurInput = {
    id?: number
    nom: string
    description?: string | null
    soldeInitial: number
    soldeActuel: number
    deviseId: number
    statut?: $Enums.StatutCaisse
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MouvementCaisseCreateManyUtilisateurInput = {
    id?: number
    caisseId: number
    type_mouvement?: $Enums.TypeMouvementCaisse
    categorie?: $Enums.CategorieMouvement
    montant: number
    description?: string | null
    referenceExterne?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClotureCaisseCreateManyUtilisateurClotureInput = {
    id?: number
    caisseId: number
    dateCloture?: Date | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdresseUpdateWithoutUtilisateurInput = {
    ville?: StringFieldUpdateOperationsInput | string
    commune?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fournisseur?: FournisseurUpdateOneWithoutAdresseNestedInput
    Reservation?: ReservationUpdateManyWithoutAdresseNestedInput
    Commande?: CommandeUpdateManyWithoutAdresseNestedInput
  }

  export type AdresseUncheckedUpdateWithoutUtilisateurInput = {
    id?: IntFieldUpdateOperationsInput | number
    ville?: StringFieldUpdateOperationsInput | string
    commune?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Reservation?: ReservationUncheckedUpdateManyWithoutAdresseNestedInput
    Commande?: CommandeUncheckedUpdateManyWithoutAdresseNestedInput
  }

  export type AdresseUncheckedUpdateManyWithoutUtilisateurInput = {
    id?: IntFieldUpdateOperationsInput | number
    ville?: StringFieldUpdateOperationsInput | string
    commune?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUpdateWithoutUtilisateurInput = {
    tel?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fournisseur?: FournisseurUpdateOneWithoutContactNestedInput
    Reservation?: ReservationUpdateManyWithoutContactNestedInput
    Commande?: CommandeUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutUtilisateurInput = {
    id?: IntFieldUpdateOperationsInput | number
    tel?: StringFieldUpdateOperationsInput | string
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Reservation?: ReservationUncheckedUpdateManyWithoutContactNestedInput
    Commande?: CommandeUncheckedUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateManyWithoutUtilisateurInput = {
    id?: IntFieldUpdateOperationsInput | number
    tel?: StringFieldUpdateOperationsInput | string
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProduitUpdateWithoutUtilisateurInput = {
    designation?: StringFieldUpdateOperationsInput | string
    prix?: FloatFieldUpdateOperationsInput | number
    qtte?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    devise?: DeviseUpdateOneRequiredWithoutProduitNestedInput
    teneur?: TeneurUpdateOneRequiredWithoutProduitNestedInput
    DetailPanier?: DetailPanierUpdateManyWithoutProduitNestedInput
    DetailClotureCaisse?: DetailClotureCaisseUpdateManyWithoutProduitNestedInput
  }

  export type ProduitUncheckedUpdateWithoutUtilisateurInput = {
    id?: IntFieldUpdateOperationsInput | number
    designation?: StringFieldUpdateOperationsInput | string
    prix?: FloatFieldUpdateOperationsInput | number
    qtte?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    deviseId?: IntFieldUpdateOperationsInput | number
    teneurId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DetailPanier?: DetailPanierUncheckedUpdateManyWithoutProduitNestedInput
    DetailClotureCaisse?: DetailClotureCaisseUncheckedUpdateManyWithoutProduitNestedInput
  }

  export type ProduitUncheckedUpdateManyWithoutUtilisateurInput = {
    id?: IntFieldUpdateOperationsInput | number
    designation?: StringFieldUpdateOperationsInput | string
    prix?: FloatFieldUpdateOperationsInput | number
    qtte?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    deviseId?: IntFieldUpdateOperationsInput | number
    teneurId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VenteUpdateWithoutUtilisateurInput = {
    statut?: EnumStatutVenteFieldUpdateOperationsInput | $Enums.StatutVente
    total_ttc?: FloatFieldUpdateOperationsInput | number
    total_ht?: FloatFieldUpdateOperationsInput | number
    type_acheteur?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    agentId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paiement?: PaiementUpdateOneWithoutVenteNestedInput
    panier?: PanierUpdateOneRequiredWithoutVenteNestedInput
    fournisseur?: FournisseurUpdateOneWithoutVenteNestedInput
  }

  export type VenteUncheckedUpdateWithoutUtilisateurInput = {
    id?: IntFieldUpdateOperationsInput | number
    statut?: EnumStatutVenteFieldUpdateOperationsInput | $Enums.StatutVente
    total_ttc?: FloatFieldUpdateOperationsInput | number
    total_ht?: FloatFieldUpdateOperationsInput | number
    type_acheteur?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    agentId?: NullableIntFieldUpdateOperationsInput | number | null
    paiementId?: IntFieldUpdateOperationsInput | number
    panierId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VenteUncheckedUpdateManyWithoutUtilisateurInput = {
    id?: IntFieldUpdateOperationsInput | number
    statut?: EnumStatutVenteFieldUpdateOperationsInput | $Enums.StatutVente
    total_ttc?: FloatFieldUpdateOperationsInput | number
    total_ht?: FloatFieldUpdateOperationsInput | number
    type_acheteur?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    agentId?: NullableIntFieldUpdateOperationsInput | number | null
    paiementId?: IntFieldUpdateOperationsInput | number
    panierId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchatUpdateWithoutUtilisateurInput = {
    statut?: EnumStatutAchatFieldUpdateOperationsInput | $Enums.StatutAchat
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    panier?: PanierUpdateOneRequiredWithoutAchatNestedInput
    fournisseur?: FournisseurUpdateOneRequiredWithoutAchatNestedInput
    paiement?: PaiementUpdateOneRequiredWithoutAchatNestedInput
  }

  export type AchatUncheckedUpdateWithoutUtilisateurInput = {
    id?: IntFieldUpdateOperationsInput | number
    statut?: EnumStatutAchatFieldUpdateOperationsInput | $Enums.StatutAchat
    panierId?: IntFieldUpdateOperationsInput | number
    fournisseurId?: IntFieldUpdateOperationsInput | number
    paiementId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchatUncheckedUpdateManyWithoutUtilisateurInput = {
    id?: IntFieldUpdateOperationsInput | number
    statut?: EnumStatutAchatFieldUpdateOperationsInput | $Enums.StatutAchat
    panierId?: IntFieldUpdateOperationsInput | number
    fournisseurId?: IntFieldUpdateOperationsInput | number
    paiementId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeneurUpdateWithoutUtilisateurInput = {
    valeur?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Produit?: ProduitUpdateManyWithoutTeneurNestedInput
    DetailClotureCaisse?: DetailClotureCaisseUpdateManyWithoutTeneurNestedInput
  }

  export type TeneurUncheckedUpdateWithoutUtilisateurInput = {
    id?: IntFieldUpdateOperationsInput | number
    valeur?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Produit?: ProduitUncheckedUpdateManyWithoutTeneurNestedInput
    DetailClotureCaisse?: DetailClotureCaisseUncheckedUpdateManyWithoutTeneurNestedInput
  }

  export type TeneurUncheckedUpdateManyWithoutUtilisateurInput = {
    id?: IntFieldUpdateOperationsInput | number
    valeur?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviseUpdateWithoutUtilisateurInput = {
    nom?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    symbole?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Produit?: ProduitUpdateManyWithoutDeviseNestedInput
    Paiement?: PaiementUpdateManyWithoutDeviseNestedInput
    Caisse?: CaisseUpdateManyWithoutDeviseNestedInput
  }

  export type DeviseUncheckedUpdateWithoutUtilisateurInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    symbole?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Produit?: ProduitUncheckedUpdateManyWithoutDeviseNestedInput
    Paiement?: PaiementUncheckedUpdateManyWithoutDeviseNestedInput
    Caisse?: CaisseUncheckedUpdateManyWithoutDeviseNestedInput
  }

  export type DeviseUncheckedUpdateManyWithoutUtilisateurInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    symbole?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PanierUpdateWithoutUtilisateurInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DetailPanier?: DetailPanierUpdateManyWithoutPanierNestedInput
    Achat?: AchatUpdateManyWithoutPanierNestedInput
    Vente?: VenteUpdateManyWithoutPanierNestedInput
    Reservation?: ReservationUpdateManyWithoutPanierNestedInput
    Commande?: CommandeUpdateManyWithoutPanierNestedInput
  }

  export type PanierUncheckedUpdateWithoutUtilisateurInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DetailPanier?: DetailPanierUncheckedUpdateManyWithoutPanierNestedInput
    Achat?: AchatUncheckedUpdateManyWithoutPanierNestedInput
    Vente?: VenteUncheckedUpdateManyWithoutPanierNestedInput
    Reservation?: ReservationUncheckedUpdateManyWithoutPanierNestedInput
    Commande?: CommandeUncheckedUpdateManyWithoutPanierNestedInput
  }

  export type PanierUncheckedUpdateManyWithoutUtilisateurInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReservationUpdateWithoutUtilisateurInput = {
    dateLivraisonSouhaitee?: DateTimeFieldUpdateOperationsInput | Date | string
    adresseLivraison?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: EnumStatutReservationFieldUpdateOperationsInput | $Enums.StatutReservation
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    type_client?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    enregistrerParId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    panier?: PanierUpdateOneRequiredWithoutReservationNestedInput
    fournisseur?: FournisseurUpdateOneWithoutReservationNestedInput
    adresse?: AdresseUpdateOneWithoutReservationNestedInput
    contact?: ContactUpdateOneWithoutReservationNestedInput
  }

  export type ReservationUncheckedUpdateWithoutUtilisateurInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateLivraisonSouhaitee?: DateTimeFieldUpdateOperationsInput | Date | string
    adresseLivraison?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: EnumStatutReservationFieldUpdateOperationsInput | $Enums.StatutReservation
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    type_client?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    panierId?: IntFieldUpdateOperationsInput | number
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    adresseId?: NullableIntFieldUpdateOperationsInput | number | null
    contactId?: NullableIntFieldUpdateOperationsInput | number | null
    enregistrerParId?: NullableIntFieldUpdateOperationsInput | number | null
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReservationUncheckedUpdateManyWithoutUtilisateurInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateLivraisonSouhaitee?: DateTimeFieldUpdateOperationsInput | Date | string
    adresseLivraison?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: EnumStatutReservationFieldUpdateOperationsInput | $Enums.StatutReservation
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    type_client?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    panierId?: IntFieldUpdateOperationsInput | number
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    adresseId?: NullableIntFieldUpdateOperationsInput | number | null
    contactId?: NullableIntFieldUpdateOperationsInput | number | null
    enregistrerParId?: NullableIntFieldUpdateOperationsInput | number | null
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommandeUpdateWithoutClientInput = {
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    type_client?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    dateLivraisonEffective?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adresseLivraison?: NullableStringFieldUpdateOperationsInput | string | null
    enregistrerParId?: NullableIntFieldUpdateOperationsInput | number | null
    statut?: EnumStatutCommandeFieldUpdateOperationsInput | $Enums.StatutCommande
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    panier?: PanierUpdateOneRequiredWithoutCommandeNestedInput
    paiement?: PaiementUpdateOneRequiredWithoutCommandeNestedInput
    fournisseur?: FournisseurUpdateOneWithoutCommandeNestedInput
    adresse?: AdresseUpdateOneWithoutCommandeNestedInput
    contact?: ContactUpdateOneWithoutCommandeNestedInput
  }

  export type CommandeUncheckedUpdateWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    panierId?: IntFieldUpdateOperationsInput | number
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    type_client?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    paiementId?: IntFieldUpdateOperationsInput | number
    adresseId?: NullableIntFieldUpdateOperationsInput | number | null
    contactId?: NullableIntFieldUpdateOperationsInput | number | null
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    dateLivraisonEffective?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adresseLivraison?: NullableStringFieldUpdateOperationsInput | string | null
    enregistrerParId?: NullableIntFieldUpdateOperationsInput | number | null
    statut?: EnumStatutCommandeFieldUpdateOperationsInput | $Enums.StatutCommande
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommandeUncheckedUpdateManyWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    panierId?: IntFieldUpdateOperationsInput | number
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    type_client?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    paiementId?: IntFieldUpdateOperationsInput | number
    adresseId?: NullableIntFieldUpdateOperationsInput | number | null
    contactId?: NullableIntFieldUpdateOperationsInput | number | null
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    dateLivraisonEffective?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adresseLivraison?: NullableStringFieldUpdateOperationsInput | string | null
    enregistrerParId?: NullableIntFieldUpdateOperationsInput | number | null
    statut?: EnumStatutCommandeFieldUpdateOperationsInput | $Enums.StatutCommande
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CaisseUpdateWithoutUtilisateurInput = {
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    soldeInitial?: FloatFieldUpdateOperationsInput | number
    soldeActuel?: FloatFieldUpdateOperationsInput | number
    statut?: EnumStatutCaisseFieldUpdateOperationsInput | $Enums.StatutCaisse
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    devise?: DeviseUpdateOneRequiredWithoutCaisseNestedInput
    MouvementCaisse?: MouvementCaisseUpdateManyWithoutCaisseNestedInput
    clotures?: ClotureCaisseUpdateManyWithoutCaisseNestedInput
    Paiement?: PaiementUpdateManyWithoutCaisseNestedInput
  }

  export type CaisseUncheckedUpdateWithoutUtilisateurInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    soldeInitial?: FloatFieldUpdateOperationsInput | number
    soldeActuel?: FloatFieldUpdateOperationsInput | number
    deviseId?: IntFieldUpdateOperationsInput | number
    statut?: EnumStatutCaisseFieldUpdateOperationsInput | $Enums.StatutCaisse
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    MouvementCaisse?: MouvementCaisseUncheckedUpdateManyWithoutCaisseNestedInput
    clotures?: ClotureCaisseUncheckedUpdateManyWithoutCaisseNestedInput
    Paiement?: PaiementUncheckedUpdateManyWithoutCaisseNestedInput
  }

  export type CaisseUncheckedUpdateManyWithoutUtilisateurInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    soldeInitial?: FloatFieldUpdateOperationsInput | number
    soldeActuel?: FloatFieldUpdateOperationsInput | number
    deviseId?: IntFieldUpdateOperationsInput | number
    statut?: EnumStatutCaisseFieldUpdateOperationsInput | $Enums.StatutCaisse
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MouvementCaisseUpdateWithoutUtilisateurInput = {
    type_mouvement?: EnumTypeMouvementCaisseFieldUpdateOperationsInput | $Enums.TypeMouvementCaisse
    categorie?: EnumCategorieMouvementFieldUpdateOperationsInput | $Enums.CategorieMouvement
    montant?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    referenceExterne?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    caisse?: CaisseUpdateOneRequiredWithoutMouvementCaisseNestedInput
  }

  export type MouvementCaisseUncheckedUpdateWithoutUtilisateurInput = {
    id?: IntFieldUpdateOperationsInput | number
    caisseId?: IntFieldUpdateOperationsInput | number
    type_mouvement?: EnumTypeMouvementCaisseFieldUpdateOperationsInput | $Enums.TypeMouvementCaisse
    categorie?: EnumCategorieMouvementFieldUpdateOperationsInput | $Enums.CategorieMouvement
    montant?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    referenceExterne?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MouvementCaisseUncheckedUpdateManyWithoutUtilisateurInput = {
    id?: IntFieldUpdateOperationsInput | number
    caisseId?: IntFieldUpdateOperationsInput | number
    type_mouvement?: EnumTypeMouvementCaisseFieldUpdateOperationsInput | $Enums.TypeMouvementCaisse
    categorie?: EnumCategorieMouvementFieldUpdateOperationsInput | $Enums.CategorieMouvement
    montant?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    referenceExterne?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClotureCaisseUpdateWithoutUtilisateurClotureInput = {
    dateCloture?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    caisse?: CaisseUpdateOneRequiredWithoutCloturesNestedInput
    DetailClotureCaisse?: DetailClotureCaisseUpdateManyWithoutClotureCaisseNestedInput
  }

  export type ClotureCaisseUncheckedUpdateWithoutUtilisateurClotureInput = {
    id?: IntFieldUpdateOperationsInput | number
    caisseId?: IntFieldUpdateOperationsInput | number
    dateCloture?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DetailClotureCaisse?: DetailClotureCaisseUncheckedUpdateManyWithoutClotureCaisseNestedInput
  }

  export type ClotureCaisseUncheckedUpdateManyWithoutUtilisateurClotureInput = {
    id?: IntFieldUpdateOperationsInput | number
    caisseId?: IntFieldUpdateOperationsInput | number
    dateCloture?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReservationCreateManyAdresseInput = {
    id?: number
    dateLivraisonSouhaitee: Date | string
    adresseLivraison?: string | null
    statut?: $Enums.StatutReservation
    notes?: string | null
    type_client?: $Enums.TypeClient
    clientId?: number | null
    panierId: number
    nom?: string | null
    tel?: string | null
    contactId?: number | null
    enregistrerParId?: number | null
    fournisseurId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommandeCreateManyAdresseInput = {
    id?: number
    panierId: number
    clientId?: number | null
    nom?: string | null
    tel?: string | null
    type_client?: $Enums.TypeClient
    paiementId: number
    contactId?: number | null
    fournisseurId?: number | null
    notes?: string | null
    dateLivraisonEffective?: Date | string | null
    adresseLivraison?: string | null
    enregistrerParId?: number | null
    statut?: $Enums.StatutCommande
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReservationUpdateWithoutAdresseInput = {
    dateLivraisonSouhaitee?: DateTimeFieldUpdateOperationsInput | Date | string
    adresseLivraison?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: EnumStatutReservationFieldUpdateOperationsInput | $Enums.StatutReservation
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    type_client?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    enregistrerParId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    panier?: PanierUpdateOneRequiredWithoutReservationNestedInput
    utilisateur?: UtilisateurUpdateOneWithoutReservationNestedInput
    fournisseur?: FournisseurUpdateOneWithoutReservationNestedInput
    contact?: ContactUpdateOneWithoutReservationNestedInput
  }

  export type ReservationUncheckedUpdateWithoutAdresseInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateLivraisonSouhaitee?: DateTimeFieldUpdateOperationsInput | Date | string
    adresseLivraison?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: EnumStatutReservationFieldUpdateOperationsInput | $Enums.StatutReservation
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    type_client?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    panierId?: IntFieldUpdateOperationsInput | number
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableIntFieldUpdateOperationsInput | number | null
    enregistrerParId?: NullableIntFieldUpdateOperationsInput | number | null
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReservationUncheckedUpdateManyWithoutAdresseInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateLivraisonSouhaitee?: DateTimeFieldUpdateOperationsInput | Date | string
    adresseLivraison?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: EnumStatutReservationFieldUpdateOperationsInput | $Enums.StatutReservation
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    type_client?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    panierId?: IntFieldUpdateOperationsInput | number
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableIntFieldUpdateOperationsInput | number | null
    enregistrerParId?: NullableIntFieldUpdateOperationsInput | number | null
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommandeUpdateWithoutAdresseInput = {
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    type_client?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    dateLivraisonEffective?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adresseLivraison?: NullableStringFieldUpdateOperationsInput | string | null
    enregistrerParId?: NullableIntFieldUpdateOperationsInput | number | null
    statut?: EnumStatutCommandeFieldUpdateOperationsInput | $Enums.StatutCommande
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    panier?: PanierUpdateOneRequiredWithoutCommandeNestedInput
    client?: UtilisateurUpdateOneWithoutCommandeNestedInput
    paiement?: PaiementUpdateOneRequiredWithoutCommandeNestedInput
    fournisseur?: FournisseurUpdateOneWithoutCommandeNestedInput
    contact?: ContactUpdateOneWithoutCommandeNestedInput
  }

  export type CommandeUncheckedUpdateWithoutAdresseInput = {
    id?: IntFieldUpdateOperationsInput | number
    panierId?: IntFieldUpdateOperationsInput | number
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    type_client?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    paiementId?: IntFieldUpdateOperationsInput | number
    contactId?: NullableIntFieldUpdateOperationsInput | number | null
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    dateLivraisonEffective?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adresseLivraison?: NullableStringFieldUpdateOperationsInput | string | null
    enregistrerParId?: NullableIntFieldUpdateOperationsInput | number | null
    statut?: EnumStatutCommandeFieldUpdateOperationsInput | $Enums.StatutCommande
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommandeUncheckedUpdateManyWithoutAdresseInput = {
    id?: IntFieldUpdateOperationsInput | number
    panierId?: IntFieldUpdateOperationsInput | number
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    type_client?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    paiementId?: IntFieldUpdateOperationsInput | number
    contactId?: NullableIntFieldUpdateOperationsInput | number | null
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    dateLivraisonEffective?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adresseLivraison?: NullableStringFieldUpdateOperationsInput | string | null
    enregistrerParId?: NullableIntFieldUpdateOperationsInput | number | null
    statut?: EnumStatutCommandeFieldUpdateOperationsInput | $Enums.StatutCommande
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReservationCreateManyContactInput = {
    id?: number
    dateLivraisonSouhaitee: Date | string
    adresseLivraison?: string | null
    statut?: $Enums.StatutReservation
    notes?: string | null
    type_client?: $Enums.TypeClient
    clientId?: number | null
    panierId: number
    nom?: string | null
    tel?: string | null
    adresseId?: number | null
    enregistrerParId?: number | null
    fournisseurId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommandeCreateManyContactInput = {
    id?: number
    panierId: number
    clientId?: number | null
    nom?: string | null
    tel?: string | null
    type_client?: $Enums.TypeClient
    paiementId: number
    adresseId?: number | null
    fournisseurId?: number | null
    notes?: string | null
    dateLivraisonEffective?: Date | string | null
    adresseLivraison?: string | null
    enregistrerParId?: number | null
    statut?: $Enums.StatutCommande
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReservationUpdateWithoutContactInput = {
    dateLivraisonSouhaitee?: DateTimeFieldUpdateOperationsInput | Date | string
    adresseLivraison?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: EnumStatutReservationFieldUpdateOperationsInput | $Enums.StatutReservation
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    type_client?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    enregistrerParId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    panier?: PanierUpdateOneRequiredWithoutReservationNestedInput
    utilisateur?: UtilisateurUpdateOneWithoutReservationNestedInput
    fournisseur?: FournisseurUpdateOneWithoutReservationNestedInput
    adresse?: AdresseUpdateOneWithoutReservationNestedInput
  }

  export type ReservationUncheckedUpdateWithoutContactInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateLivraisonSouhaitee?: DateTimeFieldUpdateOperationsInput | Date | string
    adresseLivraison?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: EnumStatutReservationFieldUpdateOperationsInput | $Enums.StatutReservation
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    type_client?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    panierId?: IntFieldUpdateOperationsInput | number
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    adresseId?: NullableIntFieldUpdateOperationsInput | number | null
    enregistrerParId?: NullableIntFieldUpdateOperationsInput | number | null
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReservationUncheckedUpdateManyWithoutContactInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateLivraisonSouhaitee?: DateTimeFieldUpdateOperationsInput | Date | string
    adresseLivraison?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: EnumStatutReservationFieldUpdateOperationsInput | $Enums.StatutReservation
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    type_client?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    panierId?: IntFieldUpdateOperationsInput | number
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    adresseId?: NullableIntFieldUpdateOperationsInput | number | null
    enregistrerParId?: NullableIntFieldUpdateOperationsInput | number | null
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommandeUpdateWithoutContactInput = {
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    type_client?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    dateLivraisonEffective?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adresseLivraison?: NullableStringFieldUpdateOperationsInput | string | null
    enregistrerParId?: NullableIntFieldUpdateOperationsInput | number | null
    statut?: EnumStatutCommandeFieldUpdateOperationsInput | $Enums.StatutCommande
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    panier?: PanierUpdateOneRequiredWithoutCommandeNestedInput
    client?: UtilisateurUpdateOneWithoutCommandeNestedInput
    paiement?: PaiementUpdateOneRequiredWithoutCommandeNestedInput
    fournisseur?: FournisseurUpdateOneWithoutCommandeNestedInput
    adresse?: AdresseUpdateOneWithoutCommandeNestedInput
  }

  export type CommandeUncheckedUpdateWithoutContactInput = {
    id?: IntFieldUpdateOperationsInput | number
    panierId?: IntFieldUpdateOperationsInput | number
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    type_client?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    paiementId?: IntFieldUpdateOperationsInput | number
    adresseId?: NullableIntFieldUpdateOperationsInput | number | null
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    dateLivraisonEffective?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adresseLivraison?: NullableStringFieldUpdateOperationsInput | string | null
    enregistrerParId?: NullableIntFieldUpdateOperationsInput | number | null
    statut?: EnumStatutCommandeFieldUpdateOperationsInput | $Enums.StatutCommande
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommandeUncheckedUpdateManyWithoutContactInput = {
    id?: IntFieldUpdateOperationsInput | number
    panierId?: IntFieldUpdateOperationsInput | number
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    type_client?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    paiementId?: IntFieldUpdateOperationsInput | number
    adresseId?: NullableIntFieldUpdateOperationsInput | number | null
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    dateLivraisonEffective?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adresseLivraison?: NullableStringFieldUpdateOperationsInput | string | null
    enregistrerParId?: NullableIntFieldUpdateOperationsInput | number | null
    statut?: EnumStatutCommandeFieldUpdateOperationsInput | $Enums.StatutCommande
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VenteCreateManyFournisseurInput = {
    id?: number
    statut?: $Enums.StatutVente
    total_ttc: number
    total_ht: number
    type_acheteur: $Enums.TypeClient
    clientId?: number | null
    enregistrerParId: number
    agentId?: number | null
    paiementId: number
    panierId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AchatCreateManyFournisseurInput = {
    id?: number
    statut?: $Enums.StatutAchat
    panierId: number
    enregistrerParId: number
    paiementId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdresseCreateManyFournisseurInput = {
    id?: number
    ville: string
    commune: string
    adresse: string
    utilisateurId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactCreateManyFournisseurInput = {
    id?: number
    tel: string
    utilisateurId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReservationCreateManyFournisseurInput = {
    id?: number
    dateLivraisonSouhaitee: Date | string
    adresseLivraison?: string | null
    statut?: $Enums.StatutReservation
    notes?: string | null
    type_client?: $Enums.TypeClient
    clientId?: number | null
    panierId: number
    nom?: string | null
    tel?: string | null
    adresseId?: number | null
    contactId?: number | null
    enregistrerParId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommandeCreateManyFournisseurInput = {
    id?: number
    panierId: number
    clientId?: number | null
    nom?: string | null
    tel?: string | null
    type_client?: $Enums.TypeClient
    paiementId: number
    adresseId?: number | null
    contactId?: number | null
    notes?: string | null
    dateLivraisonEffective?: Date | string | null
    adresseLivraison?: string | null
    enregistrerParId?: number | null
    statut?: $Enums.StatutCommande
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VenteUpdateWithoutFournisseurInput = {
    statut?: EnumStatutVenteFieldUpdateOperationsInput | $Enums.StatutVente
    total_ttc?: FloatFieldUpdateOperationsInput | number
    total_ht?: FloatFieldUpdateOperationsInput | number
    type_acheteur?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    agentId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paiement?: PaiementUpdateOneWithoutVenteNestedInput
    panier?: PanierUpdateOneRequiredWithoutVenteNestedInput
    utilisateur?: UtilisateurUpdateOneRequiredWithoutVenteNestedInput
  }

  export type VenteUncheckedUpdateWithoutFournisseurInput = {
    id?: IntFieldUpdateOperationsInput | number
    statut?: EnumStatutVenteFieldUpdateOperationsInput | $Enums.StatutVente
    total_ttc?: FloatFieldUpdateOperationsInput | number
    total_ht?: FloatFieldUpdateOperationsInput | number
    type_acheteur?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    enregistrerParId?: IntFieldUpdateOperationsInput | number
    agentId?: NullableIntFieldUpdateOperationsInput | number | null
    paiementId?: IntFieldUpdateOperationsInput | number
    panierId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VenteUncheckedUpdateManyWithoutFournisseurInput = {
    id?: IntFieldUpdateOperationsInput | number
    statut?: EnumStatutVenteFieldUpdateOperationsInput | $Enums.StatutVente
    total_ttc?: FloatFieldUpdateOperationsInput | number
    total_ht?: FloatFieldUpdateOperationsInput | number
    type_acheteur?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    enregistrerParId?: IntFieldUpdateOperationsInput | number
    agentId?: NullableIntFieldUpdateOperationsInput | number | null
    paiementId?: IntFieldUpdateOperationsInput | number
    panierId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchatUpdateWithoutFournisseurInput = {
    statut?: EnumStatutAchatFieldUpdateOperationsInput | $Enums.StatutAchat
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    panier?: PanierUpdateOneRequiredWithoutAchatNestedInput
    utilisateur?: UtilisateurUpdateOneRequiredWithoutAchatNestedInput
    paiement?: PaiementUpdateOneRequiredWithoutAchatNestedInput
  }

  export type AchatUncheckedUpdateWithoutFournisseurInput = {
    id?: IntFieldUpdateOperationsInput | number
    statut?: EnumStatutAchatFieldUpdateOperationsInput | $Enums.StatutAchat
    panierId?: IntFieldUpdateOperationsInput | number
    enregistrerParId?: IntFieldUpdateOperationsInput | number
    paiementId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchatUncheckedUpdateManyWithoutFournisseurInput = {
    id?: IntFieldUpdateOperationsInput | number
    statut?: EnumStatutAchatFieldUpdateOperationsInput | $Enums.StatutAchat
    panierId?: IntFieldUpdateOperationsInput | number
    enregistrerParId?: IntFieldUpdateOperationsInput | number
    paiementId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdresseUpdateWithoutFournisseurInput = {
    ville?: StringFieldUpdateOperationsInput | string
    commune?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    utilisateur?: UtilisateurUpdateOneWithoutAdresseNestedInput
    Reservation?: ReservationUpdateManyWithoutAdresseNestedInput
    Commande?: CommandeUpdateManyWithoutAdresseNestedInput
  }

  export type AdresseUncheckedUpdateWithoutFournisseurInput = {
    id?: IntFieldUpdateOperationsInput | number
    ville?: StringFieldUpdateOperationsInput | string
    commune?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    utilisateurId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Reservation?: ReservationUncheckedUpdateManyWithoutAdresseNestedInput
    Commande?: CommandeUncheckedUpdateManyWithoutAdresseNestedInput
  }

  export type AdresseUncheckedUpdateManyWithoutFournisseurInput = {
    id?: IntFieldUpdateOperationsInput | number
    ville?: StringFieldUpdateOperationsInput | string
    commune?: StringFieldUpdateOperationsInput | string
    adresse?: StringFieldUpdateOperationsInput | string
    utilisateurId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUpdateWithoutFournisseurInput = {
    tel?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    utilisateur?: UtilisateurUpdateOneWithoutContactNestedInput
    Reservation?: ReservationUpdateManyWithoutContactNestedInput
    Commande?: CommandeUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutFournisseurInput = {
    id?: IntFieldUpdateOperationsInput | number
    tel?: StringFieldUpdateOperationsInput | string
    utilisateurId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Reservation?: ReservationUncheckedUpdateManyWithoutContactNestedInput
    Commande?: CommandeUncheckedUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateManyWithoutFournisseurInput = {
    id?: IntFieldUpdateOperationsInput | number
    tel?: StringFieldUpdateOperationsInput | string
    utilisateurId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReservationUpdateWithoutFournisseurInput = {
    dateLivraisonSouhaitee?: DateTimeFieldUpdateOperationsInput | Date | string
    adresseLivraison?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: EnumStatutReservationFieldUpdateOperationsInput | $Enums.StatutReservation
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    type_client?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    enregistrerParId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    panier?: PanierUpdateOneRequiredWithoutReservationNestedInput
    utilisateur?: UtilisateurUpdateOneWithoutReservationNestedInput
    adresse?: AdresseUpdateOneWithoutReservationNestedInput
    contact?: ContactUpdateOneWithoutReservationNestedInput
  }

  export type ReservationUncheckedUpdateWithoutFournisseurInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateLivraisonSouhaitee?: DateTimeFieldUpdateOperationsInput | Date | string
    adresseLivraison?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: EnumStatutReservationFieldUpdateOperationsInput | $Enums.StatutReservation
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    type_client?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    panierId?: IntFieldUpdateOperationsInput | number
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    adresseId?: NullableIntFieldUpdateOperationsInput | number | null
    contactId?: NullableIntFieldUpdateOperationsInput | number | null
    enregistrerParId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReservationUncheckedUpdateManyWithoutFournisseurInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateLivraisonSouhaitee?: DateTimeFieldUpdateOperationsInput | Date | string
    adresseLivraison?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: EnumStatutReservationFieldUpdateOperationsInput | $Enums.StatutReservation
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    type_client?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    panierId?: IntFieldUpdateOperationsInput | number
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    adresseId?: NullableIntFieldUpdateOperationsInput | number | null
    contactId?: NullableIntFieldUpdateOperationsInput | number | null
    enregistrerParId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommandeUpdateWithoutFournisseurInput = {
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    type_client?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    dateLivraisonEffective?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adresseLivraison?: NullableStringFieldUpdateOperationsInput | string | null
    enregistrerParId?: NullableIntFieldUpdateOperationsInput | number | null
    statut?: EnumStatutCommandeFieldUpdateOperationsInput | $Enums.StatutCommande
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    panier?: PanierUpdateOneRequiredWithoutCommandeNestedInput
    client?: UtilisateurUpdateOneWithoutCommandeNestedInput
    paiement?: PaiementUpdateOneRequiredWithoutCommandeNestedInput
    adresse?: AdresseUpdateOneWithoutCommandeNestedInput
    contact?: ContactUpdateOneWithoutCommandeNestedInput
  }

  export type CommandeUncheckedUpdateWithoutFournisseurInput = {
    id?: IntFieldUpdateOperationsInput | number
    panierId?: IntFieldUpdateOperationsInput | number
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    type_client?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    paiementId?: IntFieldUpdateOperationsInput | number
    adresseId?: NullableIntFieldUpdateOperationsInput | number | null
    contactId?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    dateLivraisonEffective?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adresseLivraison?: NullableStringFieldUpdateOperationsInput | string | null
    enregistrerParId?: NullableIntFieldUpdateOperationsInput | number | null
    statut?: EnumStatutCommandeFieldUpdateOperationsInput | $Enums.StatutCommande
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommandeUncheckedUpdateManyWithoutFournisseurInput = {
    id?: IntFieldUpdateOperationsInput | number
    panierId?: IntFieldUpdateOperationsInput | number
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    type_client?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    paiementId?: IntFieldUpdateOperationsInput | number
    adresseId?: NullableIntFieldUpdateOperationsInput | number | null
    contactId?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    dateLivraisonEffective?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adresseLivraison?: NullableStringFieldUpdateOperationsInput | string | null
    enregistrerParId?: NullableIntFieldUpdateOperationsInput | number | null
    statut?: EnumStatutCommandeFieldUpdateOperationsInput | $Enums.StatutCommande
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProduitCreateManyTeneurInput = {
    id?: number
    designation: string
    prix: number
    qtte?: number
    description: string
    deviseId: number
    utilisateurId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DetailClotureCaisseCreateManyTeneurInput = {
    id?: number
    produitId: number
    qtteRestante: number
    clotureCaisseId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProduitUpdateWithoutTeneurInput = {
    designation?: StringFieldUpdateOperationsInput | string
    prix?: FloatFieldUpdateOperationsInput | number
    qtte?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    devise?: DeviseUpdateOneRequiredWithoutProduitNestedInput
    utilisateur?: UtilisateurUpdateOneRequiredWithoutProduitNestedInput
    DetailPanier?: DetailPanierUpdateManyWithoutProduitNestedInput
    DetailClotureCaisse?: DetailClotureCaisseUpdateManyWithoutProduitNestedInput
  }

  export type ProduitUncheckedUpdateWithoutTeneurInput = {
    id?: IntFieldUpdateOperationsInput | number
    designation?: StringFieldUpdateOperationsInput | string
    prix?: FloatFieldUpdateOperationsInput | number
    qtte?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    deviseId?: IntFieldUpdateOperationsInput | number
    utilisateurId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DetailPanier?: DetailPanierUncheckedUpdateManyWithoutProduitNestedInput
    DetailClotureCaisse?: DetailClotureCaisseUncheckedUpdateManyWithoutProduitNestedInput
  }

  export type ProduitUncheckedUpdateManyWithoutTeneurInput = {
    id?: IntFieldUpdateOperationsInput | number
    designation?: StringFieldUpdateOperationsInput | string
    prix?: FloatFieldUpdateOperationsInput | number
    qtte?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    deviseId?: IntFieldUpdateOperationsInput | number
    utilisateurId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DetailClotureCaisseUpdateWithoutTeneurInput = {
    qtteRestante?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    produit?: ProduitUpdateOneRequiredWithoutDetailClotureCaisseNestedInput
    clotureCaisse?: ClotureCaisseUpdateOneRequiredWithoutDetailClotureCaisseNestedInput
  }

  export type DetailClotureCaisseUncheckedUpdateWithoutTeneurInput = {
    id?: IntFieldUpdateOperationsInput | number
    produitId?: IntFieldUpdateOperationsInput | number
    qtteRestante?: IntFieldUpdateOperationsInput | number
    clotureCaisseId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DetailClotureCaisseUncheckedUpdateManyWithoutTeneurInput = {
    id?: IntFieldUpdateOperationsInput | number
    produitId?: IntFieldUpdateOperationsInput | number
    qtteRestante?: IntFieldUpdateOperationsInput | number
    clotureCaisseId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProduitCreateManyDeviseInput = {
    id?: number
    designation: string
    prix: number
    qtte?: number
    description: string
    teneurId: number
    utilisateurId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaiementCreateManyDeviseInput = {
    id?: number
    montant: number
    moyen_paiement: $Enums.MoyenPaiment
    caisseId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CaisseCreateManyDeviseInput = {
    id?: number
    nom: string
    description?: string | null
    soldeInitial: number
    soldeActuel: number
    creeParId: number
    statut?: $Enums.StatutCaisse
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProduitUpdateWithoutDeviseInput = {
    designation?: StringFieldUpdateOperationsInput | string
    prix?: FloatFieldUpdateOperationsInput | number
    qtte?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teneur?: TeneurUpdateOneRequiredWithoutProduitNestedInput
    utilisateur?: UtilisateurUpdateOneRequiredWithoutProduitNestedInput
    DetailPanier?: DetailPanierUpdateManyWithoutProduitNestedInput
    DetailClotureCaisse?: DetailClotureCaisseUpdateManyWithoutProduitNestedInput
  }

  export type ProduitUncheckedUpdateWithoutDeviseInput = {
    id?: IntFieldUpdateOperationsInput | number
    designation?: StringFieldUpdateOperationsInput | string
    prix?: FloatFieldUpdateOperationsInput | number
    qtte?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    teneurId?: IntFieldUpdateOperationsInput | number
    utilisateurId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DetailPanier?: DetailPanierUncheckedUpdateManyWithoutProduitNestedInput
    DetailClotureCaisse?: DetailClotureCaisseUncheckedUpdateManyWithoutProduitNestedInput
  }

  export type ProduitUncheckedUpdateManyWithoutDeviseInput = {
    id?: IntFieldUpdateOperationsInput | number
    designation?: StringFieldUpdateOperationsInput | string
    prix?: FloatFieldUpdateOperationsInput | number
    qtte?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    teneurId?: IntFieldUpdateOperationsInput | number
    utilisateurId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaiementUpdateWithoutDeviseInput = {
    montant?: FloatFieldUpdateOperationsInput | number
    moyen_paiement?: EnumMoyenPaimentFieldUpdateOperationsInput | $Enums.MoyenPaiment
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    caisse?: CaisseUpdateOneRequiredWithoutPaiementNestedInput
    Achat?: AchatUpdateManyWithoutPaiementNestedInput
    Commande?: CommandeUpdateManyWithoutPaiementNestedInput
    Vente?: VenteUpdateManyWithoutPaiementNestedInput
  }

  export type PaiementUncheckedUpdateWithoutDeviseInput = {
    id?: IntFieldUpdateOperationsInput | number
    montant?: FloatFieldUpdateOperationsInput | number
    moyen_paiement?: EnumMoyenPaimentFieldUpdateOperationsInput | $Enums.MoyenPaiment
    caisseId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Achat?: AchatUncheckedUpdateManyWithoutPaiementNestedInput
    Commande?: CommandeUncheckedUpdateManyWithoutPaiementNestedInput
    Vente?: VenteUncheckedUpdateManyWithoutPaiementNestedInput
  }

  export type PaiementUncheckedUpdateManyWithoutDeviseInput = {
    id?: IntFieldUpdateOperationsInput | number
    montant?: FloatFieldUpdateOperationsInput | number
    moyen_paiement?: EnumMoyenPaimentFieldUpdateOperationsInput | $Enums.MoyenPaiment
    caisseId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CaisseUpdateWithoutDeviseInput = {
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    soldeInitial?: FloatFieldUpdateOperationsInput | number
    soldeActuel?: FloatFieldUpdateOperationsInput | number
    statut?: EnumStatutCaisseFieldUpdateOperationsInput | $Enums.StatutCaisse
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    utilisateur?: UtilisateurUpdateOneRequiredWithoutCaisseNestedInput
    MouvementCaisse?: MouvementCaisseUpdateManyWithoutCaisseNestedInput
    clotures?: ClotureCaisseUpdateManyWithoutCaisseNestedInput
    Paiement?: PaiementUpdateManyWithoutCaisseNestedInput
  }

  export type CaisseUncheckedUpdateWithoutDeviseInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    soldeInitial?: FloatFieldUpdateOperationsInput | number
    soldeActuel?: FloatFieldUpdateOperationsInput | number
    creeParId?: IntFieldUpdateOperationsInput | number
    statut?: EnumStatutCaisseFieldUpdateOperationsInput | $Enums.StatutCaisse
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    MouvementCaisse?: MouvementCaisseUncheckedUpdateManyWithoutCaisseNestedInput
    clotures?: ClotureCaisseUncheckedUpdateManyWithoutCaisseNestedInput
    Paiement?: PaiementUncheckedUpdateManyWithoutCaisseNestedInput
  }

  export type CaisseUncheckedUpdateManyWithoutDeviseInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    soldeInitial?: FloatFieldUpdateOperationsInput | number
    soldeActuel?: FloatFieldUpdateOperationsInput | number
    creeParId?: IntFieldUpdateOperationsInput | number
    statut?: EnumStatutCaisseFieldUpdateOperationsInput | $Enums.StatutCaisse
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DetailPanierCreateManyProduitInput = {
    id?: number
    qtte: number
    prixUnitaire: number
    prixTotal: number
    panierId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DetailClotureCaisseCreateManyProduitInput = {
    id?: number
    teneurId: number
    qtteRestante: number
    clotureCaisseId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DetailPanierUpdateWithoutProduitInput = {
    qtte?: IntFieldUpdateOperationsInput | number
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    prixTotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    panier?: PanierUpdateOneRequiredWithoutDetailPanierNestedInput
  }

  export type DetailPanierUncheckedUpdateWithoutProduitInput = {
    id?: IntFieldUpdateOperationsInput | number
    qtte?: IntFieldUpdateOperationsInput | number
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    prixTotal?: FloatFieldUpdateOperationsInput | number
    panierId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DetailPanierUncheckedUpdateManyWithoutProduitInput = {
    id?: IntFieldUpdateOperationsInput | number
    qtte?: IntFieldUpdateOperationsInput | number
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    prixTotal?: FloatFieldUpdateOperationsInput | number
    panierId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DetailClotureCaisseUpdateWithoutProduitInput = {
    qtteRestante?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teneur?: TeneurUpdateOneRequiredWithoutDetailClotureCaisseNestedInput
    clotureCaisse?: ClotureCaisseUpdateOneRequiredWithoutDetailClotureCaisseNestedInput
  }

  export type DetailClotureCaisseUncheckedUpdateWithoutProduitInput = {
    id?: IntFieldUpdateOperationsInput | number
    teneurId?: IntFieldUpdateOperationsInput | number
    qtteRestante?: IntFieldUpdateOperationsInput | number
    clotureCaisseId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DetailClotureCaisseUncheckedUpdateManyWithoutProduitInput = {
    id?: IntFieldUpdateOperationsInput | number
    teneurId?: IntFieldUpdateOperationsInput | number
    qtteRestante?: IntFieldUpdateOperationsInput | number
    clotureCaisseId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchatCreateManyPaiementInput = {
    id?: number
    statut?: $Enums.StatutAchat
    panierId: number
    fournisseurId: number
    enregistrerParId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommandeCreateManyPaiementInput = {
    id?: number
    panierId: number
    clientId?: number | null
    nom?: string | null
    tel?: string | null
    type_client?: $Enums.TypeClient
    adresseId?: number | null
    contactId?: number | null
    fournisseurId?: number | null
    notes?: string | null
    dateLivraisonEffective?: Date | string | null
    adresseLivraison?: string | null
    enregistrerParId?: number | null
    statut?: $Enums.StatutCommande
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VenteCreateManyPaiementInput = {
    id?: number
    statut?: $Enums.StatutVente
    total_ttc: number
    total_ht: number
    type_acheteur: $Enums.TypeClient
    clientId?: number | null
    enregistrerParId: number
    fournisseurId?: number | null
    agentId?: number | null
    panierId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AchatUpdateWithoutPaiementInput = {
    statut?: EnumStatutAchatFieldUpdateOperationsInput | $Enums.StatutAchat
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    panier?: PanierUpdateOneRequiredWithoutAchatNestedInput
    fournisseur?: FournisseurUpdateOneRequiredWithoutAchatNestedInput
    utilisateur?: UtilisateurUpdateOneRequiredWithoutAchatNestedInput
  }

  export type AchatUncheckedUpdateWithoutPaiementInput = {
    id?: IntFieldUpdateOperationsInput | number
    statut?: EnumStatutAchatFieldUpdateOperationsInput | $Enums.StatutAchat
    panierId?: IntFieldUpdateOperationsInput | number
    fournisseurId?: IntFieldUpdateOperationsInput | number
    enregistrerParId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchatUncheckedUpdateManyWithoutPaiementInput = {
    id?: IntFieldUpdateOperationsInput | number
    statut?: EnumStatutAchatFieldUpdateOperationsInput | $Enums.StatutAchat
    panierId?: IntFieldUpdateOperationsInput | number
    fournisseurId?: IntFieldUpdateOperationsInput | number
    enregistrerParId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommandeUpdateWithoutPaiementInput = {
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    type_client?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    dateLivraisonEffective?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adresseLivraison?: NullableStringFieldUpdateOperationsInput | string | null
    enregistrerParId?: NullableIntFieldUpdateOperationsInput | number | null
    statut?: EnumStatutCommandeFieldUpdateOperationsInput | $Enums.StatutCommande
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    panier?: PanierUpdateOneRequiredWithoutCommandeNestedInput
    client?: UtilisateurUpdateOneWithoutCommandeNestedInput
    fournisseur?: FournisseurUpdateOneWithoutCommandeNestedInput
    adresse?: AdresseUpdateOneWithoutCommandeNestedInput
    contact?: ContactUpdateOneWithoutCommandeNestedInput
  }

  export type CommandeUncheckedUpdateWithoutPaiementInput = {
    id?: IntFieldUpdateOperationsInput | number
    panierId?: IntFieldUpdateOperationsInput | number
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    type_client?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    adresseId?: NullableIntFieldUpdateOperationsInput | number | null
    contactId?: NullableIntFieldUpdateOperationsInput | number | null
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    dateLivraisonEffective?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adresseLivraison?: NullableStringFieldUpdateOperationsInput | string | null
    enregistrerParId?: NullableIntFieldUpdateOperationsInput | number | null
    statut?: EnumStatutCommandeFieldUpdateOperationsInput | $Enums.StatutCommande
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommandeUncheckedUpdateManyWithoutPaiementInput = {
    id?: IntFieldUpdateOperationsInput | number
    panierId?: IntFieldUpdateOperationsInput | number
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    type_client?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    adresseId?: NullableIntFieldUpdateOperationsInput | number | null
    contactId?: NullableIntFieldUpdateOperationsInput | number | null
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    dateLivraisonEffective?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adresseLivraison?: NullableStringFieldUpdateOperationsInput | string | null
    enregistrerParId?: NullableIntFieldUpdateOperationsInput | number | null
    statut?: EnumStatutCommandeFieldUpdateOperationsInput | $Enums.StatutCommande
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VenteUpdateWithoutPaiementInput = {
    statut?: EnumStatutVenteFieldUpdateOperationsInput | $Enums.StatutVente
    total_ttc?: FloatFieldUpdateOperationsInput | number
    total_ht?: FloatFieldUpdateOperationsInput | number
    type_acheteur?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    agentId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    panier?: PanierUpdateOneRequiredWithoutVenteNestedInput
    utilisateur?: UtilisateurUpdateOneRequiredWithoutVenteNestedInput
    fournisseur?: FournisseurUpdateOneWithoutVenteNestedInput
  }

  export type VenteUncheckedUpdateWithoutPaiementInput = {
    id?: IntFieldUpdateOperationsInput | number
    statut?: EnumStatutVenteFieldUpdateOperationsInput | $Enums.StatutVente
    total_ttc?: FloatFieldUpdateOperationsInput | number
    total_ht?: FloatFieldUpdateOperationsInput | number
    type_acheteur?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    enregistrerParId?: IntFieldUpdateOperationsInput | number
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    agentId?: NullableIntFieldUpdateOperationsInput | number | null
    panierId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VenteUncheckedUpdateManyWithoutPaiementInput = {
    id?: IntFieldUpdateOperationsInput | number
    statut?: EnumStatutVenteFieldUpdateOperationsInput | $Enums.StatutVente
    total_ttc?: FloatFieldUpdateOperationsInput | number
    total_ht?: FloatFieldUpdateOperationsInput | number
    type_acheteur?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    enregistrerParId?: IntFieldUpdateOperationsInput | number
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    agentId?: NullableIntFieldUpdateOperationsInput | number | null
    panierId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MouvementCaisseCreateManyCaisseInput = {
    id?: number
    type_mouvement?: $Enums.TypeMouvementCaisse
    categorie?: $Enums.CategorieMouvement
    montant: number
    description?: string | null
    enregistrerParId: number
    referenceExterne?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClotureCaisseCreateManyCaisseInput = {
    id?: number
    dateCloture?: Date | string
    utilisateurClotureId: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaiementCreateManyCaisseInput = {
    id?: number
    montant: number
    moyen_paiement: $Enums.MoyenPaiment
    deviseId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MouvementCaisseUpdateWithoutCaisseInput = {
    type_mouvement?: EnumTypeMouvementCaisseFieldUpdateOperationsInput | $Enums.TypeMouvementCaisse
    categorie?: EnumCategorieMouvementFieldUpdateOperationsInput | $Enums.CategorieMouvement
    montant?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    referenceExterne?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    utilisateur?: UtilisateurUpdateOneRequiredWithoutMouvementCaisseNestedInput
  }

  export type MouvementCaisseUncheckedUpdateWithoutCaisseInput = {
    id?: IntFieldUpdateOperationsInput | number
    type_mouvement?: EnumTypeMouvementCaisseFieldUpdateOperationsInput | $Enums.TypeMouvementCaisse
    categorie?: EnumCategorieMouvementFieldUpdateOperationsInput | $Enums.CategorieMouvement
    montant?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    enregistrerParId?: IntFieldUpdateOperationsInput | number
    referenceExterne?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MouvementCaisseUncheckedUpdateManyWithoutCaisseInput = {
    id?: IntFieldUpdateOperationsInput | number
    type_mouvement?: EnumTypeMouvementCaisseFieldUpdateOperationsInput | $Enums.TypeMouvementCaisse
    categorie?: EnumCategorieMouvementFieldUpdateOperationsInput | $Enums.CategorieMouvement
    montant?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    enregistrerParId?: IntFieldUpdateOperationsInput | number
    referenceExterne?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClotureCaisseUpdateWithoutCaisseInput = {
    dateCloture?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    utilisateurCloture?: UtilisateurUpdateOneRequiredWithoutClotureCaisseNestedInput
    DetailClotureCaisse?: DetailClotureCaisseUpdateManyWithoutClotureCaisseNestedInput
  }

  export type ClotureCaisseUncheckedUpdateWithoutCaisseInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateCloture?: DateTimeFieldUpdateOperationsInput | Date | string
    utilisateurClotureId?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DetailClotureCaisse?: DetailClotureCaisseUncheckedUpdateManyWithoutClotureCaisseNestedInput
  }

  export type ClotureCaisseUncheckedUpdateManyWithoutCaisseInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateCloture?: DateTimeFieldUpdateOperationsInput | Date | string
    utilisateurClotureId?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaiementUpdateWithoutCaisseInput = {
    montant?: FloatFieldUpdateOperationsInput | number
    moyen_paiement?: EnumMoyenPaimentFieldUpdateOperationsInput | $Enums.MoyenPaiment
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    devise?: DeviseUpdateOneRequiredWithoutPaiementNestedInput
    Achat?: AchatUpdateManyWithoutPaiementNestedInput
    Commande?: CommandeUpdateManyWithoutPaiementNestedInput
    Vente?: VenteUpdateManyWithoutPaiementNestedInput
  }

  export type PaiementUncheckedUpdateWithoutCaisseInput = {
    id?: IntFieldUpdateOperationsInput | number
    montant?: FloatFieldUpdateOperationsInput | number
    moyen_paiement?: EnumMoyenPaimentFieldUpdateOperationsInput | $Enums.MoyenPaiment
    deviseId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Achat?: AchatUncheckedUpdateManyWithoutPaiementNestedInput
    Commande?: CommandeUncheckedUpdateManyWithoutPaiementNestedInput
    Vente?: VenteUncheckedUpdateManyWithoutPaiementNestedInput
  }

  export type PaiementUncheckedUpdateManyWithoutCaisseInput = {
    id?: IntFieldUpdateOperationsInput | number
    montant?: FloatFieldUpdateOperationsInput | number
    moyen_paiement?: EnumMoyenPaimentFieldUpdateOperationsInput | $Enums.MoyenPaiment
    deviseId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DetailPanierCreateManyPanierInput = {
    id?: number
    produitId: number
    qtte: number
    prixUnitaire: number
    prixTotal: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AchatCreateManyPanierInput = {
    id?: number
    statut?: $Enums.StatutAchat
    fournisseurId: number
    enregistrerParId: number
    paiementId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VenteCreateManyPanierInput = {
    id?: number
    statut?: $Enums.StatutVente
    total_ttc: number
    total_ht: number
    type_acheteur: $Enums.TypeClient
    clientId?: number | null
    enregistrerParId: number
    fournisseurId?: number | null
    agentId?: number | null
    paiementId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReservationCreateManyPanierInput = {
    id?: number
    dateLivraisonSouhaitee: Date | string
    adresseLivraison?: string | null
    statut?: $Enums.StatutReservation
    notes?: string | null
    type_client?: $Enums.TypeClient
    clientId?: number | null
    nom?: string | null
    tel?: string | null
    adresseId?: number | null
    contactId?: number | null
    enregistrerParId?: number | null
    fournisseurId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommandeCreateManyPanierInput = {
    id?: number
    clientId?: number | null
    nom?: string | null
    tel?: string | null
    type_client?: $Enums.TypeClient
    paiementId: number
    adresseId?: number | null
    contactId?: number | null
    fournisseurId?: number | null
    notes?: string | null
    dateLivraisonEffective?: Date | string | null
    adresseLivraison?: string | null
    enregistrerParId?: number | null
    statut?: $Enums.StatutCommande
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DetailPanierUpdateWithoutPanierInput = {
    qtte?: IntFieldUpdateOperationsInput | number
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    prixTotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    produit?: ProduitUpdateOneRequiredWithoutDetailPanierNestedInput
  }

  export type DetailPanierUncheckedUpdateWithoutPanierInput = {
    id?: IntFieldUpdateOperationsInput | number
    produitId?: IntFieldUpdateOperationsInput | number
    qtte?: IntFieldUpdateOperationsInput | number
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    prixTotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DetailPanierUncheckedUpdateManyWithoutPanierInput = {
    id?: IntFieldUpdateOperationsInput | number
    produitId?: IntFieldUpdateOperationsInput | number
    qtte?: IntFieldUpdateOperationsInput | number
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    prixTotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchatUpdateWithoutPanierInput = {
    statut?: EnumStatutAchatFieldUpdateOperationsInput | $Enums.StatutAchat
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fournisseur?: FournisseurUpdateOneRequiredWithoutAchatNestedInput
    utilisateur?: UtilisateurUpdateOneRequiredWithoutAchatNestedInput
    paiement?: PaiementUpdateOneRequiredWithoutAchatNestedInput
  }

  export type AchatUncheckedUpdateWithoutPanierInput = {
    id?: IntFieldUpdateOperationsInput | number
    statut?: EnumStatutAchatFieldUpdateOperationsInput | $Enums.StatutAchat
    fournisseurId?: IntFieldUpdateOperationsInput | number
    enregistrerParId?: IntFieldUpdateOperationsInput | number
    paiementId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchatUncheckedUpdateManyWithoutPanierInput = {
    id?: IntFieldUpdateOperationsInput | number
    statut?: EnumStatutAchatFieldUpdateOperationsInput | $Enums.StatutAchat
    fournisseurId?: IntFieldUpdateOperationsInput | number
    enregistrerParId?: IntFieldUpdateOperationsInput | number
    paiementId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VenteUpdateWithoutPanierInput = {
    statut?: EnumStatutVenteFieldUpdateOperationsInput | $Enums.StatutVente
    total_ttc?: FloatFieldUpdateOperationsInput | number
    total_ht?: FloatFieldUpdateOperationsInput | number
    type_acheteur?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    agentId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paiement?: PaiementUpdateOneWithoutVenteNestedInput
    utilisateur?: UtilisateurUpdateOneRequiredWithoutVenteNestedInput
    fournisseur?: FournisseurUpdateOneWithoutVenteNestedInput
  }

  export type VenteUncheckedUpdateWithoutPanierInput = {
    id?: IntFieldUpdateOperationsInput | number
    statut?: EnumStatutVenteFieldUpdateOperationsInput | $Enums.StatutVente
    total_ttc?: FloatFieldUpdateOperationsInput | number
    total_ht?: FloatFieldUpdateOperationsInput | number
    type_acheteur?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    enregistrerParId?: IntFieldUpdateOperationsInput | number
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    agentId?: NullableIntFieldUpdateOperationsInput | number | null
    paiementId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VenteUncheckedUpdateManyWithoutPanierInput = {
    id?: IntFieldUpdateOperationsInput | number
    statut?: EnumStatutVenteFieldUpdateOperationsInput | $Enums.StatutVente
    total_ttc?: FloatFieldUpdateOperationsInput | number
    total_ht?: FloatFieldUpdateOperationsInput | number
    type_acheteur?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    enregistrerParId?: IntFieldUpdateOperationsInput | number
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    agentId?: NullableIntFieldUpdateOperationsInput | number | null
    paiementId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReservationUpdateWithoutPanierInput = {
    dateLivraisonSouhaitee?: DateTimeFieldUpdateOperationsInput | Date | string
    adresseLivraison?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: EnumStatutReservationFieldUpdateOperationsInput | $Enums.StatutReservation
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    type_client?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    enregistrerParId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    utilisateur?: UtilisateurUpdateOneWithoutReservationNestedInput
    fournisseur?: FournisseurUpdateOneWithoutReservationNestedInput
    adresse?: AdresseUpdateOneWithoutReservationNestedInput
    contact?: ContactUpdateOneWithoutReservationNestedInput
  }

  export type ReservationUncheckedUpdateWithoutPanierInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateLivraisonSouhaitee?: DateTimeFieldUpdateOperationsInput | Date | string
    adresseLivraison?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: EnumStatutReservationFieldUpdateOperationsInput | $Enums.StatutReservation
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    type_client?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    adresseId?: NullableIntFieldUpdateOperationsInput | number | null
    contactId?: NullableIntFieldUpdateOperationsInput | number | null
    enregistrerParId?: NullableIntFieldUpdateOperationsInput | number | null
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReservationUncheckedUpdateManyWithoutPanierInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateLivraisonSouhaitee?: DateTimeFieldUpdateOperationsInput | Date | string
    adresseLivraison?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: EnumStatutReservationFieldUpdateOperationsInput | $Enums.StatutReservation
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    type_client?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    adresseId?: NullableIntFieldUpdateOperationsInput | number | null
    contactId?: NullableIntFieldUpdateOperationsInput | number | null
    enregistrerParId?: NullableIntFieldUpdateOperationsInput | number | null
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommandeUpdateWithoutPanierInput = {
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    type_client?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    dateLivraisonEffective?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adresseLivraison?: NullableStringFieldUpdateOperationsInput | string | null
    enregistrerParId?: NullableIntFieldUpdateOperationsInput | number | null
    statut?: EnumStatutCommandeFieldUpdateOperationsInput | $Enums.StatutCommande
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: UtilisateurUpdateOneWithoutCommandeNestedInput
    paiement?: PaiementUpdateOneRequiredWithoutCommandeNestedInput
    fournisseur?: FournisseurUpdateOneWithoutCommandeNestedInput
    adresse?: AdresseUpdateOneWithoutCommandeNestedInput
    contact?: ContactUpdateOneWithoutCommandeNestedInput
  }

  export type CommandeUncheckedUpdateWithoutPanierInput = {
    id?: IntFieldUpdateOperationsInput | number
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    type_client?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    paiementId?: IntFieldUpdateOperationsInput | number
    adresseId?: NullableIntFieldUpdateOperationsInput | number | null
    contactId?: NullableIntFieldUpdateOperationsInput | number | null
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    dateLivraisonEffective?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adresseLivraison?: NullableStringFieldUpdateOperationsInput | string | null
    enregistrerParId?: NullableIntFieldUpdateOperationsInput | number | null
    statut?: EnumStatutCommandeFieldUpdateOperationsInput | $Enums.StatutCommande
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommandeUncheckedUpdateManyWithoutPanierInput = {
    id?: IntFieldUpdateOperationsInput | number
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    type_client?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    paiementId?: IntFieldUpdateOperationsInput | number
    adresseId?: NullableIntFieldUpdateOperationsInput | number | null
    contactId?: NullableIntFieldUpdateOperationsInput | number | null
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    dateLivraisonEffective?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adresseLivraison?: NullableStringFieldUpdateOperationsInput | string | null
    enregistrerParId?: NullableIntFieldUpdateOperationsInput | number | null
    statut?: EnumStatutCommandeFieldUpdateOperationsInput | $Enums.StatutCommande
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DetailClotureCaisseCreateManyClotureCaisseInput = {
    id?: number
    produitId: number
    teneurId: number
    qtteRestante: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DetailClotureCaisseUpdateWithoutClotureCaisseInput = {
    qtteRestante?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    produit?: ProduitUpdateOneRequiredWithoutDetailClotureCaisseNestedInput
    teneur?: TeneurUpdateOneRequiredWithoutDetailClotureCaisseNestedInput
  }

  export type DetailClotureCaisseUncheckedUpdateWithoutClotureCaisseInput = {
    id?: IntFieldUpdateOperationsInput | number
    produitId?: IntFieldUpdateOperationsInput | number
    teneurId?: IntFieldUpdateOperationsInput | number
    qtteRestante?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DetailClotureCaisseUncheckedUpdateManyWithoutClotureCaisseInput = {
    id?: IntFieldUpdateOperationsInput | number
    produitId?: IntFieldUpdateOperationsInput | number
    teneurId?: IntFieldUpdateOperationsInput | number
    qtteRestante?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}