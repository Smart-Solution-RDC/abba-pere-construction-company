
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Teneur
 * 
 */
export type Teneur = $Result.DefaultSelection<Prisma.$TeneurPayload>
/**
 * Model Devise
 * 
 */
export type Devise = $Result.DefaultSelection<Prisma.$DevisePayload>
/**
 * Model Entreprise
 * 
 */
export type Entreprise = $Result.DefaultSelection<Prisma.$EntreprisePayload>
/**
 * Model Agent
 * 
 */
export type Agent = $Result.DefaultSelection<Prisma.$AgentPayload>
/**
 * Model Client
 * 
 */
export type Client = $Result.DefaultSelection<Prisma.$ClientPayload>
/**
 * Model Adresse
 * 
 */
export type Adresse = $Result.DefaultSelection<Prisma.$AdressePayload>
/**
 * Model Contact
 * 
 */
export type Contact = $Result.DefaultSelection<Prisma.$ContactPayload>
/**
 * Model Fournisseur
 * 
 */
export type Fournisseur = $Result.DefaultSelection<Prisma.$FournisseurPayload>
/**
 * Model Produit
 * 
 */
export type Produit = $Result.DefaultSelection<Prisma.$ProduitPayload>
/**
 * Model Paiement
 * 
 */
export type Paiement = $Result.DefaultSelection<Prisma.$PaiementPayload>
/**
 * Model Caisse
 * 
 */
export type Caisse = $Result.DefaultSelection<Prisma.$CaissePayload>
/**
 * Model Vente
 * 
 */
export type Vente = $Result.DefaultSelection<Prisma.$VentePayload>
/**
 * Model Panier
 * 
 */
export type Panier = $Result.DefaultSelection<Prisma.$PanierPayload>
/**
 * Model DetailPanier
 * 
 */
export type DetailPanier = $Result.DefaultSelection<Prisma.$DetailPanierPayload>
/**
 * Model Achat
 * 
 */
export type Achat = $Result.DefaultSelection<Prisma.$AchatPayload>
/**
 * Model Reservation
 * 
 */
export type Reservation = $Result.DefaultSelection<Prisma.$ReservationPayload>
/**
 * Model Commande
 * 
 */
export type Commande = $Result.DefaultSelection<Prisma.$CommandePayload>
/**
 * Model ClotureCaisse
 * 
 */
export type ClotureCaisse = $Result.DefaultSelection<Prisma.$ClotureCaissePayload>
/**
 * Model MouvementCaisse
 * 
 */
export type MouvementCaisse = $Result.DefaultSelection<Prisma.$MouvementCaissePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  ADMIN: 'ADMIN',
  AGENT: 'AGENT'
};

export type Role = (typeof Role)[keyof typeof Role]


export const Sexe: {
  HOMME: 'HOMME',
  FEMME: 'FEMME'
};

export type Sexe = (typeof Sexe)[keyof typeof Sexe]


export const Poste: {
  DIRECTEUR: 'DIRECTEUR',
  SECRETAIRE: 'SECRETAIRE',
  CAISSIER: 'CAISSIER',
  GERANT: 'GERANT'
};

export type Poste = (typeof Poste)[keyof typeof Poste]


export const ModePaiment: {
  CACHE: 'CACHE',
  BANQUE: 'BANQUE',
  MOBILE: 'MOBILE'
};

export type ModePaiment = (typeof ModePaiment)[keyof typeof ModePaiment]


export const StatutVente: {
  EN_ATTENTE: 'EN_ATTENTE',
  CONFIRME: 'CONFIRME',
  REMBOURSE: 'REMBOURSE',
  ANNULE: 'ANNULE'
};

export type StatutVente = (typeof StatutVente)[keyof typeof StatutVente]


export const TypeClient: {
  ORDINAIRE: 'ORDINAIRE',
  NOUVEAU: 'NOUVEAU',
  CLIENT: 'CLIENT',
  FOURNISSEUR: 'FOURNISSEUR',
  AGENT: 'AGENT'
};

export type TypeClient = (typeof TypeClient)[keyof typeof TypeClient]


export const statutPanier: {
  EN_COURS: 'EN_COURS',
  VALIDE: 'VALIDE',
  ANNULE: 'ANNULE'
};

export type statutPanier = (typeof statutPanier)[keyof typeof statutPanier]


export const StatutAchat: {
  EN_COURS: 'EN_COURS',
  TERMINE: 'TERMINE',
  ANNULE: 'ANNULE'
};

export type StatutAchat = (typeof StatutAchat)[keyof typeof StatutAchat]


export const StatutReservation: {
  EN_ATTENTE: 'EN_ATTENTE',
  ANNULEE: 'ANNULEE',
  REJETEE: 'REJETEE',
  CONVERTIE: 'CONVERTIE'
};

export type StatutReservation = (typeof StatutReservation)[keyof typeof StatutReservation]


export const StatutCommande: {
  EN_ATTENTE_PAIEMENT: 'EN_ATTENTE_PAIEMENT',
  LIVREE: 'LIVREE',
  ANNULEE: 'ANNULEE'
};

export type StatutCommande = (typeof StatutCommande)[keyof typeof StatutCommande]


export const TypeMouvementCaisse: {
  ENTREE: 'ENTREE',
  SORTIE: 'SORTIE'
};

export type TypeMouvementCaisse = (typeof TypeMouvementCaisse)[keyof typeof TypeMouvementCaisse]


export const StatutCaisse: {
  OUVERTE: 'OUVERTE',
  FERMEE: 'FERMEE'
};

export type StatutCaisse = (typeof StatutCaisse)[keyof typeof StatutCaisse]


export const CategorieMouvement: {
  ACHAT: 'ACHAT',
  VENTE: 'VENTE',
  COMMANDE: 'COMMANDE',
  FOURNITUR: 'FOURNITUR',
  SALAIRE: 'SALAIRE',
  LOYER: 'LOYER',
  EMPRUNT: 'EMPRUNT',
  TAXE: 'TAXE',
  AUTRES: 'AUTRES'
};

export type CategorieMouvement = (typeof CategorieMouvement)[keyof typeof CategorieMouvement]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type Sexe = $Enums.Sexe

export const Sexe: typeof $Enums.Sexe

export type Poste = $Enums.Poste

export const Poste: typeof $Enums.Poste

export type ModePaiment = $Enums.ModePaiment

export const ModePaiment: typeof $Enums.ModePaiment

export type StatutVente = $Enums.StatutVente

export const StatutVente: typeof $Enums.StatutVente

export type TypeClient = $Enums.TypeClient

export const TypeClient: typeof $Enums.TypeClient

export type statutPanier = $Enums.statutPanier

export const statutPanier: typeof $Enums.statutPanier

export type StatutAchat = $Enums.StatutAchat

export const StatutAchat: typeof $Enums.StatutAchat

export type StatutReservation = $Enums.StatutReservation

export const StatutReservation: typeof $Enums.StatutReservation

export type StatutCommande = $Enums.StatutCommande

export const StatutCommande: typeof $Enums.StatutCommande

export type TypeMouvementCaisse = $Enums.TypeMouvementCaisse

export const TypeMouvementCaisse: typeof $Enums.TypeMouvementCaisse

export type StatutCaisse = $Enums.StatutCaisse

export const StatutCaisse: typeof $Enums.StatutCaisse

export type CategorieMouvement = $Enums.CategorieMouvement

export const CategorieMouvement: typeof $Enums.CategorieMouvement

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Teneurs
 * const teneurs = await prisma.teneur.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Teneurs
   * const teneurs = await prisma.teneur.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.teneur`: Exposes CRUD operations for the **Teneur** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teneurs
    * const teneurs = await prisma.teneur.findMany()
    * ```
    */
  get teneur(): Prisma.TeneurDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.devise`: Exposes CRUD operations for the **Devise** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Devises
    * const devises = await prisma.devise.findMany()
    * ```
    */
  get devise(): Prisma.DeviseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.entreprise`: Exposes CRUD operations for the **Entreprise** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Entreprises
    * const entreprises = await prisma.entreprise.findMany()
    * ```
    */
  get entreprise(): Prisma.EntrepriseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agent`: Exposes CRUD operations for the **Agent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Agents
    * const agents = await prisma.agent.findMany()
    * ```
    */
  get agent(): Prisma.AgentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.client`: Exposes CRUD operations for the **Client** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clients
    * const clients = await prisma.client.findMany()
    * ```
    */
  get client(): Prisma.ClientDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.adresse`: Exposes CRUD operations for the **Adresse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Adresses
    * const adresses = await prisma.adresse.findMany()
    * ```
    */
  get adresse(): Prisma.AdresseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contact`: Exposes CRUD operations for the **Contact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contacts
    * const contacts = await prisma.contact.findMany()
    * ```
    */
  get contact(): Prisma.ContactDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fournisseur`: Exposes CRUD operations for the **Fournisseur** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Fournisseurs
    * const fournisseurs = await prisma.fournisseur.findMany()
    * ```
    */
  get fournisseur(): Prisma.FournisseurDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.produit`: Exposes CRUD operations for the **Produit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Produits
    * const produits = await prisma.produit.findMany()
    * ```
    */
  get produit(): Prisma.ProduitDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.paiement`: Exposes CRUD operations for the **Paiement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Paiements
    * const paiements = await prisma.paiement.findMany()
    * ```
    */
  get paiement(): Prisma.PaiementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.caisse`: Exposes CRUD operations for the **Caisse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Caisses
    * const caisses = await prisma.caisse.findMany()
    * ```
    */
  get caisse(): Prisma.CaisseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vente`: Exposes CRUD operations for the **Vente** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ventes
    * const ventes = await prisma.vente.findMany()
    * ```
    */
  get vente(): Prisma.VenteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.panier`: Exposes CRUD operations for the **Panier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Paniers
    * const paniers = await prisma.panier.findMany()
    * ```
    */
  get panier(): Prisma.PanierDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.detailPanier`: Exposes CRUD operations for the **DetailPanier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DetailPaniers
    * const detailPaniers = await prisma.detailPanier.findMany()
    * ```
    */
  get detailPanier(): Prisma.DetailPanierDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.achat`: Exposes CRUD operations for the **Achat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Achats
    * const achats = await prisma.achat.findMany()
    * ```
    */
  get achat(): Prisma.AchatDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reservation`: Exposes CRUD operations for the **Reservation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reservations
    * const reservations = await prisma.reservation.findMany()
    * ```
    */
  get reservation(): Prisma.ReservationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.commande`: Exposes CRUD operations for the **Commande** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Commandes
    * const commandes = await prisma.commande.findMany()
    * ```
    */
  get commande(): Prisma.CommandeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.clotureCaisse`: Exposes CRUD operations for the **ClotureCaisse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClotureCaisses
    * const clotureCaisses = await prisma.clotureCaisse.findMany()
    * ```
    */
  get clotureCaisse(): Prisma.ClotureCaisseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mouvementCaisse`: Exposes CRUD operations for the **MouvementCaisse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MouvementCaisses
    * const mouvementCaisses = await prisma.mouvementCaisse.findMany()
    * ```
    */
  get mouvementCaisse(): Prisma.MouvementCaisseDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.9.0
   * Query Engine version: 81e4af48011447c3cc503a190e86995b66d2a28e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Teneur: 'Teneur',
    Devise: 'Devise',
    Entreprise: 'Entreprise',
    Agent: 'Agent',
    Client: 'Client',
    Adresse: 'Adresse',
    Contact: 'Contact',
    Fournisseur: 'Fournisseur',
    Produit: 'Produit',
    Paiement: 'Paiement',
    Caisse: 'Caisse',
    Vente: 'Vente',
    Panier: 'Panier',
    DetailPanier: 'DetailPanier',
    Achat: 'Achat',
    Reservation: 'Reservation',
    Commande: 'Commande',
    ClotureCaisse: 'ClotureCaisse',
    MouvementCaisse: 'MouvementCaisse'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "teneur" | "devise" | "entreprise" | "agent" | "client" | "adresse" | "contact" | "fournisseur" | "produit" | "paiement" | "caisse" | "vente" | "panier" | "detailPanier" | "achat" | "reservation" | "commande" | "clotureCaisse" | "mouvementCaisse"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Teneur: {
        payload: Prisma.$TeneurPayload<ExtArgs>
        fields: Prisma.TeneurFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeneurFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeneurPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeneurFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeneurPayload>
          }
          findFirst: {
            args: Prisma.TeneurFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeneurPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeneurFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeneurPayload>
          }
          findMany: {
            args: Prisma.TeneurFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeneurPayload>[]
          }
          create: {
            args: Prisma.TeneurCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeneurPayload>
          }
          createMany: {
            args: Prisma.TeneurCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeneurCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeneurPayload>[]
          }
          delete: {
            args: Prisma.TeneurDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeneurPayload>
          }
          update: {
            args: Prisma.TeneurUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeneurPayload>
          }
          deleteMany: {
            args: Prisma.TeneurDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeneurUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TeneurUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeneurPayload>[]
          }
          upsert: {
            args: Prisma.TeneurUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeneurPayload>
          }
          aggregate: {
            args: Prisma.TeneurAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeneur>
          }
          groupBy: {
            args: Prisma.TeneurGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeneurGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeneurCountArgs<ExtArgs>
            result: $Utils.Optional<TeneurCountAggregateOutputType> | number
          }
        }
      }
      Devise: {
        payload: Prisma.$DevisePayload<ExtArgs>
        fields: Prisma.DeviseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeviseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevisePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeviseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevisePayload>
          }
          findFirst: {
            args: Prisma.DeviseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevisePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeviseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevisePayload>
          }
          findMany: {
            args: Prisma.DeviseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevisePayload>[]
          }
          create: {
            args: Prisma.DeviseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevisePayload>
          }
          createMany: {
            args: Prisma.DeviseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeviseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevisePayload>[]
          }
          delete: {
            args: Prisma.DeviseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevisePayload>
          }
          update: {
            args: Prisma.DeviseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevisePayload>
          }
          deleteMany: {
            args: Prisma.DeviseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeviseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DeviseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevisePayload>[]
          }
          upsert: {
            args: Prisma.DeviseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevisePayload>
          }
          aggregate: {
            args: Prisma.DeviseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDevise>
          }
          groupBy: {
            args: Prisma.DeviseGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeviseGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeviseCountArgs<ExtArgs>
            result: $Utils.Optional<DeviseCountAggregateOutputType> | number
          }
        }
      }
      Entreprise: {
        payload: Prisma.$EntreprisePayload<ExtArgs>
        fields: Prisma.EntrepriseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EntrepriseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntreprisePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EntrepriseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntreprisePayload>
          }
          findFirst: {
            args: Prisma.EntrepriseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntreprisePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EntrepriseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntreprisePayload>
          }
          findMany: {
            args: Prisma.EntrepriseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntreprisePayload>[]
          }
          create: {
            args: Prisma.EntrepriseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntreprisePayload>
          }
          createMany: {
            args: Prisma.EntrepriseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EntrepriseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntreprisePayload>[]
          }
          delete: {
            args: Prisma.EntrepriseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntreprisePayload>
          }
          update: {
            args: Prisma.EntrepriseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntreprisePayload>
          }
          deleteMany: {
            args: Prisma.EntrepriseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EntrepriseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EntrepriseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntreprisePayload>[]
          }
          upsert: {
            args: Prisma.EntrepriseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntreprisePayload>
          }
          aggregate: {
            args: Prisma.EntrepriseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEntreprise>
          }
          groupBy: {
            args: Prisma.EntrepriseGroupByArgs<ExtArgs>
            result: $Utils.Optional<EntrepriseGroupByOutputType>[]
          }
          count: {
            args: Prisma.EntrepriseCountArgs<ExtArgs>
            result: $Utils.Optional<EntrepriseCountAggregateOutputType> | number
          }
        }
      }
      Agent: {
        payload: Prisma.$AgentPayload<ExtArgs>
        fields: Prisma.AgentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          findFirst: {
            args: Prisma.AgentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          findMany: {
            args: Prisma.AgentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>[]
          }
          create: {
            args: Prisma.AgentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          createMany: {
            args: Prisma.AgentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AgentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>[]
          }
          delete: {
            args: Prisma.AgentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          update: {
            args: Prisma.AgentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          deleteMany: {
            args: Prisma.AgentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AgentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>[]
          }
          upsert: {
            args: Prisma.AgentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          aggregate: {
            args: Prisma.AgentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgent>
          }
          groupBy: {
            args: Prisma.AgentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgentCountArgs<ExtArgs>
            result: $Utils.Optional<AgentCountAggregateOutputType> | number
          }
        }
      }
      Client: {
        payload: Prisma.$ClientPayload<ExtArgs>
        fields: Prisma.ClientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          findFirst: {
            args: Prisma.ClientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          findMany: {
            args: Prisma.ClientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          create: {
            args: Prisma.ClientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          createMany: {
            args: Prisma.ClientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          delete: {
            args: Prisma.ClientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          update: {
            args: Prisma.ClientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          deleteMany: {
            args: Prisma.ClientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClientUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          upsert: {
            args: Prisma.ClientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          aggregate: {
            args: Prisma.ClientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClient>
          }
          groupBy: {
            args: Prisma.ClientGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientCountArgs<ExtArgs>
            result: $Utils.Optional<ClientCountAggregateOutputType> | number
          }
        }
      }
      Adresse: {
        payload: Prisma.$AdressePayload<ExtArgs>
        fields: Prisma.AdresseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdresseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdressePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdresseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdressePayload>
          }
          findFirst: {
            args: Prisma.AdresseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdressePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdresseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdressePayload>
          }
          findMany: {
            args: Prisma.AdresseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdressePayload>[]
          }
          create: {
            args: Prisma.AdresseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdressePayload>
          }
          createMany: {
            args: Prisma.AdresseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdresseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdressePayload>[]
          }
          delete: {
            args: Prisma.AdresseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdressePayload>
          }
          update: {
            args: Prisma.AdresseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdressePayload>
          }
          deleteMany: {
            args: Prisma.AdresseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdresseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdresseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdressePayload>[]
          }
          upsert: {
            args: Prisma.AdresseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdressePayload>
          }
          aggregate: {
            args: Prisma.AdresseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdresse>
          }
          groupBy: {
            args: Prisma.AdresseGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdresseGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdresseCountArgs<ExtArgs>
            result: $Utils.Optional<AdresseCountAggregateOutputType> | number
          }
        }
      }
      Contact: {
        payload: Prisma.$ContactPayload<ExtArgs>
        fields: Prisma.ContactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          findFirst: {
            args: Prisma.ContactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          findMany: {
            args: Prisma.ContactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          create: {
            args: Prisma.ContactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          createMany: {
            args: Prisma.ContactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContactCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          delete: {
            args: Prisma.ContactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          update: {
            args: Prisma.ContactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          deleteMany: {
            args: Prisma.ContactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContactUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          upsert: {
            args: Prisma.ContactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          aggregate: {
            args: Prisma.ContactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContact>
          }
          groupBy: {
            args: Prisma.ContactGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactCountArgs<ExtArgs>
            result: $Utils.Optional<ContactCountAggregateOutputType> | number
          }
        }
      }
      Fournisseur: {
        payload: Prisma.$FournisseurPayload<ExtArgs>
        fields: Prisma.FournisseurFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FournisseurFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FournisseurPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FournisseurFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FournisseurPayload>
          }
          findFirst: {
            args: Prisma.FournisseurFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FournisseurPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FournisseurFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FournisseurPayload>
          }
          findMany: {
            args: Prisma.FournisseurFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FournisseurPayload>[]
          }
          create: {
            args: Prisma.FournisseurCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FournisseurPayload>
          }
          createMany: {
            args: Prisma.FournisseurCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FournisseurCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FournisseurPayload>[]
          }
          delete: {
            args: Prisma.FournisseurDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FournisseurPayload>
          }
          update: {
            args: Prisma.FournisseurUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FournisseurPayload>
          }
          deleteMany: {
            args: Prisma.FournisseurDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FournisseurUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FournisseurUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FournisseurPayload>[]
          }
          upsert: {
            args: Prisma.FournisseurUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FournisseurPayload>
          }
          aggregate: {
            args: Prisma.FournisseurAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFournisseur>
          }
          groupBy: {
            args: Prisma.FournisseurGroupByArgs<ExtArgs>
            result: $Utils.Optional<FournisseurGroupByOutputType>[]
          }
          count: {
            args: Prisma.FournisseurCountArgs<ExtArgs>
            result: $Utils.Optional<FournisseurCountAggregateOutputType> | number
          }
        }
      }
      Produit: {
        payload: Prisma.$ProduitPayload<ExtArgs>
        fields: Prisma.ProduitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProduitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProduitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProduitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProduitPayload>
          }
          findFirst: {
            args: Prisma.ProduitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProduitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProduitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProduitPayload>
          }
          findMany: {
            args: Prisma.ProduitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProduitPayload>[]
          }
          create: {
            args: Prisma.ProduitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProduitPayload>
          }
          createMany: {
            args: Prisma.ProduitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProduitCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProduitPayload>[]
          }
          delete: {
            args: Prisma.ProduitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProduitPayload>
          }
          update: {
            args: Prisma.ProduitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProduitPayload>
          }
          deleteMany: {
            args: Prisma.ProduitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProduitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProduitUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProduitPayload>[]
          }
          upsert: {
            args: Prisma.ProduitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProduitPayload>
          }
          aggregate: {
            args: Prisma.ProduitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduit>
          }
          groupBy: {
            args: Prisma.ProduitGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProduitGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProduitCountArgs<ExtArgs>
            result: $Utils.Optional<ProduitCountAggregateOutputType> | number
          }
        }
      }
      Paiement: {
        payload: Prisma.$PaiementPayload<ExtArgs>
        fields: Prisma.PaiementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaiementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaiementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaiementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaiementPayload>
          }
          findFirst: {
            args: Prisma.PaiementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaiementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaiementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaiementPayload>
          }
          findMany: {
            args: Prisma.PaiementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaiementPayload>[]
          }
          create: {
            args: Prisma.PaiementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaiementPayload>
          }
          createMany: {
            args: Prisma.PaiementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaiementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaiementPayload>[]
          }
          delete: {
            args: Prisma.PaiementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaiementPayload>
          }
          update: {
            args: Prisma.PaiementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaiementPayload>
          }
          deleteMany: {
            args: Prisma.PaiementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaiementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaiementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaiementPayload>[]
          }
          upsert: {
            args: Prisma.PaiementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaiementPayload>
          }
          aggregate: {
            args: Prisma.PaiementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaiement>
          }
          groupBy: {
            args: Prisma.PaiementGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaiementGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaiementCountArgs<ExtArgs>
            result: $Utils.Optional<PaiementCountAggregateOutputType> | number
          }
        }
      }
      Caisse: {
        payload: Prisma.$CaissePayload<ExtArgs>
        fields: Prisma.CaisseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CaisseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaissePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CaisseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaissePayload>
          }
          findFirst: {
            args: Prisma.CaisseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaissePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CaisseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaissePayload>
          }
          findMany: {
            args: Prisma.CaisseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaissePayload>[]
          }
          create: {
            args: Prisma.CaisseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaissePayload>
          }
          createMany: {
            args: Prisma.CaisseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CaisseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaissePayload>[]
          }
          delete: {
            args: Prisma.CaisseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaissePayload>
          }
          update: {
            args: Prisma.CaisseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaissePayload>
          }
          deleteMany: {
            args: Prisma.CaisseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CaisseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CaisseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaissePayload>[]
          }
          upsert: {
            args: Prisma.CaisseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaissePayload>
          }
          aggregate: {
            args: Prisma.CaisseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCaisse>
          }
          groupBy: {
            args: Prisma.CaisseGroupByArgs<ExtArgs>
            result: $Utils.Optional<CaisseGroupByOutputType>[]
          }
          count: {
            args: Prisma.CaisseCountArgs<ExtArgs>
            result: $Utils.Optional<CaisseCountAggregateOutputType> | number
          }
        }
      }
      Vente: {
        payload: Prisma.$VentePayload<ExtArgs>
        fields: Prisma.VenteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VenteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VenteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentePayload>
          }
          findFirst: {
            args: Prisma.VenteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VenteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentePayload>
          }
          findMany: {
            args: Prisma.VenteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentePayload>[]
          }
          create: {
            args: Prisma.VenteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentePayload>
          }
          createMany: {
            args: Prisma.VenteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VenteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentePayload>[]
          }
          delete: {
            args: Prisma.VenteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentePayload>
          }
          update: {
            args: Prisma.VenteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentePayload>
          }
          deleteMany: {
            args: Prisma.VenteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VenteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VenteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentePayload>[]
          }
          upsert: {
            args: Prisma.VenteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VentePayload>
          }
          aggregate: {
            args: Prisma.VenteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVente>
          }
          groupBy: {
            args: Prisma.VenteGroupByArgs<ExtArgs>
            result: $Utils.Optional<VenteGroupByOutputType>[]
          }
          count: {
            args: Prisma.VenteCountArgs<ExtArgs>
            result: $Utils.Optional<VenteCountAggregateOutputType> | number
          }
        }
      }
      Panier: {
        payload: Prisma.$PanierPayload<ExtArgs>
        fields: Prisma.PanierFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PanierFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PanierPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PanierFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PanierPayload>
          }
          findFirst: {
            args: Prisma.PanierFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PanierPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PanierFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PanierPayload>
          }
          findMany: {
            args: Prisma.PanierFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PanierPayload>[]
          }
          create: {
            args: Prisma.PanierCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PanierPayload>
          }
          createMany: {
            args: Prisma.PanierCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PanierCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PanierPayload>[]
          }
          delete: {
            args: Prisma.PanierDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PanierPayload>
          }
          update: {
            args: Prisma.PanierUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PanierPayload>
          }
          deleteMany: {
            args: Prisma.PanierDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PanierUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PanierUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PanierPayload>[]
          }
          upsert: {
            args: Prisma.PanierUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PanierPayload>
          }
          aggregate: {
            args: Prisma.PanierAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePanier>
          }
          groupBy: {
            args: Prisma.PanierGroupByArgs<ExtArgs>
            result: $Utils.Optional<PanierGroupByOutputType>[]
          }
          count: {
            args: Prisma.PanierCountArgs<ExtArgs>
            result: $Utils.Optional<PanierCountAggregateOutputType> | number
          }
        }
      }
      DetailPanier: {
        payload: Prisma.$DetailPanierPayload<ExtArgs>
        fields: Prisma.DetailPanierFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DetailPanierFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetailPanierPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DetailPanierFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetailPanierPayload>
          }
          findFirst: {
            args: Prisma.DetailPanierFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetailPanierPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DetailPanierFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetailPanierPayload>
          }
          findMany: {
            args: Prisma.DetailPanierFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetailPanierPayload>[]
          }
          create: {
            args: Prisma.DetailPanierCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetailPanierPayload>
          }
          createMany: {
            args: Prisma.DetailPanierCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DetailPanierCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetailPanierPayload>[]
          }
          delete: {
            args: Prisma.DetailPanierDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetailPanierPayload>
          }
          update: {
            args: Prisma.DetailPanierUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetailPanierPayload>
          }
          deleteMany: {
            args: Prisma.DetailPanierDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DetailPanierUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DetailPanierUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetailPanierPayload>[]
          }
          upsert: {
            args: Prisma.DetailPanierUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetailPanierPayload>
          }
          aggregate: {
            args: Prisma.DetailPanierAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDetailPanier>
          }
          groupBy: {
            args: Prisma.DetailPanierGroupByArgs<ExtArgs>
            result: $Utils.Optional<DetailPanierGroupByOutputType>[]
          }
          count: {
            args: Prisma.DetailPanierCountArgs<ExtArgs>
            result: $Utils.Optional<DetailPanierCountAggregateOutputType> | number
          }
        }
      }
      Achat: {
        payload: Prisma.$AchatPayload<ExtArgs>
        fields: Prisma.AchatFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AchatFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchatPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AchatFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchatPayload>
          }
          findFirst: {
            args: Prisma.AchatFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchatPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AchatFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchatPayload>
          }
          findMany: {
            args: Prisma.AchatFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchatPayload>[]
          }
          create: {
            args: Prisma.AchatCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchatPayload>
          }
          createMany: {
            args: Prisma.AchatCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AchatCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchatPayload>[]
          }
          delete: {
            args: Prisma.AchatDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchatPayload>
          }
          update: {
            args: Prisma.AchatUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchatPayload>
          }
          deleteMany: {
            args: Prisma.AchatDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AchatUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AchatUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchatPayload>[]
          }
          upsert: {
            args: Prisma.AchatUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchatPayload>
          }
          aggregate: {
            args: Prisma.AchatAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAchat>
          }
          groupBy: {
            args: Prisma.AchatGroupByArgs<ExtArgs>
            result: $Utils.Optional<AchatGroupByOutputType>[]
          }
          count: {
            args: Prisma.AchatCountArgs<ExtArgs>
            result: $Utils.Optional<AchatCountAggregateOutputType> | number
          }
        }
      }
      Reservation: {
        payload: Prisma.$ReservationPayload<ExtArgs>
        fields: Prisma.ReservationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReservationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReservationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>
          }
          findFirst: {
            args: Prisma.ReservationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReservationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>
          }
          findMany: {
            args: Prisma.ReservationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>[]
          }
          create: {
            args: Prisma.ReservationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>
          }
          createMany: {
            args: Prisma.ReservationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReservationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>[]
          }
          delete: {
            args: Prisma.ReservationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>
          }
          update: {
            args: Prisma.ReservationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>
          }
          deleteMany: {
            args: Prisma.ReservationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReservationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReservationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>[]
          }
          upsert: {
            args: Prisma.ReservationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>
          }
          aggregate: {
            args: Prisma.ReservationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReservation>
          }
          groupBy: {
            args: Prisma.ReservationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReservationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReservationCountArgs<ExtArgs>
            result: $Utils.Optional<ReservationCountAggregateOutputType> | number
          }
        }
      }
      Commande: {
        payload: Prisma.$CommandePayload<ExtArgs>
        fields: Prisma.CommandeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommandeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommandeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandePayload>
          }
          findFirst: {
            args: Prisma.CommandeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommandeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandePayload>
          }
          findMany: {
            args: Prisma.CommandeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandePayload>[]
          }
          create: {
            args: Prisma.CommandeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandePayload>
          }
          createMany: {
            args: Prisma.CommandeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommandeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandePayload>[]
          }
          delete: {
            args: Prisma.CommandeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandePayload>
          }
          update: {
            args: Prisma.CommandeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandePayload>
          }
          deleteMany: {
            args: Prisma.CommandeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommandeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CommandeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandePayload>[]
          }
          upsert: {
            args: Prisma.CommandeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommandePayload>
          }
          aggregate: {
            args: Prisma.CommandeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCommande>
          }
          groupBy: {
            args: Prisma.CommandeGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommandeGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommandeCountArgs<ExtArgs>
            result: $Utils.Optional<CommandeCountAggregateOutputType> | number
          }
        }
      }
      ClotureCaisse: {
        payload: Prisma.$ClotureCaissePayload<ExtArgs>
        fields: Prisma.ClotureCaisseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClotureCaisseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClotureCaissePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClotureCaisseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClotureCaissePayload>
          }
          findFirst: {
            args: Prisma.ClotureCaisseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClotureCaissePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClotureCaisseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClotureCaissePayload>
          }
          findMany: {
            args: Prisma.ClotureCaisseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClotureCaissePayload>[]
          }
          create: {
            args: Prisma.ClotureCaisseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClotureCaissePayload>
          }
          createMany: {
            args: Prisma.ClotureCaisseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClotureCaisseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClotureCaissePayload>[]
          }
          delete: {
            args: Prisma.ClotureCaisseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClotureCaissePayload>
          }
          update: {
            args: Prisma.ClotureCaisseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClotureCaissePayload>
          }
          deleteMany: {
            args: Prisma.ClotureCaisseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClotureCaisseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClotureCaisseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClotureCaissePayload>[]
          }
          upsert: {
            args: Prisma.ClotureCaisseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClotureCaissePayload>
          }
          aggregate: {
            args: Prisma.ClotureCaisseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClotureCaisse>
          }
          groupBy: {
            args: Prisma.ClotureCaisseGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClotureCaisseGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClotureCaisseCountArgs<ExtArgs>
            result: $Utils.Optional<ClotureCaisseCountAggregateOutputType> | number
          }
        }
      }
      MouvementCaisse: {
        payload: Prisma.$MouvementCaissePayload<ExtArgs>
        fields: Prisma.MouvementCaisseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MouvementCaisseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MouvementCaissePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MouvementCaisseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MouvementCaissePayload>
          }
          findFirst: {
            args: Prisma.MouvementCaisseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MouvementCaissePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MouvementCaisseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MouvementCaissePayload>
          }
          findMany: {
            args: Prisma.MouvementCaisseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MouvementCaissePayload>[]
          }
          create: {
            args: Prisma.MouvementCaisseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MouvementCaissePayload>
          }
          createMany: {
            args: Prisma.MouvementCaisseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MouvementCaisseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MouvementCaissePayload>[]
          }
          delete: {
            args: Prisma.MouvementCaisseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MouvementCaissePayload>
          }
          update: {
            args: Prisma.MouvementCaisseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MouvementCaissePayload>
          }
          deleteMany: {
            args: Prisma.MouvementCaisseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MouvementCaisseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MouvementCaisseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MouvementCaissePayload>[]
          }
          upsert: {
            args: Prisma.MouvementCaisseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MouvementCaissePayload>
          }
          aggregate: {
            args: Prisma.MouvementCaisseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMouvementCaisse>
          }
          groupBy: {
            args: Prisma.MouvementCaisseGroupByArgs<ExtArgs>
            result: $Utils.Optional<MouvementCaisseGroupByOutputType>[]
          }
          count: {
            args: Prisma.MouvementCaisseCountArgs<ExtArgs>
            result: $Utils.Optional<MouvementCaisseCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    teneur?: TeneurOmit
    devise?: DeviseOmit
    entreprise?: EntrepriseOmit
    agent?: AgentOmit
    client?: ClientOmit
    adresse?: AdresseOmit
    contact?: ContactOmit
    fournisseur?: FournisseurOmit
    produit?: ProduitOmit
    paiement?: PaiementOmit
    caisse?: CaisseOmit
    vente?: VenteOmit
    panier?: PanierOmit
    detailPanier?: DetailPanierOmit
    achat?: AchatOmit
    reservation?: ReservationOmit
    commande?: CommandeOmit
    clotureCaisse?: ClotureCaisseOmit
    mouvementCaisse?: MouvementCaisseOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type TeneurCountOutputType
   */

  export type TeneurCountOutputType = {
    produits: number
  }

  export type TeneurCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    produits?: boolean | TeneurCountOutputTypeCountProduitsArgs
  }

  // Custom InputTypes
  /**
   * TeneurCountOutputType without action
   */
  export type TeneurCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeneurCountOutputType
     */
    select?: TeneurCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TeneurCountOutputType without action
   */
  export type TeneurCountOutputTypeCountProduitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProduitWhereInput
  }


  /**
   * Count Type DeviseCountOutputType
   */

  export type DeviseCountOutputType = {
    produits: number
    paiements: number
    caisses: number
    DetailPanier: number
  }

  export type DeviseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    produits?: boolean | DeviseCountOutputTypeCountProduitsArgs
    paiements?: boolean | DeviseCountOutputTypeCountPaiementsArgs
    caisses?: boolean | DeviseCountOutputTypeCountCaissesArgs
    DetailPanier?: boolean | DeviseCountOutputTypeCountDetailPanierArgs
  }

  // Custom InputTypes
  /**
   * DeviseCountOutputType without action
   */
  export type DeviseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviseCountOutputType
     */
    select?: DeviseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DeviseCountOutputType without action
   */
  export type DeviseCountOutputTypeCountProduitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProduitWhereInput
  }

  /**
   * DeviseCountOutputType without action
   */
  export type DeviseCountOutputTypeCountPaiementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaiementWhereInput
  }

  /**
   * DeviseCountOutputType without action
   */
  export type DeviseCountOutputTypeCountCaissesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CaisseWhereInput
  }

  /**
   * DeviseCountOutputType without action
   */
  export type DeviseCountOutputTypeCountDetailPanierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DetailPanierWhereInput
  }


  /**
   * Count Type EntrepriseCountOutputType
   */

  export type EntrepriseCountOutputType = {
    clotureCaisses: number
    Adresse: number
    Contact: number
  }

  export type EntrepriseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clotureCaisses?: boolean | EntrepriseCountOutputTypeCountClotureCaissesArgs
    Adresse?: boolean | EntrepriseCountOutputTypeCountAdresseArgs
    Contact?: boolean | EntrepriseCountOutputTypeCountContactArgs
  }

  // Custom InputTypes
  /**
   * EntrepriseCountOutputType without action
   */
  export type EntrepriseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntrepriseCountOutputType
     */
    select?: EntrepriseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EntrepriseCountOutputType without action
   */
  export type EntrepriseCountOutputTypeCountClotureCaissesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClotureCaisseWhereInput
  }

  /**
   * EntrepriseCountOutputType without action
   */
  export type EntrepriseCountOutputTypeCountAdresseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdresseWhereInput
  }

  /**
   * EntrepriseCountOutputType without action
   */
  export type EntrepriseCountOutputTypeCountContactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
  }


  /**
   * Count Type AgentCountOutputType
   */

  export type AgentCountOutputType = {
    adresses: number
    contacts: number
    produits: number
    ventes: number
    achats: number
    teneurs: number
    devises: number
    paniers: number
    caisses: number
    mouvementCaisses: number
    clotureCaisses: number
    Fournisseur: number
  }

  export type AgentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    adresses?: boolean | AgentCountOutputTypeCountAdressesArgs
    contacts?: boolean | AgentCountOutputTypeCountContactsArgs
    produits?: boolean | AgentCountOutputTypeCountProduitsArgs
    ventes?: boolean | AgentCountOutputTypeCountVentesArgs
    achats?: boolean | AgentCountOutputTypeCountAchatsArgs
    teneurs?: boolean | AgentCountOutputTypeCountTeneursArgs
    devises?: boolean | AgentCountOutputTypeCountDevisesArgs
    paniers?: boolean | AgentCountOutputTypeCountPaniersArgs
    caisses?: boolean | AgentCountOutputTypeCountCaissesArgs
    mouvementCaisses?: boolean | AgentCountOutputTypeCountMouvementCaissesArgs
    clotureCaisses?: boolean | AgentCountOutputTypeCountClotureCaissesArgs
    Fournisseur?: boolean | AgentCountOutputTypeCountFournisseurArgs
  }

  // Custom InputTypes
  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentCountOutputType
     */
    select?: AgentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountAdressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdresseWhereInput
  }

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
  }

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountProduitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProduitWhereInput
  }

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountVentesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VenteWhereInput
  }

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountAchatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AchatWhereInput
  }

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountTeneursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeneurWhereInput
  }

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountDevisesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviseWhereInput
  }

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountPaniersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PanierWhereInput
  }

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountCaissesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CaisseWhereInput
  }

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountMouvementCaissesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MouvementCaisseWhereInput
  }

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountClotureCaissesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClotureCaisseWhereInput
  }

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountFournisseurArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FournisseurWhereInput
  }


  /**
   * Count Type ClientCountOutputType
   */

  export type ClientCountOutputType = {
    adresses: number
    contacts: number
    ventes: number
    achats: number
    paniers: number
    reservations: number
    commandes: number
  }

  export type ClientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    adresses?: boolean | ClientCountOutputTypeCountAdressesArgs
    contacts?: boolean | ClientCountOutputTypeCountContactsArgs
    ventes?: boolean | ClientCountOutputTypeCountVentesArgs
    achats?: boolean | ClientCountOutputTypeCountAchatsArgs
    paniers?: boolean | ClientCountOutputTypeCountPaniersArgs
    reservations?: boolean | ClientCountOutputTypeCountReservationsArgs
    commandes?: boolean | ClientCountOutputTypeCountCommandesArgs
  }

  // Custom InputTypes
  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCountOutputType
     */
    select?: ClientCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountAdressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdresseWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountVentesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VenteWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountAchatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AchatWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountPaniersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PanierWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountReservationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReservationWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountCommandesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommandeWhereInput
  }


  /**
   * Count Type AdresseCountOutputType
   */

  export type AdresseCountOutputType = {
    reservations: number
    commandes: number
  }

  export type AdresseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reservations?: boolean | AdresseCountOutputTypeCountReservationsArgs
    commandes?: boolean | AdresseCountOutputTypeCountCommandesArgs
  }

  // Custom InputTypes
  /**
   * AdresseCountOutputType without action
   */
  export type AdresseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdresseCountOutputType
     */
    select?: AdresseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AdresseCountOutputType without action
   */
  export type AdresseCountOutputTypeCountReservationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReservationWhereInput
  }

  /**
   * AdresseCountOutputType without action
   */
  export type AdresseCountOutputTypeCountCommandesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommandeWhereInput
  }


  /**
   * Count Type ContactCountOutputType
   */

  export type ContactCountOutputType = {
    reservations: number
    commandes: number
  }

  export type ContactCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reservations?: boolean | ContactCountOutputTypeCountReservationsArgs
    commandes?: boolean | ContactCountOutputTypeCountCommandesArgs
  }

  // Custom InputTypes
  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactCountOutputType
     */
    select?: ContactCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeCountReservationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReservationWhereInput
  }

  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeCountCommandesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommandeWhereInput
  }


  /**
   * Count Type FournisseurCountOutputType
   */

  export type FournisseurCountOutputType = {
    ventes: number
    achats: number
    adresses: number
    contacts: number
    reservations: number
    commandes: number
  }

  export type FournisseurCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ventes?: boolean | FournisseurCountOutputTypeCountVentesArgs
    achats?: boolean | FournisseurCountOutputTypeCountAchatsArgs
    adresses?: boolean | FournisseurCountOutputTypeCountAdressesArgs
    contacts?: boolean | FournisseurCountOutputTypeCountContactsArgs
    reservations?: boolean | FournisseurCountOutputTypeCountReservationsArgs
    commandes?: boolean | FournisseurCountOutputTypeCountCommandesArgs
  }

  // Custom InputTypes
  /**
   * FournisseurCountOutputType without action
   */
  export type FournisseurCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FournisseurCountOutputType
     */
    select?: FournisseurCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FournisseurCountOutputType without action
   */
  export type FournisseurCountOutputTypeCountVentesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VenteWhereInput
  }

  /**
   * FournisseurCountOutputType without action
   */
  export type FournisseurCountOutputTypeCountAchatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AchatWhereInput
  }

  /**
   * FournisseurCountOutputType without action
   */
  export type FournisseurCountOutputTypeCountAdressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdresseWhereInput
  }

  /**
   * FournisseurCountOutputType without action
   */
  export type FournisseurCountOutputTypeCountContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
  }

  /**
   * FournisseurCountOutputType without action
   */
  export type FournisseurCountOutputTypeCountReservationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReservationWhereInput
  }

  /**
   * FournisseurCountOutputType without action
   */
  export type FournisseurCountOutputTypeCountCommandesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommandeWhereInput
  }


  /**
   * Count Type ProduitCountOutputType
   */

  export type ProduitCountOutputType = {
    detailsPaniers: number
  }

  export type ProduitCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    detailsPaniers?: boolean | ProduitCountOutputTypeCountDetailsPaniersArgs
  }

  // Custom InputTypes
  /**
   * ProduitCountOutputType without action
   */
  export type ProduitCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProduitCountOutputType
     */
    select?: ProduitCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProduitCountOutputType without action
   */
  export type ProduitCountOutputTypeCountDetailsPaniersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DetailPanierWhereInput
  }


  /**
   * Count Type CaisseCountOutputType
   */

  export type CaisseCountOutputType = {
    mouvementCaisses: number
    paiements: number
  }

  export type CaisseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mouvementCaisses?: boolean | CaisseCountOutputTypeCountMouvementCaissesArgs
    paiements?: boolean | CaisseCountOutputTypeCountPaiementsArgs
  }

  // Custom InputTypes
  /**
   * CaisseCountOutputType without action
   */
  export type CaisseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaisseCountOutputType
     */
    select?: CaisseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CaisseCountOutputType without action
   */
  export type CaisseCountOutputTypeCountMouvementCaissesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MouvementCaisseWhereInput
  }

  /**
   * CaisseCountOutputType without action
   */
  export type CaisseCountOutputTypeCountPaiementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaiementWhereInput
  }


  /**
   * Count Type VenteCountOutputType
   */

  export type VenteCountOutputType = {
    paiements: number
  }

  export type VenteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    paiements?: boolean | VenteCountOutputTypeCountPaiementsArgs
  }

  // Custom InputTypes
  /**
   * VenteCountOutputType without action
   */
  export type VenteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VenteCountOutputType
     */
    select?: VenteCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VenteCountOutputType without action
   */
  export type VenteCountOutputTypeCountPaiementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaiementWhereInput
  }


  /**
   * Count Type PanierCountOutputType
   */

  export type PanierCountOutputType = {
    detailPaniers: number
    achats: number
    ventes: number
    reservations: number
    commandes: number
  }

  export type PanierCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    detailPaniers?: boolean | PanierCountOutputTypeCountDetailPaniersArgs
    achats?: boolean | PanierCountOutputTypeCountAchatsArgs
    ventes?: boolean | PanierCountOutputTypeCountVentesArgs
    reservations?: boolean | PanierCountOutputTypeCountReservationsArgs
    commandes?: boolean | PanierCountOutputTypeCountCommandesArgs
  }

  // Custom InputTypes
  /**
   * PanierCountOutputType without action
   */
  export type PanierCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PanierCountOutputType
     */
    select?: PanierCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PanierCountOutputType without action
   */
  export type PanierCountOutputTypeCountDetailPaniersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DetailPanierWhereInput
  }

  /**
   * PanierCountOutputType without action
   */
  export type PanierCountOutputTypeCountAchatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AchatWhereInput
  }

  /**
   * PanierCountOutputType without action
   */
  export type PanierCountOutputTypeCountVentesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VenteWhereInput
  }

  /**
   * PanierCountOutputType without action
   */
  export type PanierCountOutputTypeCountReservationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReservationWhereInput
  }

  /**
   * PanierCountOutputType without action
   */
  export type PanierCountOutputTypeCountCommandesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommandeWhereInput
  }


  /**
   * Count Type AchatCountOutputType
   */

  export type AchatCountOutputType = {
    paiements: number
  }

  export type AchatCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    paiements?: boolean | AchatCountOutputTypeCountPaiementsArgs
  }

  // Custom InputTypes
  /**
   * AchatCountOutputType without action
   */
  export type AchatCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchatCountOutputType
     */
    select?: AchatCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AchatCountOutputType without action
   */
  export type AchatCountOutputTypeCountPaiementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaiementWhereInput
  }


  /**
   * Count Type CommandeCountOutputType
   */

  export type CommandeCountOutputType = {
    Paiement: number
  }

  export type CommandeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Paiement?: boolean | CommandeCountOutputTypeCountPaiementArgs
  }

  // Custom InputTypes
  /**
   * CommandeCountOutputType without action
   */
  export type CommandeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommandeCountOutputType
     */
    select?: CommandeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CommandeCountOutputType without action
   */
  export type CommandeCountOutputTypeCountPaiementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaiementWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Teneur
   */

  export type AggregateTeneur = {
    _count: TeneurCountAggregateOutputType | null
    _avg: TeneurAvgAggregateOutputType | null
    _sum: TeneurSumAggregateOutputType | null
    _min: TeneurMinAggregateOutputType | null
    _max: TeneurMaxAggregateOutputType | null
  }

  export type TeneurAvgAggregateOutputType = {
    id: number | null
    valeur: number | null
    agentId: number | null
  }

  export type TeneurSumAggregateOutputType = {
    id: number | null
    valeur: number | null
    agentId: number | null
  }

  export type TeneurMinAggregateOutputType = {
    id: number | null
    valeur: number | null
    agentId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeneurMaxAggregateOutputType = {
    id: number | null
    valeur: number | null
    agentId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeneurCountAggregateOutputType = {
    id: number
    valeur: number
    agentId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TeneurAvgAggregateInputType = {
    id?: true
    valeur?: true
    agentId?: true
  }

  export type TeneurSumAggregateInputType = {
    id?: true
    valeur?: true
    agentId?: true
  }

  export type TeneurMinAggregateInputType = {
    id?: true
    valeur?: true
    agentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeneurMaxAggregateInputType = {
    id?: true
    valeur?: true
    agentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeneurCountAggregateInputType = {
    id?: true
    valeur?: true
    agentId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TeneurAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Teneur to aggregate.
     */
    where?: TeneurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teneurs to fetch.
     */
    orderBy?: TeneurOrderByWithRelationInput | TeneurOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeneurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teneurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teneurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Teneurs
    **/
    _count?: true | TeneurCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TeneurAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TeneurSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeneurMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeneurMaxAggregateInputType
  }

  export type GetTeneurAggregateType<T extends TeneurAggregateArgs> = {
        [P in keyof T & keyof AggregateTeneur]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeneur[P]>
      : GetScalarType<T[P], AggregateTeneur[P]>
  }




  export type TeneurGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeneurWhereInput
    orderBy?: TeneurOrderByWithAggregationInput | TeneurOrderByWithAggregationInput[]
    by: TeneurScalarFieldEnum[] | TeneurScalarFieldEnum
    having?: TeneurScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeneurCountAggregateInputType | true
    _avg?: TeneurAvgAggregateInputType
    _sum?: TeneurSumAggregateInputType
    _min?: TeneurMinAggregateInputType
    _max?: TeneurMaxAggregateInputType
  }

  export type TeneurGroupByOutputType = {
    id: number
    valeur: number
    agentId: number
    createdAt: Date
    updatedAt: Date
    _count: TeneurCountAggregateOutputType | null
    _avg: TeneurAvgAggregateOutputType | null
    _sum: TeneurSumAggregateOutputType | null
    _min: TeneurMinAggregateOutputType | null
    _max: TeneurMaxAggregateOutputType | null
  }

  type GetTeneurGroupByPayload<T extends TeneurGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeneurGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeneurGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeneurGroupByOutputType[P]>
            : GetScalarType<T[P], TeneurGroupByOutputType[P]>
        }
      >
    >


  export type TeneurSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    valeur?: boolean
    agentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agents?: boolean | AgentDefaultArgs<ExtArgs>
    produits?: boolean | Teneur$produitsArgs<ExtArgs>
    _count?: boolean | TeneurCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teneur"]>

  export type TeneurSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    valeur?: boolean
    agentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agents?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teneur"]>

  export type TeneurSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    valeur?: boolean
    agentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agents?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teneur"]>

  export type TeneurSelectScalar = {
    id?: boolean
    valeur?: boolean
    agentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TeneurOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "valeur" | "agentId" | "createdAt" | "updatedAt", ExtArgs["result"]["teneur"]>
  export type TeneurInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agents?: boolean | AgentDefaultArgs<ExtArgs>
    produits?: boolean | Teneur$produitsArgs<ExtArgs>
    _count?: boolean | TeneurCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TeneurIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agents?: boolean | AgentDefaultArgs<ExtArgs>
  }
  export type TeneurIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agents?: boolean | AgentDefaultArgs<ExtArgs>
  }

  export type $TeneurPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Teneur"
    objects: {
      agents: Prisma.$AgentPayload<ExtArgs>
      produits: Prisma.$ProduitPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      valeur: number
      agentId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["teneur"]>
    composites: {}
  }

  type TeneurGetPayload<S extends boolean | null | undefined | TeneurDefaultArgs> = $Result.GetResult<Prisma.$TeneurPayload, S>

  type TeneurCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TeneurFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeneurCountAggregateInputType | true
    }

  export interface TeneurDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Teneur'], meta: { name: 'Teneur' } }
    /**
     * Find zero or one Teneur that matches the filter.
     * @param {TeneurFindUniqueArgs} args - Arguments to find a Teneur
     * @example
     * // Get one Teneur
     * const teneur = await prisma.teneur.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeneurFindUniqueArgs>(args: SelectSubset<T, TeneurFindUniqueArgs<ExtArgs>>): Prisma__TeneurClient<$Result.GetResult<Prisma.$TeneurPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Teneur that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeneurFindUniqueOrThrowArgs} args - Arguments to find a Teneur
     * @example
     * // Get one Teneur
     * const teneur = await prisma.teneur.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeneurFindUniqueOrThrowArgs>(args: SelectSubset<T, TeneurFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeneurClient<$Result.GetResult<Prisma.$TeneurPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Teneur that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeneurFindFirstArgs} args - Arguments to find a Teneur
     * @example
     * // Get one Teneur
     * const teneur = await prisma.teneur.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeneurFindFirstArgs>(args?: SelectSubset<T, TeneurFindFirstArgs<ExtArgs>>): Prisma__TeneurClient<$Result.GetResult<Prisma.$TeneurPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Teneur that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeneurFindFirstOrThrowArgs} args - Arguments to find a Teneur
     * @example
     * // Get one Teneur
     * const teneur = await prisma.teneur.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeneurFindFirstOrThrowArgs>(args?: SelectSubset<T, TeneurFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeneurClient<$Result.GetResult<Prisma.$TeneurPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Teneurs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeneurFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teneurs
     * const teneurs = await prisma.teneur.findMany()
     * 
     * // Get first 10 Teneurs
     * const teneurs = await prisma.teneur.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teneurWithIdOnly = await prisma.teneur.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeneurFindManyArgs>(args?: SelectSubset<T, TeneurFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeneurPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Teneur.
     * @param {TeneurCreateArgs} args - Arguments to create a Teneur.
     * @example
     * // Create one Teneur
     * const Teneur = await prisma.teneur.create({
     *   data: {
     *     // ... data to create a Teneur
     *   }
     * })
     * 
     */
    create<T extends TeneurCreateArgs>(args: SelectSubset<T, TeneurCreateArgs<ExtArgs>>): Prisma__TeneurClient<$Result.GetResult<Prisma.$TeneurPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Teneurs.
     * @param {TeneurCreateManyArgs} args - Arguments to create many Teneurs.
     * @example
     * // Create many Teneurs
     * const teneur = await prisma.teneur.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeneurCreateManyArgs>(args?: SelectSubset<T, TeneurCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Teneurs and returns the data saved in the database.
     * @param {TeneurCreateManyAndReturnArgs} args - Arguments to create many Teneurs.
     * @example
     * // Create many Teneurs
     * const teneur = await prisma.teneur.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Teneurs and only return the `id`
     * const teneurWithIdOnly = await prisma.teneur.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeneurCreateManyAndReturnArgs>(args?: SelectSubset<T, TeneurCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeneurPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Teneur.
     * @param {TeneurDeleteArgs} args - Arguments to delete one Teneur.
     * @example
     * // Delete one Teneur
     * const Teneur = await prisma.teneur.delete({
     *   where: {
     *     // ... filter to delete one Teneur
     *   }
     * })
     * 
     */
    delete<T extends TeneurDeleteArgs>(args: SelectSubset<T, TeneurDeleteArgs<ExtArgs>>): Prisma__TeneurClient<$Result.GetResult<Prisma.$TeneurPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Teneur.
     * @param {TeneurUpdateArgs} args - Arguments to update one Teneur.
     * @example
     * // Update one Teneur
     * const teneur = await prisma.teneur.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeneurUpdateArgs>(args: SelectSubset<T, TeneurUpdateArgs<ExtArgs>>): Prisma__TeneurClient<$Result.GetResult<Prisma.$TeneurPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Teneurs.
     * @param {TeneurDeleteManyArgs} args - Arguments to filter Teneurs to delete.
     * @example
     * // Delete a few Teneurs
     * const { count } = await prisma.teneur.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeneurDeleteManyArgs>(args?: SelectSubset<T, TeneurDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teneurs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeneurUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teneurs
     * const teneur = await prisma.teneur.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeneurUpdateManyArgs>(args: SelectSubset<T, TeneurUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teneurs and returns the data updated in the database.
     * @param {TeneurUpdateManyAndReturnArgs} args - Arguments to update many Teneurs.
     * @example
     * // Update many Teneurs
     * const teneur = await prisma.teneur.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Teneurs and only return the `id`
     * const teneurWithIdOnly = await prisma.teneur.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TeneurUpdateManyAndReturnArgs>(args: SelectSubset<T, TeneurUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeneurPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Teneur.
     * @param {TeneurUpsertArgs} args - Arguments to update or create a Teneur.
     * @example
     * // Update or create a Teneur
     * const teneur = await prisma.teneur.upsert({
     *   create: {
     *     // ... data to create a Teneur
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Teneur we want to update
     *   }
     * })
     */
    upsert<T extends TeneurUpsertArgs>(args: SelectSubset<T, TeneurUpsertArgs<ExtArgs>>): Prisma__TeneurClient<$Result.GetResult<Prisma.$TeneurPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Teneurs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeneurCountArgs} args - Arguments to filter Teneurs to count.
     * @example
     * // Count the number of Teneurs
     * const count = await prisma.teneur.count({
     *   where: {
     *     // ... the filter for the Teneurs we want to count
     *   }
     * })
    **/
    count<T extends TeneurCountArgs>(
      args?: Subset<T, TeneurCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeneurCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Teneur.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeneurAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeneurAggregateArgs>(args: Subset<T, TeneurAggregateArgs>): Prisma.PrismaPromise<GetTeneurAggregateType<T>>

    /**
     * Group by Teneur.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeneurGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeneurGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeneurGroupByArgs['orderBy'] }
        : { orderBy?: TeneurGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeneurGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeneurGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Teneur model
   */
  readonly fields: TeneurFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Teneur.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeneurClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agents<T extends AgentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgentDefaultArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    produits<T extends Teneur$produitsArgs<ExtArgs> = {}>(args?: Subset<T, Teneur$produitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProduitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Teneur model
   */
  interface TeneurFieldRefs {
    readonly id: FieldRef<"Teneur", 'Int'>
    readonly valeur: FieldRef<"Teneur", 'Float'>
    readonly agentId: FieldRef<"Teneur", 'Int'>
    readonly createdAt: FieldRef<"Teneur", 'DateTime'>
    readonly updatedAt: FieldRef<"Teneur", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Teneur findUnique
   */
  export type TeneurFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teneur
     */
    select?: TeneurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teneur
     */
    omit?: TeneurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeneurInclude<ExtArgs> | null
    /**
     * Filter, which Teneur to fetch.
     */
    where: TeneurWhereUniqueInput
  }

  /**
   * Teneur findUniqueOrThrow
   */
  export type TeneurFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teneur
     */
    select?: TeneurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teneur
     */
    omit?: TeneurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeneurInclude<ExtArgs> | null
    /**
     * Filter, which Teneur to fetch.
     */
    where: TeneurWhereUniqueInput
  }

  /**
   * Teneur findFirst
   */
  export type TeneurFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teneur
     */
    select?: TeneurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teneur
     */
    omit?: TeneurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeneurInclude<ExtArgs> | null
    /**
     * Filter, which Teneur to fetch.
     */
    where?: TeneurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teneurs to fetch.
     */
    orderBy?: TeneurOrderByWithRelationInput | TeneurOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teneurs.
     */
    cursor?: TeneurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teneurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teneurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teneurs.
     */
    distinct?: TeneurScalarFieldEnum | TeneurScalarFieldEnum[]
  }

  /**
   * Teneur findFirstOrThrow
   */
  export type TeneurFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teneur
     */
    select?: TeneurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teneur
     */
    omit?: TeneurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeneurInclude<ExtArgs> | null
    /**
     * Filter, which Teneur to fetch.
     */
    where?: TeneurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teneurs to fetch.
     */
    orderBy?: TeneurOrderByWithRelationInput | TeneurOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teneurs.
     */
    cursor?: TeneurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teneurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teneurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teneurs.
     */
    distinct?: TeneurScalarFieldEnum | TeneurScalarFieldEnum[]
  }

  /**
   * Teneur findMany
   */
  export type TeneurFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teneur
     */
    select?: TeneurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teneur
     */
    omit?: TeneurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeneurInclude<ExtArgs> | null
    /**
     * Filter, which Teneurs to fetch.
     */
    where?: TeneurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teneurs to fetch.
     */
    orderBy?: TeneurOrderByWithRelationInput | TeneurOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Teneurs.
     */
    cursor?: TeneurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teneurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teneurs.
     */
    skip?: number
    distinct?: TeneurScalarFieldEnum | TeneurScalarFieldEnum[]
  }

  /**
   * Teneur create
   */
  export type TeneurCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teneur
     */
    select?: TeneurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teneur
     */
    omit?: TeneurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeneurInclude<ExtArgs> | null
    /**
     * The data needed to create a Teneur.
     */
    data: XOR<TeneurCreateInput, TeneurUncheckedCreateInput>
  }

  /**
   * Teneur createMany
   */
  export type TeneurCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Teneurs.
     */
    data: TeneurCreateManyInput | TeneurCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Teneur createManyAndReturn
   */
  export type TeneurCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teneur
     */
    select?: TeneurSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Teneur
     */
    omit?: TeneurOmit<ExtArgs> | null
    /**
     * The data used to create many Teneurs.
     */
    data: TeneurCreateManyInput | TeneurCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeneurIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Teneur update
   */
  export type TeneurUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teneur
     */
    select?: TeneurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teneur
     */
    omit?: TeneurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeneurInclude<ExtArgs> | null
    /**
     * The data needed to update a Teneur.
     */
    data: XOR<TeneurUpdateInput, TeneurUncheckedUpdateInput>
    /**
     * Choose, which Teneur to update.
     */
    where: TeneurWhereUniqueInput
  }

  /**
   * Teneur updateMany
   */
  export type TeneurUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Teneurs.
     */
    data: XOR<TeneurUpdateManyMutationInput, TeneurUncheckedUpdateManyInput>
    /**
     * Filter which Teneurs to update
     */
    where?: TeneurWhereInput
    /**
     * Limit how many Teneurs to update.
     */
    limit?: number
  }

  /**
   * Teneur updateManyAndReturn
   */
  export type TeneurUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teneur
     */
    select?: TeneurSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Teneur
     */
    omit?: TeneurOmit<ExtArgs> | null
    /**
     * The data used to update Teneurs.
     */
    data: XOR<TeneurUpdateManyMutationInput, TeneurUncheckedUpdateManyInput>
    /**
     * Filter which Teneurs to update
     */
    where?: TeneurWhereInput
    /**
     * Limit how many Teneurs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeneurIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Teneur upsert
   */
  export type TeneurUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teneur
     */
    select?: TeneurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teneur
     */
    omit?: TeneurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeneurInclude<ExtArgs> | null
    /**
     * The filter to search for the Teneur to update in case it exists.
     */
    where: TeneurWhereUniqueInput
    /**
     * In case the Teneur found by the `where` argument doesn't exist, create a new Teneur with this data.
     */
    create: XOR<TeneurCreateInput, TeneurUncheckedCreateInput>
    /**
     * In case the Teneur was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeneurUpdateInput, TeneurUncheckedUpdateInput>
  }

  /**
   * Teneur delete
   */
  export type TeneurDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teneur
     */
    select?: TeneurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teneur
     */
    omit?: TeneurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeneurInclude<ExtArgs> | null
    /**
     * Filter which Teneur to delete.
     */
    where: TeneurWhereUniqueInput
  }

  /**
   * Teneur deleteMany
   */
  export type TeneurDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Teneurs to delete
     */
    where?: TeneurWhereInput
    /**
     * Limit how many Teneurs to delete.
     */
    limit?: number
  }

  /**
   * Teneur.produits
   */
  export type Teneur$produitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Produit
     */
    select?: ProduitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Produit
     */
    omit?: ProduitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProduitInclude<ExtArgs> | null
    where?: ProduitWhereInput
    orderBy?: ProduitOrderByWithRelationInput | ProduitOrderByWithRelationInput[]
    cursor?: ProduitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProduitScalarFieldEnum | ProduitScalarFieldEnum[]
  }

  /**
   * Teneur without action
   */
  export type TeneurDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teneur
     */
    select?: TeneurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teneur
     */
    omit?: TeneurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeneurInclude<ExtArgs> | null
  }


  /**
   * Model Devise
   */

  export type AggregateDevise = {
    _count: DeviseCountAggregateOutputType | null
    _avg: DeviseAvgAggregateOutputType | null
    _sum: DeviseSumAggregateOutputType | null
    _min: DeviseMinAggregateOutputType | null
    _max: DeviseMaxAggregateOutputType | null
  }

  export type DeviseAvgAggregateOutputType = {
    id: number | null
    tauxDEchange: number | null
    agentId: number | null
  }

  export type DeviseSumAggregateOutputType = {
    id: number | null
    tauxDEchange: number | null
    agentId: number | null
  }

  export type DeviseMinAggregateOutputType = {
    id: number | null
    nom: string | null
    code: string | null
    symbole: string | null
    tauxDEchange: number | null
    agentId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DeviseMaxAggregateOutputType = {
    id: number | null
    nom: string | null
    code: string | null
    symbole: string | null
    tauxDEchange: number | null
    agentId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DeviseCountAggregateOutputType = {
    id: number
    nom: number
    code: number
    symbole: number
    tauxDEchange: number
    agentId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DeviseAvgAggregateInputType = {
    id?: true
    tauxDEchange?: true
    agentId?: true
  }

  export type DeviseSumAggregateInputType = {
    id?: true
    tauxDEchange?: true
    agentId?: true
  }

  export type DeviseMinAggregateInputType = {
    id?: true
    nom?: true
    code?: true
    symbole?: true
    tauxDEchange?: true
    agentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DeviseMaxAggregateInputType = {
    id?: true
    nom?: true
    code?: true
    symbole?: true
    tauxDEchange?: true
    agentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DeviseCountAggregateInputType = {
    id?: true
    nom?: true
    code?: true
    symbole?: true
    tauxDEchange?: true
    agentId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DeviseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Devise to aggregate.
     */
    where?: DeviseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Devises to fetch.
     */
    orderBy?: DeviseOrderByWithRelationInput | DeviseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeviseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Devises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Devises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Devises
    **/
    _count?: true | DeviseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeviseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeviseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeviseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeviseMaxAggregateInputType
  }

  export type GetDeviseAggregateType<T extends DeviseAggregateArgs> = {
        [P in keyof T & keyof AggregateDevise]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDevise[P]>
      : GetScalarType<T[P], AggregateDevise[P]>
  }




  export type DeviseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviseWhereInput
    orderBy?: DeviseOrderByWithAggregationInput | DeviseOrderByWithAggregationInput[]
    by: DeviseScalarFieldEnum[] | DeviseScalarFieldEnum
    having?: DeviseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeviseCountAggregateInputType | true
    _avg?: DeviseAvgAggregateInputType
    _sum?: DeviseSumAggregateInputType
    _min?: DeviseMinAggregateInputType
    _max?: DeviseMaxAggregateInputType
  }

  export type DeviseGroupByOutputType = {
    id: number
    nom: string
    code: string
    symbole: string
    tauxDEchange: number
    agentId: number
    createdAt: Date
    updatedAt: Date
    _count: DeviseCountAggregateOutputType | null
    _avg: DeviseAvgAggregateOutputType | null
    _sum: DeviseSumAggregateOutputType | null
    _min: DeviseMinAggregateOutputType | null
    _max: DeviseMaxAggregateOutputType | null
  }

  type GetDeviseGroupByPayload<T extends DeviseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeviseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeviseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeviseGroupByOutputType[P]>
            : GetScalarType<T[P], DeviseGroupByOutputType[P]>
        }
      >
    >


  export type DeviseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    code?: boolean
    symbole?: boolean
    tauxDEchange?: boolean
    agentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    produits?: boolean | Devise$produitsArgs<ExtArgs>
    paiements?: boolean | Devise$paiementsArgs<ExtArgs>
    caisses?: boolean | Devise$caissesArgs<ExtArgs>
    DetailPanier?: boolean | Devise$DetailPanierArgs<ExtArgs>
    _count?: boolean | DeviseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["devise"]>

  export type DeviseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    code?: boolean
    symbole?: boolean
    tauxDEchange?: boolean
    agentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["devise"]>

  export type DeviseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    code?: boolean
    symbole?: boolean
    tauxDEchange?: boolean
    agentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["devise"]>

  export type DeviseSelectScalar = {
    id?: boolean
    nom?: boolean
    code?: boolean
    symbole?: boolean
    tauxDEchange?: boolean
    agentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DeviseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nom" | "code" | "symbole" | "tauxDEchange" | "agentId" | "createdAt" | "updatedAt", ExtArgs["result"]["devise"]>
  export type DeviseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    produits?: boolean | Devise$produitsArgs<ExtArgs>
    paiements?: boolean | Devise$paiementsArgs<ExtArgs>
    caisses?: boolean | Devise$caissesArgs<ExtArgs>
    DetailPanier?: boolean | Devise$DetailPanierArgs<ExtArgs>
    _count?: boolean | DeviseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DeviseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }
  export type DeviseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }

  export type $DevisePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Devise"
    objects: {
      agent: Prisma.$AgentPayload<ExtArgs>
      produits: Prisma.$ProduitPayload<ExtArgs>[]
      paiements: Prisma.$PaiementPayload<ExtArgs>[]
      caisses: Prisma.$CaissePayload<ExtArgs>[]
      DetailPanier: Prisma.$DetailPanierPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nom: string
      code: string
      symbole: string
      tauxDEchange: number
      agentId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["devise"]>
    composites: {}
  }

  type DeviseGetPayload<S extends boolean | null | undefined | DeviseDefaultArgs> = $Result.GetResult<Prisma.$DevisePayload, S>

  type DeviseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeviseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeviseCountAggregateInputType | true
    }

  export interface DeviseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Devise'], meta: { name: 'Devise' } }
    /**
     * Find zero or one Devise that matches the filter.
     * @param {DeviseFindUniqueArgs} args - Arguments to find a Devise
     * @example
     * // Get one Devise
     * const devise = await prisma.devise.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeviseFindUniqueArgs>(args: SelectSubset<T, DeviseFindUniqueArgs<ExtArgs>>): Prisma__DeviseClient<$Result.GetResult<Prisma.$DevisePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Devise that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeviseFindUniqueOrThrowArgs} args - Arguments to find a Devise
     * @example
     * // Get one Devise
     * const devise = await prisma.devise.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeviseFindUniqueOrThrowArgs>(args: SelectSubset<T, DeviseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeviseClient<$Result.GetResult<Prisma.$DevisePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Devise that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviseFindFirstArgs} args - Arguments to find a Devise
     * @example
     * // Get one Devise
     * const devise = await prisma.devise.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeviseFindFirstArgs>(args?: SelectSubset<T, DeviseFindFirstArgs<ExtArgs>>): Prisma__DeviseClient<$Result.GetResult<Prisma.$DevisePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Devise that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviseFindFirstOrThrowArgs} args - Arguments to find a Devise
     * @example
     * // Get one Devise
     * const devise = await prisma.devise.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeviseFindFirstOrThrowArgs>(args?: SelectSubset<T, DeviseFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeviseClient<$Result.GetResult<Prisma.$DevisePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Devises that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Devises
     * const devises = await prisma.devise.findMany()
     * 
     * // Get first 10 Devises
     * const devises = await prisma.devise.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deviseWithIdOnly = await prisma.devise.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeviseFindManyArgs>(args?: SelectSubset<T, DeviseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DevisePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Devise.
     * @param {DeviseCreateArgs} args - Arguments to create a Devise.
     * @example
     * // Create one Devise
     * const Devise = await prisma.devise.create({
     *   data: {
     *     // ... data to create a Devise
     *   }
     * })
     * 
     */
    create<T extends DeviseCreateArgs>(args: SelectSubset<T, DeviseCreateArgs<ExtArgs>>): Prisma__DeviseClient<$Result.GetResult<Prisma.$DevisePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Devises.
     * @param {DeviseCreateManyArgs} args - Arguments to create many Devises.
     * @example
     * // Create many Devises
     * const devise = await prisma.devise.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeviseCreateManyArgs>(args?: SelectSubset<T, DeviseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Devises and returns the data saved in the database.
     * @param {DeviseCreateManyAndReturnArgs} args - Arguments to create many Devises.
     * @example
     * // Create many Devises
     * const devise = await prisma.devise.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Devises and only return the `id`
     * const deviseWithIdOnly = await prisma.devise.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeviseCreateManyAndReturnArgs>(args?: SelectSubset<T, DeviseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DevisePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Devise.
     * @param {DeviseDeleteArgs} args - Arguments to delete one Devise.
     * @example
     * // Delete one Devise
     * const Devise = await prisma.devise.delete({
     *   where: {
     *     // ... filter to delete one Devise
     *   }
     * })
     * 
     */
    delete<T extends DeviseDeleteArgs>(args: SelectSubset<T, DeviseDeleteArgs<ExtArgs>>): Prisma__DeviseClient<$Result.GetResult<Prisma.$DevisePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Devise.
     * @param {DeviseUpdateArgs} args - Arguments to update one Devise.
     * @example
     * // Update one Devise
     * const devise = await prisma.devise.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeviseUpdateArgs>(args: SelectSubset<T, DeviseUpdateArgs<ExtArgs>>): Prisma__DeviseClient<$Result.GetResult<Prisma.$DevisePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Devises.
     * @param {DeviseDeleteManyArgs} args - Arguments to filter Devises to delete.
     * @example
     * // Delete a few Devises
     * const { count } = await prisma.devise.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeviseDeleteManyArgs>(args?: SelectSubset<T, DeviseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Devises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Devises
     * const devise = await prisma.devise.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeviseUpdateManyArgs>(args: SelectSubset<T, DeviseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Devises and returns the data updated in the database.
     * @param {DeviseUpdateManyAndReturnArgs} args - Arguments to update many Devises.
     * @example
     * // Update many Devises
     * const devise = await prisma.devise.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Devises and only return the `id`
     * const deviseWithIdOnly = await prisma.devise.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DeviseUpdateManyAndReturnArgs>(args: SelectSubset<T, DeviseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DevisePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Devise.
     * @param {DeviseUpsertArgs} args - Arguments to update or create a Devise.
     * @example
     * // Update or create a Devise
     * const devise = await prisma.devise.upsert({
     *   create: {
     *     // ... data to create a Devise
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Devise we want to update
     *   }
     * })
     */
    upsert<T extends DeviseUpsertArgs>(args: SelectSubset<T, DeviseUpsertArgs<ExtArgs>>): Prisma__DeviseClient<$Result.GetResult<Prisma.$DevisePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Devises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviseCountArgs} args - Arguments to filter Devises to count.
     * @example
     * // Count the number of Devises
     * const count = await prisma.devise.count({
     *   where: {
     *     // ... the filter for the Devises we want to count
     *   }
     * })
    **/
    count<T extends DeviseCountArgs>(
      args?: Subset<T, DeviseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeviseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Devise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeviseAggregateArgs>(args: Subset<T, DeviseAggregateArgs>): Prisma.PrismaPromise<GetDeviseAggregateType<T>>

    /**
     * Group by Devise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeviseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeviseGroupByArgs['orderBy'] }
        : { orderBy?: DeviseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeviseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeviseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Devise model
   */
  readonly fields: DeviseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Devise.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeviseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agent<T extends AgentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgentDefaultArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    produits<T extends Devise$produitsArgs<ExtArgs> = {}>(args?: Subset<T, Devise$produitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProduitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    paiements<T extends Devise$paiementsArgs<ExtArgs> = {}>(args?: Subset<T, Devise$paiementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaiementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    caisses<T extends Devise$caissesArgs<ExtArgs> = {}>(args?: Subset<T, Devise$caissesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CaissePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    DetailPanier<T extends Devise$DetailPanierArgs<ExtArgs> = {}>(args?: Subset<T, Devise$DetailPanierArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DetailPanierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Devise model
   */
  interface DeviseFieldRefs {
    readonly id: FieldRef<"Devise", 'Int'>
    readonly nom: FieldRef<"Devise", 'String'>
    readonly code: FieldRef<"Devise", 'String'>
    readonly symbole: FieldRef<"Devise", 'String'>
    readonly tauxDEchange: FieldRef<"Devise", 'Int'>
    readonly agentId: FieldRef<"Devise", 'Int'>
    readonly createdAt: FieldRef<"Devise", 'DateTime'>
    readonly updatedAt: FieldRef<"Devise", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Devise findUnique
   */
  export type DeviseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Devise
     */
    select?: DeviseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Devise
     */
    omit?: DeviseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviseInclude<ExtArgs> | null
    /**
     * Filter, which Devise to fetch.
     */
    where: DeviseWhereUniqueInput
  }

  /**
   * Devise findUniqueOrThrow
   */
  export type DeviseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Devise
     */
    select?: DeviseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Devise
     */
    omit?: DeviseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviseInclude<ExtArgs> | null
    /**
     * Filter, which Devise to fetch.
     */
    where: DeviseWhereUniqueInput
  }

  /**
   * Devise findFirst
   */
  export type DeviseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Devise
     */
    select?: DeviseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Devise
     */
    omit?: DeviseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviseInclude<ExtArgs> | null
    /**
     * Filter, which Devise to fetch.
     */
    where?: DeviseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Devises to fetch.
     */
    orderBy?: DeviseOrderByWithRelationInput | DeviseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Devises.
     */
    cursor?: DeviseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Devises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Devises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Devises.
     */
    distinct?: DeviseScalarFieldEnum | DeviseScalarFieldEnum[]
  }

  /**
   * Devise findFirstOrThrow
   */
  export type DeviseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Devise
     */
    select?: DeviseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Devise
     */
    omit?: DeviseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviseInclude<ExtArgs> | null
    /**
     * Filter, which Devise to fetch.
     */
    where?: DeviseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Devises to fetch.
     */
    orderBy?: DeviseOrderByWithRelationInput | DeviseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Devises.
     */
    cursor?: DeviseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Devises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Devises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Devises.
     */
    distinct?: DeviseScalarFieldEnum | DeviseScalarFieldEnum[]
  }

  /**
   * Devise findMany
   */
  export type DeviseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Devise
     */
    select?: DeviseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Devise
     */
    omit?: DeviseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviseInclude<ExtArgs> | null
    /**
     * Filter, which Devises to fetch.
     */
    where?: DeviseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Devises to fetch.
     */
    orderBy?: DeviseOrderByWithRelationInput | DeviseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Devises.
     */
    cursor?: DeviseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Devises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Devises.
     */
    skip?: number
    distinct?: DeviseScalarFieldEnum | DeviseScalarFieldEnum[]
  }

  /**
   * Devise create
   */
  export type DeviseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Devise
     */
    select?: DeviseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Devise
     */
    omit?: DeviseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviseInclude<ExtArgs> | null
    /**
     * The data needed to create a Devise.
     */
    data: XOR<DeviseCreateInput, DeviseUncheckedCreateInput>
  }

  /**
   * Devise createMany
   */
  export type DeviseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Devises.
     */
    data: DeviseCreateManyInput | DeviseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Devise createManyAndReturn
   */
  export type DeviseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Devise
     */
    select?: DeviseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Devise
     */
    omit?: DeviseOmit<ExtArgs> | null
    /**
     * The data used to create many Devises.
     */
    data: DeviseCreateManyInput | DeviseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Devise update
   */
  export type DeviseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Devise
     */
    select?: DeviseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Devise
     */
    omit?: DeviseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviseInclude<ExtArgs> | null
    /**
     * The data needed to update a Devise.
     */
    data: XOR<DeviseUpdateInput, DeviseUncheckedUpdateInput>
    /**
     * Choose, which Devise to update.
     */
    where: DeviseWhereUniqueInput
  }

  /**
   * Devise updateMany
   */
  export type DeviseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Devises.
     */
    data: XOR<DeviseUpdateManyMutationInput, DeviseUncheckedUpdateManyInput>
    /**
     * Filter which Devises to update
     */
    where?: DeviseWhereInput
    /**
     * Limit how many Devises to update.
     */
    limit?: number
  }

  /**
   * Devise updateManyAndReturn
   */
  export type DeviseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Devise
     */
    select?: DeviseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Devise
     */
    omit?: DeviseOmit<ExtArgs> | null
    /**
     * The data used to update Devises.
     */
    data: XOR<DeviseUpdateManyMutationInput, DeviseUncheckedUpdateManyInput>
    /**
     * Filter which Devises to update
     */
    where?: DeviseWhereInput
    /**
     * Limit how many Devises to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Devise upsert
   */
  export type DeviseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Devise
     */
    select?: DeviseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Devise
     */
    omit?: DeviseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviseInclude<ExtArgs> | null
    /**
     * The filter to search for the Devise to update in case it exists.
     */
    where: DeviseWhereUniqueInput
    /**
     * In case the Devise found by the `where` argument doesn't exist, create a new Devise with this data.
     */
    create: XOR<DeviseCreateInput, DeviseUncheckedCreateInput>
    /**
     * In case the Devise was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeviseUpdateInput, DeviseUncheckedUpdateInput>
  }

  /**
   * Devise delete
   */
  export type DeviseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Devise
     */
    select?: DeviseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Devise
     */
    omit?: DeviseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviseInclude<ExtArgs> | null
    /**
     * Filter which Devise to delete.
     */
    where: DeviseWhereUniqueInput
  }

  /**
   * Devise deleteMany
   */
  export type DeviseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Devises to delete
     */
    where?: DeviseWhereInput
    /**
     * Limit how many Devises to delete.
     */
    limit?: number
  }

  /**
   * Devise.produits
   */
  export type Devise$produitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Produit
     */
    select?: ProduitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Produit
     */
    omit?: ProduitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProduitInclude<ExtArgs> | null
    where?: ProduitWhereInput
    orderBy?: ProduitOrderByWithRelationInput | ProduitOrderByWithRelationInput[]
    cursor?: ProduitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProduitScalarFieldEnum | ProduitScalarFieldEnum[]
  }

  /**
   * Devise.paiements
   */
  export type Devise$paiementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paiement
     */
    select?: PaiementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Paiement
     */
    omit?: PaiementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaiementInclude<ExtArgs> | null
    where?: PaiementWhereInput
    orderBy?: PaiementOrderByWithRelationInput | PaiementOrderByWithRelationInput[]
    cursor?: PaiementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaiementScalarFieldEnum | PaiementScalarFieldEnum[]
  }

  /**
   * Devise.caisses
   */
  export type Devise$caissesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Caisse
     */
    select?: CaisseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Caisse
     */
    omit?: CaisseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaisseInclude<ExtArgs> | null
    where?: CaisseWhereInput
    orderBy?: CaisseOrderByWithRelationInput | CaisseOrderByWithRelationInput[]
    cursor?: CaisseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CaisseScalarFieldEnum | CaisseScalarFieldEnum[]
  }

  /**
   * Devise.DetailPanier
   */
  export type Devise$DetailPanierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetailPanier
     */
    select?: DetailPanierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DetailPanier
     */
    omit?: DetailPanierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetailPanierInclude<ExtArgs> | null
    where?: DetailPanierWhereInput
    orderBy?: DetailPanierOrderByWithRelationInput | DetailPanierOrderByWithRelationInput[]
    cursor?: DetailPanierWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DetailPanierScalarFieldEnum | DetailPanierScalarFieldEnum[]
  }

  /**
   * Devise without action
   */
  export type DeviseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Devise
     */
    select?: DeviseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Devise
     */
    omit?: DeviseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviseInclude<ExtArgs> | null
  }


  /**
   * Model Entreprise
   */

  export type AggregateEntreprise = {
    _count: EntrepriseCountAggregateOutputType | null
    _avg: EntrepriseAvgAggregateOutputType | null
    _sum: EntrepriseSumAggregateOutputType | null
    _min: EntrepriseMinAggregateOutputType | null
    _max: EntrepriseMaxAggregateOutputType | null
  }

  export type EntrepriseAvgAggregateOutputType = {
    id: number | null
  }

  export type EntrepriseSumAggregateOutputType = {
    id: number | null
  }

  export type EntrepriseMinAggregateOutputType = {
    id: number | null
    nom: string | null
    email: string | null
    encronyme: string | null
    codePostale: string | null
    site: string | null
    description: string | null
    logo: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EntrepriseMaxAggregateOutputType = {
    id: number | null
    nom: string | null
    email: string | null
    encronyme: string | null
    codePostale: string | null
    site: string | null
    description: string | null
    logo: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EntrepriseCountAggregateOutputType = {
    id: number
    nom: number
    email: number
    encronyme: number
    codePostale: number
    site: number
    description: number
    logo: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EntrepriseAvgAggregateInputType = {
    id?: true
  }

  export type EntrepriseSumAggregateInputType = {
    id?: true
  }

  export type EntrepriseMinAggregateInputType = {
    id?: true
    nom?: true
    email?: true
    encronyme?: true
    codePostale?: true
    site?: true
    description?: true
    logo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EntrepriseMaxAggregateInputType = {
    id?: true
    nom?: true
    email?: true
    encronyme?: true
    codePostale?: true
    site?: true
    description?: true
    logo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EntrepriseCountAggregateInputType = {
    id?: true
    nom?: true
    email?: true
    encronyme?: true
    codePostale?: true
    site?: true
    description?: true
    logo?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EntrepriseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Entreprise to aggregate.
     */
    where?: EntrepriseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Entreprises to fetch.
     */
    orderBy?: EntrepriseOrderByWithRelationInput | EntrepriseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EntrepriseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Entreprises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Entreprises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Entreprises
    **/
    _count?: true | EntrepriseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EntrepriseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EntrepriseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EntrepriseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EntrepriseMaxAggregateInputType
  }

  export type GetEntrepriseAggregateType<T extends EntrepriseAggregateArgs> = {
        [P in keyof T & keyof AggregateEntreprise]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEntreprise[P]>
      : GetScalarType<T[P], AggregateEntreprise[P]>
  }




  export type EntrepriseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EntrepriseWhereInput
    orderBy?: EntrepriseOrderByWithAggregationInput | EntrepriseOrderByWithAggregationInput[]
    by: EntrepriseScalarFieldEnum[] | EntrepriseScalarFieldEnum
    having?: EntrepriseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EntrepriseCountAggregateInputType | true
    _avg?: EntrepriseAvgAggregateInputType
    _sum?: EntrepriseSumAggregateInputType
    _min?: EntrepriseMinAggregateInputType
    _max?: EntrepriseMaxAggregateInputType
  }

  export type EntrepriseGroupByOutputType = {
    id: number
    nom: string
    email: string
    encronyme: string
    codePostale: string
    site: string | null
    description: string | null
    logo: string | null
    createdAt: Date
    updatedAt: Date
    _count: EntrepriseCountAggregateOutputType | null
    _avg: EntrepriseAvgAggregateOutputType | null
    _sum: EntrepriseSumAggregateOutputType | null
    _min: EntrepriseMinAggregateOutputType | null
    _max: EntrepriseMaxAggregateOutputType | null
  }

  type GetEntrepriseGroupByPayload<T extends EntrepriseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EntrepriseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EntrepriseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EntrepriseGroupByOutputType[P]>
            : GetScalarType<T[P], EntrepriseGroupByOutputType[P]>
        }
      >
    >


  export type EntrepriseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    email?: boolean
    encronyme?: boolean
    codePostale?: boolean
    site?: boolean
    description?: boolean
    logo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clotureCaisses?: boolean | Entreprise$clotureCaissesArgs<ExtArgs>
    Adresse?: boolean | Entreprise$AdresseArgs<ExtArgs>
    Contact?: boolean | Entreprise$ContactArgs<ExtArgs>
    _count?: boolean | EntrepriseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["entreprise"]>

  export type EntrepriseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    email?: boolean
    encronyme?: boolean
    codePostale?: boolean
    site?: boolean
    description?: boolean
    logo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["entreprise"]>

  export type EntrepriseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    email?: boolean
    encronyme?: boolean
    codePostale?: boolean
    site?: boolean
    description?: boolean
    logo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["entreprise"]>

  export type EntrepriseSelectScalar = {
    id?: boolean
    nom?: boolean
    email?: boolean
    encronyme?: boolean
    codePostale?: boolean
    site?: boolean
    description?: boolean
    logo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EntrepriseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nom" | "email" | "encronyme" | "codePostale" | "site" | "description" | "logo" | "createdAt" | "updatedAt", ExtArgs["result"]["entreprise"]>
  export type EntrepriseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clotureCaisses?: boolean | Entreprise$clotureCaissesArgs<ExtArgs>
    Adresse?: boolean | Entreprise$AdresseArgs<ExtArgs>
    Contact?: boolean | Entreprise$ContactArgs<ExtArgs>
    _count?: boolean | EntrepriseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EntrepriseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type EntrepriseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $EntreprisePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Entreprise"
    objects: {
      clotureCaisses: Prisma.$ClotureCaissePayload<ExtArgs>[]
      Adresse: Prisma.$AdressePayload<ExtArgs>[]
      Contact: Prisma.$ContactPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nom: string
      email: string
      encronyme: string
      codePostale: string
      site: string | null
      description: string | null
      logo: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["entreprise"]>
    composites: {}
  }

  type EntrepriseGetPayload<S extends boolean | null | undefined | EntrepriseDefaultArgs> = $Result.GetResult<Prisma.$EntreprisePayload, S>

  type EntrepriseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EntrepriseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EntrepriseCountAggregateInputType | true
    }

  export interface EntrepriseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Entreprise'], meta: { name: 'Entreprise' } }
    /**
     * Find zero or one Entreprise that matches the filter.
     * @param {EntrepriseFindUniqueArgs} args - Arguments to find a Entreprise
     * @example
     * // Get one Entreprise
     * const entreprise = await prisma.entreprise.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EntrepriseFindUniqueArgs>(args: SelectSubset<T, EntrepriseFindUniqueArgs<ExtArgs>>): Prisma__EntrepriseClient<$Result.GetResult<Prisma.$EntreprisePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Entreprise that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EntrepriseFindUniqueOrThrowArgs} args - Arguments to find a Entreprise
     * @example
     * // Get one Entreprise
     * const entreprise = await prisma.entreprise.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EntrepriseFindUniqueOrThrowArgs>(args: SelectSubset<T, EntrepriseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EntrepriseClient<$Result.GetResult<Prisma.$EntreprisePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Entreprise that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntrepriseFindFirstArgs} args - Arguments to find a Entreprise
     * @example
     * // Get one Entreprise
     * const entreprise = await prisma.entreprise.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EntrepriseFindFirstArgs>(args?: SelectSubset<T, EntrepriseFindFirstArgs<ExtArgs>>): Prisma__EntrepriseClient<$Result.GetResult<Prisma.$EntreprisePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Entreprise that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntrepriseFindFirstOrThrowArgs} args - Arguments to find a Entreprise
     * @example
     * // Get one Entreprise
     * const entreprise = await prisma.entreprise.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EntrepriseFindFirstOrThrowArgs>(args?: SelectSubset<T, EntrepriseFindFirstOrThrowArgs<ExtArgs>>): Prisma__EntrepriseClient<$Result.GetResult<Prisma.$EntreprisePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Entreprises that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntrepriseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Entreprises
     * const entreprises = await prisma.entreprise.findMany()
     * 
     * // Get first 10 Entreprises
     * const entreprises = await prisma.entreprise.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const entrepriseWithIdOnly = await prisma.entreprise.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EntrepriseFindManyArgs>(args?: SelectSubset<T, EntrepriseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EntreprisePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Entreprise.
     * @param {EntrepriseCreateArgs} args - Arguments to create a Entreprise.
     * @example
     * // Create one Entreprise
     * const Entreprise = await prisma.entreprise.create({
     *   data: {
     *     // ... data to create a Entreprise
     *   }
     * })
     * 
     */
    create<T extends EntrepriseCreateArgs>(args: SelectSubset<T, EntrepriseCreateArgs<ExtArgs>>): Prisma__EntrepriseClient<$Result.GetResult<Prisma.$EntreprisePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Entreprises.
     * @param {EntrepriseCreateManyArgs} args - Arguments to create many Entreprises.
     * @example
     * // Create many Entreprises
     * const entreprise = await prisma.entreprise.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EntrepriseCreateManyArgs>(args?: SelectSubset<T, EntrepriseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Entreprises and returns the data saved in the database.
     * @param {EntrepriseCreateManyAndReturnArgs} args - Arguments to create many Entreprises.
     * @example
     * // Create many Entreprises
     * const entreprise = await prisma.entreprise.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Entreprises and only return the `id`
     * const entrepriseWithIdOnly = await prisma.entreprise.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EntrepriseCreateManyAndReturnArgs>(args?: SelectSubset<T, EntrepriseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EntreprisePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Entreprise.
     * @param {EntrepriseDeleteArgs} args - Arguments to delete one Entreprise.
     * @example
     * // Delete one Entreprise
     * const Entreprise = await prisma.entreprise.delete({
     *   where: {
     *     // ... filter to delete one Entreprise
     *   }
     * })
     * 
     */
    delete<T extends EntrepriseDeleteArgs>(args: SelectSubset<T, EntrepriseDeleteArgs<ExtArgs>>): Prisma__EntrepriseClient<$Result.GetResult<Prisma.$EntreprisePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Entreprise.
     * @param {EntrepriseUpdateArgs} args - Arguments to update one Entreprise.
     * @example
     * // Update one Entreprise
     * const entreprise = await prisma.entreprise.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EntrepriseUpdateArgs>(args: SelectSubset<T, EntrepriseUpdateArgs<ExtArgs>>): Prisma__EntrepriseClient<$Result.GetResult<Prisma.$EntreprisePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Entreprises.
     * @param {EntrepriseDeleteManyArgs} args - Arguments to filter Entreprises to delete.
     * @example
     * // Delete a few Entreprises
     * const { count } = await prisma.entreprise.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EntrepriseDeleteManyArgs>(args?: SelectSubset<T, EntrepriseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Entreprises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntrepriseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Entreprises
     * const entreprise = await prisma.entreprise.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EntrepriseUpdateManyArgs>(args: SelectSubset<T, EntrepriseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Entreprises and returns the data updated in the database.
     * @param {EntrepriseUpdateManyAndReturnArgs} args - Arguments to update many Entreprises.
     * @example
     * // Update many Entreprises
     * const entreprise = await prisma.entreprise.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Entreprises and only return the `id`
     * const entrepriseWithIdOnly = await prisma.entreprise.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EntrepriseUpdateManyAndReturnArgs>(args: SelectSubset<T, EntrepriseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EntreprisePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Entreprise.
     * @param {EntrepriseUpsertArgs} args - Arguments to update or create a Entreprise.
     * @example
     * // Update or create a Entreprise
     * const entreprise = await prisma.entreprise.upsert({
     *   create: {
     *     // ... data to create a Entreprise
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Entreprise we want to update
     *   }
     * })
     */
    upsert<T extends EntrepriseUpsertArgs>(args: SelectSubset<T, EntrepriseUpsertArgs<ExtArgs>>): Prisma__EntrepriseClient<$Result.GetResult<Prisma.$EntreprisePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Entreprises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntrepriseCountArgs} args - Arguments to filter Entreprises to count.
     * @example
     * // Count the number of Entreprises
     * const count = await prisma.entreprise.count({
     *   where: {
     *     // ... the filter for the Entreprises we want to count
     *   }
     * })
    **/
    count<T extends EntrepriseCountArgs>(
      args?: Subset<T, EntrepriseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EntrepriseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Entreprise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntrepriseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EntrepriseAggregateArgs>(args: Subset<T, EntrepriseAggregateArgs>): Prisma.PrismaPromise<GetEntrepriseAggregateType<T>>

    /**
     * Group by Entreprise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntrepriseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EntrepriseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EntrepriseGroupByArgs['orderBy'] }
        : { orderBy?: EntrepriseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EntrepriseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEntrepriseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Entreprise model
   */
  readonly fields: EntrepriseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Entreprise.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EntrepriseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clotureCaisses<T extends Entreprise$clotureCaissesArgs<ExtArgs> = {}>(args?: Subset<T, Entreprise$clotureCaissesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClotureCaissePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Adresse<T extends Entreprise$AdresseArgs<ExtArgs> = {}>(args?: Subset<T, Entreprise$AdresseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdressePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Contact<T extends Entreprise$ContactArgs<ExtArgs> = {}>(args?: Subset<T, Entreprise$ContactArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Entreprise model
   */
  interface EntrepriseFieldRefs {
    readonly id: FieldRef<"Entreprise", 'Int'>
    readonly nom: FieldRef<"Entreprise", 'String'>
    readonly email: FieldRef<"Entreprise", 'String'>
    readonly encronyme: FieldRef<"Entreprise", 'String'>
    readonly codePostale: FieldRef<"Entreprise", 'String'>
    readonly site: FieldRef<"Entreprise", 'String'>
    readonly description: FieldRef<"Entreprise", 'String'>
    readonly logo: FieldRef<"Entreprise", 'String'>
    readonly createdAt: FieldRef<"Entreprise", 'DateTime'>
    readonly updatedAt: FieldRef<"Entreprise", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Entreprise findUnique
   */
  export type EntrepriseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entreprise
     */
    select?: EntrepriseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Entreprise
     */
    omit?: EntrepriseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntrepriseInclude<ExtArgs> | null
    /**
     * Filter, which Entreprise to fetch.
     */
    where: EntrepriseWhereUniqueInput
  }

  /**
   * Entreprise findUniqueOrThrow
   */
  export type EntrepriseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entreprise
     */
    select?: EntrepriseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Entreprise
     */
    omit?: EntrepriseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntrepriseInclude<ExtArgs> | null
    /**
     * Filter, which Entreprise to fetch.
     */
    where: EntrepriseWhereUniqueInput
  }

  /**
   * Entreprise findFirst
   */
  export type EntrepriseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entreprise
     */
    select?: EntrepriseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Entreprise
     */
    omit?: EntrepriseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntrepriseInclude<ExtArgs> | null
    /**
     * Filter, which Entreprise to fetch.
     */
    where?: EntrepriseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Entreprises to fetch.
     */
    orderBy?: EntrepriseOrderByWithRelationInput | EntrepriseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Entreprises.
     */
    cursor?: EntrepriseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Entreprises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Entreprises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Entreprises.
     */
    distinct?: EntrepriseScalarFieldEnum | EntrepriseScalarFieldEnum[]
  }

  /**
   * Entreprise findFirstOrThrow
   */
  export type EntrepriseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entreprise
     */
    select?: EntrepriseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Entreprise
     */
    omit?: EntrepriseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntrepriseInclude<ExtArgs> | null
    /**
     * Filter, which Entreprise to fetch.
     */
    where?: EntrepriseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Entreprises to fetch.
     */
    orderBy?: EntrepriseOrderByWithRelationInput | EntrepriseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Entreprises.
     */
    cursor?: EntrepriseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Entreprises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Entreprises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Entreprises.
     */
    distinct?: EntrepriseScalarFieldEnum | EntrepriseScalarFieldEnum[]
  }

  /**
   * Entreprise findMany
   */
  export type EntrepriseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entreprise
     */
    select?: EntrepriseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Entreprise
     */
    omit?: EntrepriseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntrepriseInclude<ExtArgs> | null
    /**
     * Filter, which Entreprises to fetch.
     */
    where?: EntrepriseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Entreprises to fetch.
     */
    orderBy?: EntrepriseOrderByWithRelationInput | EntrepriseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Entreprises.
     */
    cursor?: EntrepriseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Entreprises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Entreprises.
     */
    skip?: number
    distinct?: EntrepriseScalarFieldEnum | EntrepriseScalarFieldEnum[]
  }

  /**
   * Entreprise create
   */
  export type EntrepriseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entreprise
     */
    select?: EntrepriseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Entreprise
     */
    omit?: EntrepriseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntrepriseInclude<ExtArgs> | null
    /**
     * The data needed to create a Entreprise.
     */
    data: XOR<EntrepriseCreateInput, EntrepriseUncheckedCreateInput>
  }

  /**
   * Entreprise createMany
   */
  export type EntrepriseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Entreprises.
     */
    data: EntrepriseCreateManyInput | EntrepriseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Entreprise createManyAndReturn
   */
  export type EntrepriseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entreprise
     */
    select?: EntrepriseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Entreprise
     */
    omit?: EntrepriseOmit<ExtArgs> | null
    /**
     * The data used to create many Entreprises.
     */
    data: EntrepriseCreateManyInput | EntrepriseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Entreprise update
   */
  export type EntrepriseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entreprise
     */
    select?: EntrepriseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Entreprise
     */
    omit?: EntrepriseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntrepriseInclude<ExtArgs> | null
    /**
     * The data needed to update a Entreprise.
     */
    data: XOR<EntrepriseUpdateInput, EntrepriseUncheckedUpdateInput>
    /**
     * Choose, which Entreprise to update.
     */
    where: EntrepriseWhereUniqueInput
  }

  /**
   * Entreprise updateMany
   */
  export type EntrepriseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Entreprises.
     */
    data: XOR<EntrepriseUpdateManyMutationInput, EntrepriseUncheckedUpdateManyInput>
    /**
     * Filter which Entreprises to update
     */
    where?: EntrepriseWhereInput
    /**
     * Limit how many Entreprises to update.
     */
    limit?: number
  }

  /**
   * Entreprise updateManyAndReturn
   */
  export type EntrepriseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entreprise
     */
    select?: EntrepriseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Entreprise
     */
    omit?: EntrepriseOmit<ExtArgs> | null
    /**
     * The data used to update Entreprises.
     */
    data: XOR<EntrepriseUpdateManyMutationInput, EntrepriseUncheckedUpdateManyInput>
    /**
     * Filter which Entreprises to update
     */
    where?: EntrepriseWhereInput
    /**
     * Limit how many Entreprises to update.
     */
    limit?: number
  }

  /**
   * Entreprise upsert
   */
  export type EntrepriseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entreprise
     */
    select?: EntrepriseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Entreprise
     */
    omit?: EntrepriseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntrepriseInclude<ExtArgs> | null
    /**
     * The filter to search for the Entreprise to update in case it exists.
     */
    where: EntrepriseWhereUniqueInput
    /**
     * In case the Entreprise found by the `where` argument doesn't exist, create a new Entreprise with this data.
     */
    create: XOR<EntrepriseCreateInput, EntrepriseUncheckedCreateInput>
    /**
     * In case the Entreprise was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EntrepriseUpdateInput, EntrepriseUncheckedUpdateInput>
  }

  /**
   * Entreprise delete
   */
  export type EntrepriseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entreprise
     */
    select?: EntrepriseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Entreprise
     */
    omit?: EntrepriseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntrepriseInclude<ExtArgs> | null
    /**
     * Filter which Entreprise to delete.
     */
    where: EntrepriseWhereUniqueInput
  }

  /**
   * Entreprise deleteMany
   */
  export type EntrepriseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Entreprises to delete
     */
    where?: EntrepriseWhereInput
    /**
     * Limit how many Entreprises to delete.
     */
    limit?: number
  }

  /**
   * Entreprise.clotureCaisses
   */
  export type Entreprise$clotureCaissesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClotureCaisse
     */
    select?: ClotureCaisseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClotureCaisse
     */
    omit?: ClotureCaisseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClotureCaisseInclude<ExtArgs> | null
    where?: ClotureCaisseWhereInput
    orderBy?: ClotureCaisseOrderByWithRelationInput | ClotureCaisseOrderByWithRelationInput[]
    cursor?: ClotureCaisseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClotureCaisseScalarFieldEnum | ClotureCaisseScalarFieldEnum[]
  }

  /**
   * Entreprise.Adresse
   */
  export type Entreprise$AdresseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adresse
     */
    select?: AdresseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Adresse
     */
    omit?: AdresseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdresseInclude<ExtArgs> | null
    where?: AdresseWhereInput
    orderBy?: AdresseOrderByWithRelationInput | AdresseOrderByWithRelationInput[]
    cursor?: AdresseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdresseScalarFieldEnum | AdresseScalarFieldEnum[]
  }

  /**
   * Entreprise.Contact
   */
  export type Entreprise$ContactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    cursor?: ContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Entreprise without action
   */
  export type EntrepriseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entreprise
     */
    select?: EntrepriseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Entreprise
     */
    omit?: EntrepriseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntrepriseInclude<ExtArgs> | null
  }


  /**
   * Model Agent
   */

  export type AggregateAgent = {
    _count: AgentCountAggregateOutputType | null
    _avg: AgentAvgAggregateOutputType | null
    _sum: AgentSumAggregateOutputType | null
    _min: AgentMinAggregateOutputType | null
    _max: AgentMaxAggregateOutputType | null
  }

  export type AgentAvgAggregateOutputType = {
    id: number | null
  }

  export type AgentSumAggregateOutputType = {
    id: number | null
  }

  export type AgentMinAggregateOutputType = {
    id: number | null
    email: string | null
    nom: string | null
    postnom: string | null
    nom_complet: string | null
    sexe: $Enums.Sexe | null
    role: $Enums.Role | null
    poste: $Enums.Poste | null
    picture: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgentMaxAggregateOutputType = {
    id: number | null
    email: string | null
    nom: string | null
    postnom: string | null
    nom_complet: string | null
    sexe: $Enums.Sexe | null
    role: $Enums.Role | null
    poste: $Enums.Poste | null
    picture: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgentCountAggregateOutputType = {
    id: number
    email: number
    nom: number
    postnom: number
    nom_complet: number
    sexe: number
    role: number
    poste: number
    picture: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AgentAvgAggregateInputType = {
    id?: true
  }

  export type AgentSumAggregateInputType = {
    id?: true
  }

  export type AgentMinAggregateInputType = {
    id?: true
    email?: true
    nom?: true
    postnom?: true
    nom_complet?: true
    sexe?: true
    role?: true
    poste?: true
    picture?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgentMaxAggregateInputType = {
    id?: true
    email?: true
    nom?: true
    postnom?: true
    nom_complet?: true
    sexe?: true
    role?: true
    poste?: true
    picture?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgentCountAggregateInputType = {
    id?: true
    email?: true
    nom?: true
    postnom?: true
    nom_complet?: true
    sexe?: true
    role?: true
    poste?: true
    picture?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AgentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Agent to aggregate.
     */
    where?: AgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agents to fetch.
     */
    orderBy?: AgentOrderByWithRelationInput | AgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Agents
    **/
    _count?: true | AgentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AgentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AgentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgentMaxAggregateInputType
  }

  export type GetAgentAggregateType<T extends AgentAggregateArgs> = {
        [P in keyof T & keyof AggregateAgent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgent[P]>
      : GetScalarType<T[P], AggregateAgent[P]>
  }




  export type AgentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentWhereInput
    orderBy?: AgentOrderByWithAggregationInput | AgentOrderByWithAggregationInput[]
    by: AgentScalarFieldEnum[] | AgentScalarFieldEnum
    having?: AgentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgentCountAggregateInputType | true
    _avg?: AgentAvgAggregateInputType
    _sum?: AgentSumAggregateInputType
    _min?: AgentMinAggregateInputType
    _max?: AgentMaxAggregateInputType
  }

  export type AgentGroupByOutputType = {
    id: number
    email: string
    nom: string
    postnom: string | null
    nom_complet: string | null
    sexe: $Enums.Sexe | null
    role: $Enums.Role
    poste: $Enums.Poste | null
    picture: string | null
    createdAt: Date
    updatedAt: Date
    _count: AgentCountAggregateOutputType | null
    _avg: AgentAvgAggregateOutputType | null
    _sum: AgentSumAggregateOutputType | null
    _min: AgentMinAggregateOutputType | null
    _max: AgentMaxAggregateOutputType | null
  }

  type GetAgentGroupByPayload<T extends AgentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgentGroupByOutputType[P]>
            : GetScalarType<T[P], AgentGroupByOutputType[P]>
        }
      >
    >


  export type AgentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    nom?: boolean
    postnom?: boolean
    nom_complet?: boolean
    sexe?: boolean
    role?: boolean
    poste?: boolean
    picture?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    adresses?: boolean | Agent$adressesArgs<ExtArgs>
    contacts?: boolean | Agent$contactsArgs<ExtArgs>
    produits?: boolean | Agent$produitsArgs<ExtArgs>
    ventes?: boolean | Agent$ventesArgs<ExtArgs>
    achats?: boolean | Agent$achatsArgs<ExtArgs>
    teneurs?: boolean | Agent$teneursArgs<ExtArgs>
    devises?: boolean | Agent$devisesArgs<ExtArgs>
    paniers?: boolean | Agent$paniersArgs<ExtArgs>
    caisses?: boolean | Agent$caissesArgs<ExtArgs>
    mouvementCaisses?: boolean | Agent$mouvementCaissesArgs<ExtArgs>
    clotureCaisses?: boolean | Agent$clotureCaissesArgs<ExtArgs>
    Fournisseur?: boolean | Agent$FournisseurArgs<ExtArgs>
    _count?: boolean | AgentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agent"]>

  export type AgentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    nom?: boolean
    postnom?: boolean
    nom_complet?: boolean
    sexe?: boolean
    role?: boolean
    poste?: boolean
    picture?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["agent"]>

  export type AgentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    nom?: boolean
    postnom?: boolean
    nom_complet?: boolean
    sexe?: boolean
    role?: boolean
    poste?: boolean
    picture?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["agent"]>

  export type AgentSelectScalar = {
    id?: boolean
    email?: boolean
    nom?: boolean
    postnom?: boolean
    nom_complet?: boolean
    sexe?: boolean
    role?: boolean
    poste?: boolean
    picture?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AgentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "nom" | "postnom" | "nom_complet" | "sexe" | "role" | "poste" | "picture" | "createdAt" | "updatedAt", ExtArgs["result"]["agent"]>
  export type AgentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    adresses?: boolean | Agent$adressesArgs<ExtArgs>
    contacts?: boolean | Agent$contactsArgs<ExtArgs>
    produits?: boolean | Agent$produitsArgs<ExtArgs>
    ventes?: boolean | Agent$ventesArgs<ExtArgs>
    achats?: boolean | Agent$achatsArgs<ExtArgs>
    teneurs?: boolean | Agent$teneursArgs<ExtArgs>
    devises?: boolean | Agent$devisesArgs<ExtArgs>
    paniers?: boolean | Agent$paniersArgs<ExtArgs>
    caisses?: boolean | Agent$caissesArgs<ExtArgs>
    mouvementCaisses?: boolean | Agent$mouvementCaissesArgs<ExtArgs>
    clotureCaisses?: boolean | Agent$clotureCaissesArgs<ExtArgs>
    Fournisseur?: boolean | Agent$FournisseurArgs<ExtArgs>
    _count?: boolean | AgentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AgentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AgentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AgentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Agent"
    objects: {
      adresses: Prisma.$AdressePayload<ExtArgs>[]
      contacts: Prisma.$ContactPayload<ExtArgs>[]
      produits: Prisma.$ProduitPayload<ExtArgs>[]
      ventes: Prisma.$VentePayload<ExtArgs>[]
      achats: Prisma.$AchatPayload<ExtArgs>[]
      teneurs: Prisma.$TeneurPayload<ExtArgs>[]
      devises: Prisma.$DevisePayload<ExtArgs>[]
      paniers: Prisma.$PanierPayload<ExtArgs>[]
      caisses: Prisma.$CaissePayload<ExtArgs>[]
      mouvementCaisses: Prisma.$MouvementCaissePayload<ExtArgs>[]
      clotureCaisses: Prisma.$ClotureCaissePayload<ExtArgs>[]
      Fournisseur: Prisma.$FournisseurPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      nom: string
      postnom: string | null
      nom_complet: string | null
      sexe: $Enums.Sexe | null
      role: $Enums.Role
      poste: $Enums.Poste | null
      picture: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["agent"]>
    composites: {}
  }

  type AgentGetPayload<S extends boolean | null | undefined | AgentDefaultArgs> = $Result.GetResult<Prisma.$AgentPayload, S>

  type AgentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AgentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AgentCountAggregateInputType | true
    }

  export interface AgentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Agent'], meta: { name: 'Agent' } }
    /**
     * Find zero or one Agent that matches the filter.
     * @param {AgentFindUniqueArgs} args - Arguments to find a Agent
     * @example
     * // Get one Agent
     * const agent = await prisma.agent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgentFindUniqueArgs>(args: SelectSubset<T, AgentFindUniqueArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Agent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AgentFindUniqueOrThrowArgs} args - Arguments to find a Agent
     * @example
     * // Get one Agent
     * const agent = await prisma.agent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgentFindUniqueOrThrowArgs>(args: SelectSubset<T, AgentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Agent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentFindFirstArgs} args - Arguments to find a Agent
     * @example
     * // Get one Agent
     * const agent = await prisma.agent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgentFindFirstArgs>(args?: SelectSubset<T, AgentFindFirstArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Agent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentFindFirstOrThrowArgs} args - Arguments to find a Agent
     * @example
     * // Get one Agent
     * const agent = await prisma.agent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgentFindFirstOrThrowArgs>(args?: SelectSubset<T, AgentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Agents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Agents
     * const agents = await prisma.agent.findMany()
     * 
     * // Get first 10 Agents
     * const agents = await prisma.agent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agentWithIdOnly = await prisma.agent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgentFindManyArgs>(args?: SelectSubset<T, AgentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Agent.
     * @param {AgentCreateArgs} args - Arguments to create a Agent.
     * @example
     * // Create one Agent
     * const Agent = await prisma.agent.create({
     *   data: {
     *     // ... data to create a Agent
     *   }
     * })
     * 
     */
    create<T extends AgentCreateArgs>(args: SelectSubset<T, AgentCreateArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Agents.
     * @param {AgentCreateManyArgs} args - Arguments to create many Agents.
     * @example
     * // Create many Agents
     * const agent = await prisma.agent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgentCreateManyArgs>(args?: SelectSubset<T, AgentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Agents and returns the data saved in the database.
     * @param {AgentCreateManyAndReturnArgs} args - Arguments to create many Agents.
     * @example
     * // Create many Agents
     * const agent = await prisma.agent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Agents and only return the `id`
     * const agentWithIdOnly = await prisma.agent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AgentCreateManyAndReturnArgs>(args?: SelectSubset<T, AgentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Agent.
     * @param {AgentDeleteArgs} args - Arguments to delete one Agent.
     * @example
     * // Delete one Agent
     * const Agent = await prisma.agent.delete({
     *   where: {
     *     // ... filter to delete one Agent
     *   }
     * })
     * 
     */
    delete<T extends AgentDeleteArgs>(args: SelectSubset<T, AgentDeleteArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Agent.
     * @param {AgentUpdateArgs} args - Arguments to update one Agent.
     * @example
     * // Update one Agent
     * const agent = await prisma.agent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgentUpdateArgs>(args: SelectSubset<T, AgentUpdateArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Agents.
     * @param {AgentDeleteManyArgs} args - Arguments to filter Agents to delete.
     * @example
     * // Delete a few Agents
     * const { count } = await prisma.agent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgentDeleteManyArgs>(args?: SelectSubset<T, AgentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Agents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Agents
     * const agent = await prisma.agent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgentUpdateManyArgs>(args: SelectSubset<T, AgentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Agents and returns the data updated in the database.
     * @param {AgentUpdateManyAndReturnArgs} args - Arguments to update many Agents.
     * @example
     * // Update many Agents
     * const agent = await prisma.agent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Agents and only return the `id`
     * const agentWithIdOnly = await prisma.agent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AgentUpdateManyAndReturnArgs>(args: SelectSubset<T, AgentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Agent.
     * @param {AgentUpsertArgs} args - Arguments to update or create a Agent.
     * @example
     * // Update or create a Agent
     * const agent = await prisma.agent.upsert({
     *   create: {
     *     // ... data to create a Agent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Agent we want to update
     *   }
     * })
     */
    upsert<T extends AgentUpsertArgs>(args: SelectSubset<T, AgentUpsertArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Agents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentCountArgs} args - Arguments to filter Agents to count.
     * @example
     * // Count the number of Agents
     * const count = await prisma.agent.count({
     *   where: {
     *     // ... the filter for the Agents we want to count
     *   }
     * })
    **/
    count<T extends AgentCountArgs>(
      args?: Subset<T, AgentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Agent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgentAggregateArgs>(args: Subset<T, AgentAggregateArgs>): Prisma.PrismaPromise<GetAgentAggregateType<T>>

    /**
     * Group by Agent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgentGroupByArgs['orderBy'] }
        : { orderBy?: AgentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Agent model
   */
  readonly fields: AgentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Agent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    adresses<T extends Agent$adressesArgs<ExtArgs> = {}>(args?: Subset<T, Agent$adressesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdressePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    contacts<T extends Agent$contactsArgs<ExtArgs> = {}>(args?: Subset<T, Agent$contactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    produits<T extends Agent$produitsArgs<ExtArgs> = {}>(args?: Subset<T, Agent$produitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProduitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ventes<T extends Agent$ventesArgs<ExtArgs> = {}>(args?: Subset<T, Agent$ventesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VentePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    achats<T extends Agent$achatsArgs<ExtArgs> = {}>(args?: Subset<T, Agent$achatsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    teneurs<T extends Agent$teneursArgs<ExtArgs> = {}>(args?: Subset<T, Agent$teneursArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeneurPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    devises<T extends Agent$devisesArgs<ExtArgs> = {}>(args?: Subset<T, Agent$devisesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DevisePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    paniers<T extends Agent$paniersArgs<ExtArgs> = {}>(args?: Subset<T, Agent$paniersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PanierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    caisses<T extends Agent$caissesArgs<ExtArgs> = {}>(args?: Subset<T, Agent$caissesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CaissePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    mouvementCaisses<T extends Agent$mouvementCaissesArgs<ExtArgs> = {}>(args?: Subset<T, Agent$mouvementCaissesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MouvementCaissePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    clotureCaisses<T extends Agent$clotureCaissesArgs<ExtArgs> = {}>(args?: Subset<T, Agent$clotureCaissesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClotureCaissePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Fournisseur<T extends Agent$FournisseurArgs<ExtArgs> = {}>(args?: Subset<T, Agent$FournisseurArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FournisseurPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Agent model
   */
  interface AgentFieldRefs {
    readonly id: FieldRef<"Agent", 'Int'>
    readonly email: FieldRef<"Agent", 'String'>
    readonly nom: FieldRef<"Agent", 'String'>
    readonly postnom: FieldRef<"Agent", 'String'>
    readonly nom_complet: FieldRef<"Agent", 'String'>
    readonly sexe: FieldRef<"Agent", 'Sexe'>
    readonly role: FieldRef<"Agent", 'Role'>
    readonly poste: FieldRef<"Agent", 'Poste'>
    readonly picture: FieldRef<"Agent", 'String'>
    readonly createdAt: FieldRef<"Agent", 'DateTime'>
    readonly updatedAt: FieldRef<"Agent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Agent findUnique
   */
  export type AgentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter, which Agent to fetch.
     */
    where: AgentWhereUniqueInput
  }

  /**
   * Agent findUniqueOrThrow
   */
  export type AgentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter, which Agent to fetch.
     */
    where: AgentWhereUniqueInput
  }

  /**
   * Agent findFirst
   */
  export type AgentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter, which Agent to fetch.
     */
    where?: AgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agents to fetch.
     */
    orderBy?: AgentOrderByWithRelationInput | AgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Agents.
     */
    cursor?: AgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Agents.
     */
    distinct?: AgentScalarFieldEnum | AgentScalarFieldEnum[]
  }

  /**
   * Agent findFirstOrThrow
   */
  export type AgentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter, which Agent to fetch.
     */
    where?: AgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agents to fetch.
     */
    orderBy?: AgentOrderByWithRelationInput | AgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Agents.
     */
    cursor?: AgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Agents.
     */
    distinct?: AgentScalarFieldEnum | AgentScalarFieldEnum[]
  }

  /**
   * Agent findMany
   */
  export type AgentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter, which Agents to fetch.
     */
    where?: AgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agents to fetch.
     */
    orderBy?: AgentOrderByWithRelationInput | AgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Agents.
     */
    cursor?: AgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agents.
     */
    skip?: number
    distinct?: AgentScalarFieldEnum | AgentScalarFieldEnum[]
  }

  /**
   * Agent create
   */
  export type AgentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * The data needed to create a Agent.
     */
    data: XOR<AgentCreateInput, AgentUncheckedCreateInput>
  }

  /**
   * Agent createMany
   */
  export type AgentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Agents.
     */
    data: AgentCreateManyInput | AgentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Agent createManyAndReturn
   */
  export type AgentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * The data used to create many Agents.
     */
    data: AgentCreateManyInput | AgentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Agent update
   */
  export type AgentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * The data needed to update a Agent.
     */
    data: XOR<AgentUpdateInput, AgentUncheckedUpdateInput>
    /**
     * Choose, which Agent to update.
     */
    where: AgentWhereUniqueInput
  }

  /**
   * Agent updateMany
   */
  export type AgentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Agents.
     */
    data: XOR<AgentUpdateManyMutationInput, AgentUncheckedUpdateManyInput>
    /**
     * Filter which Agents to update
     */
    where?: AgentWhereInput
    /**
     * Limit how many Agents to update.
     */
    limit?: number
  }

  /**
   * Agent updateManyAndReturn
   */
  export type AgentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * The data used to update Agents.
     */
    data: XOR<AgentUpdateManyMutationInput, AgentUncheckedUpdateManyInput>
    /**
     * Filter which Agents to update
     */
    where?: AgentWhereInput
    /**
     * Limit how many Agents to update.
     */
    limit?: number
  }

  /**
   * Agent upsert
   */
  export type AgentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * The filter to search for the Agent to update in case it exists.
     */
    where: AgentWhereUniqueInput
    /**
     * In case the Agent found by the `where` argument doesn't exist, create a new Agent with this data.
     */
    create: XOR<AgentCreateInput, AgentUncheckedCreateInput>
    /**
     * In case the Agent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgentUpdateInput, AgentUncheckedUpdateInput>
  }

  /**
   * Agent delete
   */
  export type AgentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter which Agent to delete.
     */
    where: AgentWhereUniqueInput
  }

  /**
   * Agent deleteMany
   */
  export type AgentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Agents to delete
     */
    where?: AgentWhereInput
    /**
     * Limit how many Agents to delete.
     */
    limit?: number
  }

  /**
   * Agent.adresses
   */
  export type Agent$adressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adresse
     */
    select?: AdresseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Adresse
     */
    omit?: AdresseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdresseInclude<ExtArgs> | null
    where?: AdresseWhereInput
    orderBy?: AdresseOrderByWithRelationInput | AdresseOrderByWithRelationInput[]
    cursor?: AdresseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdresseScalarFieldEnum | AdresseScalarFieldEnum[]
  }

  /**
   * Agent.contacts
   */
  export type Agent$contactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    cursor?: ContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Agent.produits
   */
  export type Agent$produitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Produit
     */
    select?: ProduitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Produit
     */
    omit?: ProduitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProduitInclude<ExtArgs> | null
    where?: ProduitWhereInput
    orderBy?: ProduitOrderByWithRelationInput | ProduitOrderByWithRelationInput[]
    cursor?: ProduitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProduitScalarFieldEnum | ProduitScalarFieldEnum[]
  }

  /**
   * Agent.ventes
   */
  export type Agent$ventesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vente
     */
    select?: VenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vente
     */
    omit?: VenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenteInclude<ExtArgs> | null
    where?: VenteWhereInput
    orderBy?: VenteOrderByWithRelationInput | VenteOrderByWithRelationInput[]
    cursor?: VenteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VenteScalarFieldEnum | VenteScalarFieldEnum[]
  }

  /**
   * Agent.achats
   */
  export type Agent$achatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achat
     */
    select?: AchatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achat
     */
    omit?: AchatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchatInclude<ExtArgs> | null
    where?: AchatWhereInput
    orderBy?: AchatOrderByWithRelationInput | AchatOrderByWithRelationInput[]
    cursor?: AchatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AchatScalarFieldEnum | AchatScalarFieldEnum[]
  }

  /**
   * Agent.teneurs
   */
  export type Agent$teneursArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teneur
     */
    select?: TeneurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Teneur
     */
    omit?: TeneurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeneurInclude<ExtArgs> | null
    where?: TeneurWhereInput
    orderBy?: TeneurOrderByWithRelationInput | TeneurOrderByWithRelationInput[]
    cursor?: TeneurWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeneurScalarFieldEnum | TeneurScalarFieldEnum[]
  }

  /**
   * Agent.devises
   */
  export type Agent$devisesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Devise
     */
    select?: DeviseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Devise
     */
    omit?: DeviseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviseInclude<ExtArgs> | null
    where?: DeviseWhereInput
    orderBy?: DeviseOrderByWithRelationInput | DeviseOrderByWithRelationInput[]
    cursor?: DeviseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeviseScalarFieldEnum | DeviseScalarFieldEnum[]
  }

  /**
   * Agent.paniers
   */
  export type Agent$paniersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Panier
     */
    select?: PanierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Panier
     */
    omit?: PanierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PanierInclude<ExtArgs> | null
    where?: PanierWhereInput
    orderBy?: PanierOrderByWithRelationInput | PanierOrderByWithRelationInput[]
    cursor?: PanierWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PanierScalarFieldEnum | PanierScalarFieldEnum[]
  }

  /**
   * Agent.caisses
   */
  export type Agent$caissesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Caisse
     */
    select?: CaisseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Caisse
     */
    omit?: CaisseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaisseInclude<ExtArgs> | null
    where?: CaisseWhereInput
    orderBy?: CaisseOrderByWithRelationInput | CaisseOrderByWithRelationInput[]
    cursor?: CaisseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CaisseScalarFieldEnum | CaisseScalarFieldEnum[]
  }

  /**
   * Agent.mouvementCaisses
   */
  export type Agent$mouvementCaissesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MouvementCaisse
     */
    select?: MouvementCaisseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MouvementCaisse
     */
    omit?: MouvementCaisseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MouvementCaisseInclude<ExtArgs> | null
    where?: MouvementCaisseWhereInput
    orderBy?: MouvementCaisseOrderByWithRelationInput | MouvementCaisseOrderByWithRelationInput[]
    cursor?: MouvementCaisseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MouvementCaisseScalarFieldEnum | MouvementCaisseScalarFieldEnum[]
  }

  /**
   * Agent.clotureCaisses
   */
  export type Agent$clotureCaissesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClotureCaisse
     */
    select?: ClotureCaisseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClotureCaisse
     */
    omit?: ClotureCaisseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClotureCaisseInclude<ExtArgs> | null
    where?: ClotureCaisseWhereInput
    orderBy?: ClotureCaisseOrderByWithRelationInput | ClotureCaisseOrderByWithRelationInput[]
    cursor?: ClotureCaisseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClotureCaisseScalarFieldEnum | ClotureCaisseScalarFieldEnum[]
  }

  /**
   * Agent.Fournisseur
   */
  export type Agent$FournisseurArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fournisseur
     */
    select?: FournisseurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fournisseur
     */
    omit?: FournisseurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FournisseurInclude<ExtArgs> | null
    where?: FournisseurWhereInput
    orderBy?: FournisseurOrderByWithRelationInput | FournisseurOrderByWithRelationInput[]
    cursor?: FournisseurWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FournisseurScalarFieldEnum | FournisseurScalarFieldEnum[]
  }

  /**
   * Agent without action
   */
  export type AgentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
  }


  /**
   * Model Client
   */

  export type AggregateClient = {
    _count: ClientCountAggregateOutputType | null
    _avg: ClientAvgAggregateOutputType | null
    _sum: ClientSumAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  export type ClientAvgAggregateOutputType = {
    id: number | null
  }

  export type ClientSumAggregateOutputType = {
    id: number | null
  }

  export type ClientMinAggregateOutputType = {
    id: number | null
    email: string | null
    nom: string | null
    postnom: string | null
    nom_complet: string | null
    sexe: $Enums.Sexe | null
    picture: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientMaxAggregateOutputType = {
    id: number | null
    email: string | null
    nom: string | null
    postnom: string | null
    nom_complet: string | null
    sexe: $Enums.Sexe | null
    picture: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientCountAggregateOutputType = {
    id: number
    email: number
    nom: number
    postnom: number
    nom_complet: number
    sexe: number
    picture: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClientAvgAggregateInputType = {
    id?: true
  }

  export type ClientSumAggregateInputType = {
    id?: true
  }

  export type ClientMinAggregateInputType = {
    id?: true
    email?: true
    nom?: true
    postnom?: true
    nom_complet?: true
    sexe?: true
    picture?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientMaxAggregateInputType = {
    id?: true
    email?: true
    nom?: true
    postnom?: true
    nom_complet?: true
    sexe?: true
    picture?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientCountAggregateInputType = {
    id?: true
    email?: true
    nom?: true
    postnom?: true
    nom_complet?: true
    sexe?: true
    picture?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Client to aggregate.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Clients
    **/
    _count?: true | ClientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClientAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClientSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientMaxAggregateInputType
  }

  export type GetClientAggregateType<T extends ClientAggregateArgs> = {
        [P in keyof T & keyof AggregateClient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClient[P]>
      : GetScalarType<T[P], AggregateClient[P]>
  }




  export type ClientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientWhereInput
    orderBy?: ClientOrderByWithAggregationInput | ClientOrderByWithAggregationInput[]
    by: ClientScalarFieldEnum[] | ClientScalarFieldEnum
    having?: ClientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientCountAggregateInputType | true
    _avg?: ClientAvgAggregateInputType
    _sum?: ClientSumAggregateInputType
    _min?: ClientMinAggregateInputType
    _max?: ClientMaxAggregateInputType
  }

  export type ClientGroupByOutputType = {
    id: number
    email: string
    nom: string
    postnom: string | null
    nom_complet: string | null
    sexe: $Enums.Sexe | null
    picture: string | null
    createdAt: Date
    updatedAt: Date
    _count: ClientCountAggregateOutputType | null
    _avg: ClientAvgAggregateOutputType | null
    _sum: ClientSumAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  type GetClientGroupByPayload<T extends ClientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientGroupByOutputType[P]>
            : GetScalarType<T[P], ClientGroupByOutputType[P]>
        }
      >
    >


  export type ClientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    nom?: boolean
    postnom?: boolean
    nom_complet?: boolean
    sexe?: boolean
    picture?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    adresses?: boolean | Client$adressesArgs<ExtArgs>
    contacts?: boolean | Client$contactsArgs<ExtArgs>
    ventes?: boolean | Client$ventesArgs<ExtArgs>
    achats?: boolean | Client$achatsArgs<ExtArgs>
    paniers?: boolean | Client$paniersArgs<ExtArgs>
    reservations?: boolean | Client$reservationsArgs<ExtArgs>
    commandes?: boolean | Client$commandesArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["client"]>

  export type ClientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    nom?: boolean
    postnom?: boolean
    nom_complet?: boolean
    sexe?: boolean
    picture?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["client"]>

  export type ClientSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    nom?: boolean
    postnom?: boolean
    nom_complet?: boolean
    sexe?: boolean
    picture?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["client"]>

  export type ClientSelectScalar = {
    id?: boolean
    email?: boolean
    nom?: boolean
    postnom?: boolean
    nom_complet?: boolean
    sexe?: boolean
    picture?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClientOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "nom" | "postnom" | "nom_complet" | "sexe" | "picture" | "createdAt" | "updatedAt", ExtArgs["result"]["client"]>
  export type ClientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    adresses?: boolean | Client$adressesArgs<ExtArgs>
    contacts?: boolean | Client$contactsArgs<ExtArgs>
    ventes?: boolean | Client$ventesArgs<ExtArgs>
    achats?: boolean | Client$achatsArgs<ExtArgs>
    paniers?: boolean | Client$paniersArgs<ExtArgs>
    reservations?: boolean | Client$reservationsArgs<ExtArgs>
    commandes?: boolean | Client$commandesArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClientIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ClientIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ClientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Client"
    objects: {
      adresses: Prisma.$AdressePayload<ExtArgs>[]
      contacts: Prisma.$ContactPayload<ExtArgs>[]
      ventes: Prisma.$VentePayload<ExtArgs>[]
      achats: Prisma.$AchatPayload<ExtArgs>[]
      paniers: Prisma.$PanierPayload<ExtArgs>[]
      reservations: Prisma.$ReservationPayload<ExtArgs>[]
      commandes: Prisma.$CommandePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      nom: string
      postnom: string | null
      nom_complet: string | null
      sexe: $Enums.Sexe | null
      picture: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["client"]>
    composites: {}
  }

  type ClientGetPayload<S extends boolean | null | undefined | ClientDefaultArgs> = $Result.GetResult<Prisma.$ClientPayload, S>

  type ClientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClientFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClientCountAggregateInputType | true
    }

  export interface ClientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Client'], meta: { name: 'Client' } }
    /**
     * Find zero or one Client that matches the filter.
     * @param {ClientFindUniqueArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientFindUniqueArgs>(args: SelectSubset<T, ClientFindUniqueArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Client that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClientFindUniqueOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientFindUniqueOrThrowArgs>(args: SelectSubset<T, ClientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Client that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientFindFirstArgs>(args?: SelectSubset<T, ClientFindFirstArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Client that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientFindFirstOrThrowArgs>(args?: SelectSubset<T, ClientFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Clients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clients
     * const clients = await prisma.client.findMany()
     * 
     * // Get first 10 Clients
     * const clients = await prisma.client.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientWithIdOnly = await prisma.client.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClientFindManyArgs>(args?: SelectSubset<T, ClientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Client.
     * @param {ClientCreateArgs} args - Arguments to create a Client.
     * @example
     * // Create one Client
     * const Client = await prisma.client.create({
     *   data: {
     *     // ... data to create a Client
     *   }
     * })
     * 
     */
    create<T extends ClientCreateArgs>(args: SelectSubset<T, ClientCreateArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Clients.
     * @param {ClientCreateManyArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const client = await prisma.client.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClientCreateManyArgs>(args?: SelectSubset<T, ClientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Clients and returns the data saved in the database.
     * @param {ClientCreateManyAndReturnArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const client = await prisma.client.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Clients and only return the `id`
     * const clientWithIdOnly = await prisma.client.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClientCreateManyAndReturnArgs>(args?: SelectSubset<T, ClientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Client.
     * @param {ClientDeleteArgs} args - Arguments to delete one Client.
     * @example
     * // Delete one Client
     * const Client = await prisma.client.delete({
     *   where: {
     *     // ... filter to delete one Client
     *   }
     * })
     * 
     */
    delete<T extends ClientDeleteArgs>(args: SelectSubset<T, ClientDeleteArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Client.
     * @param {ClientUpdateArgs} args - Arguments to update one Client.
     * @example
     * // Update one Client
     * const client = await prisma.client.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClientUpdateArgs>(args: SelectSubset<T, ClientUpdateArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Clients.
     * @param {ClientDeleteManyArgs} args - Arguments to filter Clients to delete.
     * @example
     * // Delete a few Clients
     * const { count } = await prisma.client.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClientDeleteManyArgs>(args?: SelectSubset<T, ClientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clients
     * const client = await prisma.client.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClientUpdateManyArgs>(args: SelectSubset<T, ClientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clients and returns the data updated in the database.
     * @param {ClientUpdateManyAndReturnArgs} args - Arguments to update many Clients.
     * @example
     * // Update many Clients
     * const client = await prisma.client.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Clients and only return the `id`
     * const clientWithIdOnly = await prisma.client.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClientUpdateManyAndReturnArgs>(args: SelectSubset<T, ClientUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Client.
     * @param {ClientUpsertArgs} args - Arguments to update or create a Client.
     * @example
     * // Update or create a Client
     * const client = await prisma.client.upsert({
     *   create: {
     *     // ... data to create a Client
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Client we want to update
     *   }
     * })
     */
    upsert<T extends ClientUpsertArgs>(args: SelectSubset<T, ClientUpsertArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCountArgs} args - Arguments to filter Clients to count.
     * @example
     * // Count the number of Clients
     * const count = await prisma.client.count({
     *   where: {
     *     // ... the filter for the Clients we want to count
     *   }
     * })
    **/
    count<T extends ClientCountArgs>(
      args?: Subset<T, ClientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientAggregateArgs>(args: Subset<T, ClientAggregateArgs>): Prisma.PrismaPromise<GetClientAggregateType<T>>

    /**
     * Group by Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientGroupByArgs['orderBy'] }
        : { orderBy?: ClientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Client model
   */
  readonly fields: ClientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Client.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    adresses<T extends Client$adressesArgs<ExtArgs> = {}>(args?: Subset<T, Client$adressesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdressePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    contacts<T extends Client$contactsArgs<ExtArgs> = {}>(args?: Subset<T, Client$contactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ventes<T extends Client$ventesArgs<ExtArgs> = {}>(args?: Subset<T, Client$ventesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VentePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    achats<T extends Client$achatsArgs<ExtArgs> = {}>(args?: Subset<T, Client$achatsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    paniers<T extends Client$paniersArgs<ExtArgs> = {}>(args?: Subset<T, Client$paniersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PanierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reservations<T extends Client$reservationsArgs<ExtArgs> = {}>(args?: Subset<T, Client$reservationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    commandes<T extends Client$commandesArgs<ExtArgs> = {}>(args?: Subset<T, Client$commandesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommandePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Client model
   */
  interface ClientFieldRefs {
    readonly id: FieldRef<"Client", 'Int'>
    readonly email: FieldRef<"Client", 'String'>
    readonly nom: FieldRef<"Client", 'String'>
    readonly postnom: FieldRef<"Client", 'String'>
    readonly nom_complet: FieldRef<"Client", 'String'>
    readonly sexe: FieldRef<"Client", 'Sexe'>
    readonly picture: FieldRef<"Client", 'String'>
    readonly createdAt: FieldRef<"Client", 'DateTime'>
    readonly updatedAt: FieldRef<"Client", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Client findUnique
   */
  export type ClientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client findUniqueOrThrow
   */
  export type ClientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client findFirst
   */
  export type ClientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client findFirstOrThrow
   */
  export type ClientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client findMany
   */
  export type ClientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Clients to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client create
   */
  export type ClientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The data needed to create a Client.
     */
    data: XOR<ClientCreateInput, ClientUncheckedCreateInput>
  }

  /**
   * Client createMany
   */
  export type ClientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Clients.
     */
    data: ClientCreateManyInput | ClientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Client createManyAndReturn
   */
  export type ClientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * The data used to create many Clients.
     */
    data: ClientCreateManyInput | ClientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Client update
   */
  export type ClientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The data needed to update a Client.
     */
    data: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
    /**
     * Choose, which Client to update.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client updateMany
   */
  export type ClientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Clients.
     */
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyInput>
    /**
     * Filter which Clients to update
     */
    where?: ClientWhereInput
    /**
     * Limit how many Clients to update.
     */
    limit?: number
  }

  /**
   * Client updateManyAndReturn
   */
  export type ClientUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * The data used to update Clients.
     */
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyInput>
    /**
     * Filter which Clients to update
     */
    where?: ClientWhereInput
    /**
     * Limit how many Clients to update.
     */
    limit?: number
  }

  /**
   * Client upsert
   */
  export type ClientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The filter to search for the Client to update in case it exists.
     */
    where: ClientWhereUniqueInput
    /**
     * In case the Client found by the `where` argument doesn't exist, create a new Client with this data.
     */
    create: XOR<ClientCreateInput, ClientUncheckedCreateInput>
    /**
     * In case the Client was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
  }

  /**
   * Client delete
   */
  export type ClientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter which Client to delete.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client deleteMany
   */
  export type ClientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clients to delete
     */
    where?: ClientWhereInput
    /**
     * Limit how many Clients to delete.
     */
    limit?: number
  }

  /**
   * Client.adresses
   */
  export type Client$adressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adresse
     */
    select?: AdresseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Adresse
     */
    omit?: AdresseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdresseInclude<ExtArgs> | null
    where?: AdresseWhereInput
    orderBy?: AdresseOrderByWithRelationInput | AdresseOrderByWithRelationInput[]
    cursor?: AdresseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdresseScalarFieldEnum | AdresseScalarFieldEnum[]
  }

  /**
   * Client.contacts
   */
  export type Client$contactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    cursor?: ContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Client.ventes
   */
  export type Client$ventesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vente
     */
    select?: VenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vente
     */
    omit?: VenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenteInclude<ExtArgs> | null
    where?: VenteWhereInput
    orderBy?: VenteOrderByWithRelationInput | VenteOrderByWithRelationInput[]
    cursor?: VenteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VenteScalarFieldEnum | VenteScalarFieldEnum[]
  }

  /**
   * Client.achats
   */
  export type Client$achatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achat
     */
    select?: AchatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achat
     */
    omit?: AchatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchatInclude<ExtArgs> | null
    where?: AchatWhereInput
    orderBy?: AchatOrderByWithRelationInput | AchatOrderByWithRelationInput[]
    cursor?: AchatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AchatScalarFieldEnum | AchatScalarFieldEnum[]
  }

  /**
   * Client.paniers
   */
  export type Client$paniersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Panier
     */
    select?: PanierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Panier
     */
    omit?: PanierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PanierInclude<ExtArgs> | null
    where?: PanierWhereInput
    orderBy?: PanierOrderByWithRelationInput | PanierOrderByWithRelationInput[]
    cursor?: PanierWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PanierScalarFieldEnum | PanierScalarFieldEnum[]
  }

  /**
   * Client.reservations
   */
  export type Client$reservationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    where?: ReservationWhereInput
    orderBy?: ReservationOrderByWithRelationInput | ReservationOrderByWithRelationInput[]
    cursor?: ReservationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReservationScalarFieldEnum | ReservationScalarFieldEnum[]
  }

  /**
   * Client.commandes
   */
  export type Client$commandesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commande
     */
    select?: CommandeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Commande
     */
    omit?: CommandeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandeInclude<ExtArgs> | null
    where?: CommandeWhereInput
    orderBy?: CommandeOrderByWithRelationInput | CommandeOrderByWithRelationInput[]
    cursor?: CommandeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommandeScalarFieldEnum | CommandeScalarFieldEnum[]
  }

  /**
   * Client without action
   */
  export type ClientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
  }


  /**
   * Model Adresse
   */

  export type AggregateAdresse = {
    _count: AdresseCountAggregateOutputType | null
    _avg: AdresseAvgAggregateOutputType | null
    _sum: AdresseSumAggregateOutputType | null
    _min: AdresseMinAggregateOutputType | null
    _max: AdresseMaxAggregateOutputType | null
  }

  export type AdresseAvgAggregateOutputType = {
    id: number | null
    agentId: number | null
    fournisseurId: number | null
    clientId: number | null
    entrepriseId: number | null
  }

  export type AdresseSumAggregateOutputType = {
    id: number | null
    agentId: number | null
    fournisseurId: number | null
    clientId: number | null
    entrepriseId: number | null
  }

  export type AdresseMinAggregateOutputType = {
    id: number | null
    ville: string | null
    adresse: string | null
    isActive: boolean | null
    agentId: number | null
    fournisseurId: number | null
    clientId: number | null
    entrepriseId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdresseMaxAggregateOutputType = {
    id: number | null
    ville: string | null
    adresse: string | null
    isActive: boolean | null
    agentId: number | null
    fournisseurId: number | null
    clientId: number | null
    entrepriseId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdresseCountAggregateOutputType = {
    id: number
    ville: number
    adresse: number
    isActive: number
    agentId: number
    fournisseurId: number
    clientId: number
    entrepriseId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AdresseAvgAggregateInputType = {
    id?: true
    agentId?: true
    fournisseurId?: true
    clientId?: true
    entrepriseId?: true
  }

  export type AdresseSumAggregateInputType = {
    id?: true
    agentId?: true
    fournisseurId?: true
    clientId?: true
    entrepriseId?: true
  }

  export type AdresseMinAggregateInputType = {
    id?: true
    ville?: true
    adresse?: true
    isActive?: true
    agentId?: true
    fournisseurId?: true
    clientId?: true
    entrepriseId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdresseMaxAggregateInputType = {
    id?: true
    ville?: true
    adresse?: true
    isActive?: true
    agentId?: true
    fournisseurId?: true
    clientId?: true
    entrepriseId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdresseCountAggregateInputType = {
    id?: true
    ville?: true
    adresse?: true
    isActive?: true
    agentId?: true
    fournisseurId?: true
    clientId?: true
    entrepriseId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AdresseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Adresse to aggregate.
     */
    where?: AdresseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Adresses to fetch.
     */
    orderBy?: AdresseOrderByWithRelationInput | AdresseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdresseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Adresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Adresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Adresses
    **/
    _count?: true | AdresseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdresseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdresseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdresseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdresseMaxAggregateInputType
  }

  export type GetAdresseAggregateType<T extends AdresseAggregateArgs> = {
        [P in keyof T & keyof AggregateAdresse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdresse[P]>
      : GetScalarType<T[P], AggregateAdresse[P]>
  }




  export type AdresseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdresseWhereInput
    orderBy?: AdresseOrderByWithAggregationInput | AdresseOrderByWithAggregationInput[]
    by: AdresseScalarFieldEnum[] | AdresseScalarFieldEnum
    having?: AdresseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdresseCountAggregateInputType | true
    _avg?: AdresseAvgAggregateInputType
    _sum?: AdresseSumAggregateInputType
    _min?: AdresseMinAggregateInputType
    _max?: AdresseMaxAggregateInputType
  }

  export type AdresseGroupByOutputType = {
    id: number
    ville: string | null
    adresse: string
    isActive: boolean
    agentId: number | null
    fournisseurId: number | null
    clientId: number | null
    entrepriseId: number | null
    createdAt: Date
    updatedAt: Date
    _count: AdresseCountAggregateOutputType | null
    _avg: AdresseAvgAggregateOutputType | null
    _sum: AdresseSumAggregateOutputType | null
    _min: AdresseMinAggregateOutputType | null
    _max: AdresseMaxAggregateOutputType | null
  }

  type GetAdresseGroupByPayload<T extends AdresseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdresseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdresseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdresseGroupByOutputType[P]>
            : GetScalarType<T[P], AdresseGroupByOutputType[P]>
        }
      >
    >


  export type AdresseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ville?: boolean
    adresse?: boolean
    isActive?: boolean
    agentId?: boolean
    fournisseurId?: boolean
    clientId?: boolean
    entrepriseId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agent?: boolean | Adresse$agentArgs<ExtArgs>
    entreprise?: boolean | Adresse$entrepriseArgs<ExtArgs>
    fournisseur?: boolean | Adresse$fournisseurArgs<ExtArgs>
    client?: boolean | Adresse$clientArgs<ExtArgs>
    reservations?: boolean | Adresse$reservationsArgs<ExtArgs>
    commandes?: boolean | Adresse$commandesArgs<ExtArgs>
    _count?: boolean | AdresseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adresse"]>

  export type AdresseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ville?: boolean
    adresse?: boolean
    isActive?: boolean
    agentId?: boolean
    fournisseurId?: boolean
    clientId?: boolean
    entrepriseId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agent?: boolean | Adresse$agentArgs<ExtArgs>
    entreprise?: boolean | Adresse$entrepriseArgs<ExtArgs>
    fournisseur?: boolean | Adresse$fournisseurArgs<ExtArgs>
    client?: boolean | Adresse$clientArgs<ExtArgs>
  }, ExtArgs["result"]["adresse"]>

  export type AdresseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ville?: boolean
    adresse?: boolean
    isActive?: boolean
    agentId?: boolean
    fournisseurId?: boolean
    clientId?: boolean
    entrepriseId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agent?: boolean | Adresse$agentArgs<ExtArgs>
    entreprise?: boolean | Adresse$entrepriseArgs<ExtArgs>
    fournisseur?: boolean | Adresse$fournisseurArgs<ExtArgs>
    client?: boolean | Adresse$clientArgs<ExtArgs>
  }, ExtArgs["result"]["adresse"]>

  export type AdresseSelectScalar = {
    id?: boolean
    ville?: boolean
    adresse?: boolean
    isActive?: boolean
    agentId?: boolean
    fournisseurId?: boolean
    clientId?: boolean
    entrepriseId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AdresseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ville" | "adresse" | "isActive" | "agentId" | "fournisseurId" | "clientId" | "entrepriseId" | "createdAt" | "updatedAt", ExtArgs["result"]["adresse"]>
  export type AdresseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | Adresse$agentArgs<ExtArgs>
    entreprise?: boolean | Adresse$entrepriseArgs<ExtArgs>
    fournisseur?: boolean | Adresse$fournisseurArgs<ExtArgs>
    client?: boolean | Adresse$clientArgs<ExtArgs>
    reservations?: boolean | Adresse$reservationsArgs<ExtArgs>
    commandes?: boolean | Adresse$commandesArgs<ExtArgs>
    _count?: boolean | AdresseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AdresseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | Adresse$agentArgs<ExtArgs>
    entreprise?: boolean | Adresse$entrepriseArgs<ExtArgs>
    fournisseur?: boolean | Adresse$fournisseurArgs<ExtArgs>
    client?: boolean | Adresse$clientArgs<ExtArgs>
  }
  export type AdresseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | Adresse$agentArgs<ExtArgs>
    entreprise?: boolean | Adresse$entrepriseArgs<ExtArgs>
    fournisseur?: boolean | Adresse$fournisseurArgs<ExtArgs>
    client?: boolean | Adresse$clientArgs<ExtArgs>
  }

  export type $AdressePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Adresse"
    objects: {
      agent: Prisma.$AgentPayload<ExtArgs> | null
      entreprise: Prisma.$EntreprisePayload<ExtArgs> | null
      fournisseur: Prisma.$FournisseurPayload<ExtArgs> | null
      client: Prisma.$ClientPayload<ExtArgs> | null
      reservations: Prisma.$ReservationPayload<ExtArgs>[]
      commandes: Prisma.$CommandePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      ville: string | null
      adresse: string
      isActive: boolean
      agentId: number | null
      fournisseurId: number | null
      clientId: number | null
      entrepriseId: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["adresse"]>
    composites: {}
  }

  type AdresseGetPayload<S extends boolean | null | undefined | AdresseDefaultArgs> = $Result.GetResult<Prisma.$AdressePayload, S>

  type AdresseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdresseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdresseCountAggregateInputType | true
    }

  export interface AdresseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Adresse'], meta: { name: 'Adresse' } }
    /**
     * Find zero or one Adresse that matches the filter.
     * @param {AdresseFindUniqueArgs} args - Arguments to find a Adresse
     * @example
     * // Get one Adresse
     * const adresse = await prisma.adresse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdresseFindUniqueArgs>(args: SelectSubset<T, AdresseFindUniqueArgs<ExtArgs>>): Prisma__AdresseClient<$Result.GetResult<Prisma.$AdressePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Adresse that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdresseFindUniqueOrThrowArgs} args - Arguments to find a Adresse
     * @example
     * // Get one Adresse
     * const adresse = await prisma.adresse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdresseFindUniqueOrThrowArgs>(args: SelectSubset<T, AdresseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdresseClient<$Result.GetResult<Prisma.$AdressePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Adresse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdresseFindFirstArgs} args - Arguments to find a Adresse
     * @example
     * // Get one Adresse
     * const adresse = await prisma.adresse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdresseFindFirstArgs>(args?: SelectSubset<T, AdresseFindFirstArgs<ExtArgs>>): Prisma__AdresseClient<$Result.GetResult<Prisma.$AdressePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Adresse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdresseFindFirstOrThrowArgs} args - Arguments to find a Adresse
     * @example
     * // Get one Adresse
     * const adresse = await prisma.adresse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdresseFindFirstOrThrowArgs>(args?: SelectSubset<T, AdresseFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdresseClient<$Result.GetResult<Prisma.$AdressePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Adresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdresseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Adresses
     * const adresses = await prisma.adresse.findMany()
     * 
     * // Get first 10 Adresses
     * const adresses = await prisma.adresse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adresseWithIdOnly = await prisma.adresse.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdresseFindManyArgs>(args?: SelectSubset<T, AdresseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdressePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Adresse.
     * @param {AdresseCreateArgs} args - Arguments to create a Adresse.
     * @example
     * // Create one Adresse
     * const Adresse = await prisma.adresse.create({
     *   data: {
     *     // ... data to create a Adresse
     *   }
     * })
     * 
     */
    create<T extends AdresseCreateArgs>(args: SelectSubset<T, AdresseCreateArgs<ExtArgs>>): Prisma__AdresseClient<$Result.GetResult<Prisma.$AdressePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Adresses.
     * @param {AdresseCreateManyArgs} args - Arguments to create many Adresses.
     * @example
     * // Create many Adresses
     * const adresse = await prisma.adresse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdresseCreateManyArgs>(args?: SelectSubset<T, AdresseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Adresses and returns the data saved in the database.
     * @param {AdresseCreateManyAndReturnArgs} args - Arguments to create many Adresses.
     * @example
     * // Create many Adresses
     * const adresse = await prisma.adresse.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Adresses and only return the `id`
     * const adresseWithIdOnly = await prisma.adresse.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdresseCreateManyAndReturnArgs>(args?: SelectSubset<T, AdresseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdressePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Adresse.
     * @param {AdresseDeleteArgs} args - Arguments to delete one Adresse.
     * @example
     * // Delete one Adresse
     * const Adresse = await prisma.adresse.delete({
     *   where: {
     *     // ... filter to delete one Adresse
     *   }
     * })
     * 
     */
    delete<T extends AdresseDeleteArgs>(args: SelectSubset<T, AdresseDeleteArgs<ExtArgs>>): Prisma__AdresseClient<$Result.GetResult<Prisma.$AdressePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Adresse.
     * @param {AdresseUpdateArgs} args - Arguments to update one Adresse.
     * @example
     * // Update one Adresse
     * const adresse = await prisma.adresse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdresseUpdateArgs>(args: SelectSubset<T, AdresseUpdateArgs<ExtArgs>>): Prisma__AdresseClient<$Result.GetResult<Prisma.$AdressePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Adresses.
     * @param {AdresseDeleteManyArgs} args - Arguments to filter Adresses to delete.
     * @example
     * // Delete a few Adresses
     * const { count } = await prisma.adresse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdresseDeleteManyArgs>(args?: SelectSubset<T, AdresseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Adresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdresseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Adresses
     * const adresse = await prisma.adresse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdresseUpdateManyArgs>(args: SelectSubset<T, AdresseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Adresses and returns the data updated in the database.
     * @param {AdresseUpdateManyAndReturnArgs} args - Arguments to update many Adresses.
     * @example
     * // Update many Adresses
     * const adresse = await prisma.adresse.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Adresses and only return the `id`
     * const adresseWithIdOnly = await prisma.adresse.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdresseUpdateManyAndReturnArgs>(args: SelectSubset<T, AdresseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdressePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Adresse.
     * @param {AdresseUpsertArgs} args - Arguments to update or create a Adresse.
     * @example
     * // Update or create a Adresse
     * const adresse = await prisma.adresse.upsert({
     *   create: {
     *     // ... data to create a Adresse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Adresse we want to update
     *   }
     * })
     */
    upsert<T extends AdresseUpsertArgs>(args: SelectSubset<T, AdresseUpsertArgs<ExtArgs>>): Prisma__AdresseClient<$Result.GetResult<Prisma.$AdressePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Adresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdresseCountArgs} args - Arguments to filter Adresses to count.
     * @example
     * // Count the number of Adresses
     * const count = await prisma.adresse.count({
     *   where: {
     *     // ... the filter for the Adresses we want to count
     *   }
     * })
    **/
    count<T extends AdresseCountArgs>(
      args?: Subset<T, AdresseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdresseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Adresse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdresseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdresseAggregateArgs>(args: Subset<T, AdresseAggregateArgs>): Prisma.PrismaPromise<GetAdresseAggregateType<T>>

    /**
     * Group by Adresse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdresseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdresseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdresseGroupByArgs['orderBy'] }
        : { orderBy?: AdresseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdresseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdresseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Adresse model
   */
  readonly fields: AdresseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Adresse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdresseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agent<T extends Adresse$agentArgs<ExtArgs> = {}>(args?: Subset<T, Adresse$agentArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    entreprise<T extends Adresse$entrepriseArgs<ExtArgs> = {}>(args?: Subset<T, Adresse$entrepriseArgs<ExtArgs>>): Prisma__EntrepriseClient<$Result.GetResult<Prisma.$EntreprisePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    fournisseur<T extends Adresse$fournisseurArgs<ExtArgs> = {}>(args?: Subset<T, Adresse$fournisseurArgs<ExtArgs>>): Prisma__FournisseurClient<$Result.GetResult<Prisma.$FournisseurPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    client<T extends Adresse$clientArgs<ExtArgs> = {}>(args?: Subset<T, Adresse$clientArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    reservations<T extends Adresse$reservationsArgs<ExtArgs> = {}>(args?: Subset<T, Adresse$reservationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    commandes<T extends Adresse$commandesArgs<ExtArgs> = {}>(args?: Subset<T, Adresse$commandesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommandePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Adresse model
   */
  interface AdresseFieldRefs {
    readonly id: FieldRef<"Adresse", 'Int'>
    readonly ville: FieldRef<"Adresse", 'String'>
    readonly adresse: FieldRef<"Adresse", 'String'>
    readonly isActive: FieldRef<"Adresse", 'Boolean'>
    readonly agentId: FieldRef<"Adresse", 'Int'>
    readonly fournisseurId: FieldRef<"Adresse", 'Int'>
    readonly clientId: FieldRef<"Adresse", 'Int'>
    readonly entrepriseId: FieldRef<"Adresse", 'Int'>
    readonly createdAt: FieldRef<"Adresse", 'DateTime'>
    readonly updatedAt: FieldRef<"Adresse", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Adresse findUnique
   */
  export type AdresseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adresse
     */
    select?: AdresseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Adresse
     */
    omit?: AdresseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdresseInclude<ExtArgs> | null
    /**
     * Filter, which Adresse to fetch.
     */
    where: AdresseWhereUniqueInput
  }

  /**
   * Adresse findUniqueOrThrow
   */
  export type AdresseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adresse
     */
    select?: AdresseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Adresse
     */
    omit?: AdresseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdresseInclude<ExtArgs> | null
    /**
     * Filter, which Adresse to fetch.
     */
    where: AdresseWhereUniqueInput
  }

  /**
   * Adresse findFirst
   */
  export type AdresseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adresse
     */
    select?: AdresseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Adresse
     */
    omit?: AdresseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdresseInclude<ExtArgs> | null
    /**
     * Filter, which Adresse to fetch.
     */
    where?: AdresseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Adresses to fetch.
     */
    orderBy?: AdresseOrderByWithRelationInput | AdresseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Adresses.
     */
    cursor?: AdresseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Adresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Adresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Adresses.
     */
    distinct?: AdresseScalarFieldEnum | AdresseScalarFieldEnum[]
  }

  /**
   * Adresse findFirstOrThrow
   */
  export type AdresseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adresse
     */
    select?: AdresseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Adresse
     */
    omit?: AdresseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdresseInclude<ExtArgs> | null
    /**
     * Filter, which Adresse to fetch.
     */
    where?: AdresseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Adresses to fetch.
     */
    orderBy?: AdresseOrderByWithRelationInput | AdresseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Adresses.
     */
    cursor?: AdresseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Adresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Adresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Adresses.
     */
    distinct?: AdresseScalarFieldEnum | AdresseScalarFieldEnum[]
  }

  /**
   * Adresse findMany
   */
  export type AdresseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adresse
     */
    select?: AdresseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Adresse
     */
    omit?: AdresseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdresseInclude<ExtArgs> | null
    /**
     * Filter, which Adresses to fetch.
     */
    where?: AdresseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Adresses to fetch.
     */
    orderBy?: AdresseOrderByWithRelationInput | AdresseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Adresses.
     */
    cursor?: AdresseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Adresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Adresses.
     */
    skip?: number
    distinct?: AdresseScalarFieldEnum | AdresseScalarFieldEnum[]
  }

  /**
   * Adresse create
   */
  export type AdresseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adresse
     */
    select?: AdresseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Adresse
     */
    omit?: AdresseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdresseInclude<ExtArgs> | null
    /**
     * The data needed to create a Adresse.
     */
    data: XOR<AdresseCreateInput, AdresseUncheckedCreateInput>
  }

  /**
   * Adresse createMany
   */
  export type AdresseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Adresses.
     */
    data: AdresseCreateManyInput | AdresseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Adresse createManyAndReturn
   */
  export type AdresseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adresse
     */
    select?: AdresseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Adresse
     */
    omit?: AdresseOmit<ExtArgs> | null
    /**
     * The data used to create many Adresses.
     */
    data: AdresseCreateManyInput | AdresseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdresseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Adresse update
   */
  export type AdresseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adresse
     */
    select?: AdresseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Adresse
     */
    omit?: AdresseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdresseInclude<ExtArgs> | null
    /**
     * The data needed to update a Adresse.
     */
    data: XOR<AdresseUpdateInput, AdresseUncheckedUpdateInput>
    /**
     * Choose, which Adresse to update.
     */
    where: AdresseWhereUniqueInput
  }

  /**
   * Adresse updateMany
   */
  export type AdresseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Adresses.
     */
    data: XOR<AdresseUpdateManyMutationInput, AdresseUncheckedUpdateManyInput>
    /**
     * Filter which Adresses to update
     */
    where?: AdresseWhereInput
    /**
     * Limit how many Adresses to update.
     */
    limit?: number
  }

  /**
   * Adresse updateManyAndReturn
   */
  export type AdresseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adresse
     */
    select?: AdresseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Adresse
     */
    omit?: AdresseOmit<ExtArgs> | null
    /**
     * The data used to update Adresses.
     */
    data: XOR<AdresseUpdateManyMutationInput, AdresseUncheckedUpdateManyInput>
    /**
     * Filter which Adresses to update
     */
    where?: AdresseWhereInput
    /**
     * Limit how many Adresses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdresseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Adresse upsert
   */
  export type AdresseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adresse
     */
    select?: AdresseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Adresse
     */
    omit?: AdresseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdresseInclude<ExtArgs> | null
    /**
     * The filter to search for the Adresse to update in case it exists.
     */
    where: AdresseWhereUniqueInput
    /**
     * In case the Adresse found by the `where` argument doesn't exist, create a new Adresse with this data.
     */
    create: XOR<AdresseCreateInput, AdresseUncheckedCreateInput>
    /**
     * In case the Adresse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdresseUpdateInput, AdresseUncheckedUpdateInput>
  }

  /**
   * Adresse delete
   */
  export type AdresseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adresse
     */
    select?: AdresseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Adresse
     */
    omit?: AdresseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdresseInclude<ExtArgs> | null
    /**
     * Filter which Adresse to delete.
     */
    where: AdresseWhereUniqueInput
  }

  /**
   * Adresse deleteMany
   */
  export type AdresseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Adresses to delete
     */
    where?: AdresseWhereInput
    /**
     * Limit how many Adresses to delete.
     */
    limit?: number
  }

  /**
   * Adresse.agent
   */
  export type Adresse$agentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    where?: AgentWhereInput
  }

  /**
   * Adresse.entreprise
   */
  export type Adresse$entrepriseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entreprise
     */
    select?: EntrepriseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Entreprise
     */
    omit?: EntrepriseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntrepriseInclude<ExtArgs> | null
    where?: EntrepriseWhereInput
  }

  /**
   * Adresse.fournisseur
   */
  export type Adresse$fournisseurArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fournisseur
     */
    select?: FournisseurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fournisseur
     */
    omit?: FournisseurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FournisseurInclude<ExtArgs> | null
    where?: FournisseurWhereInput
  }

  /**
   * Adresse.client
   */
  export type Adresse$clientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
  }

  /**
   * Adresse.reservations
   */
  export type Adresse$reservationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    where?: ReservationWhereInput
    orderBy?: ReservationOrderByWithRelationInput | ReservationOrderByWithRelationInput[]
    cursor?: ReservationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReservationScalarFieldEnum | ReservationScalarFieldEnum[]
  }

  /**
   * Adresse.commandes
   */
  export type Adresse$commandesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commande
     */
    select?: CommandeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Commande
     */
    omit?: CommandeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandeInclude<ExtArgs> | null
    where?: CommandeWhereInput
    orderBy?: CommandeOrderByWithRelationInput | CommandeOrderByWithRelationInput[]
    cursor?: CommandeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommandeScalarFieldEnum | CommandeScalarFieldEnum[]
  }

  /**
   * Adresse without action
   */
  export type AdresseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adresse
     */
    select?: AdresseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Adresse
     */
    omit?: AdresseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdresseInclude<ExtArgs> | null
  }


  /**
   * Model Contact
   */

  export type AggregateContact = {
    _count: ContactCountAggregateOutputType | null
    _avg: ContactAvgAggregateOutputType | null
    _sum: ContactSumAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  export type ContactAvgAggregateOutputType = {
    id: number | null
    agentId: number | null
    fournisseurId: number | null
    clientId: number | null
    entrepriseId: number | null
  }

  export type ContactSumAggregateOutputType = {
    id: number | null
    agentId: number | null
    fournisseurId: number | null
    clientId: number | null
    entrepriseId: number | null
  }

  export type ContactMinAggregateOutputType = {
    id: number | null
    tel: string | null
    isActive: boolean | null
    agentId: number | null
    fournisseurId: number | null
    clientId: number | null
    entrepriseId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactMaxAggregateOutputType = {
    id: number | null
    tel: string | null
    isActive: boolean | null
    agentId: number | null
    fournisseurId: number | null
    clientId: number | null
    entrepriseId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactCountAggregateOutputType = {
    id: number
    tel: number
    isActive: number
    agentId: number
    fournisseurId: number
    clientId: number
    entrepriseId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContactAvgAggregateInputType = {
    id?: true
    agentId?: true
    fournisseurId?: true
    clientId?: true
    entrepriseId?: true
  }

  export type ContactSumAggregateInputType = {
    id?: true
    agentId?: true
    fournisseurId?: true
    clientId?: true
    entrepriseId?: true
  }

  export type ContactMinAggregateInputType = {
    id?: true
    tel?: true
    isActive?: true
    agentId?: true
    fournisseurId?: true
    clientId?: true
    entrepriseId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactMaxAggregateInputType = {
    id?: true
    tel?: true
    isActive?: true
    agentId?: true
    fournisseurId?: true
    clientId?: true
    entrepriseId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactCountAggregateInputType = {
    id?: true
    tel?: true
    isActive?: true
    agentId?: true
    fournisseurId?: true
    clientId?: true
    entrepriseId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contact to aggregate.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contacts
    **/
    _count?: true | ContactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContactAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContactSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactMaxAggregateInputType
  }

  export type GetContactAggregateType<T extends ContactAggregateArgs> = {
        [P in keyof T & keyof AggregateContact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContact[P]>
      : GetScalarType<T[P], AggregateContact[P]>
  }




  export type ContactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithAggregationInput | ContactOrderByWithAggregationInput[]
    by: ContactScalarFieldEnum[] | ContactScalarFieldEnum
    having?: ContactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactCountAggregateInputType | true
    _avg?: ContactAvgAggregateInputType
    _sum?: ContactSumAggregateInputType
    _min?: ContactMinAggregateInputType
    _max?: ContactMaxAggregateInputType
  }

  export type ContactGroupByOutputType = {
    id: number
    tel: string
    isActive: boolean
    agentId: number | null
    fournisseurId: number | null
    clientId: number | null
    entrepriseId: number | null
    createdAt: Date
    updatedAt: Date
    _count: ContactCountAggregateOutputType | null
    _avg: ContactAvgAggregateOutputType | null
    _sum: ContactSumAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  type GetContactGroupByPayload<T extends ContactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactGroupByOutputType[P]>
            : GetScalarType<T[P], ContactGroupByOutputType[P]>
        }
      >
    >


  export type ContactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tel?: boolean
    isActive?: boolean
    agentId?: boolean
    fournisseurId?: boolean
    clientId?: boolean
    entrepriseId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    entreprise?: boolean | Contact$entrepriseArgs<ExtArgs>
    client?: boolean | Contact$clientArgs<ExtArgs>
    agent?: boolean | Contact$agentArgs<ExtArgs>
    fournisseur?: boolean | Contact$fournisseurArgs<ExtArgs>
    reservations?: boolean | Contact$reservationsArgs<ExtArgs>
    commandes?: boolean | Contact$commandesArgs<ExtArgs>
    _count?: boolean | ContactCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contact"]>

  export type ContactSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tel?: boolean
    isActive?: boolean
    agentId?: boolean
    fournisseurId?: boolean
    clientId?: boolean
    entrepriseId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    entreprise?: boolean | Contact$entrepriseArgs<ExtArgs>
    client?: boolean | Contact$clientArgs<ExtArgs>
    agent?: boolean | Contact$agentArgs<ExtArgs>
    fournisseur?: boolean | Contact$fournisseurArgs<ExtArgs>
  }, ExtArgs["result"]["contact"]>

  export type ContactSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tel?: boolean
    isActive?: boolean
    agentId?: boolean
    fournisseurId?: boolean
    clientId?: boolean
    entrepriseId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    entreprise?: boolean | Contact$entrepriseArgs<ExtArgs>
    client?: boolean | Contact$clientArgs<ExtArgs>
    agent?: boolean | Contact$agentArgs<ExtArgs>
    fournisseur?: boolean | Contact$fournisseurArgs<ExtArgs>
  }, ExtArgs["result"]["contact"]>

  export type ContactSelectScalar = {
    id?: boolean
    tel?: boolean
    isActive?: boolean
    agentId?: boolean
    fournisseurId?: boolean
    clientId?: boolean
    entrepriseId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContactOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tel" | "isActive" | "agentId" | "fournisseurId" | "clientId" | "entrepriseId" | "createdAt" | "updatedAt", ExtArgs["result"]["contact"]>
  export type ContactInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entreprise?: boolean | Contact$entrepriseArgs<ExtArgs>
    client?: boolean | Contact$clientArgs<ExtArgs>
    agent?: boolean | Contact$agentArgs<ExtArgs>
    fournisseur?: boolean | Contact$fournisseurArgs<ExtArgs>
    reservations?: boolean | Contact$reservationsArgs<ExtArgs>
    commandes?: boolean | Contact$commandesArgs<ExtArgs>
    _count?: boolean | ContactCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ContactIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entreprise?: boolean | Contact$entrepriseArgs<ExtArgs>
    client?: boolean | Contact$clientArgs<ExtArgs>
    agent?: boolean | Contact$agentArgs<ExtArgs>
    fournisseur?: boolean | Contact$fournisseurArgs<ExtArgs>
  }
  export type ContactIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entreprise?: boolean | Contact$entrepriseArgs<ExtArgs>
    client?: boolean | Contact$clientArgs<ExtArgs>
    agent?: boolean | Contact$agentArgs<ExtArgs>
    fournisseur?: boolean | Contact$fournisseurArgs<ExtArgs>
  }

  export type $ContactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Contact"
    objects: {
      entreprise: Prisma.$EntreprisePayload<ExtArgs> | null
      client: Prisma.$ClientPayload<ExtArgs> | null
      agent: Prisma.$AgentPayload<ExtArgs> | null
      fournisseur: Prisma.$FournisseurPayload<ExtArgs> | null
      reservations: Prisma.$ReservationPayload<ExtArgs>[]
      commandes: Prisma.$CommandePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      tel: string
      isActive: boolean
      agentId: number | null
      fournisseurId: number | null
      clientId: number | null
      entrepriseId: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["contact"]>
    composites: {}
  }

  type ContactGetPayload<S extends boolean | null | undefined | ContactDefaultArgs> = $Result.GetResult<Prisma.$ContactPayload, S>

  type ContactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContactFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContactCountAggregateInputType | true
    }

  export interface ContactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Contact'], meta: { name: 'Contact' } }
    /**
     * Find zero or one Contact that matches the filter.
     * @param {ContactFindUniqueArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactFindUniqueArgs>(args: SelectSubset<T, ContactFindUniqueArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Contact that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContactFindUniqueOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindFirstArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactFindFirstArgs>(args?: SelectSubset<T, ContactFindFirstArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindFirstOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Contacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contacts
     * const contacts = await prisma.contact.findMany()
     * 
     * // Get first 10 Contacts
     * const contacts = await prisma.contact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactWithIdOnly = await prisma.contact.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContactFindManyArgs>(args?: SelectSubset<T, ContactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Contact.
     * @param {ContactCreateArgs} args - Arguments to create a Contact.
     * @example
     * // Create one Contact
     * const Contact = await prisma.contact.create({
     *   data: {
     *     // ... data to create a Contact
     *   }
     * })
     * 
     */
    create<T extends ContactCreateArgs>(args: SelectSubset<T, ContactCreateArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Contacts.
     * @param {ContactCreateManyArgs} args - Arguments to create many Contacts.
     * @example
     * // Create many Contacts
     * const contact = await prisma.contact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactCreateManyArgs>(args?: SelectSubset<T, ContactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Contacts and returns the data saved in the database.
     * @param {ContactCreateManyAndReturnArgs} args - Arguments to create many Contacts.
     * @example
     * // Create many Contacts
     * const contact = await prisma.contact.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Contacts and only return the `id`
     * const contactWithIdOnly = await prisma.contact.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContactCreateManyAndReturnArgs>(args?: SelectSubset<T, ContactCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Contact.
     * @param {ContactDeleteArgs} args - Arguments to delete one Contact.
     * @example
     * // Delete one Contact
     * const Contact = await prisma.contact.delete({
     *   where: {
     *     // ... filter to delete one Contact
     *   }
     * })
     * 
     */
    delete<T extends ContactDeleteArgs>(args: SelectSubset<T, ContactDeleteArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Contact.
     * @param {ContactUpdateArgs} args - Arguments to update one Contact.
     * @example
     * // Update one Contact
     * const contact = await prisma.contact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactUpdateArgs>(args: SelectSubset<T, ContactUpdateArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Contacts.
     * @param {ContactDeleteManyArgs} args - Arguments to filter Contacts to delete.
     * @example
     * // Delete a few Contacts
     * const { count } = await prisma.contact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactDeleteManyArgs>(args?: SelectSubset<T, ContactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contacts
     * const contact = await prisma.contact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactUpdateManyArgs>(args: SelectSubset<T, ContactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contacts and returns the data updated in the database.
     * @param {ContactUpdateManyAndReturnArgs} args - Arguments to update many Contacts.
     * @example
     * // Update many Contacts
     * const contact = await prisma.contact.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Contacts and only return the `id`
     * const contactWithIdOnly = await prisma.contact.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContactUpdateManyAndReturnArgs>(args: SelectSubset<T, ContactUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Contact.
     * @param {ContactUpsertArgs} args - Arguments to update or create a Contact.
     * @example
     * // Update or create a Contact
     * const contact = await prisma.contact.upsert({
     *   create: {
     *     // ... data to create a Contact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contact we want to update
     *   }
     * })
     */
    upsert<T extends ContactUpsertArgs>(args: SelectSubset<T, ContactUpsertArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactCountArgs} args - Arguments to filter Contacts to count.
     * @example
     * // Count the number of Contacts
     * const count = await prisma.contact.count({
     *   where: {
     *     // ... the filter for the Contacts we want to count
     *   }
     * })
    **/
    count<T extends ContactCountArgs>(
      args?: Subset<T, ContactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactAggregateArgs>(args: Subset<T, ContactAggregateArgs>): Prisma.PrismaPromise<GetContactAggregateType<T>>

    /**
     * Group by Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactGroupByArgs['orderBy'] }
        : { orderBy?: ContactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Contact model
   */
  readonly fields: ContactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Contact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    entreprise<T extends Contact$entrepriseArgs<ExtArgs> = {}>(args?: Subset<T, Contact$entrepriseArgs<ExtArgs>>): Prisma__EntrepriseClient<$Result.GetResult<Prisma.$EntreprisePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    client<T extends Contact$clientArgs<ExtArgs> = {}>(args?: Subset<T, Contact$clientArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    agent<T extends Contact$agentArgs<ExtArgs> = {}>(args?: Subset<T, Contact$agentArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    fournisseur<T extends Contact$fournisseurArgs<ExtArgs> = {}>(args?: Subset<T, Contact$fournisseurArgs<ExtArgs>>): Prisma__FournisseurClient<$Result.GetResult<Prisma.$FournisseurPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    reservations<T extends Contact$reservationsArgs<ExtArgs> = {}>(args?: Subset<T, Contact$reservationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    commandes<T extends Contact$commandesArgs<ExtArgs> = {}>(args?: Subset<T, Contact$commandesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommandePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Contact model
   */
  interface ContactFieldRefs {
    readonly id: FieldRef<"Contact", 'Int'>
    readonly tel: FieldRef<"Contact", 'String'>
    readonly isActive: FieldRef<"Contact", 'Boolean'>
    readonly agentId: FieldRef<"Contact", 'Int'>
    readonly fournisseurId: FieldRef<"Contact", 'Int'>
    readonly clientId: FieldRef<"Contact", 'Int'>
    readonly entrepriseId: FieldRef<"Contact", 'Int'>
    readonly createdAt: FieldRef<"Contact", 'DateTime'>
    readonly updatedAt: FieldRef<"Contact", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Contact findUnique
   */
  export type ContactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact findUniqueOrThrow
   */
  export type ContactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact findFirst
   */
  export type ContactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact findFirstOrThrow
   */
  export type ContactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact findMany
   */
  export type ContactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contacts to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact create
   */
  export type ContactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The data needed to create a Contact.
     */
    data: XOR<ContactCreateInput, ContactUncheckedCreateInput>
  }

  /**
   * Contact createMany
   */
  export type ContactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contacts.
     */
    data: ContactCreateManyInput | ContactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contact createManyAndReturn
   */
  export type ContactCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * The data used to create many Contacts.
     */
    data: ContactCreateManyInput | ContactCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Contact update
   */
  export type ContactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The data needed to update a Contact.
     */
    data: XOR<ContactUpdateInput, ContactUncheckedUpdateInput>
    /**
     * Choose, which Contact to update.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact updateMany
   */
  export type ContactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contacts.
     */
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyInput>
    /**
     * Filter which Contacts to update
     */
    where?: ContactWhereInput
    /**
     * Limit how many Contacts to update.
     */
    limit?: number
  }

  /**
   * Contact updateManyAndReturn
   */
  export type ContactUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * The data used to update Contacts.
     */
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyInput>
    /**
     * Filter which Contacts to update
     */
    where?: ContactWhereInput
    /**
     * Limit how many Contacts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Contact upsert
   */
  export type ContactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The filter to search for the Contact to update in case it exists.
     */
    where: ContactWhereUniqueInput
    /**
     * In case the Contact found by the `where` argument doesn't exist, create a new Contact with this data.
     */
    create: XOR<ContactCreateInput, ContactUncheckedCreateInput>
    /**
     * In case the Contact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactUpdateInput, ContactUncheckedUpdateInput>
  }

  /**
   * Contact delete
   */
  export type ContactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter which Contact to delete.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact deleteMany
   */
  export type ContactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contacts to delete
     */
    where?: ContactWhereInput
    /**
     * Limit how many Contacts to delete.
     */
    limit?: number
  }

  /**
   * Contact.entreprise
   */
  export type Contact$entrepriseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entreprise
     */
    select?: EntrepriseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Entreprise
     */
    omit?: EntrepriseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntrepriseInclude<ExtArgs> | null
    where?: EntrepriseWhereInput
  }

  /**
   * Contact.client
   */
  export type Contact$clientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
  }

  /**
   * Contact.agent
   */
  export type Contact$agentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    where?: AgentWhereInput
  }

  /**
   * Contact.fournisseur
   */
  export type Contact$fournisseurArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fournisseur
     */
    select?: FournisseurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fournisseur
     */
    omit?: FournisseurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FournisseurInclude<ExtArgs> | null
    where?: FournisseurWhereInput
  }

  /**
   * Contact.reservations
   */
  export type Contact$reservationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    where?: ReservationWhereInput
    orderBy?: ReservationOrderByWithRelationInput | ReservationOrderByWithRelationInput[]
    cursor?: ReservationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReservationScalarFieldEnum | ReservationScalarFieldEnum[]
  }

  /**
   * Contact.commandes
   */
  export type Contact$commandesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commande
     */
    select?: CommandeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Commande
     */
    omit?: CommandeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandeInclude<ExtArgs> | null
    where?: CommandeWhereInput
    orderBy?: CommandeOrderByWithRelationInput | CommandeOrderByWithRelationInput[]
    cursor?: CommandeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommandeScalarFieldEnum | CommandeScalarFieldEnum[]
  }

  /**
   * Contact without action
   */
  export type ContactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
  }


  /**
   * Model Fournisseur
   */

  export type AggregateFournisseur = {
    _count: FournisseurCountAggregateOutputType | null
    _avg: FournisseurAvgAggregateOutputType | null
    _sum: FournisseurSumAggregateOutputType | null
    _min: FournisseurMinAggregateOutputType | null
    _max: FournisseurMaxAggregateOutputType | null
  }

  export type FournisseurAvgAggregateOutputType = {
    id: number | null
    agentId: number | null
  }

  export type FournisseurSumAggregateOutputType = {
    id: number | null
    agentId: number | null
  }

  export type FournisseurMinAggregateOutputType = {
    id: number | null
    nom: string | null
    email: string | null
    codePostale: string | null
    agentId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FournisseurMaxAggregateOutputType = {
    id: number | null
    nom: string | null
    email: string | null
    codePostale: string | null
    agentId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FournisseurCountAggregateOutputType = {
    id: number
    nom: number
    email: number
    codePostale: number
    agentId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FournisseurAvgAggregateInputType = {
    id?: true
    agentId?: true
  }

  export type FournisseurSumAggregateInputType = {
    id?: true
    agentId?: true
  }

  export type FournisseurMinAggregateInputType = {
    id?: true
    nom?: true
    email?: true
    codePostale?: true
    agentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FournisseurMaxAggregateInputType = {
    id?: true
    nom?: true
    email?: true
    codePostale?: true
    agentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FournisseurCountAggregateInputType = {
    id?: true
    nom?: true
    email?: true
    codePostale?: true
    agentId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FournisseurAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Fournisseur to aggregate.
     */
    where?: FournisseurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fournisseurs to fetch.
     */
    orderBy?: FournisseurOrderByWithRelationInput | FournisseurOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FournisseurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fournisseurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fournisseurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Fournisseurs
    **/
    _count?: true | FournisseurCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FournisseurAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FournisseurSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FournisseurMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FournisseurMaxAggregateInputType
  }

  export type GetFournisseurAggregateType<T extends FournisseurAggregateArgs> = {
        [P in keyof T & keyof AggregateFournisseur]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFournisseur[P]>
      : GetScalarType<T[P], AggregateFournisseur[P]>
  }




  export type FournisseurGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FournisseurWhereInput
    orderBy?: FournisseurOrderByWithAggregationInput | FournisseurOrderByWithAggregationInput[]
    by: FournisseurScalarFieldEnum[] | FournisseurScalarFieldEnum
    having?: FournisseurScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FournisseurCountAggregateInputType | true
    _avg?: FournisseurAvgAggregateInputType
    _sum?: FournisseurSumAggregateInputType
    _min?: FournisseurMinAggregateInputType
    _max?: FournisseurMaxAggregateInputType
  }

  export type FournisseurGroupByOutputType = {
    id: number
    nom: string
    email: string
    codePostale: string | null
    agentId: number
    createdAt: Date
    updatedAt: Date
    _count: FournisseurCountAggregateOutputType | null
    _avg: FournisseurAvgAggregateOutputType | null
    _sum: FournisseurSumAggregateOutputType | null
    _min: FournisseurMinAggregateOutputType | null
    _max: FournisseurMaxAggregateOutputType | null
  }

  type GetFournisseurGroupByPayload<T extends FournisseurGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FournisseurGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FournisseurGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FournisseurGroupByOutputType[P]>
            : GetScalarType<T[P], FournisseurGroupByOutputType[P]>
        }
      >
    >


  export type FournisseurSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    email?: boolean
    codePostale?: boolean
    agentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    ventes?: boolean | Fournisseur$ventesArgs<ExtArgs>
    achats?: boolean | Fournisseur$achatsArgs<ExtArgs>
    adresses?: boolean | Fournisseur$adressesArgs<ExtArgs>
    contacts?: boolean | Fournisseur$contactsArgs<ExtArgs>
    reservations?: boolean | Fournisseur$reservationsArgs<ExtArgs>
    commandes?: boolean | Fournisseur$commandesArgs<ExtArgs>
    _count?: boolean | FournisseurCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fournisseur"]>

  export type FournisseurSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    email?: boolean
    codePostale?: boolean
    agentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fournisseur"]>

  export type FournisseurSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    email?: boolean
    codePostale?: boolean
    agentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fournisseur"]>

  export type FournisseurSelectScalar = {
    id?: boolean
    nom?: boolean
    email?: boolean
    codePostale?: boolean
    agentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FournisseurOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nom" | "email" | "codePostale" | "agentId" | "createdAt" | "updatedAt", ExtArgs["result"]["fournisseur"]>
  export type FournisseurInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    ventes?: boolean | Fournisseur$ventesArgs<ExtArgs>
    achats?: boolean | Fournisseur$achatsArgs<ExtArgs>
    adresses?: boolean | Fournisseur$adressesArgs<ExtArgs>
    contacts?: boolean | Fournisseur$contactsArgs<ExtArgs>
    reservations?: boolean | Fournisseur$reservationsArgs<ExtArgs>
    commandes?: boolean | Fournisseur$commandesArgs<ExtArgs>
    _count?: boolean | FournisseurCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FournisseurIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }
  export type FournisseurIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }

  export type $FournisseurPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Fournisseur"
    objects: {
      agent: Prisma.$AgentPayload<ExtArgs>
      ventes: Prisma.$VentePayload<ExtArgs>[]
      achats: Prisma.$AchatPayload<ExtArgs>[]
      adresses: Prisma.$AdressePayload<ExtArgs>[]
      contacts: Prisma.$ContactPayload<ExtArgs>[]
      reservations: Prisma.$ReservationPayload<ExtArgs>[]
      commandes: Prisma.$CommandePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nom: string
      email: string
      codePostale: string | null
      agentId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["fournisseur"]>
    composites: {}
  }

  type FournisseurGetPayload<S extends boolean | null | undefined | FournisseurDefaultArgs> = $Result.GetResult<Prisma.$FournisseurPayload, S>

  type FournisseurCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FournisseurFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FournisseurCountAggregateInputType | true
    }

  export interface FournisseurDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Fournisseur'], meta: { name: 'Fournisseur' } }
    /**
     * Find zero or one Fournisseur that matches the filter.
     * @param {FournisseurFindUniqueArgs} args - Arguments to find a Fournisseur
     * @example
     * // Get one Fournisseur
     * const fournisseur = await prisma.fournisseur.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FournisseurFindUniqueArgs>(args: SelectSubset<T, FournisseurFindUniqueArgs<ExtArgs>>): Prisma__FournisseurClient<$Result.GetResult<Prisma.$FournisseurPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Fournisseur that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FournisseurFindUniqueOrThrowArgs} args - Arguments to find a Fournisseur
     * @example
     * // Get one Fournisseur
     * const fournisseur = await prisma.fournisseur.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FournisseurFindUniqueOrThrowArgs>(args: SelectSubset<T, FournisseurFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FournisseurClient<$Result.GetResult<Prisma.$FournisseurPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Fournisseur that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FournisseurFindFirstArgs} args - Arguments to find a Fournisseur
     * @example
     * // Get one Fournisseur
     * const fournisseur = await prisma.fournisseur.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FournisseurFindFirstArgs>(args?: SelectSubset<T, FournisseurFindFirstArgs<ExtArgs>>): Prisma__FournisseurClient<$Result.GetResult<Prisma.$FournisseurPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Fournisseur that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FournisseurFindFirstOrThrowArgs} args - Arguments to find a Fournisseur
     * @example
     * // Get one Fournisseur
     * const fournisseur = await prisma.fournisseur.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FournisseurFindFirstOrThrowArgs>(args?: SelectSubset<T, FournisseurFindFirstOrThrowArgs<ExtArgs>>): Prisma__FournisseurClient<$Result.GetResult<Prisma.$FournisseurPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Fournisseurs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FournisseurFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Fournisseurs
     * const fournisseurs = await prisma.fournisseur.findMany()
     * 
     * // Get first 10 Fournisseurs
     * const fournisseurs = await prisma.fournisseur.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fournisseurWithIdOnly = await prisma.fournisseur.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FournisseurFindManyArgs>(args?: SelectSubset<T, FournisseurFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FournisseurPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Fournisseur.
     * @param {FournisseurCreateArgs} args - Arguments to create a Fournisseur.
     * @example
     * // Create one Fournisseur
     * const Fournisseur = await prisma.fournisseur.create({
     *   data: {
     *     // ... data to create a Fournisseur
     *   }
     * })
     * 
     */
    create<T extends FournisseurCreateArgs>(args: SelectSubset<T, FournisseurCreateArgs<ExtArgs>>): Prisma__FournisseurClient<$Result.GetResult<Prisma.$FournisseurPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Fournisseurs.
     * @param {FournisseurCreateManyArgs} args - Arguments to create many Fournisseurs.
     * @example
     * // Create many Fournisseurs
     * const fournisseur = await prisma.fournisseur.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FournisseurCreateManyArgs>(args?: SelectSubset<T, FournisseurCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Fournisseurs and returns the data saved in the database.
     * @param {FournisseurCreateManyAndReturnArgs} args - Arguments to create many Fournisseurs.
     * @example
     * // Create many Fournisseurs
     * const fournisseur = await prisma.fournisseur.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Fournisseurs and only return the `id`
     * const fournisseurWithIdOnly = await prisma.fournisseur.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FournisseurCreateManyAndReturnArgs>(args?: SelectSubset<T, FournisseurCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FournisseurPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Fournisseur.
     * @param {FournisseurDeleteArgs} args - Arguments to delete one Fournisseur.
     * @example
     * // Delete one Fournisseur
     * const Fournisseur = await prisma.fournisseur.delete({
     *   where: {
     *     // ... filter to delete one Fournisseur
     *   }
     * })
     * 
     */
    delete<T extends FournisseurDeleteArgs>(args: SelectSubset<T, FournisseurDeleteArgs<ExtArgs>>): Prisma__FournisseurClient<$Result.GetResult<Prisma.$FournisseurPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Fournisseur.
     * @param {FournisseurUpdateArgs} args - Arguments to update one Fournisseur.
     * @example
     * // Update one Fournisseur
     * const fournisseur = await prisma.fournisseur.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FournisseurUpdateArgs>(args: SelectSubset<T, FournisseurUpdateArgs<ExtArgs>>): Prisma__FournisseurClient<$Result.GetResult<Prisma.$FournisseurPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Fournisseurs.
     * @param {FournisseurDeleteManyArgs} args - Arguments to filter Fournisseurs to delete.
     * @example
     * // Delete a few Fournisseurs
     * const { count } = await prisma.fournisseur.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FournisseurDeleteManyArgs>(args?: SelectSubset<T, FournisseurDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fournisseurs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FournisseurUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Fournisseurs
     * const fournisseur = await prisma.fournisseur.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FournisseurUpdateManyArgs>(args: SelectSubset<T, FournisseurUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fournisseurs and returns the data updated in the database.
     * @param {FournisseurUpdateManyAndReturnArgs} args - Arguments to update many Fournisseurs.
     * @example
     * // Update many Fournisseurs
     * const fournisseur = await prisma.fournisseur.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Fournisseurs and only return the `id`
     * const fournisseurWithIdOnly = await prisma.fournisseur.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FournisseurUpdateManyAndReturnArgs>(args: SelectSubset<T, FournisseurUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FournisseurPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Fournisseur.
     * @param {FournisseurUpsertArgs} args - Arguments to update or create a Fournisseur.
     * @example
     * // Update or create a Fournisseur
     * const fournisseur = await prisma.fournisseur.upsert({
     *   create: {
     *     // ... data to create a Fournisseur
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Fournisseur we want to update
     *   }
     * })
     */
    upsert<T extends FournisseurUpsertArgs>(args: SelectSubset<T, FournisseurUpsertArgs<ExtArgs>>): Prisma__FournisseurClient<$Result.GetResult<Prisma.$FournisseurPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Fournisseurs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FournisseurCountArgs} args - Arguments to filter Fournisseurs to count.
     * @example
     * // Count the number of Fournisseurs
     * const count = await prisma.fournisseur.count({
     *   where: {
     *     // ... the filter for the Fournisseurs we want to count
     *   }
     * })
    **/
    count<T extends FournisseurCountArgs>(
      args?: Subset<T, FournisseurCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FournisseurCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Fournisseur.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FournisseurAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FournisseurAggregateArgs>(args: Subset<T, FournisseurAggregateArgs>): Prisma.PrismaPromise<GetFournisseurAggregateType<T>>

    /**
     * Group by Fournisseur.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FournisseurGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FournisseurGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FournisseurGroupByArgs['orderBy'] }
        : { orderBy?: FournisseurGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FournisseurGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFournisseurGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Fournisseur model
   */
  readonly fields: FournisseurFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Fournisseur.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FournisseurClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agent<T extends AgentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgentDefaultArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    ventes<T extends Fournisseur$ventesArgs<ExtArgs> = {}>(args?: Subset<T, Fournisseur$ventesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VentePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    achats<T extends Fournisseur$achatsArgs<ExtArgs> = {}>(args?: Subset<T, Fournisseur$achatsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    adresses<T extends Fournisseur$adressesArgs<ExtArgs> = {}>(args?: Subset<T, Fournisseur$adressesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdressePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    contacts<T extends Fournisseur$contactsArgs<ExtArgs> = {}>(args?: Subset<T, Fournisseur$contactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reservations<T extends Fournisseur$reservationsArgs<ExtArgs> = {}>(args?: Subset<T, Fournisseur$reservationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    commandes<T extends Fournisseur$commandesArgs<ExtArgs> = {}>(args?: Subset<T, Fournisseur$commandesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommandePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Fournisseur model
   */
  interface FournisseurFieldRefs {
    readonly id: FieldRef<"Fournisseur", 'Int'>
    readonly nom: FieldRef<"Fournisseur", 'String'>
    readonly email: FieldRef<"Fournisseur", 'String'>
    readonly codePostale: FieldRef<"Fournisseur", 'String'>
    readonly agentId: FieldRef<"Fournisseur", 'Int'>
    readonly createdAt: FieldRef<"Fournisseur", 'DateTime'>
    readonly updatedAt: FieldRef<"Fournisseur", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Fournisseur findUnique
   */
  export type FournisseurFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fournisseur
     */
    select?: FournisseurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fournisseur
     */
    omit?: FournisseurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FournisseurInclude<ExtArgs> | null
    /**
     * Filter, which Fournisseur to fetch.
     */
    where: FournisseurWhereUniqueInput
  }

  /**
   * Fournisseur findUniqueOrThrow
   */
  export type FournisseurFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fournisseur
     */
    select?: FournisseurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fournisseur
     */
    omit?: FournisseurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FournisseurInclude<ExtArgs> | null
    /**
     * Filter, which Fournisseur to fetch.
     */
    where: FournisseurWhereUniqueInput
  }

  /**
   * Fournisseur findFirst
   */
  export type FournisseurFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fournisseur
     */
    select?: FournisseurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fournisseur
     */
    omit?: FournisseurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FournisseurInclude<ExtArgs> | null
    /**
     * Filter, which Fournisseur to fetch.
     */
    where?: FournisseurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fournisseurs to fetch.
     */
    orderBy?: FournisseurOrderByWithRelationInput | FournisseurOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Fournisseurs.
     */
    cursor?: FournisseurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fournisseurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fournisseurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Fournisseurs.
     */
    distinct?: FournisseurScalarFieldEnum | FournisseurScalarFieldEnum[]
  }

  /**
   * Fournisseur findFirstOrThrow
   */
  export type FournisseurFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fournisseur
     */
    select?: FournisseurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fournisseur
     */
    omit?: FournisseurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FournisseurInclude<ExtArgs> | null
    /**
     * Filter, which Fournisseur to fetch.
     */
    where?: FournisseurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fournisseurs to fetch.
     */
    orderBy?: FournisseurOrderByWithRelationInput | FournisseurOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Fournisseurs.
     */
    cursor?: FournisseurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fournisseurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fournisseurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Fournisseurs.
     */
    distinct?: FournisseurScalarFieldEnum | FournisseurScalarFieldEnum[]
  }

  /**
   * Fournisseur findMany
   */
  export type FournisseurFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fournisseur
     */
    select?: FournisseurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fournisseur
     */
    omit?: FournisseurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FournisseurInclude<ExtArgs> | null
    /**
     * Filter, which Fournisseurs to fetch.
     */
    where?: FournisseurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fournisseurs to fetch.
     */
    orderBy?: FournisseurOrderByWithRelationInput | FournisseurOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Fournisseurs.
     */
    cursor?: FournisseurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fournisseurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fournisseurs.
     */
    skip?: number
    distinct?: FournisseurScalarFieldEnum | FournisseurScalarFieldEnum[]
  }

  /**
   * Fournisseur create
   */
  export type FournisseurCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fournisseur
     */
    select?: FournisseurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fournisseur
     */
    omit?: FournisseurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FournisseurInclude<ExtArgs> | null
    /**
     * The data needed to create a Fournisseur.
     */
    data: XOR<FournisseurCreateInput, FournisseurUncheckedCreateInput>
  }

  /**
   * Fournisseur createMany
   */
  export type FournisseurCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Fournisseurs.
     */
    data: FournisseurCreateManyInput | FournisseurCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Fournisseur createManyAndReturn
   */
  export type FournisseurCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fournisseur
     */
    select?: FournisseurSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Fournisseur
     */
    omit?: FournisseurOmit<ExtArgs> | null
    /**
     * The data used to create many Fournisseurs.
     */
    data: FournisseurCreateManyInput | FournisseurCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FournisseurIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Fournisseur update
   */
  export type FournisseurUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fournisseur
     */
    select?: FournisseurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fournisseur
     */
    omit?: FournisseurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FournisseurInclude<ExtArgs> | null
    /**
     * The data needed to update a Fournisseur.
     */
    data: XOR<FournisseurUpdateInput, FournisseurUncheckedUpdateInput>
    /**
     * Choose, which Fournisseur to update.
     */
    where: FournisseurWhereUniqueInput
  }

  /**
   * Fournisseur updateMany
   */
  export type FournisseurUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Fournisseurs.
     */
    data: XOR<FournisseurUpdateManyMutationInput, FournisseurUncheckedUpdateManyInput>
    /**
     * Filter which Fournisseurs to update
     */
    where?: FournisseurWhereInput
    /**
     * Limit how many Fournisseurs to update.
     */
    limit?: number
  }

  /**
   * Fournisseur updateManyAndReturn
   */
  export type FournisseurUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fournisseur
     */
    select?: FournisseurSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Fournisseur
     */
    omit?: FournisseurOmit<ExtArgs> | null
    /**
     * The data used to update Fournisseurs.
     */
    data: XOR<FournisseurUpdateManyMutationInput, FournisseurUncheckedUpdateManyInput>
    /**
     * Filter which Fournisseurs to update
     */
    where?: FournisseurWhereInput
    /**
     * Limit how many Fournisseurs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FournisseurIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Fournisseur upsert
   */
  export type FournisseurUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fournisseur
     */
    select?: FournisseurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fournisseur
     */
    omit?: FournisseurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FournisseurInclude<ExtArgs> | null
    /**
     * The filter to search for the Fournisseur to update in case it exists.
     */
    where: FournisseurWhereUniqueInput
    /**
     * In case the Fournisseur found by the `where` argument doesn't exist, create a new Fournisseur with this data.
     */
    create: XOR<FournisseurCreateInput, FournisseurUncheckedCreateInput>
    /**
     * In case the Fournisseur was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FournisseurUpdateInput, FournisseurUncheckedUpdateInput>
  }

  /**
   * Fournisseur delete
   */
  export type FournisseurDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fournisseur
     */
    select?: FournisseurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fournisseur
     */
    omit?: FournisseurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FournisseurInclude<ExtArgs> | null
    /**
     * Filter which Fournisseur to delete.
     */
    where: FournisseurWhereUniqueInput
  }

  /**
   * Fournisseur deleteMany
   */
  export type FournisseurDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Fournisseurs to delete
     */
    where?: FournisseurWhereInput
    /**
     * Limit how many Fournisseurs to delete.
     */
    limit?: number
  }

  /**
   * Fournisseur.ventes
   */
  export type Fournisseur$ventesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vente
     */
    select?: VenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vente
     */
    omit?: VenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenteInclude<ExtArgs> | null
    where?: VenteWhereInput
    orderBy?: VenteOrderByWithRelationInput | VenteOrderByWithRelationInput[]
    cursor?: VenteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VenteScalarFieldEnum | VenteScalarFieldEnum[]
  }

  /**
   * Fournisseur.achats
   */
  export type Fournisseur$achatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achat
     */
    select?: AchatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achat
     */
    omit?: AchatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchatInclude<ExtArgs> | null
    where?: AchatWhereInput
    orderBy?: AchatOrderByWithRelationInput | AchatOrderByWithRelationInput[]
    cursor?: AchatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AchatScalarFieldEnum | AchatScalarFieldEnum[]
  }

  /**
   * Fournisseur.adresses
   */
  export type Fournisseur$adressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adresse
     */
    select?: AdresseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Adresse
     */
    omit?: AdresseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdresseInclude<ExtArgs> | null
    where?: AdresseWhereInput
    orderBy?: AdresseOrderByWithRelationInput | AdresseOrderByWithRelationInput[]
    cursor?: AdresseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdresseScalarFieldEnum | AdresseScalarFieldEnum[]
  }

  /**
   * Fournisseur.contacts
   */
  export type Fournisseur$contactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    cursor?: ContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Fournisseur.reservations
   */
  export type Fournisseur$reservationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    where?: ReservationWhereInput
    orderBy?: ReservationOrderByWithRelationInput | ReservationOrderByWithRelationInput[]
    cursor?: ReservationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReservationScalarFieldEnum | ReservationScalarFieldEnum[]
  }

  /**
   * Fournisseur.commandes
   */
  export type Fournisseur$commandesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commande
     */
    select?: CommandeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Commande
     */
    omit?: CommandeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandeInclude<ExtArgs> | null
    where?: CommandeWhereInput
    orderBy?: CommandeOrderByWithRelationInput | CommandeOrderByWithRelationInput[]
    cursor?: CommandeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommandeScalarFieldEnum | CommandeScalarFieldEnum[]
  }

  /**
   * Fournisseur without action
   */
  export type FournisseurDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fournisseur
     */
    select?: FournisseurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fournisseur
     */
    omit?: FournisseurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FournisseurInclude<ExtArgs> | null
  }


  /**
   * Model Produit
   */

  export type AggregateProduit = {
    _count: ProduitCountAggregateOutputType | null
    _avg: ProduitAvgAggregateOutputType | null
    _sum: ProduitSumAggregateOutputType | null
    _min: ProduitMinAggregateOutputType | null
    _max: ProduitMaxAggregateOutputType | null
  }

  export type ProduitAvgAggregateOutputType = {
    id: number | null
    prixUnitaire: number | null
    qtteDisponible: number | null
    deviseId: number | null
    teneurId: number | null
    agentId: number | null
  }

  export type ProduitSumAggregateOutputType = {
    id: number | null
    prixUnitaire: number | null
    qtteDisponible: number | null
    deviseId: number | null
    teneurId: number | null
    agentId: number | null
  }

  export type ProduitMinAggregateOutputType = {
    id: number | null
    designation: string | null
    prixUnitaire: number | null
    qtteDisponible: number | null
    description: string | null
    deviseId: number | null
    teneurId: number | null
    agentId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProduitMaxAggregateOutputType = {
    id: number | null
    designation: string | null
    prixUnitaire: number | null
    qtteDisponible: number | null
    description: string | null
    deviseId: number | null
    teneurId: number | null
    agentId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProduitCountAggregateOutputType = {
    id: number
    designation: number
    prixUnitaire: number
    qtteDisponible: number
    description: number
    deviseId: number
    teneurId: number
    agentId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProduitAvgAggregateInputType = {
    id?: true
    prixUnitaire?: true
    qtteDisponible?: true
    deviseId?: true
    teneurId?: true
    agentId?: true
  }

  export type ProduitSumAggregateInputType = {
    id?: true
    prixUnitaire?: true
    qtteDisponible?: true
    deviseId?: true
    teneurId?: true
    agentId?: true
  }

  export type ProduitMinAggregateInputType = {
    id?: true
    designation?: true
    prixUnitaire?: true
    qtteDisponible?: true
    description?: true
    deviseId?: true
    teneurId?: true
    agentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProduitMaxAggregateInputType = {
    id?: true
    designation?: true
    prixUnitaire?: true
    qtteDisponible?: true
    description?: true
    deviseId?: true
    teneurId?: true
    agentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProduitCountAggregateInputType = {
    id?: true
    designation?: true
    prixUnitaire?: true
    qtteDisponible?: true
    description?: true
    deviseId?: true
    teneurId?: true
    agentId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProduitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Produit to aggregate.
     */
    where?: ProduitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Produits to fetch.
     */
    orderBy?: ProduitOrderByWithRelationInput | ProduitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProduitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Produits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Produits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Produits
    **/
    _count?: true | ProduitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProduitAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProduitSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProduitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProduitMaxAggregateInputType
  }

  export type GetProduitAggregateType<T extends ProduitAggregateArgs> = {
        [P in keyof T & keyof AggregateProduit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduit[P]>
      : GetScalarType<T[P], AggregateProduit[P]>
  }




  export type ProduitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProduitWhereInput
    orderBy?: ProduitOrderByWithAggregationInput | ProduitOrderByWithAggregationInput[]
    by: ProduitScalarFieldEnum[] | ProduitScalarFieldEnum
    having?: ProduitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProduitCountAggregateInputType | true
    _avg?: ProduitAvgAggregateInputType
    _sum?: ProduitSumAggregateInputType
    _min?: ProduitMinAggregateInputType
    _max?: ProduitMaxAggregateInputType
  }

  export type ProduitGroupByOutputType = {
    id: number
    designation: string
    prixUnitaire: number
    qtteDisponible: number
    description: string | null
    deviseId: number
    teneurId: number
    agentId: number
    createdAt: Date
    updatedAt: Date
    _count: ProduitCountAggregateOutputType | null
    _avg: ProduitAvgAggregateOutputType | null
    _sum: ProduitSumAggregateOutputType | null
    _min: ProduitMinAggregateOutputType | null
    _max: ProduitMaxAggregateOutputType | null
  }

  type GetProduitGroupByPayload<T extends ProduitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProduitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProduitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProduitGroupByOutputType[P]>
            : GetScalarType<T[P], ProduitGroupByOutputType[P]>
        }
      >
    >


  export type ProduitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    designation?: boolean
    prixUnitaire?: boolean
    qtteDisponible?: boolean
    description?: boolean
    deviseId?: boolean
    teneurId?: boolean
    agentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    detailsPaniers?: boolean | Produit$detailsPaniersArgs<ExtArgs>
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    devise?: boolean | DeviseDefaultArgs<ExtArgs>
    teneur?: boolean | TeneurDefaultArgs<ExtArgs>
    _count?: boolean | ProduitCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["produit"]>

  export type ProduitSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    designation?: boolean
    prixUnitaire?: boolean
    qtteDisponible?: boolean
    description?: boolean
    deviseId?: boolean
    teneurId?: boolean
    agentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    devise?: boolean | DeviseDefaultArgs<ExtArgs>
    teneur?: boolean | TeneurDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["produit"]>

  export type ProduitSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    designation?: boolean
    prixUnitaire?: boolean
    qtteDisponible?: boolean
    description?: boolean
    deviseId?: boolean
    teneurId?: boolean
    agentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    devise?: boolean | DeviseDefaultArgs<ExtArgs>
    teneur?: boolean | TeneurDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["produit"]>

  export type ProduitSelectScalar = {
    id?: boolean
    designation?: boolean
    prixUnitaire?: boolean
    qtteDisponible?: boolean
    description?: boolean
    deviseId?: boolean
    teneurId?: boolean
    agentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProduitOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "designation" | "prixUnitaire" | "qtteDisponible" | "description" | "deviseId" | "teneurId" | "agentId" | "createdAt" | "updatedAt", ExtArgs["result"]["produit"]>
  export type ProduitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    detailsPaniers?: boolean | Produit$detailsPaniersArgs<ExtArgs>
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    devise?: boolean | DeviseDefaultArgs<ExtArgs>
    teneur?: boolean | TeneurDefaultArgs<ExtArgs>
    _count?: boolean | ProduitCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProduitIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    devise?: boolean | DeviseDefaultArgs<ExtArgs>
    teneur?: boolean | TeneurDefaultArgs<ExtArgs>
  }
  export type ProduitIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    devise?: boolean | DeviseDefaultArgs<ExtArgs>
    teneur?: boolean | TeneurDefaultArgs<ExtArgs>
  }

  export type $ProduitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Produit"
    objects: {
      detailsPaniers: Prisma.$DetailPanierPayload<ExtArgs>[]
      agent: Prisma.$AgentPayload<ExtArgs>
      devise: Prisma.$DevisePayload<ExtArgs>
      teneur: Prisma.$TeneurPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      designation: string
      prixUnitaire: number
      qtteDisponible: number
      description: string | null
      deviseId: number
      teneurId: number
      agentId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["produit"]>
    composites: {}
  }

  type ProduitGetPayload<S extends boolean | null | undefined | ProduitDefaultArgs> = $Result.GetResult<Prisma.$ProduitPayload, S>

  type ProduitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProduitFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProduitCountAggregateInputType | true
    }

  export interface ProduitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Produit'], meta: { name: 'Produit' } }
    /**
     * Find zero or one Produit that matches the filter.
     * @param {ProduitFindUniqueArgs} args - Arguments to find a Produit
     * @example
     * // Get one Produit
     * const produit = await prisma.produit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProduitFindUniqueArgs>(args: SelectSubset<T, ProduitFindUniqueArgs<ExtArgs>>): Prisma__ProduitClient<$Result.GetResult<Prisma.$ProduitPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Produit that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProduitFindUniqueOrThrowArgs} args - Arguments to find a Produit
     * @example
     * // Get one Produit
     * const produit = await prisma.produit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProduitFindUniqueOrThrowArgs>(args: SelectSubset<T, ProduitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProduitClient<$Result.GetResult<Prisma.$ProduitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Produit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProduitFindFirstArgs} args - Arguments to find a Produit
     * @example
     * // Get one Produit
     * const produit = await prisma.produit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProduitFindFirstArgs>(args?: SelectSubset<T, ProduitFindFirstArgs<ExtArgs>>): Prisma__ProduitClient<$Result.GetResult<Prisma.$ProduitPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Produit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProduitFindFirstOrThrowArgs} args - Arguments to find a Produit
     * @example
     * // Get one Produit
     * const produit = await prisma.produit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProduitFindFirstOrThrowArgs>(args?: SelectSubset<T, ProduitFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProduitClient<$Result.GetResult<Prisma.$ProduitPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Produits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProduitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Produits
     * const produits = await prisma.produit.findMany()
     * 
     * // Get first 10 Produits
     * const produits = await prisma.produit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const produitWithIdOnly = await prisma.produit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProduitFindManyArgs>(args?: SelectSubset<T, ProduitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProduitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Produit.
     * @param {ProduitCreateArgs} args - Arguments to create a Produit.
     * @example
     * // Create one Produit
     * const Produit = await prisma.produit.create({
     *   data: {
     *     // ... data to create a Produit
     *   }
     * })
     * 
     */
    create<T extends ProduitCreateArgs>(args: SelectSubset<T, ProduitCreateArgs<ExtArgs>>): Prisma__ProduitClient<$Result.GetResult<Prisma.$ProduitPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Produits.
     * @param {ProduitCreateManyArgs} args - Arguments to create many Produits.
     * @example
     * // Create many Produits
     * const produit = await prisma.produit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProduitCreateManyArgs>(args?: SelectSubset<T, ProduitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Produits and returns the data saved in the database.
     * @param {ProduitCreateManyAndReturnArgs} args - Arguments to create many Produits.
     * @example
     * // Create many Produits
     * const produit = await prisma.produit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Produits and only return the `id`
     * const produitWithIdOnly = await prisma.produit.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProduitCreateManyAndReturnArgs>(args?: SelectSubset<T, ProduitCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProduitPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Produit.
     * @param {ProduitDeleteArgs} args - Arguments to delete one Produit.
     * @example
     * // Delete one Produit
     * const Produit = await prisma.produit.delete({
     *   where: {
     *     // ... filter to delete one Produit
     *   }
     * })
     * 
     */
    delete<T extends ProduitDeleteArgs>(args: SelectSubset<T, ProduitDeleteArgs<ExtArgs>>): Prisma__ProduitClient<$Result.GetResult<Prisma.$ProduitPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Produit.
     * @param {ProduitUpdateArgs} args - Arguments to update one Produit.
     * @example
     * // Update one Produit
     * const produit = await prisma.produit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProduitUpdateArgs>(args: SelectSubset<T, ProduitUpdateArgs<ExtArgs>>): Prisma__ProduitClient<$Result.GetResult<Prisma.$ProduitPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Produits.
     * @param {ProduitDeleteManyArgs} args - Arguments to filter Produits to delete.
     * @example
     * // Delete a few Produits
     * const { count } = await prisma.produit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProduitDeleteManyArgs>(args?: SelectSubset<T, ProduitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Produits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProduitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Produits
     * const produit = await prisma.produit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProduitUpdateManyArgs>(args: SelectSubset<T, ProduitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Produits and returns the data updated in the database.
     * @param {ProduitUpdateManyAndReturnArgs} args - Arguments to update many Produits.
     * @example
     * // Update many Produits
     * const produit = await prisma.produit.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Produits and only return the `id`
     * const produitWithIdOnly = await prisma.produit.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProduitUpdateManyAndReturnArgs>(args: SelectSubset<T, ProduitUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProduitPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Produit.
     * @param {ProduitUpsertArgs} args - Arguments to update or create a Produit.
     * @example
     * // Update or create a Produit
     * const produit = await prisma.produit.upsert({
     *   create: {
     *     // ... data to create a Produit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Produit we want to update
     *   }
     * })
     */
    upsert<T extends ProduitUpsertArgs>(args: SelectSubset<T, ProduitUpsertArgs<ExtArgs>>): Prisma__ProduitClient<$Result.GetResult<Prisma.$ProduitPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Produits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProduitCountArgs} args - Arguments to filter Produits to count.
     * @example
     * // Count the number of Produits
     * const count = await prisma.produit.count({
     *   where: {
     *     // ... the filter for the Produits we want to count
     *   }
     * })
    **/
    count<T extends ProduitCountArgs>(
      args?: Subset<T, ProduitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProduitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Produit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProduitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProduitAggregateArgs>(args: Subset<T, ProduitAggregateArgs>): Prisma.PrismaPromise<GetProduitAggregateType<T>>

    /**
     * Group by Produit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProduitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProduitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProduitGroupByArgs['orderBy'] }
        : { orderBy?: ProduitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProduitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProduitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Produit model
   */
  readonly fields: ProduitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Produit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProduitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    detailsPaniers<T extends Produit$detailsPaniersArgs<ExtArgs> = {}>(args?: Subset<T, Produit$detailsPaniersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DetailPanierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    agent<T extends AgentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgentDefaultArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    devise<T extends DeviseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DeviseDefaultArgs<ExtArgs>>): Prisma__DeviseClient<$Result.GetResult<Prisma.$DevisePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    teneur<T extends TeneurDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeneurDefaultArgs<ExtArgs>>): Prisma__TeneurClient<$Result.GetResult<Prisma.$TeneurPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Produit model
   */
  interface ProduitFieldRefs {
    readonly id: FieldRef<"Produit", 'Int'>
    readonly designation: FieldRef<"Produit", 'String'>
    readonly prixUnitaire: FieldRef<"Produit", 'Float'>
    readonly qtteDisponible: FieldRef<"Produit", 'Int'>
    readonly description: FieldRef<"Produit", 'String'>
    readonly deviseId: FieldRef<"Produit", 'Int'>
    readonly teneurId: FieldRef<"Produit", 'Int'>
    readonly agentId: FieldRef<"Produit", 'Int'>
    readonly createdAt: FieldRef<"Produit", 'DateTime'>
    readonly updatedAt: FieldRef<"Produit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Produit findUnique
   */
  export type ProduitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Produit
     */
    select?: ProduitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Produit
     */
    omit?: ProduitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProduitInclude<ExtArgs> | null
    /**
     * Filter, which Produit to fetch.
     */
    where: ProduitWhereUniqueInput
  }

  /**
   * Produit findUniqueOrThrow
   */
  export type ProduitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Produit
     */
    select?: ProduitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Produit
     */
    omit?: ProduitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProduitInclude<ExtArgs> | null
    /**
     * Filter, which Produit to fetch.
     */
    where: ProduitWhereUniqueInput
  }

  /**
   * Produit findFirst
   */
  export type ProduitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Produit
     */
    select?: ProduitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Produit
     */
    omit?: ProduitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProduitInclude<ExtArgs> | null
    /**
     * Filter, which Produit to fetch.
     */
    where?: ProduitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Produits to fetch.
     */
    orderBy?: ProduitOrderByWithRelationInput | ProduitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Produits.
     */
    cursor?: ProduitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Produits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Produits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Produits.
     */
    distinct?: ProduitScalarFieldEnum | ProduitScalarFieldEnum[]
  }

  /**
   * Produit findFirstOrThrow
   */
  export type ProduitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Produit
     */
    select?: ProduitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Produit
     */
    omit?: ProduitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProduitInclude<ExtArgs> | null
    /**
     * Filter, which Produit to fetch.
     */
    where?: ProduitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Produits to fetch.
     */
    orderBy?: ProduitOrderByWithRelationInput | ProduitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Produits.
     */
    cursor?: ProduitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Produits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Produits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Produits.
     */
    distinct?: ProduitScalarFieldEnum | ProduitScalarFieldEnum[]
  }

  /**
   * Produit findMany
   */
  export type ProduitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Produit
     */
    select?: ProduitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Produit
     */
    omit?: ProduitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProduitInclude<ExtArgs> | null
    /**
     * Filter, which Produits to fetch.
     */
    where?: ProduitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Produits to fetch.
     */
    orderBy?: ProduitOrderByWithRelationInput | ProduitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Produits.
     */
    cursor?: ProduitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Produits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Produits.
     */
    skip?: number
    distinct?: ProduitScalarFieldEnum | ProduitScalarFieldEnum[]
  }

  /**
   * Produit create
   */
  export type ProduitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Produit
     */
    select?: ProduitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Produit
     */
    omit?: ProduitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProduitInclude<ExtArgs> | null
    /**
     * The data needed to create a Produit.
     */
    data: XOR<ProduitCreateInput, ProduitUncheckedCreateInput>
  }

  /**
   * Produit createMany
   */
  export type ProduitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Produits.
     */
    data: ProduitCreateManyInput | ProduitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Produit createManyAndReturn
   */
  export type ProduitCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Produit
     */
    select?: ProduitSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Produit
     */
    omit?: ProduitOmit<ExtArgs> | null
    /**
     * The data used to create many Produits.
     */
    data: ProduitCreateManyInput | ProduitCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProduitIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Produit update
   */
  export type ProduitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Produit
     */
    select?: ProduitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Produit
     */
    omit?: ProduitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProduitInclude<ExtArgs> | null
    /**
     * The data needed to update a Produit.
     */
    data: XOR<ProduitUpdateInput, ProduitUncheckedUpdateInput>
    /**
     * Choose, which Produit to update.
     */
    where: ProduitWhereUniqueInput
  }

  /**
   * Produit updateMany
   */
  export type ProduitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Produits.
     */
    data: XOR<ProduitUpdateManyMutationInput, ProduitUncheckedUpdateManyInput>
    /**
     * Filter which Produits to update
     */
    where?: ProduitWhereInput
    /**
     * Limit how many Produits to update.
     */
    limit?: number
  }

  /**
   * Produit updateManyAndReturn
   */
  export type ProduitUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Produit
     */
    select?: ProduitSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Produit
     */
    omit?: ProduitOmit<ExtArgs> | null
    /**
     * The data used to update Produits.
     */
    data: XOR<ProduitUpdateManyMutationInput, ProduitUncheckedUpdateManyInput>
    /**
     * Filter which Produits to update
     */
    where?: ProduitWhereInput
    /**
     * Limit how many Produits to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProduitIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Produit upsert
   */
  export type ProduitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Produit
     */
    select?: ProduitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Produit
     */
    omit?: ProduitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProduitInclude<ExtArgs> | null
    /**
     * The filter to search for the Produit to update in case it exists.
     */
    where: ProduitWhereUniqueInput
    /**
     * In case the Produit found by the `where` argument doesn't exist, create a new Produit with this data.
     */
    create: XOR<ProduitCreateInput, ProduitUncheckedCreateInput>
    /**
     * In case the Produit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProduitUpdateInput, ProduitUncheckedUpdateInput>
  }

  /**
   * Produit delete
   */
  export type ProduitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Produit
     */
    select?: ProduitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Produit
     */
    omit?: ProduitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProduitInclude<ExtArgs> | null
    /**
     * Filter which Produit to delete.
     */
    where: ProduitWhereUniqueInput
  }

  /**
   * Produit deleteMany
   */
  export type ProduitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Produits to delete
     */
    where?: ProduitWhereInput
    /**
     * Limit how many Produits to delete.
     */
    limit?: number
  }

  /**
   * Produit.detailsPaniers
   */
  export type Produit$detailsPaniersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetailPanier
     */
    select?: DetailPanierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DetailPanier
     */
    omit?: DetailPanierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetailPanierInclude<ExtArgs> | null
    where?: DetailPanierWhereInput
    orderBy?: DetailPanierOrderByWithRelationInput | DetailPanierOrderByWithRelationInput[]
    cursor?: DetailPanierWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DetailPanierScalarFieldEnum | DetailPanierScalarFieldEnum[]
  }

  /**
   * Produit without action
   */
  export type ProduitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Produit
     */
    select?: ProduitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Produit
     */
    omit?: ProduitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProduitInclude<ExtArgs> | null
  }


  /**
   * Model Paiement
   */

  export type AggregatePaiement = {
    _count: PaiementCountAggregateOutputType | null
    _avg: PaiementAvgAggregateOutputType | null
    _sum: PaiementSumAggregateOutputType | null
    _min: PaiementMinAggregateOutputType | null
    _max: PaiementMaxAggregateOutputType | null
  }

  export type PaiementAvgAggregateOutputType = {
    id: number | null
    totalHT: number | null
    totalTTC: number | null
    deviseId: number | null
    caisseId: number | null
    venteId: number | null
    achatId: number | null
    commandeId: number | null
  }

  export type PaiementSumAggregateOutputType = {
    id: number | null
    totalHT: number | null
    totalTTC: number | null
    deviseId: number | null
    caisseId: number | null
    venteId: number | null
    achatId: number | null
    commandeId: number | null
  }

  export type PaiementMinAggregateOutputType = {
    id: number | null
    totalHT: number | null
    totalTTC: number | null
    modePaiement: $Enums.ModePaiment | null
    deviseId: number | null
    caisseId: number | null
    venteId: number | null
    achatId: number | null
    commandeId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaiementMaxAggregateOutputType = {
    id: number | null
    totalHT: number | null
    totalTTC: number | null
    modePaiement: $Enums.ModePaiment | null
    deviseId: number | null
    caisseId: number | null
    venteId: number | null
    achatId: number | null
    commandeId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaiementCountAggregateOutputType = {
    id: number
    totalHT: number
    totalTTC: number
    modePaiement: number
    deviseId: number
    caisseId: number
    venteId: number
    achatId: number
    commandeId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaiementAvgAggregateInputType = {
    id?: true
    totalHT?: true
    totalTTC?: true
    deviseId?: true
    caisseId?: true
    venteId?: true
    achatId?: true
    commandeId?: true
  }

  export type PaiementSumAggregateInputType = {
    id?: true
    totalHT?: true
    totalTTC?: true
    deviseId?: true
    caisseId?: true
    venteId?: true
    achatId?: true
    commandeId?: true
  }

  export type PaiementMinAggregateInputType = {
    id?: true
    totalHT?: true
    totalTTC?: true
    modePaiement?: true
    deviseId?: true
    caisseId?: true
    venteId?: true
    achatId?: true
    commandeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaiementMaxAggregateInputType = {
    id?: true
    totalHT?: true
    totalTTC?: true
    modePaiement?: true
    deviseId?: true
    caisseId?: true
    venteId?: true
    achatId?: true
    commandeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaiementCountAggregateInputType = {
    id?: true
    totalHT?: true
    totalTTC?: true
    modePaiement?: true
    deviseId?: true
    caisseId?: true
    venteId?: true
    achatId?: true
    commandeId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaiementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Paiement to aggregate.
     */
    where?: PaiementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Paiements to fetch.
     */
    orderBy?: PaiementOrderByWithRelationInput | PaiementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaiementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Paiements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Paiements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Paiements
    **/
    _count?: true | PaiementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaiementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaiementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaiementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaiementMaxAggregateInputType
  }

  export type GetPaiementAggregateType<T extends PaiementAggregateArgs> = {
        [P in keyof T & keyof AggregatePaiement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaiement[P]>
      : GetScalarType<T[P], AggregatePaiement[P]>
  }




  export type PaiementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaiementWhereInput
    orderBy?: PaiementOrderByWithAggregationInput | PaiementOrderByWithAggregationInput[]
    by: PaiementScalarFieldEnum[] | PaiementScalarFieldEnum
    having?: PaiementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaiementCountAggregateInputType | true
    _avg?: PaiementAvgAggregateInputType
    _sum?: PaiementSumAggregateInputType
    _min?: PaiementMinAggregateInputType
    _max?: PaiementMaxAggregateInputType
  }

  export type PaiementGroupByOutputType = {
    id: number
    totalHT: number | null
    totalTTC: number | null
    modePaiement: $Enums.ModePaiment
    deviseId: number
    caisseId: number
    venteId: number | null
    achatId: number | null
    commandeId: number | null
    createdAt: Date
    updatedAt: Date
    _count: PaiementCountAggregateOutputType | null
    _avg: PaiementAvgAggregateOutputType | null
    _sum: PaiementSumAggregateOutputType | null
    _min: PaiementMinAggregateOutputType | null
    _max: PaiementMaxAggregateOutputType | null
  }

  type GetPaiementGroupByPayload<T extends PaiementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaiementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaiementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaiementGroupByOutputType[P]>
            : GetScalarType<T[P], PaiementGroupByOutputType[P]>
        }
      >
    >


  export type PaiementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    totalHT?: boolean
    totalTTC?: boolean
    modePaiement?: boolean
    deviseId?: boolean
    caisseId?: boolean
    venteId?: boolean
    achatId?: boolean
    commandeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vente?: boolean | Paiement$venteArgs<ExtArgs>
    achat?: boolean | Paiement$achatArgs<ExtArgs>
    commande?: boolean | Paiement$commandeArgs<ExtArgs>
    caisse?: boolean | CaisseDefaultArgs<ExtArgs>
    devise?: boolean | DeviseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paiement"]>

  export type PaiementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    totalHT?: boolean
    totalTTC?: boolean
    modePaiement?: boolean
    deviseId?: boolean
    caisseId?: boolean
    venteId?: boolean
    achatId?: boolean
    commandeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vente?: boolean | Paiement$venteArgs<ExtArgs>
    achat?: boolean | Paiement$achatArgs<ExtArgs>
    commande?: boolean | Paiement$commandeArgs<ExtArgs>
    caisse?: boolean | CaisseDefaultArgs<ExtArgs>
    devise?: boolean | DeviseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paiement"]>

  export type PaiementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    totalHT?: boolean
    totalTTC?: boolean
    modePaiement?: boolean
    deviseId?: boolean
    caisseId?: boolean
    venteId?: boolean
    achatId?: boolean
    commandeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vente?: boolean | Paiement$venteArgs<ExtArgs>
    achat?: boolean | Paiement$achatArgs<ExtArgs>
    commande?: boolean | Paiement$commandeArgs<ExtArgs>
    caisse?: boolean | CaisseDefaultArgs<ExtArgs>
    devise?: boolean | DeviseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paiement"]>

  export type PaiementSelectScalar = {
    id?: boolean
    totalHT?: boolean
    totalTTC?: boolean
    modePaiement?: boolean
    deviseId?: boolean
    caisseId?: boolean
    venteId?: boolean
    achatId?: boolean
    commandeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaiementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "totalHT" | "totalTTC" | "modePaiement" | "deviseId" | "caisseId" | "venteId" | "achatId" | "commandeId" | "createdAt" | "updatedAt", ExtArgs["result"]["paiement"]>
  export type PaiementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vente?: boolean | Paiement$venteArgs<ExtArgs>
    achat?: boolean | Paiement$achatArgs<ExtArgs>
    commande?: boolean | Paiement$commandeArgs<ExtArgs>
    caisse?: boolean | CaisseDefaultArgs<ExtArgs>
    devise?: boolean | DeviseDefaultArgs<ExtArgs>
  }
  export type PaiementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vente?: boolean | Paiement$venteArgs<ExtArgs>
    achat?: boolean | Paiement$achatArgs<ExtArgs>
    commande?: boolean | Paiement$commandeArgs<ExtArgs>
    caisse?: boolean | CaisseDefaultArgs<ExtArgs>
    devise?: boolean | DeviseDefaultArgs<ExtArgs>
  }
  export type PaiementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vente?: boolean | Paiement$venteArgs<ExtArgs>
    achat?: boolean | Paiement$achatArgs<ExtArgs>
    commande?: boolean | Paiement$commandeArgs<ExtArgs>
    caisse?: boolean | CaisseDefaultArgs<ExtArgs>
    devise?: boolean | DeviseDefaultArgs<ExtArgs>
  }

  export type $PaiementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Paiement"
    objects: {
      vente: Prisma.$VentePayload<ExtArgs> | null
      achat: Prisma.$AchatPayload<ExtArgs> | null
      commande: Prisma.$CommandePayload<ExtArgs> | null
      caisse: Prisma.$CaissePayload<ExtArgs>
      devise: Prisma.$DevisePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      totalHT: number | null
      totalTTC: number | null
      modePaiement: $Enums.ModePaiment
      deviseId: number
      caisseId: number
      venteId: number | null
      achatId: number | null
      commandeId: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["paiement"]>
    composites: {}
  }

  type PaiementGetPayload<S extends boolean | null | undefined | PaiementDefaultArgs> = $Result.GetResult<Prisma.$PaiementPayload, S>

  type PaiementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaiementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaiementCountAggregateInputType | true
    }

  export interface PaiementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Paiement'], meta: { name: 'Paiement' } }
    /**
     * Find zero or one Paiement that matches the filter.
     * @param {PaiementFindUniqueArgs} args - Arguments to find a Paiement
     * @example
     * // Get one Paiement
     * const paiement = await prisma.paiement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaiementFindUniqueArgs>(args: SelectSubset<T, PaiementFindUniqueArgs<ExtArgs>>): Prisma__PaiementClient<$Result.GetResult<Prisma.$PaiementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Paiement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaiementFindUniqueOrThrowArgs} args - Arguments to find a Paiement
     * @example
     * // Get one Paiement
     * const paiement = await prisma.paiement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaiementFindUniqueOrThrowArgs>(args: SelectSubset<T, PaiementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaiementClient<$Result.GetResult<Prisma.$PaiementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Paiement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaiementFindFirstArgs} args - Arguments to find a Paiement
     * @example
     * // Get one Paiement
     * const paiement = await prisma.paiement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaiementFindFirstArgs>(args?: SelectSubset<T, PaiementFindFirstArgs<ExtArgs>>): Prisma__PaiementClient<$Result.GetResult<Prisma.$PaiementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Paiement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaiementFindFirstOrThrowArgs} args - Arguments to find a Paiement
     * @example
     * // Get one Paiement
     * const paiement = await prisma.paiement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaiementFindFirstOrThrowArgs>(args?: SelectSubset<T, PaiementFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaiementClient<$Result.GetResult<Prisma.$PaiementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Paiements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaiementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Paiements
     * const paiements = await prisma.paiement.findMany()
     * 
     * // Get first 10 Paiements
     * const paiements = await prisma.paiement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paiementWithIdOnly = await prisma.paiement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaiementFindManyArgs>(args?: SelectSubset<T, PaiementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaiementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Paiement.
     * @param {PaiementCreateArgs} args - Arguments to create a Paiement.
     * @example
     * // Create one Paiement
     * const Paiement = await prisma.paiement.create({
     *   data: {
     *     // ... data to create a Paiement
     *   }
     * })
     * 
     */
    create<T extends PaiementCreateArgs>(args: SelectSubset<T, PaiementCreateArgs<ExtArgs>>): Prisma__PaiementClient<$Result.GetResult<Prisma.$PaiementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Paiements.
     * @param {PaiementCreateManyArgs} args - Arguments to create many Paiements.
     * @example
     * // Create many Paiements
     * const paiement = await prisma.paiement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaiementCreateManyArgs>(args?: SelectSubset<T, PaiementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Paiements and returns the data saved in the database.
     * @param {PaiementCreateManyAndReturnArgs} args - Arguments to create many Paiements.
     * @example
     * // Create many Paiements
     * const paiement = await prisma.paiement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Paiements and only return the `id`
     * const paiementWithIdOnly = await prisma.paiement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaiementCreateManyAndReturnArgs>(args?: SelectSubset<T, PaiementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaiementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Paiement.
     * @param {PaiementDeleteArgs} args - Arguments to delete one Paiement.
     * @example
     * // Delete one Paiement
     * const Paiement = await prisma.paiement.delete({
     *   where: {
     *     // ... filter to delete one Paiement
     *   }
     * })
     * 
     */
    delete<T extends PaiementDeleteArgs>(args: SelectSubset<T, PaiementDeleteArgs<ExtArgs>>): Prisma__PaiementClient<$Result.GetResult<Prisma.$PaiementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Paiement.
     * @param {PaiementUpdateArgs} args - Arguments to update one Paiement.
     * @example
     * // Update one Paiement
     * const paiement = await prisma.paiement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaiementUpdateArgs>(args: SelectSubset<T, PaiementUpdateArgs<ExtArgs>>): Prisma__PaiementClient<$Result.GetResult<Prisma.$PaiementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Paiements.
     * @param {PaiementDeleteManyArgs} args - Arguments to filter Paiements to delete.
     * @example
     * // Delete a few Paiements
     * const { count } = await prisma.paiement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaiementDeleteManyArgs>(args?: SelectSubset<T, PaiementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Paiements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaiementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Paiements
     * const paiement = await prisma.paiement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaiementUpdateManyArgs>(args: SelectSubset<T, PaiementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Paiements and returns the data updated in the database.
     * @param {PaiementUpdateManyAndReturnArgs} args - Arguments to update many Paiements.
     * @example
     * // Update many Paiements
     * const paiement = await prisma.paiement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Paiements and only return the `id`
     * const paiementWithIdOnly = await prisma.paiement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaiementUpdateManyAndReturnArgs>(args: SelectSubset<T, PaiementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaiementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Paiement.
     * @param {PaiementUpsertArgs} args - Arguments to update or create a Paiement.
     * @example
     * // Update or create a Paiement
     * const paiement = await prisma.paiement.upsert({
     *   create: {
     *     // ... data to create a Paiement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Paiement we want to update
     *   }
     * })
     */
    upsert<T extends PaiementUpsertArgs>(args: SelectSubset<T, PaiementUpsertArgs<ExtArgs>>): Prisma__PaiementClient<$Result.GetResult<Prisma.$PaiementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Paiements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaiementCountArgs} args - Arguments to filter Paiements to count.
     * @example
     * // Count the number of Paiements
     * const count = await prisma.paiement.count({
     *   where: {
     *     // ... the filter for the Paiements we want to count
     *   }
     * })
    **/
    count<T extends PaiementCountArgs>(
      args?: Subset<T, PaiementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaiementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Paiement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaiementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaiementAggregateArgs>(args: Subset<T, PaiementAggregateArgs>): Prisma.PrismaPromise<GetPaiementAggregateType<T>>

    /**
     * Group by Paiement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaiementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaiementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaiementGroupByArgs['orderBy'] }
        : { orderBy?: PaiementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaiementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaiementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Paiement model
   */
  readonly fields: PaiementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Paiement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaiementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vente<T extends Paiement$venteArgs<ExtArgs> = {}>(args?: Subset<T, Paiement$venteArgs<ExtArgs>>): Prisma__VenteClient<$Result.GetResult<Prisma.$VentePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    achat<T extends Paiement$achatArgs<ExtArgs> = {}>(args?: Subset<T, Paiement$achatArgs<ExtArgs>>): Prisma__AchatClient<$Result.GetResult<Prisma.$AchatPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    commande<T extends Paiement$commandeArgs<ExtArgs> = {}>(args?: Subset<T, Paiement$commandeArgs<ExtArgs>>): Prisma__CommandeClient<$Result.GetResult<Prisma.$CommandePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    caisse<T extends CaisseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CaisseDefaultArgs<ExtArgs>>): Prisma__CaisseClient<$Result.GetResult<Prisma.$CaissePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    devise<T extends DeviseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DeviseDefaultArgs<ExtArgs>>): Prisma__DeviseClient<$Result.GetResult<Prisma.$DevisePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Paiement model
   */
  interface PaiementFieldRefs {
    readonly id: FieldRef<"Paiement", 'Int'>
    readonly totalHT: FieldRef<"Paiement", 'Float'>
    readonly totalTTC: FieldRef<"Paiement", 'Float'>
    readonly modePaiement: FieldRef<"Paiement", 'ModePaiment'>
    readonly deviseId: FieldRef<"Paiement", 'Int'>
    readonly caisseId: FieldRef<"Paiement", 'Int'>
    readonly venteId: FieldRef<"Paiement", 'Int'>
    readonly achatId: FieldRef<"Paiement", 'Int'>
    readonly commandeId: FieldRef<"Paiement", 'Int'>
    readonly createdAt: FieldRef<"Paiement", 'DateTime'>
    readonly updatedAt: FieldRef<"Paiement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Paiement findUnique
   */
  export type PaiementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paiement
     */
    select?: PaiementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Paiement
     */
    omit?: PaiementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaiementInclude<ExtArgs> | null
    /**
     * Filter, which Paiement to fetch.
     */
    where: PaiementWhereUniqueInput
  }

  /**
   * Paiement findUniqueOrThrow
   */
  export type PaiementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paiement
     */
    select?: PaiementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Paiement
     */
    omit?: PaiementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaiementInclude<ExtArgs> | null
    /**
     * Filter, which Paiement to fetch.
     */
    where: PaiementWhereUniqueInput
  }

  /**
   * Paiement findFirst
   */
  export type PaiementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paiement
     */
    select?: PaiementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Paiement
     */
    omit?: PaiementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaiementInclude<ExtArgs> | null
    /**
     * Filter, which Paiement to fetch.
     */
    where?: PaiementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Paiements to fetch.
     */
    orderBy?: PaiementOrderByWithRelationInput | PaiementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Paiements.
     */
    cursor?: PaiementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Paiements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Paiements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Paiements.
     */
    distinct?: PaiementScalarFieldEnum | PaiementScalarFieldEnum[]
  }

  /**
   * Paiement findFirstOrThrow
   */
  export type PaiementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paiement
     */
    select?: PaiementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Paiement
     */
    omit?: PaiementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaiementInclude<ExtArgs> | null
    /**
     * Filter, which Paiement to fetch.
     */
    where?: PaiementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Paiements to fetch.
     */
    orderBy?: PaiementOrderByWithRelationInput | PaiementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Paiements.
     */
    cursor?: PaiementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Paiements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Paiements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Paiements.
     */
    distinct?: PaiementScalarFieldEnum | PaiementScalarFieldEnum[]
  }

  /**
   * Paiement findMany
   */
  export type PaiementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paiement
     */
    select?: PaiementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Paiement
     */
    omit?: PaiementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaiementInclude<ExtArgs> | null
    /**
     * Filter, which Paiements to fetch.
     */
    where?: PaiementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Paiements to fetch.
     */
    orderBy?: PaiementOrderByWithRelationInput | PaiementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Paiements.
     */
    cursor?: PaiementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Paiements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Paiements.
     */
    skip?: number
    distinct?: PaiementScalarFieldEnum | PaiementScalarFieldEnum[]
  }

  /**
   * Paiement create
   */
  export type PaiementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paiement
     */
    select?: PaiementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Paiement
     */
    omit?: PaiementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaiementInclude<ExtArgs> | null
    /**
     * The data needed to create a Paiement.
     */
    data: XOR<PaiementCreateInput, PaiementUncheckedCreateInput>
  }

  /**
   * Paiement createMany
   */
  export type PaiementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Paiements.
     */
    data: PaiementCreateManyInput | PaiementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Paiement createManyAndReturn
   */
  export type PaiementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paiement
     */
    select?: PaiementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Paiement
     */
    omit?: PaiementOmit<ExtArgs> | null
    /**
     * The data used to create many Paiements.
     */
    data: PaiementCreateManyInput | PaiementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaiementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Paiement update
   */
  export type PaiementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paiement
     */
    select?: PaiementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Paiement
     */
    omit?: PaiementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaiementInclude<ExtArgs> | null
    /**
     * The data needed to update a Paiement.
     */
    data: XOR<PaiementUpdateInput, PaiementUncheckedUpdateInput>
    /**
     * Choose, which Paiement to update.
     */
    where: PaiementWhereUniqueInput
  }

  /**
   * Paiement updateMany
   */
  export type PaiementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Paiements.
     */
    data: XOR<PaiementUpdateManyMutationInput, PaiementUncheckedUpdateManyInput>
    /**
     * Filter which Paiements to update
     */
    where?: PaiementWhereInput
    /**
     * Limit how many Paiements to update.
     */
    limit?: number
  }

  /**
   * Paiement updateManyAndReturn
   */
  export type PaiementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paiement
     */
    select?: PaiementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Paiement
     */
    omit?: PaiementOmit<ExtArgs> | null
    /**
     * The data used to update Paiements.
     */
    data: XOR<PaiementUpdateManyMutationInput, PaiementUncheckedUpdateManyInput>
    /**
     * Filter which Paiements to update
     */
    where?: PaiementWhereInput
    /**
     * Limit how many Paiements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaiementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Paiement upsert
   */
  export type PaiementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paiement
     */
    select?: PaiementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Paiement
     */
    omit?: PaiementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaiementInclude<ExtArgs> | null
    /**
     * The filter to search for the Paiement to update in case it exists.
     */
    where: PaiementWhereUniqueInput
    /**
     * In case the Paiement found by the `where` argument doesn't exist, create a new Paiement with this data.
     */
    create: XOR<PaiementCreateInput, PaiementUncheckedCreateInput>
    /**
     * In case the Paiement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaiementUpdateInput, PaiementUncheckedUpdateInput>
  }

  /**
   * Paiement delete
   */
  export type PaiementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paiement
     */
    select?: PaiementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Paiement
     */
    omit?: PaiementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaiementInclude<ExtArgs> | null
    /**
     * Filter which Paiement to delete.
     */
    where: PaiementWhereUniqueInput
  }

  /**
   * Paiement deleteMany
   */
  export type PaiementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Paiements to delete
     */
    where?: PaiementWhereInput
    /**
     * Limit how many Paiements to delete.
     */
    limit?: number
  }

  /**
   * Paiement.vente
   */
  export type Paiement$venteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vente
     */
    select?: VenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vente
     */
    omit?: VenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenteInclude<ExtArgs> | null
    where?: VenteWhereInput
  }

  /**
   * Paiement.achat
   */
  export type Paiement$achatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achat
     */
    select?: AchatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achat
     */
    omit?: AchatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchatInclude<ExtArgs> | null
    where?: AchatWhereInput
  }

  /**
   * Paiement.commande
   */
  export type Paiement$commandeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commande
     */
    select?: CommandeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Commande
     */
    omit?: CommandeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandeInclude<ExtArgs> | null
    where?: CommandeWhereInput
  }

  /**
   * Paiement without action
   */
  export type PaiementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paiement
     */
    select?: PaiementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Paiement
     */
    omit?: PaiementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaiementInclude<ExtArgs> | null
  }


  /**
   * Model Caisse
   */

  export type AggregateCaisse = {
    _count: CaisseCountAggregateOutputType | null
    _avg: CaisseAvgAggregateOutputType | null
    _sum: CaisseSumAggregateOutputType | null
    _min: CaisseMinAggregateOutputType | null
    _max: CaisseMaxAggregateOutputType | null
  }

  export type CaisseAvgAggregateOutputType = {
    id: number | null
    soldeActuel: number | null
    deviseId: number | null
    agentId: number | null
  }

  export type CaisseSumAggregateOutputType = {
    id: number | null
    soldeActuel: number | null
    deviseId: number | null
    agentId: number | null
  }

  export type CaisseMinAggregateOutputType = {
    id: number | null
    nom: string | null
    description: string | null
    soldeActuel: number | null
    deviseId: number | null
    agentId: number | null
    statut: $Enums.StatutCaisse | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CaisseMaxAggregateOutputType = {
    id: number | null
    nom: string | null
    description: string | null
    soldeActuel: number | null
    deviseId: number | null
    agentId: number | null
    statut: $Enums.StatutCaisse | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CaisseCountAggregateOutputType = {
    id: number
    nom: number
    description: number
    soldeActuel: number
    deviseId: number
    agentId: number
    statut: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CaisseAvgAggregateInputType = {
    id?: true
    soldeActuel?: true
    deviseId?: true
    agentId?: true
  }

  export type CaisseSumAggregateInputType = {
    id?: true
    soldeActuel?: true
    deviseId?: true
    agentId?: true
  }

  export type CaisseMinAggregateInputType = {
    id?: true
    nom?: true
    description?: true
    soldeActuel?: true
    deviseId?: true
    agentId?: true
    statut?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CaisseMaxAggregateInputType = {
    id?: true
    nom?: true
    description?: true
    soldeActuel?: true
    deviseId?: true
    agentId?: true
    statut?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CaisseCountAggregateInputType = {
    id?: true
    nom?: true
    description?: true
    soldeActuel?: true
    deviseId?: true
    agentId?: true
    statut?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CaisseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Caisse to aggregate.
     */
    where?: CaisseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Caisses to fetch.
     */
    orderBy?: CaisseOrderByWithRelationInput | CaisseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CaisseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Caisses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Caisses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Caisses
    **/
    _count?: true | CaisseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CaisseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CaisseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CaisseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CaisseMaxAggregateInputType
  }

  export type GetCaisseAggregateType<T extends CaisseAggregateArgs> = {
        [P in keyof T & keyof AggregateCaisse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCaisse[P]>
      : GetScalarType<T[P], AggregateCaisse[P]>
  }




  export type CaisseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CaisseWhereInput
    orderBy?: CaisseOrderByWithAggregationInput | CaisseOrderByWithAggregationInput[]
    by: CaisseScalarFieldEnum[] | CaisseScalarFieldEnum
    having?: CaisseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CaisseCountAggregateInputType | true
    _avg?: CaisseAvgAggregateInputType
    _sum?: CaisseSumAggregateInputType
    _min?: CaisseMinAggregateInputType
    _max?: CaisseMaxAggregateInputType
  }

  export type CaisseGroupByOutputType = {
    id: number
    nom: string
    description: string | null
    soldeActuel: number | null
    deviseId: number
    agentId: number
    statut: $Enums.StatutCaisse
    createdAt: Date
    updatedAt: Date
    _count: CaisseCountAggregateOutputType | null
    _avg: CaisseAvgAggregateOutputType | null
    _sum: CaisseSumAggregateOutputType | null
    _min: CaisseMinAggregateOutputType | null
    _max: CaisseMaxAggregateOutputType | null
  }

  type GetCaisseGroupByPayload<T extends CaisseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CaisseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CaisseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CaisseGroupByOutputType[P]>
            : GetScalarType<T[P], CaisseGroupByOutputType[P]>
        }
      >
    >


  export type CaisseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    description?: boolean
    soldeActuel?: boolean
    deviseId?: boolean
    agentId?: boolean
    statut?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    devise?: boolean | DeviseDefaultArgs<ExtArgs>
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    mouvementCaisses?: boolean | Caisse$mouvementCaissesArgs<ExtArgs>
    paiements?: boolean | Caisse$paiementsArgs<ExtArgs>
    _count?: boolean | CaisseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["caisse"]>

  export type CaisseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    description?: boolean
    soldeActuel?: boolean
    deviseId?: boolean
    agentId?: boolean
    statut?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    devise?: boolean | DeviseDefaultArgs<ExtArgs>
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["caisse"]>

  export type CaisseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    description?: boolean
    soldeActuel?: boolean
    deviseId?: boolean
    agentId?: boolean
    statut?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    devise?: boolean | DeviseDefaultArgs<ExtArgs>
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["caisse"]>

  export type CaisseSelectScalar = {
    id?: boolean
    nom?: boolean
    description?: boolean
    soldeActuel?: boolean
    deviseId?: boolean
    agentId?: boolean
    statut?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CaisseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nom" | "description" | "soldeActuel" | "deviseId" | "agentId" | "statut" | "createdAt" | "updatedAt", ExtArgs["result"]["caisse"]>
  export type CaisseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    devise?: boolean | DeviseDefaultArgs<ExtArgs>
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    mouvementCaisses?: boolean | Caisse$mouvementCaissesArgs<ExtArgs>
    paiements?: boolean | Caisse$paiementsArgs<ExtArgs>
    _count?: boolean | CaisseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CaisseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    devise?: boolean | DeviseDefaultArgs<ExtArgs>
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }
  export type CaisseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    devise?: boolean | DeviseDefaultArgs<ExtArgs>
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }

  export type $CaissePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Caisse"
    objects: {
      devise: Prisma.$DevisePayload<ExtArgs>
      agent: Prisma.$AgentPayload<ExtArgs>
      mouvementCaisses: Prisma.$MouvementCaissePayload<ExtArgs>[]
      paiements: Prisma.$PaiementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nom: string
      description: string | null
      soldeActuel: number | null
      deviseId: number
      agentId: number
      statut: $Enums.StatutCaisse
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["caisse"]>
    composites: {}
  }

  type CaisseGetPayload<S extends boolean | null | undefined | CaisseDefaultArgs> = $Result.GetResult<Prisma.$CaissePayload, S>

  type CaisseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CaisseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CaisseCountAggregateInputType | true
    }

  export interface CaisseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Caisse'], meta: { name: 'Caisse' } }
    /**
     * Find zero or one Caisse that matches the filter.
     * @param {CaisseFindUniqueArgs} args - Arguments to find a Caisse
     * @example
     * // Get one Caisse
     * const caisse = await prisma.caisse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CaisseFindUniqueArgs>(args: SelectSubset<T, CaisseFindUniqueArgs<ExtArgs>>): Prisma__CaisseClient<$Result.GetResult<Prisma.$CaissePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Caisse that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CaisseFindUniqueOrThrowArgs} args - Arguments to find a Caisse
     * @example
     * // Get one Caisse
     * const caisse = await prisma.caisse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CaisseFindUniqueOrThrowArgs>(args: SelectSubset<T, CaisseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CaisseClient<$Result.GetResult<Prisma.$CaissePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Caisse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaisseFindFirstArgs} args - Arguments to find a Caisse
     * @example
     * // Get one Caisse
     * const caisse = await prisma.caisse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CaisseFindFirstArgs>(args?: SelectSubset<T, CaisseFindFirstArgs<ExtArgs>>): Prisma__CaisseClient<$Result.GetResult<Prisma.$CaissePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Caisse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaisseFindFirstOrThrowArgs} args - Arguments to find a Caisse
     * @example
     * // Get one Caisse
     * const caisse = await prisma.caisse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CaisseFindFirstOrThrowArgs>(args?: SelectSubset<T, CaisseFindFirstOrThrowArgs<ExtArgs>>): Prisma__CaisseClient<$Result.GetResult<Prisma.$CaissePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Caisses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaisseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Caisses
     * const caisses = await prisma.caisse.findMany()
     * 
     * // Get first 10 Caisses
     * const caisses = await prisma.caisse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const caisseWithIdOnly = await prisma.caisse.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CaisseFindManyArgs>(args?: SelectSubset<T, CaisseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CaissePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Caisse.
     * @param {CaisseCreateArgs} args - Arguments to create a Caisse.
     * @example
     * // Create one Caisse
     * const Caisse = await prisma.caisse.create({
     *   data: {
     *     // ... data to create a Caisse
     *   }
     * })
     * 
     */
    create<T extends CaisseCreateArgs>(args: SelectSubset<T, CaisseCreateArgs<ExtArgs>>): Prisma__CaisseClient<$Result.GetResult<Prisma.$CaissePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Caisses.
     * @param {CaisseCreateManyArgs} args - Arguments to create many Caisses.
     * @example
     * // Create many Caisses
     * const caisse = await prisma.caisse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CaisseCreateManyArgs>(args?: SelectSubset<T, CaisseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Caisses and returns the data saved in the database.
     * @param {CaisseCreateManyAndReturnArgs} args - Arguments to create many Caisses.
     * @example
     * // Create many Caisses
     * const caisse = await prisma.caisse.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Caisses and only return the `id`
     * const caisseWithIdOnly = await prisma.caisse.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CaisseCreateManyAndReturnArgs>(args?: SelectSubset<T, CaisseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CaissePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Caisse.
     * @param {CaisseDeleteArgs} args - Arguments to delete one Caisse.
     * @example
     * // Delete one Caisse
     * const Caisse = await prisma.caisse.delete({
     *   where: {
     *     // ... filter to delete one Caisse
     *   }
     * })
     * 
     */
    delete<T extends CaisseDeleteArgs>(args: SelectSubset<T, CaisseDeleteArgs<ExtArgs>>): Prisma__CaisseClient<$Result.GetResult<Prisma.$CaissePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Caisse.
     * @param {CaisseUpdateArgs} args - Arguments to update one Caisse.
     * @example
     * // Update one Caisse
     * const caisse = await prisma.caisse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CaisseUpdateArgs>(args: SelectSubset<T, CaisseUpdateArgs<ExtArgs>>): Prisma__CaisseClient<$Result.GetResult<Prisma.$CaissePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Caisses.
     * @param {CaisseDeleteManyArgs} args - Arguments to filter Caisses to delete.
     * @example
     * // Delete a few Caisses
     * const { count } = await prisma.caisse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CaisseDeleteManyArgs>(args?: SelectSubset<T, CaisseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Caisses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaisseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Caisses
     * const caisse = await prisma.caisse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CaisseUpdateManyArgs>(args: SelectSubset<T, CaisseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Caisses and returns the data updated in the database.
     * @param {CaisseUpdateManyAndReturnArgs} args - Arguments to update many Caisses.
     * @example
     * // Update many Caisses
     * const caisse = await prisma.caisse.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Caisses and only return the `id`
     * const caisseWithIdOnly = await prisma.caisse.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CaisseUpdateManyAndReturnArgs>(args: SelectSubset<T, CaisseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CaissePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Caisse.
     * @param {CaisseUpsertArgs} args - Arguments to update or create a Caisse.
     * @example
     * // Update or create a Caisse
     * const caisse = await prisma.caisse.upsert({
     *   create: {
     *     // ... data to create a Caisse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Caisse we want to update
     *   }
     * })
     */
    upsert<T extends CaisseUpsertArgs>(args: SelectSubset<T, CaisseUpsertArgs<ExtArgs>>): Prisma__CaisseClient<$Result.GetResult<Prisma.$CaissePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Caisses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaisseCountArgs} args - Arguments to filter Caisses to count.
     * @example
     * // Count the number of Caisses
     * const count = await prisma.caisse.count({
     *   where: {
     *     // ... the filter for the Caisses we want to count
     *   }
     * })
    **/
    count<T extends CaisseCountArgs>(
      args?: Subset<T, CaisseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CaisseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Caisse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaisseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CaisseAggregateArgs>(args: Subset<T, CaisseAggregateArgs>): Prisma.PrismaPromise<GetCaisseAggregateType<T>>

    /**
     * Group by Caisse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaisseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CaisseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CaisseGroupByArgs['orderBy'] }
        : { orderBy?: CaisseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CaisseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCaisseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Caisse model
   */
  readonly fields: CaisseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Caisse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CaisseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    devise<T extends DeviseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DeviseDefaultArgs<ExtArgs>>): Prisma__DeviseClient<$Result.GetResult<Prisma.$DevisePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    agent<T extends AgentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgentDefaultArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    mouvementCaisses<T extends Caisse$mouvementCaissesArgs<ExtArgs> = {}>(args?: Subset<T, Caisse$mouvementCaissesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MouvementCaissePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    paiements<T extends Caisse$paiementsArgs<ExtArgs> = {}>(args?: Subset<T, Caisse$paiementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaiementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Caisse model
   */
  interface CaisseFieldRefs {
    readonly id: FieldRef<"Caisse", 'Int'>
    readonly nom: FieldRef<"Caisse", 'String'>
    readonly description: FieldRef<"Caisse", 'String'>
    readonly soldeActuel: FieldRef<"Caisse", 'Float'>
    readonly deviseId: FieldRef<"Caisse", 'Int'>
    readonly agentId: FieldRef<"Caisse", 'Int'>
    readonly statut: FieldRef<"Caisse", 'StatutCaisse'>
    readonly createdAt: FieldRef<"Caisse", 'DateTime'>
    readonly updatedAt: FieldRef<"Caisse", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Caisse findUnique
   */
  export type CaisseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Caisse
     */
    select?: CaisseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Caisse
     */
    omit?: CaisseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaisseInclude<ExtArgs> | null
    /**
     * Filter, which Caisse to fetch.
     */
    where: CaisseWhereUniqueInput
  }

  /**
   * Caisse findUniqueOrThrow
   */
  export type CaisseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Caisse
     */
    select?: CaisseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Caisse
     */
    omit?: CaisseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaisseInclude<ExtArgs> | null
    /**
     * Filter, which Caisse to fetch.
     */
    where: CaisseWhereUniqueInput
  }

  /**
   * Caisse findFirst
   */
  export type CaisseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Caisse
     */
    select?: CaisseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Caisse
     */
    omit?: CaisseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaisseInclude<ExtArgs> | null
    /**
     * Filter, which Caisse to fetch.
     */
    where?: CaisseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Caisses to fetch.
     */
    orderBy?: CaisseOrderByWithRelationInput | CaisseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Caisses.
     */
    cursor?: CaisseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Caisses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Caisses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Caisses.
     */
    distinct?: CaisseScalarFieldEnum | CaisseScalarFieldEnum[]
  }

  /**
   * Caisse findFirstOrThrow
   */
  export type CaisseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Caisse
     */
    select?: CaisseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Caisse
     */
    omit?: CaisseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaisseInclude<ExtArgs> | null
    /**
     * Filter, which Caisse to fetch.
     */
    where?: CaisseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Caisses to fetch.
     */
    orderBy?: CaisseOrderByWithRelationInput | CaisseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Caisses.
     */
    cursor?: CaisseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Caisses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Caisses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Caisses.
     */
    distinct?: CaisseScalarFieldEnum | CaisseScalarFieldEnum[]
  }

  /**
   * Caisse findMany
   */
  export type CaisseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Caisse
     */
    select?: CaisseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Caisse
     */
    omit?: CaisseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaisseInclude<ExtArgs> | null
    /**
     * Filter, which Caisses to fetch.
     */
    where?: CaisseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Caisses to fetch.
     */
    orderBy?: CaisseOrderByWithRelationInput | CaisseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Caisses.
     */
    cursor?: CaisseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Caisses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Caisses.
     */
    skip?: number
    distinct?: CaisseScalarFieldEnum | CaisseScalarFieldEnum[]
  }

  /**
   * Caisse create
   */
  export type CaisseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Caisse
     */
    select?: CaisseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Caisse
     */
    omit?: CaisseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaisseInclude<ExtArgs> | null
    /**
     * The data needed to create a Caisse.
     */
    data: XOR<CaisseCreateInput, CaisseUncheckedCreateInput>
  }

  /**
   * Caisse createMany
   */
  export type CaisseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Caisses.
     */
    data: CaisseCreateManyInput | CaisseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Caisse createManyAndReturn
   */
  export type CaisseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Caisse
     */
    select?: CaisseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Caisse
     */
    omit?: CaisseOmit<ExtArgs> | null
    /**
     * The data used to create many Caisses.
     */
    data: CaisseCreateManyInput | CaisseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaisseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Caisse update
   */
  export type CaisseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Caisse
     */
    select?: CaisseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Caisse
     */
    omit?: CaisseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaisseInclude<ExtArgs> | null
    /**
     * The data needed to update a Caisse.
     */
    data: XOR<CaisseUpdateInput, CaisseUncheckedUpdateInput>
    /**
     * Choose, which Caisse to update.
     */
    where: CaisseWhereUniqueInput
  }

  /**
   * Caisse updateMany
   */
  export type CaisseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Caisses.
     */
    data: XOR<CaisseUpdateManyMutationInput, CaisseUncheckedUpdateManyInput>
    /**
     * Filter which Caisses to update
     */
    where?: CaisseWhereInput
    /**
     * Limit how many Caisses to update.
     */
    limit?: number
  }

  /**
   * Caisse updateManyAndReturn
   */
  export type CaisseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Caisse
     */
    select?: CaisseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Caisse
     */
    omit?: CaisseOmit<ExtArgs> | null
    /**
     * The data used to update Caisses.
     */
    data: XOR<CaisseUpdateManyMutationInput, CaisseUncheckedUpdateManyInput>
    /**
     * Filter which Caisses to update
     */
    where?: CaisseWhereInput
    /**
     * Limit how many Caisses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaisseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Caisse upsert
   */
  export type CaisseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Caisse
     */
    select?: CaisseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Caisse
     */
    omit?: CaisseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaisseInclude<ExtArgs> | null
    /**
     * The filter to search for the Caisse to update in case it exists.
     */
    where: CaisseWhereUniqueInput
    /**
     * In case the Caisse found by the `where` argument doesn't exist, create a new Caisse with this data.
     */
    create: XOR<CaisseCreateInput, CaisseUncheckedCreateInput>
    /**
     * In case the Caisse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CaisseUpdateInput, CaisseUncheckedUpdateInput>
  }

  /**
   * Caisse delete
   */
  export type CaisseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Caisse
     */
    select?: CaisseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Caisse
     */
    omit?: CaisseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaisseInclude<ExtArgs> | null
    /**
     * Filter which Caisse to delete.
     */
    where: CaisseWhereUniqueInput
  }

  /**
   * Caisse deleteMany
   */
  export type CaisseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Caisses to delete
     */
    where?: CaisseWhereInput
    /**
     * Limit how many Caisses to delete.
     */
    limit?: number
  }

  /**
   * Caisse.mouvementCaisses
   */
  export type Caisse$mouvementCaissesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MouvementCaisse
     */
    select?: MouvementCaisseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MouvementCaisse
     */
    omit?: MouvementCaisseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MouvementCaisseInclude<ExtArgs> | null
    where?: MouvementCaisseWhereInput
    orderBy?: MouvementCaisseOrderByWithRelationInput | MouvementCaisseOrderByWithRelationInput[]
    cursor?: MouvementCaisseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MouvementCaisseScalarFieldEnum | MouvementCaisseScalarFieldEnum[]
  }

  /**
   * Caisse.paiements
   */
  export type Caisse$paiementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paiement
     */
    select?: PaiementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Paiement
     */
    omit?: PaiementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaiementInclude<ExtArgs> | null
    where?: PaiementWhereInput
    orderBy?: PaiementOrderByWithRelationInput | PaiementOrderByWithRelationInput[]
    cursor?: PaiementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaiementScalarFieldEnum | PaiementScalarFieldEnum[]
  }

  /**
   * Caisse without action
   */
  export type CaisseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Caisse
     */
    select?: CaisseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Caisse
     */
    omit?: CaisseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaisseInclude<ExtArgs> | null
  }


  /**
   * Model Vente
   */

  export type AggregateVente = {
    _count: VenteCountAggregateOutputType | null
    _avg: VenteAvgAggregateOutputType | null
    _sum: VenteSumAggregateOutputType | null
    _min: VenteMinAggregateOutputType | null
    _max: VenteMaxAggregateOutputType | null
  }

  export type VenteAvgAggregateOutputType = {
    id: number | null
    clientId: number | null
    agentId: number | null
    fournisseurId: number | null
    panierId: number | null
  }

  export type VenteSumAggregateOutputType = {
    id: number | null
    clientId: number | null
    agentId: number | null
    fournisseurId: number | null
    panierId: number | null
  }

  export type VenteMinAggregateOutputType = {
    id: number | null
    statut: $Enums.StatutVente | null
    typeAcheteur: $Enums.TypeClient | null
    clientId: number | null
    agentId: number | null
    fournisseurId: number | null
    panierId: number | null
    enregistrerPar: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VenteMaxAggregateOutputType = {
    id: number | null
    statut: $Enums.StatutVente | null
    typeAcheteur: $Enums.TypeClient | null
    clientId: number | null
    agentId: number | null
    fournisseurId: number | null
    panierId: number | null
    enregistrerPar: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VenteCountAggregateOutputType = {
    id: number
    statut: number
    typeAcheteur: number
    clientId: number
    agentId: number
    fournisseurId: number
    panierId: number
    enregistrerPar: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VenteAvgAggregateInputType = {
    id?: true
    clientId?: true
    agentId?: true
    fournisseurId?: true
    panierId?: true
  }

  export type VenteSumAggregateInputType = {
    id?: true
    clientId?: true
    agentId?: true
    fournisseurId?: true
    panierId?: true
  }

  export type VenteMinAggregateInputType = {
    id?: true
    statut?: true
    typeAcheteur?: true
    clientId?: true
    agentId?: true
    fournisseurId?: true
    panierId?: true
    enregistrerPar?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VenteMaxAggregateInputType = {
    id?: true
    statut?: true
    typeAcheteur?: true
    clientId?: true
    agentId?: true
    fournisseurId?: true
    panierId?: true
    enregistrerPar?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VenteCountAggregateInputType = {
    id?: true
    statut?: true
    typeAcheteur?: true
    clientId?: true
    agentId?: true
    fournisseurId?: true
    panierId?: true
    enregistrerPar?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VenteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vente to aggregate.
     */
    where?: VenteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ventes to fetch.
     */
    orderBy?: VenteOrderByWithRelationInput | VenteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VenteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ventes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ventes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Ventes
    **/
    _count?: true | VenteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VenteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VenteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VenteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VenteMaxAggregateInputType
  }

  export type GetVenteAggregateType<T extends VenteAggregateArgs> = {
        [P in keyof T & keyof AggregateVente]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVente[P]>
      : GetScalarType<T[P], AggregateVente[P]>
  }




  export type VenteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VenteWhereInput
    orderBy?: VenteOrderByWithAggregationInput | VenteOrderByWithAggregationInput[]
    by: VenteScalarFieldEnum[] | VenteScalarFieldEnum
    having?: VenteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VenteCountAggregateInputType | true
    _avg?: VenteAvgAggregateInputType
    _sum?: VenteSumAggregateInputType
    _min?: VenteMinAggregateInputType
    _max?: VenteMaxAggregateInputType
  }

  export type VenteGroupByOutputType = {
    id: number
    statut: $Enums.StatutVente
    typeAcheteur: $Enums.TypeClient
    clientId: number | null
    agentId: number | null
    fournisseurId: number | null
    panierId: number
    enregistrerPar: string | null
    createdAt: Date
    updatedAt: Date
    _count: VenteCountAggregateOutputType | null
    _avg: VenteAvgAggregateOutputType | null
    _sum: VenteSumAggregateOutputType | null
    _min: VenteMinAggregateOutputType | null
    _max: VenteMaxAggregateOutputType | null
  }

  type GetVenteGroupByPayload<T extends VenteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VenteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VenteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VenteGroupByOutputType[P]>
            : GetScalarType<T[P], VenteGroupByOutputType[P]>
        }
      >
    >


  export type VenteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    statut?: boolean
    typeAcheteur?: boolean
    clientId?: boolean
    agentId?: boolean
    fournisseurId?: boolean
    panierId?: boolean
    enregistrerPar?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    panier?: boolean | PanierDefaultArgs<ExtArgs>
    agent?: boolean | Vente$agentArgs<ExtArgs>
    fournisseur?: boolean | Vente$fournisseurArgs<ExtArgs>
    client?: boolean | Vente$clientArgs<ExtArgs>
    paiements?: boolean | Vente$paiementsArgs<ExtArgs>
    _count?: boolean | VenteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vente"]>

  export type VenteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    statut?: boolean
    typeAcheteur?: boolean
    clientId?: boolean
    agentId?: boolean
    fournisseurId?: boolean
    panierId?: boolean
    enregistrerPar?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    panier?: boolean | PanierDefaultArgs<ExtArgs>
    agent?: boolean | Vente$agentArgs<ExtArgs>
    fournisseur?: boolean | Vente$fournisseurArgs<ExtArgs>
    client?: boolean | Vente$clientArgs<ExtArgs>
  }, ExtArgs["result"]["vente"]>

  export type VenteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    statut?: boolean
    typeAcheteur?: boolean
    clientId?: boolean
    agentId?: boolean
    fournisseurId?: boolean
    panierId?: boolean
    enregistrerPar?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    panier?: boolean | PanierDefaultArgs<ExtArgs>
    agent?: boolean | Vente$agentArgs<ExtArgs>
    fournisseur?: boolean | Vente$fournisseurArgs<ExtArgs>
    client?: boolean | Vente$clientArgs<ExtArgs>
  }, ExtArgs["result"]["vente"]>

  export type VenteSelectScalar = {
    id?: boolean
    statut?: boolean
    typeAcheteur?: boolean
    clientId?: boolean
    agentId?: boolean
    fournisseurId?: boolean
    panierId?: boolean
    enregistrerPar?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VenteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "statut" | "typeAcheteur" | "clientId" | "agentId" | "fournisseurId" | "panierId" | "enregistrerPar" | "createdAt" | "updatedAt", ExtArgs["result"]["vente"]>
  export type VenteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    panier?: boolean | PanierDefaultArgs<ExtArgs>
    agent?: boolean | Vente$agentArgs<ExtArgs>
    fournisseur?: boolean | Vente$fournisseurArgs<ExtArgs>
    client?: boolean | Vente$clientArgs<ExtArgs>
    paiements?: boolean | Vente$paiementsArgs<ExtArgs>
    _count?: boolean | VenteCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VenteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    panier?: boolean | PanierDefaultArgs<ExtArgs>
    agent?: boolean | Vente$agentArgs<ExtArgs>
    fournisseur?: boolean | Vente$fournisseurArgs<ExtArgs>
    client?: boolean | Vente$clientArgs<ExtArgs>
  }
  export type VenteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    panier?: boolean | PanierDefaultArgs<ExtArgs>
    agent?: boolean | Vente$agentArgs<ExtArgs>
    fournisseur?: boolean | Vente$fournisseurArgs<ExtArgs>
    client?: boolean | Vente$clientArgs<ExtArgs>
  }

  export type $VentePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Vente"
    objects: {
      panier: Prisma.$PanierPayload<ExtArgs>
      agent: Prisma.$AgentPayload<ExtArgs> | null
      fournisseur: Prisma.$FournisseurPayload<ExtArgs> | null
      client: Prisma.$ClientPayload<ExtArgs> | null
      paiements: Prisma.$PaiementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      statut: $Enums.StatutVente
      typeAcheteur: $Enums.TypeClient
      clientId: number | null
      agentId: number | null
      fournisseurId: number | null
      panierId: number
      enregistrerPar: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["vente"]>
    composites: {}
  }

  type VenteGetPayload<S extends boolean | null | undefined | VenteDefaultArgs> = $Result.GetResult<Prisma.$VentePayload, S>

  type VenteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VenteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VenteCountAggregateInputType | true
    }

  export interface VenteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Vente'], meta: { name: 'Vente' } }
    /**
     * Find zero or one Vente that matches the filter.
     * @param {VenteFindUniqueArgs} args - Arguments to find a Vente
     * @example
     * // Get one Vente
     * const vente = await prisma.vente.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VenteFindUniqueArgs>(args: SelectSubset<T, VenteFindUniqueArgs<ExtArgs>>): Prisma__VenteClient<$Result.GetResult<Prisma.$VentePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Vente that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VenteFindUniqueOrThrowArgs} args - Arguments to find a Vente
     * @example
     * // Get one Vente
     * const vente = await prisma.vente.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VenteFindUniqueOrThrowArgs>(args: SelectSubset<T, VenteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VenteClient<$Result.GetResult<Prisma.$VentePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vente that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenteFindFirstArgs} args - Arguments to find a Vente
     * @example
     * // Get one Vente
     * const vente = await prisma.vente.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VenteFindFirstArgs>(args?: SelectSubset<T, VenteFindFirstArgs<ExtArgs>>): Prisma__VenteClient<$Result.GetResult<Prisma.$VentePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vente that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenteFindFirstOrThrowArgs} args - Arguments to find a Vente
     * @example
     * // Get one Vente
     * const vente = await prisma.vente.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VenteFindFirstOrThrowArgs>(args?: SelectSubset<T, VenteFindFirstOrThrowArgs<ExtArgs>>): Prisma__VenteClient<$Result.GetResult<Prisma.$VentePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ventes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ventes
     * const ventes = await prisma.vente.findMany()
     * 
     * // Get first 10 Ventes
     * const ventes = await prisma.vente.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const venteWithIdOnly = await prisma.vente.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VenteFindManyArgs>(args?: SelectSubset<T, VenteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VentePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Vente.
     * @param {VenteCreateArgs} args - Arguments to create a Vente.
     * @example
     * // Create one Vente
     * const Vente = await prisma.vente.create({
     *   data: {
     *     // ... data to create a Vente
     *   }
     * })
     * 
     */
    create<T extends VenteCreateArgs>(args: SelectSubset<T, VenteCreateArgs<ExtArgs>>): Prisma__VenteClient<$Result.GetResult<Prisma.$VentePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ventes.
     * @param {VenteCreateManyArgs} args - Arguments to create many Ventes.
     * @example
     * // Create many Ventes
     * const vente = await prisma.vente.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VenteCreateManyArgs>(args?: SelectSubset<T, VenteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ventes and returns the data saved in the database.
     * @param {VenteCreateManyAndReturnArgs} args - Arguments to create many Ventes.
     * @example
     * // Create many Ventes
     * const vente = await prisma.vente.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ventes and only return the `id`
     * const venteWithIdOnly = await prisma.vente.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VenteCreateManyAndReturnArgs>(args?: SelectSubset<T, VenteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VentePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Vente.
     * @param {VenteDeleteArgs} args - Arguments to delete one Vente.
     * @example
     * // Delete one Vente
     * const Vente = await prisma.vente.delete({
     *   where: {
     *     // ... filter to delete one Vente
     *   }
     * })
     * 
     */
    delete<T extends VenteDeleteArgs>(args: SelectSubset<T, VenteDeleteArgs<ExtArgs>>): Prisma__VenteClient<$Result.GetResult<Prisma.$VentePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Vente.
     * @param {VenteUpdateArgs} args - Arguments to update one Vente.
     * @example
     * // Update one Vente
     * const vente = await prisma.vente.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VenteUpdateArgs>(args: SelectSubset<T, VenteUpdateArgs<ExtArgs>>): Prisma__VenteClient<$Result.GetResult<Prisma.$VentePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ventes.
     * @param {VenteDeleteManyArgs} args - Arguments to filter Ventes to delete.
     * @example
     * // Delete a few Ventes
     * const { count } = await prisma.vente.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VenteDeleteManyArgs>(args?: SelectSubset<T, VenteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ventes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ventes
     * const vente = await prisma.vente.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VenteUpdateManyArgs>(args: SelectSubset<T, VenteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ventes and returns the data updated in the database.
     * @param {VenteUpdateManyAndReturnArgs} args - Arguments to update many Ventes.
     * @example
     * // Update many Ventes
     * const vente = await prisma.vente.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Ventes and only return the `id`
     * const venteWithIdOnly = await prisma.vente.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VenteUpdateManyAndReturnArgs>(args: SelectSubset<T, VenteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VentePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Vente.
     * @param {VenteUpsertArgs} args - Arguments to update or create a Vente.
     * @example
     * // Update or create a Vente
     * const vente = await prisma.vente.upsert({
     *   create: {
     *     // ... data to create a Vente
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vente we want to update
     *   }
     * })
     */
    upsert<T extends VenteUpsertArgs>(args: SelectSubset<T, VenteUpsertArgs<ExtArgs>>): Prisma__VenteClient<$Result.GetResult<Prisma.$VentePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ventes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenteCountArgs} args - Arguments to filter Ventes to count.
     * @example
     * // Count the number of Ventes
     * const count = await prisma.vente.count({
     *   where: {
     *     // ... the filter for the Ventes we want to count
     *   }
     * })
    **/
    count<T extends VenteCountArgs>(
      args?: Subset<T, VenteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VenteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VenteAggregateArgs>(args: Subset<T, VenteAggregateArgs>): Prisma.PrismaPromise<GetVenteAggregateType<T>>

    /**
     * Group by Vente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VenteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VenteGroupByArgs['orderBy'] }
        : { orderBy?: VenteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VenteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVenteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Vente model
   */
  readonly fields: VenteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Vente.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VenteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    panier<T extends PanierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PanierDefaultArgs<ExtArgs>>): Prisma__PanierClient<$Result.GetResult<Prisma.$PanierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    agent<T extends Vente$agentArgs<ExtArgs> = {}>(args?: Subset<T, Vente$agentArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    fournisseur<T extends Vente$fournisseurArgs<ExtArgs> = {}>(args?: Subset<T, Vente$fournisseurArgs<ExtArgs>>): Prisma__FournisseurClient<$Result.GetResult<Prisma.$FournisseurPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    client<T extends Vente$clientArgs<ExtArgs> = {}>(args?: Subset<T, Vente$clientArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    paiements<T extends Vente$paiementsArgs<ExtArgs> = {}>(args?: Subset<T, Vente$paiementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaiementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Vente model
   */
  interface VenteFieldRefs {
    readonly id: FieldRef<"Vente", 'Int'>
    readonly statut: FieldRef<"Vente", 'StatutVente'>
    readonly typeAcheteur: FieldRef<"Vente", 'TypeClient'>
    readonly clientId: FieldRef<"Vente", 'Int'>
    readonly agentId: FieldRef<"Vente", 'Int'>
    readonly fournisseurId: FieldRef<"Vente", 'Int'>
    readonly panierId: FieldRef<"Vente", 'Int'>
    readonly enregistrerPar: FieldRef<"Vente", 'String'>
    readonly createdAt: FieldRef<"Vente", 'DateTime'>
    readonly updatedAt: FieldRef<"Vente", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Vente findUnique
   */
  export type VenteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vente
     */
    select?: VenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vente
     */
    omit?: VenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenteInclude<ExtArgs> | null
    /**
     * Filter, which Vente to fetch.
     */
    where: VenteWhereUniqueInput
  }

  /**
   * Vente findUniqueOrThrow
   */
  export type VenteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vente
     */
    select?: VenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vente
     */
    omit?: VenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenteInclude<ExtArgs> | null
    /**
     * Filter, which Vente to fetch.
     */
    where: VenteWhereUniqueInput
  }

  /**
   * Vente findFirst
   */
  export type VenteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vente
     */
    select?: VenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vente
     */
    omit?: VenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenteInclude<ExtArgs> | null
    /**
     * Filter, which Vente to fetch.
     */
    where?: VenteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ventes to fetch.
     */
    orderBy?: VenteOrderByWithRelationInput | VenteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ventes.
     */
    cursor?: VenteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ventes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ventes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ventes.
     */
    distinct?: VenteScalarFieldEnum | VenteScalarFieldEnum[]
  }

  /**
   * Vente findFirstOrThrow
   */
  export type VenteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vente
     */
    select?: VenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vente
     */
    omit?: VenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenteInclude<ExtArgs> | null
    /**
     * Filter, which Vente to fetch.
     */
    where?: VenteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ventes to fetch.
     */
    orderBy?: VenteOrderByWithRelationInput | VenteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ventes.
     */
    cursor?: VenteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ventes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ventes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ventes.
     */
    distinct?: VenteScalarFieldEnum | VenteScalarFieldEnum[]
  }

  /**
   * Vente findMany
   */
  export type VenteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vente
     */
    select?: VenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vente
     */
    omit?: VenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenteInclude<ExtArgs> | null
    /**
     * Filter, which Ventes to fetch.
     */
    where?: VenteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ventes to fetch.
     */
    orderBy?: VenteOrderByWithRelationInput | VenteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Ventes.
     */
    cursor?: VenteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ventes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ventes.
     */
    skip?: number
    distinct?: VenteScalarFieldEnum | VenteScalarFieldEnum[]
  }

  /**
   * Vente create
   */
  export type VenteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vente
     */
    select?: VenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vente
     */
    omit?: VenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenteInclude<ExtArgs> | null
    /**
     * The data needed to create a Vente.
     */
    data: XOR<VenteCreateInput, VenteUncheckedCreateInput>
  }

  /**
   * Vente createMany
   */
  export type VenteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Ventes.
     */
    data: VenteCreateManyInput | VenteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Vente createManyAndReturn
   */
  export type VenteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vente
     */
    select?: VenteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Vente
     */
    omit?: VenteOmit<ExtArgs> | null
    /**
     * The data used to create many Ventes.
     */
    data: VenteCreateManyInput | VenteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Vente update
   */
  export type VenteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vente
     */
    select?: VenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vente
     */
    omit?: VenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenteInclude<ExtArgs> | null
    /**
     * The data needed to update a Vente.
     */
    data: XOR<VenteUpdateInput, VenteUncheckedUpdateInput>
    /**
     * Choose, which Vente to update.
     */
    where: VenteWhereUniqueInput
  }

  /**
   * Vente updateMany
   */
  export type VenteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Ventes.
     */
    data: XOR<VenteUpdateManyMutationInput, VenteUncheckedUpdateManyInput>
    /**
     * Filter which Ventes to update
     */
    where?: VenteWhereInput
    /**
     * Limit how many Ventes to update.
     */
    limit?: number
  }

  /**
   * Vente updateManyAndReturn
   */
  export type VenteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vente
     */
    select?: VenteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Vente
     */
    omit?: VenteOmit<ExtArgs> | null
    /**
     * The data used to update Ventes.
     */
    data: XOR<VenteUpdateManyMutationInput, VenteUncheckedUpdateManyInput>
    /**
     * Filter which Ventes to update
     */
    where?: VenteWhereInput
    /**
     * Limit how many Ventes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Vente upsert
   */
  export type VenteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vente
     */
    select?: VenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vente
     */
    omit?: VenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenteInclude<ExtArgs> | null
    /**
     * The filter to search for the Vente to update in case it exists.
     */
    where: VenteWhereUniqueInput
    /**
     * In case the Vente found by the `where` argument doesn't exist, create a new Vente with this data.
     */
    create: XOR<VenteCreateInput, VenteUncheckedCreateInput>
    /**
     * In case the Vente was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VenteUpdateInput, VenteUncheckedUpdateInput>
  }

  /**
   * Vente delete
   */
  export type VenteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vente
     */
    select?: VenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vente
     */
    omit?: VenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenteInclude<ExtArgs> | null
    /**
     * Filter which Vente to delete.
     */
    where: VenteWhereUniqueInput
  }

  /**
   * Vente deleteMany
   */
  export type VenteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ventes to delete
     */
    where?: VenteWhereInput
    /**
     * Limit how many Ventes to delete.
     */
    limit?: number
  }

  /**
   * Vente.agent
   */
  export type Vente$agentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    where?: AgentWhereInput
  }

  /**
   * Vente.fournisseur
   */
  export type Vente$fournisseurArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fournisseur
     */
    select?: FournisseurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fournisseur
     */
    omit?: FournisseurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FournisseurInclude<ExtArgs> | null
    where?: FournisseurWhereInput
  }

  /**
   * Vente.client
   */
  export type Vente$clientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
  }

  /**
   * Vente.paiements
   */
  export type Vente$paiementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paiement
     */
    select?: PaiementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Paiement
     */
    omit?: PaiementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaiementInclude<ExtArgs> | null
    where?: PaiementWhereInput
    orderBy?: PaiementOrderByWithRelationInput | PaiementOrderByWithRelationInput[]
    cursor?: PaiementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaiementScalarFieldEnum | PaiementScalarFieldEnum[]
  }

  /**
   * Vente without action
   */
  export type VenteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vente
     */
    select?: VenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vente
     */
    omit?: VenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenteInclude<ExtArgs> | null
  }


  /**
   * Model Panier
   */

  export type AggregatePanier = {
    _count: PanierCountAggregateOutputType | null
    _avg: PanierAvgAggregateOutputType | null
    _sum: PanierSumAggregateOutputType | null
    _min: PanierMinAggregateOutputType | null
    _max: PanierMaxAggregateOutputType | null
  }

  export type PanierAvgAggregateOutputType = {
    id: number | null
    agentId: number | null
    clientId: number | null
  }

  export type PanierSumAggregateOutputType = {
    id: number | null
    agentId: number | null
    clientId: number | null
  }

  export type PanierMinAggregateOutputType = {
    id: number | null
    agentId: number | null
    clientId: number | null
    statut: $Enums.statutPanier | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PanierMaxAggregateOutputType = {
    id: number | null
    agentId: number | null
    clientId: number | null
    statut: $Enums.statutPanier | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PanierCountAggregateOutputType = {
    id: number
    agentId: number
    clientId: number
    statut: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PanierAvgAggregateInputType = {
    id?: true
    agentId?: true
    clientId?: true
  }

  export type PanierSumAggregateInputType = {
    id?: true
    agentId?: true
    clientId?: true
  }

  export type PanierMinAggregateInputType = {
    id?: true
    agentId?: true
    clientId?: true
    statut?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PanierMaxAggregateInputType = {
    id?: true
    agentId?: true
    clientId?: true
    statut?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PanierCountAggregateInputType = {
    id?: true
    agentId?: true
    clientId?: true
    statut?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PanierAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Panier to aggregate.
     */
    where?: PanierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Paniers to fetch.
     */
    orderBy?: PanierOrderByWithRelationInput | PanierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PanierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Paniers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Paniers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Paniers
    **/
    _count?: true | PanierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PanierAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PanierSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PanierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PanierMaxAggregateInputType
  }

  export type GetPanierAggregateType<T extends PanierAggregateArgs> = {
        [P in keyof T & keyof AggregatePanier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePanier[P]>
      : GetScalarType<T[P], AggregatePanier[P]>
  }




  export type PanierGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PanierWhereInput
    orderBy?: PanierOrderByWithAggregationInput | PanierOrderByWithAggregationInput[]
    by: PanierScalarFieldEnum[] | PanierScalarFieldEnum
    having?: PanierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PanierCountAggregateInputType | true
    _avg?: PanierAvgAggregateInputType
    _sum?: PanierSumAggregateInputType
    _min?: PanierMinAggregateInputType
    _max?: PanierMaxAggregateInputType
  }

  export type PanierGroupByOutputType = {
    id: number
    agentId: number | null
    clientId: number | null
    statut: $Enums.statutPanier
    createdAt: Date
    updatedAt: Date
    _count: PanierCountAggregateOutputType | null
    _avg: PanierAvgAggregateOutputType | null
    _sum: PanierSumAggregateOutputType | null
    _min: PanierMinAggregateOutputType | null
    _max: PanierMaxAggregateOutputType | null
  }

  type GetPanierGroupByPayload<T extends PanierGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PanierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PanierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PanierGroupByOutputType[P]>
            : GetScalarType<T[P], PanierGroupByOutputType[P]>
        }
      >
    >


  export type PanierSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    clientId?: boolean
    statut?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agent?: boolean | Panier$agentArgs<ExtArgs>
    client?: boolean | Panier$clientArgs<ExtArgs>
    detailPaniers?: boolean | Panier$detailPaniersArgs<ExtArgs>
    achats?: boolean | Panier$achatsArgs<ExtArgs>
    ventes?: boolean | Panier$ventesArgs<ExtArgs>
    reservations?: boolean | Panier$reservationsArgs<ExtArgs>
    commandes?: boolean | Panier$commandesArgs<ExtArgs>
    _count?: boolean | PanierCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["panier"]>

  export type PanierSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    clientId?: boolean
    statut?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agent?: boolean | Panier$agentArgs<ExtArgs>
    client?: boolean | Panier$clientArgs<ExtArgs>
  }, ExtArgs["result"]["panier"]>

  export type PanierSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    clientId?: boolean
    statut?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agent?: boolean | Panier$agentArgs<ExtArgs>
    client?: boolean | Panier$clientArgs<ExtArgs>
  }, ExtArgs["result"]["panier"]>

  export type PanierSelectScalar = {
    id?: boolean
    agentId?: boolean
    clientId?: boolean
    statut?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PanierOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "agentId" | "clientId" | "statut" | "createdAt" | "updatedAt", ExtArgs["result"]["panier"]>
  export type PanierInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | Panier$agentArgs<ExtArgs>
    client?: boolean | Panier$clientArgs<ExtArgs>
    detailPaniers?: boolean | Panier$detailPaniersArgs<ExtArgs>
    achats?: boolean | Panier$achatsArgs<ExtArgs>
    ventes?: boolean | Panier$ventesArgs<ExtArgs>
    reservations?: boolean | Panier$reservationsArgs<ExtArgs>
    commandes?: boolean | Panier$commandesArgs<ExtArgs>
    _count?: boolean | PanierCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PanierIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | Panier$agentArgs<ExtArgs>
    client?: boolean | Panier$clientArgs<ExtArgs>
  }
  export type PanierIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | Panier$agentArgs<ExtArgs>
    client?: boolean | Panier$clientArgs<ExtArgs>
  }

  export type $PanierPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Panier"
    objects: {
      agent: Prisma.$AgentPayload<ExtArgs> | null
      client: Prisma.$ClientPayload<ExtArgs> | null
      detailPaniers: Prisma.$DetailPanierPayload<ExtArgs>[]
      achats: Prisma.$AchatPayload<ExtArgs>[]
      ventes: Prisma.$VentePayload<ExtArgs>[]
      reservations: Prisma.$ReservationPayload<ExtArgs>[]
      commandes: Prisma.$CommandePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      agentId: number | null
      clientId: number | null
      statut: $Enums.statutPanier
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["panier"]>
    composites: {}
  }

  type PanierGetPayload<S extends boolean | null | undefined | PanierDefaultArgs> = $Result.GetResult<Prisma.$PanierPayload, S>

  type PanierCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PanierFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PanierCountAggregateInputType | true
    }

  export interface PanierDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Panier'], meta: { name: 'Panier' } }
    /**
     * Find zero or one Panier that matches the filter.
     * @param {PanierFindUniqueArgs} args - Arguments to find a Panier
     * @example
     * // Get one Panier
     * const panier = await prisma.panier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PanierFindUniqueArgs>(args: SelectSubset<T, PanierFindUniqueArgs<ExtArgs>>): Prisma__PanierClient<$Result.GetResult<Prisma.$PanierPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Panier that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PanierFindUniqueOrThrowArgs} args - Arguments to find a Panier
     * @example
     * // Get one Panier
     * const panier = await prisma.panier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PanierFindUniqueOrThrowArgs>(args: SelectSubset<T, PanierFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PanierClient<$Result.GetResult<Prisma.$PanierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Panier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PanierFindFirstArgs} args - Arguments to find a Panier
     * @example
     * // Get one Panier
     * const panier = await prisma.panier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PanierFindFirstArgs>(args?: SelectSubset<T, PanierFindFirstArgs<ExtArgs>>): Prisma__PanierClient<$Result.GetResult<Prisma.$PanierPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Panier that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PanierFindFirstOrThrowArgs} args - Arguments to find a Panier
     * @example
     * // Get one Panier
     * const panier = await prisma.panier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PanierFindFirstOrThrowArgs>(args?: SelectSubset<T, PanierFindFirstOrThrowArgs<ExtArgs>>): Prisma__PanierClient<$Result.GetResult<Prisma.$PanierPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Paniers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PanierFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Paniers
     * const paniers = await prisma.panier.findMany()
     * 
     * // Get first 10 Paniers
     * const paniers = await prisma.panier.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const panierWithIdOnly = await prisma.panier.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PanierFindManyArgs>(args?: SelectSubset<T, PanierFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PanierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Panier.
     * @param {PanierCreateArgs} args - Arguments to create a Panier.
     * @example
     * // Create one Panier
     * const Panier = await prisma.panier.create({
     *   data: {
     *     // ... data to create a Panier
     *   }
     * })
     * 
     */
    create<T extends PanierCreateArgs>(args: SelectSubset<T, PanierCreateArgs<ExtArgs>>): Prisma__PanierClient<$Result.GetResult<Prisma.$PanierPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Paniers.
     * @param {PanierCreateManyArgs} args - Arguments to create many Paniers.
     * @example
     * // Create many Paniers
     * const panier = await prisma.panier.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PanierCreateManyArgs>(args?: SelectSubset<T, PanierCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Paniers and returns the data saved in the database.
     * @param {PanierCreateManyAndReturnArgs} args - Arguments to create many Paniers.
     * @example
     * // Create many Paniers
     * const panier = await prisma.panier.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Paniers and only return the `id`
     * const panierWithIdOnly = await prisma.panier.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PanierCreateManyAndReturnArgs>(args?: SelectSubset<T, PanierCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PanierPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Panier.
     * @param {PanierDeleteArgs} args - Arguments to delete one Panier.
     * @example
     * // Delete one Panier
     * const Panier = await prisma.panier.delete({
     *   where: {
     *     // ... filter to delete one Panier
     *   }
     * })
     * 
     */
    delete<T extends PanierDeleteArgs>(args: SelectSubset<T, PanierDeleteArgs<ExtArgs>>): Prisma__PanierClient<$Result.GetResult<Prisma.$PanierPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Panier.
     * @param {PanierUpdateArgs} args - Arguments to update one Panier.
     * @example
     * // Update one Panier
     * const panier = await prisma.panier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PanierUpdateArgs>(args: SelectSubset<T, PanierUpdateArgs<ExtArgs>>): Prisma__PanierClient<$Result.GetResult<Prisma.$PanierPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Paniers.
     * @param {PanierDeleteManyArgs} args - Arguments to filter Paniers to delete.
     * @example
     * // Delete a few Paniers
     * const { count } = await prisma.panier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PanierDeleteManyArgs>(args?: SelectSubset<T, PanierDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Paniers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PanierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Paniers
     * const panier = await prisma.panier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PanierUpdateManyArgs>(args: SelectSubset<T, PanierUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Paniers and returns the data updated in the database.
     * @param {PanierUpdateManyAndReturnArgs} args - Arguments to update many Paniers.
     * @example
     * // Update many Paniers
     * const panier = await prisma.panier.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Paniers and only return the `id`
     * const panierWithIdOnly = await prisma.panier.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PanierUpdateManyAndReturnArgs>(args: SelectSubset<T, PanierUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PanierPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Panier.
     * @param {PanierUpsertArgs} args - Arguments to update or create a Panier.
     * @example
     * // Update or create a Panier
     * const panier = await prisma.panier.upsert({
     *   create: {
     *     // ... data to create a Panier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Panier we want to update
     *   }
     * })
     */
    upsert<T extends PanierUpsertArgs>(args: SelectSubset<T, PanierUpsertArgs<ExtArgs>>): Prisma__PanierClient<$Result.GetResult<Prisma.$PanierPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Paniers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PanierCountArgs} args - Arguments to filter Paniers to count.
     * @example
     * // Count the number of Paniers
     * const count = await prisma.panier.count({
     *   where: {
     *     // ... the filter for the Paniers we want to count
     *   }
     * })
    **/
    count<T extends PanierCountArgs>(
      args?: Subset<T, PanierCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PanierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Panier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PanierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PanierAggregateArgs>(args: Subset<T, PanierAggregateArgs>): Prisma.PrismaPromise<GetPanierAggregateType<T>>

    /**
     * Group by Panier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PanierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PanierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PanierGroupByArgs['orderBy'] }
        : { orderBy?: PanierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PanierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPanierGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Panier model
   */
  readonly fields: PanierFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Panier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PanierClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agent<T extends Panier$agentArgs<ExtArgs> = {}>(args?: Subset<T, Panier$agentArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    client<T extends Panier$clientArgs<ExtArgs> = {}>(args?: Subset<T, Panier$clientArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    detailPaniers<T extends Panier$detailPaniersArgs<ExtArgs> = {}>(args?: Subset<T, Panier$detailPaniersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DetailPanierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    achats<T extends Panier$achatsArgs<ExtArgs> = {}>(args?: Subset<T, Panier$achatsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ventes<T extends Panier$ventesArgs<ExtArgs> = {}>(args?: Subset<T, Panier$ventesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VentePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reservations<T extends Panier$reservationsArgs<ExtArgs> = {}>(args?: Subset<T, Panier$reservationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    commandes<T extends Panier$commandesArgs<ExtArgs> = {}>(args?: Subset<T, Panier$commandesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommandePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Panier model
   */
  interface PanierFieldRefs {
    readonly id: FieldRef<"Panier", 'Int'>
    readonly agentId: FieldRef<"Panier", 'Int'>
    readonly clientId: FieldRef<"Panier", 'Int'>
    readonly statut: FieldRef<"Panier", 'statutPanier'>
    readonly createdAt: FieldRef<"Panier", 'DateTime'>
    readonly updatedAt: FieldRef<"Panier", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Panier findUnique
   */
  export type PanierFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Panier
     */
    select?: PanierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Panier
     */
    omit?: PanierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PanierInclude<ExtArgs> | null
    /**
     * Filter, which Panier to fetch.
     */
    where: PanierWhereUniqueInput
  }

  /**
   * Panier findUniqueOrThrow
   */
  export type PanierFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Panier
     */
    select?: PanierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Panier
     */
    omit?: PanierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PanierInclude<ExtArgs> | null
    /**
     * Filter, which Panier to fetch.
     */
    where: PanierWhereUniqueInput
  }

  /**
   * Panier findFirst
   */
  export type PanierFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Panier
     */
    select?: PanierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Panier
     */
    omit?: PanierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PanierInclude<ExtArgs> | null
    /**
     * Filter, which Panier to fetch.
     */
    where?: PanierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Paniers to fetch.
     */
    orderBy?: PanierOrderByWithRelationInput | PanierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Paniers.
     */
    cursor?: PanierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Paniers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Paniers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Paniers.
     */
    distinct?: PanierScalarFieldEnum | PanierScalarFieldEnum[]
  }

  /**
   * Panier findFirstOrThrow
   */
  export type PanierFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Panier
     */
    select?: PanierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Panier
     */
    omit?: PanierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PanierInclude<ExtArgs> | null
    /**
     * Filter, which Panier to fetch.
     */
    where?: PanierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Paniers to fetch.
     */
    orderBy?: PanierOrderByWithRelationInput | PanierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Paniers.
     */
    cursor?: PanierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Paniers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Paniers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Paniers.
     */
    distinct?: PanierScalarFieldEnum | PanierScalarFieldEnum[]
  }

  /**
   * Panier findMany
   */
  export type PanierFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Panier
     */
    select?: PanierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Panier
     */
    omit?: PanierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PanierInclude<ExtArgs> | null
    /**
     * Filter, which Paniers to fetch.
     */
    where?: PanierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Paniers to fetch.
     */
    orderBy?: PanierOrderByWithRelationInput | PanierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Paniers.
     */
    cursor?: PanierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Paniers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Paniers.
     */
    skip?: number
    distinct?: PanierScalarFieldEnum | PanierScalarFieldEnum[]
  }

  /**
   * Panier create
   */
  export type PanierCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Panier
     */
    select?: PanierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Panier
     */
    omit?: PanierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PanierInclude<ExtArgs> | null
    /**
     * The data needed to create a Panier.
     */
    data: XOR<PanierCreateInput, PanierUncheckedCreateInput>
  }

  /**
   * Panier createMany
   */
  export type PanierCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Paniers.
     */
    data: PanierCreateManyInput | PanierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Panier createManyAndReturn
   */
  export type PanierCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Panier
     */
    select?: PanierSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Panier
     */
    omit?: PanierOmit<ExtArgs> | null
    /**
     * The data used to create many Paniers.
     */
    data: PanierCreateManyInput | PanierCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PanierIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Panier update
   */
  export type PanierUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Panier
     */
    select?: PanierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Panier
     */
    omit?: PanierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PanierInclude<ExtArgs> | null
    /**
     * The data needed to update a Panier.
     */
    data: XOR<PanierUpdateInput, PanierUncheckedUpdateInput>
    /**
     * Choose, which Panier to update.
     */
    where: PanierWhereUniqueInput
  }

  /**
   * Panier updateMany
   */
  export type PanierUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Paniers.
     */
    data: XOR<PanierUpdateManyMutationInput, PanierUncheckedUpdateManyInput>
    /**
     * Filter which Paniers to update
     */
    where?: PanierWhereInput
    /**
     * Limit how many Paniers to update.
     */
    limit?: number
  }

  /**
   * Panier updateManyAndReturn
   */
  export type PanierUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Panier
     */
    select?: PanierSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Panier
     */
    omit?: PanierOmit<ExtArgs> | null
    /**
     * The data used to update Paniers.
     */
    data: XOR<PanierUpdateManyMutationInput, PanierUncheckedUpdateManyInput>
    /**
     * Filter which Paniers to update
     */
    where?: PanierWhereInput
    /**
     * Limit how many Paniers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PanierIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Panier upsert
   */
  export type PanierUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Panier
     */
    select?: PanierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Panier
     */
    omit?: PanierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PanierInclude<ExtArgs> | null
    /**
     * The filter to search for the Panier to update in case it exists.
     */
    where: PanierWhereUniqueInput
    /**
     * In case the Panier found by the `where` argument doesn't exist, create a new Panier with this data.
     */
    create: XOR<PanierCreateInput, PanierUncheckedCreateInput>
    /**
     * In case the Panier was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PanierUpdateInput, PanierUncheckedUpdateInput>
  }

  /**
   * Panier delete
   */
  export type PanierDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Panier
     */
    select?: PanierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Panier
     */
    omit?: PanierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PanierInclude<ExtArgs> | null
    /**
     * Filter which Panier to delete.
     */
    where: PanierWhereUniqueInput
  }

  /**
   * Panier deleteMany
   */
  export type PanierDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Paniers to delete
     */
    where?: PanierWhereInput
    /**
     * Limit how many Paniers to delete.
     */
    limit?: number
  }

  /**
   * Panier.agent
   */
  export type Panier$agentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    where?: AgentWhereInput
  }

  /**
   * Panier.client
   */
  export type Panier$clientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
  }

  /**
   * Panier.detailPaniers
   */
  export type Panier$detailPaniersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetailPanier
     */
    select?: DetailPanierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DetailPanier
     */
    omit?: DetailPanierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetailPanierInclude<ExtArgs> | null
    where?: DetailPanierWhereInput
    orderBy?: DetailPanierOrderByWithRelationInput | DetailPanierOrderByWithRelationInput[]
    cursor?: DetailPanierWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DetailPanierScalarFieldEnum | DetailPanierScalarFieldEnum[]
  }

  /**
   * Panier.achats
   */
  export type Panier$achatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achat
     */
    select?: AchatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achat
     */
    omit?: AchatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchatInclude<ExtArgs> | null
    where?: AchatWhereInput
    orderBy?: AchatOrderByWithRelationInput | AchatOrderByWithRelationInput[]
    cursor?: AchatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AchatScalarFieldEnum | AchatScalarFieldEnum[]
  }

  /**
   * Panier.ventes
   */
  export type Panier$ventesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vente
     */
    select?: VenteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vente
     */
    omit?: VenteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenteInclude<ExtArgs> | null
    where?: VenteWhereInput
    orderBy?: VenteOrderByWithRelationInput | VenteOrderByWithRelationInput[]
    cursor?: VenteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VenteScalarFieldEnum | VenteScalarFieldEnum[]
  }

  /**
   * Panier.reservations
   */
  export type Panier$reservationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    where?: ReservationWhereInput
    orderBy?: ReservationOrderByWithRelationInput | ReservationOrderByWithRelationInput[]
    cursor?: ReservationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReservationScalarFieldEnum | ReservationScalarFieldEnum[]
  }

  /**
   * Panier.commandes
   */
  export type Panier$commandesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commande
     */
    select?: CommandeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Commande
     */
    omit?: CommandeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandeInclude<ExtArgs> | null
    where?: CommandeWhereInput
    orderBy?: CommandeOrderByWithRelationInput | CommandeOrderByWithRelationInput[]
    cursor?: CommandeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommandeScalarFieldEnum | CommandeScalarFieldEnum[]
  }

  /**
   * Panier without action
   */
  export type PanierDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Panier
     */
    select?: PanierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Panier
     */
    omit?: PanierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PanierInclude<ExtArgs> | null
  }


  /**
   * Model DetailPanier
   */

  export type AggregateDetailPanier = {
    _count: DetailPanierCountAggregateOutputType | null
    _avg: DetailPanierAvgAggregateOutputType | null
    _sum: DetailPanierSumAggregateOutputType | null
    _min: DetailPanierMinAggregateOutputType | null
    _max: DetailPanierMaxAggregateOutputType | null
  }

  export type DetailPanierAvgAggregateOutputType = {
    id: number | null
    produitId: number | null
    qtte: number | null
    prixUnitaire: number | null
    prixTotalHT: number | null
    prixTotalTTC: number | null
    panierId: number | null
    deviseId: number | null
  }

  export type DetailPanierSumAggregateOutputType = {
    id: number | null
    produitId: number | null
    qtte: number | null
    prixUnitaire: number | null
    prixTotalHT: number | null
    prixTotalTTC: number | null
    panierId: number | null
    deviseId: number | null
  }

  export type DetailPanierMinAggregateOutputType = {
    id: number | null
    produitId: number | null
    qtte: number | null
    modePaiement: $Enums.ModePaiment | null
    prixUnitaire: number | null
    prixTotalHT: number | null
    prixTotalTTC: number | null
    panierId: number | null
    deviseId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DetailPanierMaxAggregateOutputType = {
    id: number | null
    produitId: number | null
    qtte: number | null
    modePaiement: $Enums.ModePaiment | null
    prixUnitaire: number | null
    prixTotalHT: number | null
    prixTotalTTC: number | null
    panierId: number | null
    deviseId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DetailPanierCountAggregateOutputType = {
    id: number
    produitId: number
    qtte: number
    modePaiement: number
    prixUnitaire: number
    prixTotalHT: number
    prixTotalTTC: number
    panierId: number
    deviseId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DetailPanierAvgAggregateInputType = {
    id?: true
    produitId?: true
    qtte?: true
    prixUnitaire?: true
    prixTotalHT?: true
    prixTotalTTC?: true
    panierId?: true
    deviseId?: true
  }

  export type DetailPanierSumAggregateInputType = {
    id?: true
    produitId?: true
    qtte?: true
    prixUnitaire?: true
    prixTotalHT?: true
    prixTotalTTC?: true
    panierId?: true
    deviseId?: true
  }

  export type DetailPanierMinAggregateInputType = {
    id?: true
    produitId?: true
    qtte?: true
    modePaiement?: true
    prixUnitaire?: true
    prixTotalHT?: true
    prixTotalTTC?: true
    panierId?: true
    deviseId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DetailPanierMaxAggregateInputType = {
    id?: true
    produitId?: true
    qtte?: true
    modePaiement?: true
    prixUnitaire?: true
    prixTotalHT?: true
    prixTotalTTC?: true
    panierId?: true
    deviseId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DetailPanierCountAggregateInputType = {
    id?: true
    produitId?: true
    qtte?: true
    modePaiement?: true
    prixUnitaire?: true
    prixTotalHT?: true
    prixTotalTTC?: true
    panierId?: true
    deviseId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DetailPanierAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DetailPanier to aggregate.
     */
    where?: DetailPanierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DetailPaniers to fetch.
     */
    orderBy?: DetailPanierOrderByWithRelationInput | DetailPanierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DetailPanierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DetailPaniers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DetailPaniers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DetailPaniers
    **/
    _count?: true | DetailPanierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DetailPanierAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DetailPanierSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DetailPanierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DetailPanierMaxAggregateInputType
  }

  export type GetDetailPanierAggregateType<T extends DetailPanierAggregateArgs> = {
        [P in keyof T & keyof AggregateDetailPanier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDetailPanier[P]>
      : GetScalarType<T[P], AggregateDetailPanier[P]>
  }




  export type DetailPanierGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DetailPanierWhereInput
    orderBy?: DetailPanierOrderByWithAggregationInput | DetailPanierOrderByWithAggregationInput[]
    by: DetailPanierScalarFieldEnum[] | DetailPanierScalarFieldEnum
    having?: DetailPanierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DetailPanierCountAggregateInputType | true
    _avg?: DetailPanierAvgAggregateInputType
    _sum?: DetailPanierSumAggregateInputType
    _min?: DetailPanierMinAggregateInputType
    _max?: DetailPanierMaxAggregateInputType
  }

  export type DetailPanierGroupByOutputType = {
    id: number
    produitId: number
    qtte: number
    modePaiement: $Enums.ModePaiment
    prixUnitaire: number
    prixTotalHT: number
    prixTotalTTC: number
    panierId: number
    deviseId: number
    createdAt: Date
    updatedAt: Date
    _count: DetailPanierCountAggregateOutputType | null
    _avg: DetailPanierAvgAggregateOutputType | null
    _sum: DetailPanierSumAggregateOutputType | null
    _min: DetailPanierMinAggregateOutputType | null
    _max: DetailPanierMaxAggregateOutputType | null
  }

  type GetDetailPanierGroupByPayload<T extends DetailPanierGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DetailPanierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DetailPanierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DetailPanierGroupByOutputType[P]>
            : GetScalarType<T[P], DetailPanierGroupByOutputType[P]>
        }
      >
    >


  export type DetailPanierSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    produitId?: boolean
    qtte?: boolean
    modePaiement?: boolean
    prixUnitaire?: boolean
    prixTotalHT?: boolean
    prixTotalTTC?: boolean
    panierId?: boolean
    deviseId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    devise?: boolean | DeviseDefaultArgs<ExtArgs>
    produit?: boolean | ProduitDefaultArgs<ExtArgs>
    panier?: boolean | PanierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["detailPanier"]>

  export type DetailPanierSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    produitId?: boolean
    qtte?: boolean
    modePaiement?: boolean
    prixUnitaire?: boolean
    prixTotalHT?: boolean
    prixTotalTTC?: boolean
    panierId?: boolean
    deviseId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    devise?: boolean | DeviseDefaultArgs<ExtArgs>
    produit?: boolean | ProduitDefaultArgs<ExtArgs>
    panier?: boolean | PanierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["detailPanier"]>

  export type DetailPanierSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    produitId?: boolean
    qtte?: boolean
    modePaiement?: boolean
    prixUnitaire?: boolean
    prixTotalHT?: boolean
    prixTotalTTC?: boolean
    panierId?: boolean
    deviseId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    devise?: boolean | DeviseDefaultArgs<ExtArgs>
    produit?: boolean | ProduitDefaultArgs<ExtArgs>
    panier?: boolean | PanierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["detailPanier"]>

  export type DetailPanierSelectScalar = {
    id?: boolean
    produitId?: boolean
    qtte?: boolean
    modePaiement?: boolean
    prixUnitaire?: boolean
    prixTotalHT?: boolean
    prixTotalTTC?: boolean
    panierId?: boolean
    deviseId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DetailPanierOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "produitId" | "qtte" | "modePaiement" | "prixUnitaire" | "prixTotalHT" | "prixTotalTTC" | "panierId" | "deviseId" | "createdAt" | "updatedAt", ExtArgs["result"]["detailPanier"]>
  export type DetailPanierInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    devise?: boolean | DeviseDefaultArgs<ExtArgs>
    produit?: boolean | ProduitDefaultArgs<ExtArgs>
    panier?: boolean | PanierDefaultArgs<ExtArgs>
  }
  export type DetailPanierIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    devise?: boolean | DeviseDefaultArgs<ExtArgs>
    produit?: boolean | ProduitDefaultArgs<ExtArgs>
    panier?: boolean | PanierDefaultArgs<ExtArgs>
  }
  export type DetailPanierIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    devise?: boolean | DeviseDefaultArgs<ExtArgs>
    produit?: boolean | ProduitDefaultArgs<ExtArgs>
    panier?: boolean | PanierDefaultArgs<ExtArgs>
  }

  export type $DetailPanierPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DetailPanier"
    objects: {
      devise: Prisma.$DevisePayload<ExtArgs>
      produit: Prisma.$ProduitPayload<ExtArgs>
      panier: Prisma.$PanierPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      produitId: number
      qtte: number
      modePaiement: $Enums.ModePaiment
      prixUnitaire: number
      prixTotalHT: number
      prixTotalTTC: number
      panierId: number
      deviseId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["detailPanier"]>
    composites: {}
  }

  type DetailPanierGetPayload<S extends boolean | null | undefined | DetailPanierDefaultArgs> = $Result.GetResult<Prisma.$DetailPanierPayload, S>

  type DetailPanierCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DetailPanierFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DetailPanierCountAggregateInputType | true
    }

  export interface DetailPanierDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DetailPanier'], meta: { name: 'DetailPanier' } }
    /**
     * Find zero or one DetailPanier that matches the filter.
     * @param {DetailPanierFindUniqueArgs} args - Arguments to find a DetailPanier
     * @example
     * // Get one DetailPanier
     * const detailPanier = await prisma.detailPanier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DetailPanierFindUniqueArgs>(args: SelectSubset<T, DetailPanierFindUniqueArgs<ExtArgs>>): Prisma__DetailPanierClient<$Result.GetResult<Prisma.$DetailPanierPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DetailPanier that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DetailPanierFindUniqueOrThrowArgs} args - Arguments to find a DetailPanier
     * @example
     * // Get one DetailPanier
     * const detailPanier = await prisma.detailPanier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DetailPanierFindUniqueOrThrowArgs>(args: SelectSubset<T, DetailPanierFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DetailPanierClient<$Result.GetResult<Prisma.$DetailPanierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DetailPanier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetailPanierFindFirstArgs} args - Arguments to find a DetailPanier
     * @example
     * // Get one DetailPanier
     * const detailPanier = await prisma.detailPanier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DetailPanierFindFirstArgs>(args?: SelectSubset<T, DetailPanierFindFirstArgs<ExtArgs>>): Prisma__DetailPanierClient<$Result.GetResult<Prisma.$DetailPanierPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DetailPanier that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetailPanierFindFirstOrThrowArgs} args - Arguments to find a DetailPanier
     * @example
     * // Get one DetailPanier
     * const detailPanier = await prisma.detailPanier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DetailPanierFindFirstOrThrowArgs>(args?: SelectSubset<T, DetailPanierFindFirstOrThrowArgs<ExtArgs>>): Prisma__DetailPanierClient<$Result.GetResult<Prisma.$DetailPanierPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DetailPaniers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetailPanierFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DetailPaniers
     * const detailPaniers = await prisma.detailPanier.findMany()
     * 
     * // Get first 10 DetailPaniers
     * const detailPaniers = await prisma.detailPanier.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const detailPanierWithIdOnly = await prisma.detailPanier.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DetailPanierFindManyArgs>(args?: SelectSubset<T, DetailPanierFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DetailPanierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DetailPanier.
     * @param {DetailPanierCreateArgs} args - Arguments to create a DetailPanier.
     * @example
     * // Create one DetailPanier
     * const DetailPanier = await prisma.detailPanier.create({
     *   data: {
     *     // ... data to create a DetailPanier
     *   }
     * })
     * 
     */
    create<T extends DetailPanierCreateArgs>(args: SelectSubset<T, DetailPanierCreateArgs<ExtArgs>>): Prisma__DetailPanierClient<$Result.GetResult<Prisma.$DetailPanierPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DetailPaniers.
     * @param {DetailPanierCreateManyArgs} args - Arguments to create many DetailPaniers.
     * @example
     * // Create many DetailPaniers
     * const detailPanier = await prisma.detailPanier.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DetailPanierCreateManyArgs>(args?: SelectSubset<T, DetailPanierCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DetailPaniers and returns the data saved in the database.
     * @param {DetailPanierCreateManyAndReturnArgs} args - Arguments to create many DetailPaniers.
     * @example
     * // Create many DetailPaniers
     * const detailPanier = await prisma.detailPanier.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DetailPaniers and only return the `id`
     * const detailPanierWithIdOnly = await prisma.detailPanier.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DetailPanierCreateManyAndReturnArgs>(args?: SelectSubset<T, DetailPanierCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DetailPanierPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DetailPanier.
     * @param {DetailPanierDeleteArgs} args - Arguments to delete one DetailPanier.
     * @example
     * // Delete one DetailPanier
     * const DetailPanier = await prisma.detailPanier.delete({
     *   where: {
     *     // ... filter to delete one DetailPanier
     *   }
     * })
     * 
     */
    delete<T extends DetailPanierDeleteArgs>(args: SelectSubset<T, DetailPanierDeleteArgs<ExtArgs>>): Prisma__DetailPanierClient<$Result.GetResult<Prisma.$DetailPanierPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DetailPanier.
     * @param {DetailPanierUpdateArgs} args - Arguments to update one DetailPanier.
     * @example
     * // Update one DetailPanier
     * const detailPanier = await prisma.detailPanier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DetailPanierUpdateArgs>(args: SelectSubset<T, DetailPanierUpdateArgs<ExtArgs>>): Prisma__DetailPanierClient<$Result.GetResult<Prisma.$DetailPanierPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DetailPaniers.
     * @param {DetailPanierDeleteManyArgs} args - Arguments to filter DetailPaniers to delete.
     * @example
     * // Delete a few DetailPaniers
     * const { count } = await prisma.detailPanier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DetailPanierDeleteManyArgs>(args?: SelectSubset<T, DetailPanierDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DetailPaniers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetailPanierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DetailPaniers
     * const detailPanier = await prisma.detailPanier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DetailPanierUpdateManyArgs>(args: SelectSubset<T, DetailPanierUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DetailPaniers and returns the data updated in the database.
     * @param {DetailPanierUpdateManyAndReturnArgs} args - Arguments to update many DetailPaniers.
     * @example
     * // Update many DetailPaniers
     * const detailPanier = await prisma.detailPanier.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DetailPaniers and only return the `id`
     * const detailPanierWithIdOnly = await prisma.detailPanier.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DetailPanierUpdateManyAndReturnArgs>(args: SelectSubset<T, DetailPanierUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DetailPanierPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DetailPanier.
     * @param {DetailPanierUpsertArgs} args - Arguments to update or create a DetailPanier.
     * @example
     * // Update or create a DetailPanier
     * const detailPanier = await prisma.detailPanier.upsert({
     *   create: {
     *     // ... data to create a DetailPanier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DetailPanier we want to update
     *   }
     * })
     */
    upsert<T extends DetailPanierUpsertArgs>(args: SelectSubset<T, DetailPanierUpsertArgs<ExtArgs>>): Prisma__DetailPanierClient<$Result.GetResult<Prisma.$DetailPanierPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DetailPaniers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetailPanierCountArgs} args - Arguments to filter DetailPaniers to count.
     * @example
     * // Count the number of DetailPaniers
     * const count = await prisma.detailPanier.count({
     *   where: {
     *     // ... the filter for the DetailPaniers we want to count
     *   }
     * })
    **/
    count<T extends DetailPanierCountArgs>(
      args?: Subset<T, DetailPanierCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DetailPanierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DetailPanier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetailPanierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DetailPanierAggregateArgs>(args: Subset<T, DetailPanierAggregateArgs>): Prisma.PrismaPromise<GetDetailPanierAggregateType<T>>

    /**
     * Group by DetailPanier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetailPanierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DetailPanierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DetailPanierGroupByArgs['orderBy'] }
        : { orderBy?: DetailPanierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DetailPanierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDetailPanierGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DetailPanier model
   */
  readonly fields: DetailPanierFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DetailPanier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DetailPanierClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    devise<T extends DeviseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DeviseDefaultArgs<ExtArgs>>): Prisma__DeviseClient<$Result.GetResult<Prisma.$DevisePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    produit<T extends ProduitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProduitDefaultArgs<ExtArgs>>): Prisma__ProduitClient<$Result.GetResult<Prisma.$ProduitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    panier<T extends PanierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PanierDefaultArgs<ExtArgs>>): Prisma__PanierClient<$Result.GetResult<Prisma.$PanierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DetailPanier model
   */
  interface DetailPanierFieldRefs {
    readonly id: FieldRef<"DetailPanier", 'Int'>
    readonly produitId: FieldRef<"DetailPanier", 'Int'>
    readonly qtte: FieldRef<"DetailPanier", 'Int'>
    readonly modePaiement: FieldRef<"DetailPanier", 'ModePaiment'>
    readonly prixUnitaire: FieldRef<"DetailPanier", 'Float'>
    readonly prixTotalHT: FieldRef<"DetailPanier", 'Float'>
    readonly prixTotalTTC: FieldRef<"DetailPanier", 'Float'>
    readonly panierId: FieldRef<"DetailPanier", 'Int'>
    readonly deviseId: FieldRef<"DetailPanier", 'Int'>
    readonly createdAt: FieldRef<"DetailPanier", 'DateTime'>
    readonly updatedAt: FieldRef<"DetailPanier", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DetailPanier findUnique
   */
  export type DetailPanierFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetailPanier
     */
    select?: DetailPanierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DetailPanier
     */
    omit?: DetailPanierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetailPanierInclude<ExtArgs> | null
    /**
     * Filter, which DetailPanier to fetch.
     */
    where: DetailPanierWhereUniqueInput
  }

  /**
   * DetailPanier findUniqueOrThrow
   */
  export type DetailPanierFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetailPanier
     */
    select?: DetailPanierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DetailPanier
     */
    omit?: DetailPanierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetailPanierInclude<ExtArgs> | null
    /**
     * Filter, which DetailPanier to fetch.
     */
    where: DetailPanierWhereUniqueInput
  }

  /**
   * DetailPanier findFirst
   */
  export type DetailPanierFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetailPanier
     */
    select?: DetailPanierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DetailPanier
     */
    omit?: DetailPanierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetailPanierInclude<ExtArgs> | null
    /**
     * Filter, which DetailPanier to fetch.
     */
    where?: DetailPanierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DetailPaniers to fetch.
     */
    orderBy?: DetailPanierOrderByWithRelationInput | DetailPanierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DetailPaniers.
     */
    cursor?: DetailPanierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DetailPaniers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DetailPaniers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DetailPaniers.
     */
    distinct?: DetailPanierScalarFieldEnum | DetailPanierScalarFieldEnum[]
  }

  /**
   * DetailPanier findFirstOrThrow
   */
  export type DetailPanierFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetailPanier
     */
    select?: DetailPanierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DetailPanier
     */
    omit?: DetailPanierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetailPanierInclude<ExtArgs> | null
    /**
     * Filter, which DetailPanier to fetch.
     */
    where?: DetailPanierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DetailPaniers to fetch.
     */
    orderBy?: DetailPanierOrderByWithRelationInput | DetailPanierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DetailPaniers.
     */
    cursor?: DetailPanierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DetailPaniers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DetailPaniers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DetailPaniers.
     */
    distinct?: DetailPanierScalarFieldEnum | DetailPanierScalarFieldEnum[]
  }

  /**
   * DetailPanier findMany
   */
  export type DetailPanierFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetailPanier
     */
    select?: DetailPanierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DetailPanier
     */
    omit?: DetailPanierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetailPanierInclude<ExtArgs> | null
    /**
     * Filter, which DetailPaniers to fetch.
     */
    where?: DetailPanierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DetailPaniers to fetch.
     */
    orderBy?: DetailPanierOrderByWithRelationInput | DetailPanierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DetailPaniers.
     */
    cursor?: DetailPanierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DetailPaniers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DetailPaniers.
     */
    skip?: number
    distinct?: DetailPanierScalarFieldEnum | DetailPanierScalarFieldEnum[]
  }

  /**
   * DetailPanier create
   */
  export type DetailPanierCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetailPanier
     */
    select?: DetailPanierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DetailPanier
     */
    omit?: DetailPanierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetailPanierInclude<ExtArgs> | null
    /**
     * The data needed to create a DetailPanier.
     */
    data: XOR<DetailPanierCreateInput, DetailPanierUncheckedCreateInput>
  }

  /**
   * DetailPanier createMany
   */
  export type DetailPanierCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DetailPaniers.
     */
    data: DetailPanierCreateManyInput | DetailPanierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DetailPanier createManyAndReturn
   */
  export type DetailPanierCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetailPanier
     */
    select?: DetailPanierSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DetailPanier
     */
    omit?: DetailPanierOmit<ExtArgs> | null
    /**
     * The data used to create many DetailPaniers.
     */
    data: DetailPanierCreateManyInput | DetailPanierCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetailPanierIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DetailPanier update
   */
  export type DetailPanierUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetailPanier
     */
    select?: DetailPanierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DetailPanier
     */
    omit?: DetailPanierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetailPanierInclude<ExtArgs> | null
    /**
     * The data needed to update a DetailPanier.
     */
    data: XOR<DetailPanierUpdateInput, DetailPanierUncheckedUpdateInput>
    /**
     * Choose, which DetailPanier to update.
     */
    where: DetailPanierWhereUniqueInput
  }

  /**
   * DetailPanier updateMany
   */
  export type DetailPanierUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DetailPaniers.
     */
    data: XOR<DetailPanierUpdateManyMutationInput, DetailPanierUncheckedUpdateManyInput>
    /**
     * Filter which DetailPaniers to update
     */
    where?: DetailPanierWhereInput
    /**
     * Limit how many DetailPaniers to update.
     */
    limit?: number
  }

  /**
   * DetailPanier updateManyAndReturn
   */
  export type DetailPanierUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetailPanier
     */
    select?: DetailPanierSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DetailPanier
     */
    omit?: DetailPanierOmit<ExtArgs> | null
    /**
     * The data used to update DetailPaniers.
     */
    data: XOR<DetailPanierUpdateManyMutationInput, DetailPanierUncheckedUpdateManyInput>
    /**
     * Filter which DetailPaniers to update
     */
    where?: DetailPanierWhereInput
    /**
     * Limit how many DetailPaniers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetailPanierIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DetailPanier upsert
   */
  export type DetailPanierUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetailPanier
     */
    select?: DetailPanierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DetailPanier
     */
    omit?: DetailPanierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetailPanierInclude<ExtArgs> | null
    /**
     * The filter to search for the DetailPanier to update in case it exists.
     */
    where: DetailPanierWhereUniqueInput
    /**
     * In case the DetailPanier found by the `where` argument doesn't exist, create a new DetailPanier with this data.
     */
    create: XOR<DetailPanierCreateInput, DetailPanierUncheckedCreateInput>
    /**
     * In case the DetailPanier was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DetailPanierUpdateInput, DetailPanierUncheckedUpdateInput>
  }

  /**
   * DetailPanier delete
   */
  export type DetailPanierDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetailPanier
     */
    select?: DetailPanierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DetailPanier
     */
    omit?: DetailPanierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetailPanierInclude<ExtArgs> | null
    /**
     * Filter which DetailPanier to delete.
     */
    where: DetailPanierWhereUniqueInput
  }

  /**
   * DetailPanier deleteMany
   */
  export type DetailPanierDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DetailPaniers to delete
     */
    where?: DetailPanierWhereInput
    /**
     * Limit how many DetailPaniers to delete.
     */
    limit?: number
  }

  /**
   * DetailPanier without action
   */
  export type DetailPanierDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetailPanier
     */
    select?: DetailPanierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DetailPanier
     */
    omit?: DetailPanierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DetailPanierInclude<ExtArgs> | null
  }


  /**
   * Model Achat
   */

  export type AggregateAchat = {
    _count: AchatCountAggregateOutputType | null
    _avg: AchatAvgAggregateOutputType | null
    _sum: AchatSumAggregateOutputType | null
    _min: AchatMinAggregateOutputType | null
    _max: AchatMaxAggregateOutputType | null
  }

  export type AchatAvgAggregateOutputType = {
    id: number | null
    panierId: number | null
    fournisseurId: number | null
    agentId: number | null
    clientId: number | null
  }

  export type AchatSumAggregateOutputType = {
    id: number | null
    panierId: number | null
    fournisseurId: number | null
    agentId: number | null
    clientId: number | null
  }

  export type AchatMinAggregateOutputType = {
    id: number | null
    statut: $Enums.StatutAchat | null
    panierId: number | null
    fournisseurId: number | null
    agentId: number | null
    clientId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AchatMaxAggregateOutputType = {
    id: number | null
    statut: $Enums.StatutAchat | null
    panierId: number | null
    fournisseurId: number | null
    agentId: number | null
    clientId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AchatCountAggregateOutputType = {
    id: number
    statut: number
    panierId: number
    fournisseurId: number
    agentId: number
    clientId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AchatAvgAggregateInputType = {
    id?: true
    panierId?: true
    fournisseurId?: true
    agentId?: true
    clientId?: true
  }

  export type AchatSumAggregateInputType = {
    id?: true
    panierId?: true
    fournisseurId?: true
    agentId?: true
    clientId?: true
  }

  export type AchatMinAggregateInputType = {
    id?: true
    statut?: true
    panierId?: true
    fournisseurId?: true
    agentId?: true
    clientId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AchatMaxAggregateInputType = {
    id?: true
    statut?: true
    panierId?: true
    fournisseurId?: true
    agentId?: true
    clientId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AchatCountAggregateInputType = {
    id?: true
    statut?: true
    panierId?: true
    fournisseurId?: true
    agentId?: true
    clientId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AchatAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Achat to aggregate.
     */
    where?: AchatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achats to fetch.
     */
    orderBy?: AchatOrderByWithRelationInput | AchatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AchatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Achats
    **/
    _count?: true | AchatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AchatAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AchatSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AchatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AchatMaxAggregateInputType
  }

  export type GetAchatAggregateType<T extends AchatAggregateArgs> = {
        [P in keyof T & keyof AggregateAchat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAchat[P]>
      : GetScalarType<T[P], AggregateAchat[P]>
  }




  export type AchatGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AchatWhereInput
    orderBy?: AchatOrderByWithAggregationInput | AchatOrderByWithAggregationInput[]
    by: AchatScalarFieldEnum[] | AchatScalarFieldEnum
    having?: AchatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AchatCountAggregateInputType | true
    _avg?: AchatAvgAggregateInputType
    _sum?: AchatSumAggregateInputType
    _min?: AchatMinAggregateInputType
    _max?: AchatMaxAggregateInputType
  }

  export type AchatGroupByOutputType = {
    id: number
    statut: $Enums.StatutAchat
    panierId: number
    fournisseurId: number
    agentId: number
    clientId: number | null
    createdAt: Date
    updatedAt: Date
    _count: AchatCountAggregateOutputType | null
    _avg: AchatAvgAggregateOutputType | null
    _sum: AchatSumAggregateOutputType | null
    _min: AchatMinAggregateOutputType | null
    _max: AchatMaxAggregateOutputType | null
  }

  type GetAchatGroupByPayload<T extends AchatGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AchatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AchatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AchatGroupByOutputType[P]>
            : GetScalarType<T[P], AchatGroupByOutputType[P]>
        }
      >
    >


  export type AchatSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    statut?: boolean
    panierId?: boolean
    fournisseurId?: boolean
    agentId?: boolean
    clientId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    panier?: boolean | PanierDefaultArgs<ExtArgs>
    fournisseur?: boolean | FournisseurDefaultArgs<ExtArgs>
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    Client?: boolean | Achat$ClientArgs<ExtArgs>
    paiements?: boolean | Achat$paiementsArgs<ExtArgs>
    _count?: boolean | AchatCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["achat"]>

  export type AchatSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    statut?: boolean
    panierId?: boolean
    fournisseurId?: boolean
    agentId?: boolean
    clientId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    panier?: boolean | PanierDefaultArgs<ExtArgs>
    fournisseur?: boolean | FournisseurDefaultArgs<ExtArgs>
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    Client?: boolean | Achat$ClientArgs<ExtArgs>
  }, ExtArgs["result"]["achat"]>

  export type AchatSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    statut?: boolean
    panierId?: boolean
    fournisseurId?: boolean
    agentId?: boolean
    clientId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    panier?: boolean | PanierDefaultArgs<ExtArgs>
    fournisseur?: boolean | FournisseurDefaultArgs<ExtArgs>
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    Client?: boolean | Achat$ClientArgs<ExtArgs>
  }, ExtArgs["result"]["achat"]>

  export type AchatSelectScalar = {
    id?: boolean
    statut?: boolean
    panierId?: boolean
    fournisseurId?: boolean
    agentId?: boolean
    clientId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AchatOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "statut" | "panierId" | "fournisseurId" | "agentId" | "clientId" | "createdAt" | "updatedAt", ExtArgs["result"]["achat"]>
  export type AchatInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    panier?: boolean | PanierDefaultArgs<ExtArgs>
    fournisseur?: boolean | FournisseurDefaultArgs<ExtArgs>
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    Client?: boolean | Achat$ClientArgs<ExtArgs>
    paiements?: boolean | Achat$paiementsArgs<ExtArgs>
    _count?: boolean | AchatCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AchatIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    panier?: boolean | PanierDefaultArgs<ExtArgs>
    fournisseur?: boolean | FournisseurDefaultArgs<ExtArgs>
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    Client?: boolean | Achat$ClientArgs<ExtArgs>
  }
  export type AchatIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    panier?: boolean | PanierDefaultArgs<ExtArgs>
    fournisseur?: boolean | FournisseurDefaultArgs<ExtArgs>
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    Client?: boolean | Achat$ClientArgs<ExtArgs>
  }

  export type $AchatPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Achat"
    objects: {
      panier: Prisma.$PanierPayload<ExtArgs>
      fournisseur: Prisma.$FournisseurPayload<ExtArgs>
      agent: Prisma.$AgentPayload<ExtArgs>
      Client: Prisma.$ClientPayload<ExtArgs> | null
      paiements: Prisma.$PaiementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      statut: $Enums.StatutAchat
      panierId: number
      fournisseurId: number
      agentId: number
      clientId: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["achat"]>
    composites: {}
  }

  type AchatGetPayload<S extends boolean | null | undefined | AchatDefaultArgs> = $Result.GetResult<Prisma.$AchatPayload, S>

  type AchatCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AchatFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AchatCountAggregateInputType | true
    }

  export interface AchatDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Achat'], meta: { name: 'Achat' } }
    /**
     * Find zero or one Achat that matches the filter.
     * @param {AchatFindUniqueArgs} args - Arguments to find a Achat
     * @example
     * // Get one Achat
     * const achat = await prisma.achat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AchatFindUniqueArgs>(args: SelectSubset<T, AchatFindUniqueArgs<ExtArgs>>): Prisma__AchatClient<$Result.GetResult<Prisma.$AchatPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Achat that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AchatFindUniqueOrThrowArgs} args - Arguments to find a Achat
     * @example
     * // Get one Achat
     * const achat = await prisma.achat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AchatFindUniqueOrThrowArgs>(args: SelectSubset<T, AchatFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AchatClient<$Result.GetResult<Prisma.$AchatPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Achat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchatFindFirstArgs} args - Arguments to find a Achat
     * @example
     * // Get one Achat
     * const achat = await prisma.achat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AchatFindFirstArgs>(args?: SelectSubset<T, AchatFindFirstArgs<ExtArgs>>): Prisma__AchatClient<$Result.GetResult<Prisma.$AchatPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Achat that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchatFindFirstOrThrowArgs} args - Arguments to find a Achat
     * @example
     * // Get one Achat
     * const achat = await prisma.achat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AchatFindFirstOrThrowArgs>(args?: SelectSubset<T, AchatFindFirstOrThrowArgs<ExtArgs>>): Prisma__AchatClient<$Result.GetResult<Prisma.$AchatPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Achats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchatFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Achats
     * const achats = await prisma.achat.findMany()
     * 
     * // Get first 10 Achats
     * const achats = await prisma.achat.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const achatWithIdOnly = await prisma.achat.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AchatFindManyArgs>(args?: SelectSubset<T, AchatFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Achat.
     * @param {AchatCreateArgs} args - Arguments to create a Achat.
     * @example
     * // Create one Achat
     * const Achat = await prisma.achat.create({
     *   data: {
     *     // ... data to create a Achat
     *   }
     * })
     * 
     */
    create<T extends AchatCreateArgs>(args: SelectSubset<T, AchatCreateArgs<ExtArgs>>): Prisma__AchatClient<$Result.GetResult<Prisma.$AchatPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Achats.
     * @param {AchatCreateManyArgs} args - Arguments to create many Achats.
     * @example
     * // Create many Achats
     * const achat = await prisma.achat.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AchatCreateManyArgs>(args?: SelectSubset<T, AchatCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Achats and returns the data saved in the database.
     * @param {AchatCreateManyAndReturnArgs} args - Arguments to create many Achats.
     * @example
     * // Create many Achats
     * const achat = await prisma.achat.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Achats and only return the `id`
     * const achatWithIdOnly = await prisma.achat.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AchatCreateManyAndReturnArgs>(args?: SelectSubset<T, AchatCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchatPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Achat.
     * @param {AchatDeleteArgs} args - Arguments to delete one Achat.
     * @example
     * // Delete one Achat
     * const Achat = await prisma.achat.delete({
     *   where: {
     *     // ... filter to delete one Achat
     *   }
     * })
     * 
     */
    delete<T extends AchatDeleteArgs>(args: SelectSubset<T, AchatDeleteArgs<ExtArgs>>): Prisma__AchatClient<$Result.GetResult<Prisma.$AchatPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Achat.
     * @param {AchatUpdateArgs} args - Arguments to update one Achat.
     * @example
     * // Update one Achat
     * const achat = await prisma.achat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AchatUpdateArgs>(args: SelectSubset<T, AchatUpdateArgs<ExtArgs>>): Prisma__AchatClient<$Result.GetResult<Prisma.$AchatPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Achats.
     * @param {AchatDeleteManyArgs} args - Arguments to filter Achats to delete.
     * @example
     * // Delete a few Achats
     * const { count } = await prisma.achat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AchatDeleteManyArgs>(args?: SelectSubset<T, AchatDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Achats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Achats
     * const achat = await prisma.achat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AchatUpdateManyArgs>(args: SelectSubset<T, AchatUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Achats and returns the data updated in the database.
     * @param {AchatUpdateManyAndReturnArgs} args - Arguments to update many Achats.
     * @example
     * // Update many Achats
     * const achat = await prisma.achat.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Achats and only return the `id`
     * const achatWithIdOnly = await prisma.achat.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AchatUpdateManyAndReturnArgs>(args: SelectSubset<T, AchatUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchatPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Achat.
     * @param {AchatUpsertArgs} args - Arguments to update or create a Achat.
     * @example
     * // Update or create a Achat
     * const achat = await prisma.achat.upsert({
     *   create: {
     *     // ... data to create a Achat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Achat we want to update
     *   }
     * })
     */
    upsert<T extends AchatUpsertArgs>(args: SelectSubset<T, AchatUpsertArgs<ExtArgs>>): Prisma__AchatClient<$Result.GetResult<Prisma.$AchatPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Achats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchatCountArgs} args - Arguments to filter Achats to count.
     * @example
     * // Count the number of Achats
     * const count = await prisma.achat.count({
     *   where: {
     *     // ... the filter for the Achats we want to count
     *   }
     * })
    **/
    count<T extends AchatCountArgs>(
      args?: Subset<T, AchatCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AchatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Achat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AchatAggregateArgs>(args: Subset<T, AchatAggregateArgs>): Prisma.PrismaPromise<GetAchatAggregateType<T>>

    /**
     * Group by Achat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AchatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AchatGroupByArgs['orderBy'] }
        : { orderBy?: AchatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AchatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAchatGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Achat model
   */
  readonly fields: AchatFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Achat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AchatClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    panier<T extends PanierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PanierDefaultArgs<ExtArgs>>): Prisma__PanierClient<$Result.GetResult<Prisma.$PanierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    fournisseur<T extends FournisseurDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FournisseurDefaultArgs<ExtArgs>>): Prisma__FournisseurClient<$Result.GetResult<Prisma.$FournisseurPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    agent<T extends AgentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgentDefaultArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Client<T extends Achat$ClientArgs<ExtArgs> = {}>(args?: Subset<T, Achat$ClientArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    paiements<T extends Achat$paiementsArgs<ExtArgs> = {}>(args?: Subset<T, Achat$paiementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaiementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Achat model
   */
  interface AchatFieldRefs {
    readonly id: FieldRef<"Achat", 'Int'>
    readonly statut: FieldRef<"Achat", 'StatutAchat'>
    readonly panierId: FieldRef<"Achat", 'Int'>
    readonly fournisseurId: FieldRef<"Achat", 'Int'>
    readonly agentId: FieldRef<"Achat", 'Int'>
    readonly clientId: FieldRef<"Achat", 'Int'>
    readonly createdAt: FieldRef<"Achat", 'DateTime'>
    readonly updatedAt: FieldRef<"Achat", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Achat findUnique
   */
  export type AchatFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achat
     */
    select?: AchatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achat
     */
    omit?: AchatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchatInclude<ExtArgs> | null
    /**
     * Filter, which Achat to fetch.
     */
    where: AchatWhereUniqueInput
  }

  /**
   * Achat findUniqueOrThrow
   */
  export type AchatFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achat
     */
    select?: AchatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achat
     */
    omit?: AchatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchatInclude<ExtArgs> | null
    /**
     * Filter, which Achat to fetch.
     */
    where: AchatWhereUniqueInput
  }

  /**
   * Achat findFirst
   */
  export type AchatFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achat
     */
    select?: AchatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achat
     */
    omit?: AchatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchatInclude<ExtArgs> | null
    /**
     * Filter, which Achat to fetch.
     */
    where?: AchatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achats to fetch.
     */
    orderBy?: AchatOrderByWithRelationInput | AchatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Achats.
     */
    cursor?: AchatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Achats.
     */
    distinct?: AchatScalarFieldEnum | AchatScalarFieldEnum[]
  }

  /**
   * Achat findFirstOrThrow
   */
  export type AchatFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achat
     */
    select?: AchatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achat
     */
    omit?: AchatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchatInclude<ExtArgs> | null
    /**
     * Filter, which Achat to fetch.
     */
    where?: AchatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achats to fetch.
     */
    orderBy?: AchatOrderByWithRelationInput | AchatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Achats.
     */
    cursor?: AchatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Achats.
     */
    distinct?: AchatScalarFieldEnum | AchatScalarFieldEnum[]
  }

  /**
   * Achat findMany
   */
  export type AchatFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achat
     */
    select?: AchatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achat
     */
    omit?: AchatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchatInclude<ExtArgs> | null
    /**
     * Filter, which Achats to fetch.
     */
    where?: AchatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achats to fetch.
     */
    orderBy?: AchatOrderByWithRelationInput | AchatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Achats.
     */
    cursor?: AchatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achats.
     */
    skip?: number
    distinct?: AchatScalarFieldEnum | AchatScalarFieldEnum[]
  }

  /**
   * Achat create
   */
  export type AchatCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achat
     */
    select?: AchatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achat
     */
    omit?: AchatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchatInclude<ExtArgs> | null
    /**
     * The data needed to create a Achat.
     */
    data: XOR<AchatCreateInput, AchatUncheckedCreateInput>
  }

  /**
   * Achat createMany
   */
  export type AchatCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Achats.
     */
    data: AchatCreateManyInput | AchatCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Achat createManyAndReturn
   */
  export type AchatCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achat
     */
    select?: AchatSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Achat
     */
    omit?: AchatOmit<ExtArgs> | null
    /**
     * The data used to create many Achats.
     */
    data: AchatCreateManyInput | AchatCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchatIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Achat update
   */
  export type AchatUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achat
     */
    select?: AchatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achat
     */
    omit?: AchatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchatInclude<ExtArgs> | null
    /**
     * The data needed to update a Achat.
     */
    data: XOR<AchatUpdateInput, AchatUncheckedUpdateInput>
    /**
     * Choose, which Achat to update.
     */
    where: AchatWhereUniqueInput
  }

  /**
   * Achat updateMany
   */
  export type AchatUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Achats.
     */
    data: XOR<AchatUpdateManyMutationInput, AchatUncheckedUpdateManyInput>
    /**
     * Filter which Achats to update
     */
    where?: AchatWhereInput
    /**
     * Limit how many Achats to update.
     */
    limit?: number
  }

  /**
   * Achat updateManyAndReturn
   */
  export type AchatUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achat
     */
    select?: AchatSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Achat
     */
    omit?: AchatOmit<ExtArgs> | null
    /**
     * The data used to update Achats.
     */
    data: XOR<AchatUpdateManyMutationInput, AchatUncheckedUpdateManyInput>
    /**
     * Filter which Achats to update
     */
    where?: AchatWhereInput
    /**
     * Limit how many Achats to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchatIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Achat upsert
   */
  export type AchatUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achat
     */
    select?: AchatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achat
     */
    omit?: AchatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchatInclude<ExtArgs> | null
    /**
     * The filter to search for the Achat to update in case it exists.
     */
    where: AchatWhereUniqueInput
    /**
     * In case the Achat found by the `where` argument doesn't exist, create a new Achat with this data.
     */
    create: XOR<AchatCreateInput, AchatUncheckedCreateInput>
    /**
     * In case the Achat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AchatUpdateInput, AchatUncheckedUpdateInput>
  }

  /**
   * Achat delete
   */
  export type AchatDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achat
     */
    select?: AchatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achat
     */
    omit?: AchatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchatInclude<ExtArgs> | null
    /**
     * Filter which Achat to delete.
     */
    where: AchatWhereUniqueInput
  }

  /**
   * Achat deleteMany
   */
  export type AchatDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Achats to delete
     */
    where?: AchatWhereInput
    /**
     * Limit how many Achats to delete.
     */
    limit?: number
  }

  /**
   * Achat.Client
   */
  export type Achat$ClientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
  }

  /**
   * Achat.paiements
   */
  export type Achat$paiementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paiement
     */
    select?: PaiementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Paiement
     */
    omit?: PaiementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaiementInclude<ExtArgs> | null
    where?: PaiementWhereInput
    orderBy?: PaiementOrderByWithRelationInput | PaiementOrderByWithRelationInput[]
    cursor?: PaiementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaiementScalarFieldEnum | PaiementScalarFieldEnum[]
  }

  /**
   * Achat without action
   */
  export type AchatDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achat
     */
    select?: AchatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achat
     */
    omit?: AchatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchatInclude<ExtArgs> | null
  }


  /**
   * Model Reservation
   */

  export type AggregateReservation = {
    _count: ReservationCountAggregateOutputType | null
    _avg: ReservationAvgAggregateOutputType | null
    _sum: ReservationSumAggregateOutputType | null
    _min: ReservationMinAggregateOutputType | null
    _max: ReservationMaxAggregateOutputType | null
  }

  export type ReservationAvgAggregateOutputType = {
    id: number | null
    clientId: number | null
    panierId: number | null
    adresseId: number | null
    contactId: number | null
    enregistrerParId: number | null
    fournisseurId: number | null
  }

  export type ReservationSumAggregateOutputType = {
    id: number | null
    clientId: number | null
    panierId: number | null
    adresseId: number | null
    contactId: number | null
    enregistrerParId: number | null
    fournisseurId: number | null
  }

  export type ReservationMinAggregateOutputType = {
    id: number | null
    dateLivraisonSouhaitee: Date | null
    adresseLivraison: string | null
    statut: $Enums.StatutReservation | null
    notes: string | null
    typeClient: $Enums.TypeClient | null
    clientId: number | null
    panierId: number | null
    nom: string | null
    tel: string | null
    adresseId: number | null
    contactId: number | null
    enregistrerParId: number | null
    fournisseurId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReservationMaxAggregateOutputType = {
    id: number | null
    dateLivraisonSouhaitee: Date | null
    adresseLivraison: string | null
    statut: $Enums.StatutReservation | null
    notes: string | null
    typeClient: $Enums.TypeClient | null
    clientId: number | null
    panierId: number | null
    nom: string | null
    tel: string | null
    adresseId: number | null
    contactId: number | null
    enregistrerParId: number | null
    fournisseurId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReservationCountAggregateOutputType = {
    id: number
    dateLivraisonSouhaitee: number
    adresseLivraison: number
    statut: number
    notes: number
    typeClient: number
    clientId: number
    panierId: number
    nom: number
    tel: number
    adresseId: number
    contactId: number
    enregistrerParId: number
    fournisseurId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReservationAvgAggregateInputType = {
    id?: true
    clientId?: true
    panierId?: true
    adresseId?: true
    contactId?: true
    enregistrerParId?: true
    fournisseurId?: true
  }

  export type ReservationSumAggregateInputType = {
    id?: true
    clientId?: true
    panierId?: true
    adresseId?: true
    contactId?: true
    enregistrerParId?: true
    fournisseurId?: true
  }

  export type ReservationMinAggregateInputType = {
    id?: true
    dateLivraisonSouhaitee?: true
    adresseLivraison?: true
    statut?: true
    notes?: true
    typeClient?: true
    clientId?: true
    panierId?: true
    nom?: true
    tel?: true
    adresseId?: true
    contactId?: true
    enregistrerParId?: true
    fournisseurId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReservationMaxAggregateInputType = {
    id?: true
    dateLivraisonSouhaitee?: true
    adresseLivraison?: true
    statut?: true
    notes?: true
    typeClient?: true
    clientId?: true
    panierId?: true
    nom?: true
    tel?: true
    adresseId?: true
    contactId?: true
    enregistrerParId?: true
    fournisseurId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReservationCountAggregateInputType = {
    id?: true
    dateLivraisonSouhaitee?: true
    adresseLivraison?: true
    statut?: true
    notes?: true
    typeClient?: true
    clientId?: true
    panierId?: true
    nom?: true
    tel?: true
    adresseId?: true
    contactId?: true
    enregistrerParId?: true
    fournisseurId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReservationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reservation to aggregate.
     */
    where?: ReservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reservations to fetch.
     */
    orderBy?: ReservationOrderByWithRelationInput | ReservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reservations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reservations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reservations
    **/
    _count?: true | ReservationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReservationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReservationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReservationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReservationMaxAggregateInputType
  }

  export type GetReservationAggregateType<T extends ReservationAggregateArgs> = {
        [P in keyof T & keyof AggregateReservation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReservation[P]>
      : GetScalarType<T[P], AggregateReservation[P]>
  }




  export type ReservationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReservationWhereInput
    orderBy?: ReservationOrderByWithAggregationInput | ReservationOrderByWithAggregationInput[]
    by: ReservationScalarFieldEnum[] | ReservationScalarFieldEnum
    having?: ReservationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReservationCountAggregateInputType | true
    _avg?: ReservationAvgAggregateInputType
    _sum?: ReservationSumAggregateInputType
    _min?: ReservationMinAggregateInputType
    _max?: ReservationMaxAggregateInputType
  }

  export type ReservationGroupByOutputType = {
    id: number
    dateLivraisonSouhaitee: Date
    adresseLivraison: string | null
    statut: $Enums.StatutReservation
    notes: string | null
    typeClient: $Enums.TypeClient
    clientId: number | null
    panierId: number
    nom: string | null
    tel: string | null
    adresseId: number | null
    contactId: number | null
    enregistrerParId: number | null
    fournisseurId: number | null
    createdAt: Date
    updatedAt: Date
    _count: ReservationCountAggregateOutputType | null
    _avg: ReservationAvgAggregateOutputType | null
    _sum: ReservationSumAggregateOutputType | null
    _min: ReservationMinAggregateOutputType | null
    _max: ReservationMaxAggregateOutputType | null
  }

  type GetReservationGroupByPayload<T extends ReservationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReservationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReservationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReservationGroupByOutputType[P]>
            : GetScalarType<T[P], ReservationGroupByOutputType[P]>
        }
      >
    >


  export type ReservationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dateLivraisonSouhaitee?: boolean
    adresseLivraison?: boolean
    statut?: boolean
    notes?: boolean
    typeClient?: boolean
    clientId?: boolean
    panierId?: boolean
    nom?: boolean
    tel?: boolean
    adresseId?: boolean
    contactId?: boolean
    enregistrerParId?: boolean
    fournisseurId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    panier?: boolean | PanierDefaultArgs<ExtArgs>
    fournisseur?: boolean | Reservation$fournisseurArgs<ExtArgs>
    adresse?: boolean | Reservation$adresseArgs<ExtArgs>
    contact?: boolean | Reservation$contactArgs<ExtArgs>
    Client?: boolean | Reservation$ClientArgs<ExtArgs>
  }, ExtArgs["result"]["reservation"]>

  export type ReservationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dateLivraisonSouhaitee?: boolean
    adresseLivraison?: boolean
    statut?: boolean
    notes?: boolean
    typeClient?: boolean
    clientId?: boolean
    panierId?: boolean
    nom?: boolean
    tel?: boolean
    adresseId?: boolean
    contactId?: boolean
    enregistrerParId?: boolean
    fournisseurId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    panier?: boolean | PanierDefaultArgs<ExtArgs>
    fournisseur?: boolean | Reservation$fournisseurArgs<ExtArgs>
    adresse?: boolean | Reservation$adresseArgs<ExtArgs>
    contact?: boolean | Reservation$contactArgs<ExtArgs>
    Client?: boolean | Reservation$ClientArgs<ExtArgs>
  }, ExtArgs["result"]["reservation"]>

  export type ReservationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dateLivraisonSouhaitee?: boolean
    adresseLivraison?: boolean
    statut?: boolean
    notes?: boolean
    typeClient?: boolean
    clientId?: boolean
    panierId?: boolean
    nom?: boolean
    tel?: boolean
    adresseId?: boolean
    contactId?: boolean
    enregistrerParId?: boolean
    fournisseurId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    panier?: boolean | PanierDefaultArgs<ExtArgs>
    fournisseur?: boolean | Reservation$fournisseurArgs<ExtArgs>
    adresse?: boolean | Reservation$adresseArgs<ExtArgs>
    contact?: boolean | Reservation$contactArgs<ExtArgs>
    Client?: boolean | Reservation$ClientArgs<ExtArgs>
  }, ExtArgs["result"]["reservation"]>

  export type ReservationSelectScalar = {
    id?: boolean
    dateLivraisonSouhaitee?: boolean
    adresseLivraison?: boolean
    statut?: boolean
    notes?: boolean
    typeClient?: boolean
    clientId?: boolean
    panierId?: boolean
    nom?: boolean
    tel?: boolean
    adresseId?: boolean
    contactId?: boolean
    enregistrerParId?: boolean
    fournisseurId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReservationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "dateLivraisonSouhaitee" | "adresseLivraison" | "statut" | "notes" | "typeClient" | "clientId" | "panierId" | "nom" | "tel" | "adresseId" | "contactId" | "enregistrerParId" | "fournisseurId" | "createdAt" | "updatedAt", ExtArgs["result"]["reservation"]>
  export type ReservationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    panier?: boolean | PanierDefaultArgs<ExtArgs>
    fournisseur?: boolean | Reservation$fournisseurArgs<ExtArgs>
    adresse?: boolean | Reservation$adresseArgs<ExtArgs>
    contact?: boolean | Reservation$contactArgs<ExtArgs>
    Client?: boolean | Reservation$ClientArgs<ExtArgs>
  }
  export type ReservationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    panier?: boolean | PanierDefaultArgs<ExtArgs>
    fournisseur?: boolean | Reservation$fournisseurArgs<ExtArgs>
    adresse?: boolean | Reservation$adresseArgs<ExtArgs>
    contact?: boolean | Reservation$contactArgs<ExtArgs>
    Client?: boolean | Reservation$ClientArgs<ExtArgs>
  }
  export type ReservationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    panier?: boolean | PanierDefaultArgs<ExtArgs>
    fournisseur?: boolean | Reservation$fournisseurArgs<ExtArgs>
    adresse?: boolean | Reservation$adresseArgs<ExtArgs>
    contact?: boolean | Reservation$contactArgs<ExtArgs>
    Client?: boolean | Reservation$ClientArgs<ExtArgs>
  }

  export type $ReservationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Reservation"
    objects: {
      panier: Prisma.$PanierPayload<ExtArgs>
      fournisseur: Prisma.$FournisseurPayload<ExtArgs> | null
      adresse: Prisma.$AdressePayload<ExtArgs> | null
      contact: Prisma.$ContactPayload<ExtArgs> | null
      Client: Prisma.$ClientPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      dateLivraisonSouhaitee: Date
      adresseLivraison: string | null
      statut: $Enums.StatutReservation
      notes: string | null
      typeClient: $Enums.TypeClient
      clientId: number | null
      panierId: number
      nom: string | null
      tel: string | null
      adresseId: number | null
      contactId: number | null
      enregistrerParId: number | null
      fournisseurId: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["reservation"]>
    composites: {}
  }

  type ReservationGetPayload<S extends boolean | null | undefined | ReservationDefaultArgs> = $Result.GetResult<Prisma.$ReservationPayload, S>

  type ReservationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReservationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReservationCountAggregateInputType | true
    }

  export interface ReservationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Reservation'], meta: { name: 'Reservation' } }
    /**
     * Find zero or one Reservation that matches the filter.
     * @param {ReservationFindUniqueArgs} args - Arguments to find a Reservation
     * @example
     * // Get one Reservation
     * const reservation = await prisma.reservation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReservationFindUniqueArgs>(args: SelectSubset<T, ReservationFindUniqueArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Reservation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReservationFindUniqueOrThrowArgs} args - Arguments to find a Reservation
     * @example
     * // Get one Reservation
     * const reservation = await prisma.reservation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReservationFindUniqueOrThrowArgs>(args: SelectSubset<T, ReservationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reservation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationFindFirstArgs} args - Arguments to find a Reservation
     * @example
     * // Get one Reservation
     * const reservation = await prisma.reservation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReservationFindFirstArgs>(args?: SelectSubset<T, ReservationFindFirstArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reservation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationFindFirstOrThrowArgs} args - Arguments to find a Reservation
     * @example
     * // Get one Reservation
     * const reservation = await prisma.reservation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReservationFindFirstOrThrowArgs>(args?: SelectSubset<T, ReservationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reservations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reservations
     * const reservations = await prisma.reservation.findMany()
     * 
     * // Get first 10 Reservations
     * const reservations = await prisma.reservation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reservationWithIdOnly = await prisma.reservation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReservationFindManyArgs>(args?: SelectSubset<T, ReservationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Reservation.
     * @param {ReservationCreateArgs} args - Arguments to create a Reservation.
     * @example
     * // Create one Reservation
     * const Reservation = await prisma.reservation.create({
     *   data: {
     *     // ... data to create a Reservation
     *   }
     * })
     * 
     */
    create<T extends ReservationCreateArgs>(args: SelectSubset<T, ReservationCreateArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reservations.
     * @param {ReservationCreateManyArgs} args - Arguments to create many Reservations.
     * @example
     * // Create many Reservations
     * const reservation = await prisma.reservation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReservationCreateManyArgs>(args?: SelectSubset<T, ReservationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reservations and returns the data saved in the database.
     * @param {ReservationCreateManyAndReturnArgs} args - Arguments to create many Reservations.
     * @example
     * // Create many Reservations
     * const reservation = await prisma.reservation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reservations and only return the `id`
     * const reservationWithIdOnly = await prisma.reservation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReservationCreateManyAndReturnArgs>(args?: SelectSubset<T, ReservationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Reservation.
     * @param {ReservationDeleteArgs} args - Arguments to delete one Reservation.
     * @example
     * // Delete one Reservation
     * const Reservation = await prisma.reservation.delete({
     *   where: {
     *     // ... filter to delete one Reservation
     *   }
     * })
     * 
     */
    delete<T extends ReservationDeleteArgs>(args: SelectSubset<T, ReservationDeleteArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Reservation.
     * @param {ReservationUpdateArgs} args - Arguments to update one Reservation.
     * @example
     * // Update one Reservation
     * const reservation = await prisma.reservation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReservationUpdateArgs>(args: SelectSubset<T, ReservationUpdateArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reservations.
     * @param {ReservationDeleteManyArgs} args - Arguments to filter Reservations to delete.
     * @example
     * // Delete a few Reservations
     * const { count } = await prisma.reservation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReservationDeleteManyArgs>(args?: SelectSubset<T, ReservationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reservations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reservations
     * const reservation = await prisma.reservation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReservationUpdateManyArgs>(args: SelectSubset<T, ReservationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reservations and returns the data updated in the database.
     * @param {ReservationUpdateManyAndReturnArgs} args - Arguments to update many Reservations.
     * @example
     * // Update many Reservations
     * const reservation = await prisma.reservation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Reservations and only return the `id`
     * const reservationWithIdOnly = await prisma.reservation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReservationUpdateManyAndReturnArgs>(args: SelectSubset<T, ReservationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Reservation.
     * @param {ReservationUpsertArgs} args - Arguments to update or create a Reservation.
     * @example
     * // Update or create a Reservation
     * const reservation = await prisma.reservation.upsert({
     *   create: {
     *     // ... data to create a Reservation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reservation we want to update
     *   }
     * })
     */
    upsert<T extends ReservationUpsertArgs>(args: SelectSubset<T, ReservationUpsertArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reservations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationCountArgs} args - Arguments to filter Reservations to count.
     * @example
     * // Count the number of Reservations
     * const count = await prisma.reservation.count({
     *   where: {
     *     // ... the filter for the Reservations we want to count
     *   }
     * })
    **/
    count<T extends ReservationCountArgs>(
      args?: Subset<T, ReservationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReservationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reservation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReservationAggregateArgs>(args: Subset<T, ReservationAggregateArgs>): Prisma.PrismaPromise<GetReservationAggregateType<T>>

    /**
     * Group by Reservation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReservationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReservationGroupByArgs['orderBy'] }
        : { orderBy?: ReservationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReservationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReservationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Reservation model
   */
  readonly fields: ReservationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Reservation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReservationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    panier<T extends PanierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PanierDefaultArgs<ExtArgs>>): Prisma__PanierClient<$Result.GetResult<Prisma.$PanierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    fournisseur<T extends Reservation$fournisseurArgs<ExtArgs> = {}>(args?: Subset<T, Reservation$fournisseurArgs<ExtArgs>>): Prisma__FournisseurClient<$Result.GetResult<Prisma.$FournisseurPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    adresse<T extends Reservation$adresseArgs<ExtArgs> = {}>(args?: Subset<T, Reservation$adresseArgs<ExtArgs>>): Prisma__AdresseClient<$Result.GetResult<Prisma.$AdressePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    contact<T extends Reservation$contactArgs<ExtArgs> = {}>(args?: Subset<T, Reservation$contactArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Client<T extends Reservation$ClientArgs<ExtArgs> = {}>(args?: Subset<T, Reservation$ClientArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Reservation model
   */
  interface ReservationFieldRefs {
    readonly id: FieldRef<"Reservation", 'Int'>
    readonly dateLivraisonSouhaitee: FieldRef<"Reservation", 'DateTime'>
    readonly adresseLivraison: FieldRef<"Reservation", 'String'>
    readonly statut: FieldRef<"Reservation", 'StatutReservation'>
    readonly notes: FieldRef<"Reservation", 'String'>
    readonly typeClient: FieldRef<"Reservation", 'TypeClient'>
    readonly clientId: FieldRef<"Reservation", 'Int'>
    readonly panierId: FieldRef<"Reservation", 'Int'>
    readonly nom: FieldRef<"Reservation", 'String'>
    readonly tel: FieldRef<"Reservation", 'String'>
    readonly adresseId: FieldRef<"Reservation", 'Int'>
    readonly contactId: FieldRef<"Reservation", 'Int'>
    readonly enregistrerParId: FieldRef<"Reservation", 'Int'>
    readonly fournisseurId: FieldRef<"Reservation", 'Int'>
    readonly createdAt: FieldRef<"Reservation", 'DateTime'>
    readonly updatedAt: FieldRef<"Reservation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Reservation findUnique
   */
  export type ReservationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * Filter, which Reservation to fetch.
     */
    where: ReservationWhereUniqueInput
  }

  /**
   * Reservation findUniqueOrThrow
   */
  export type ReservationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * Filter, which Reservation to fetch.
     */
    where: ReservationWhereUniqueInput
  }

  /**
   * Reservation findFirst
   */
  export type ReservationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * Filter, which Reservation to fetch.
     */
    where?: ReservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reservations to fetch.
     */
    orderBy?: ReservationOrderByWithRelationInput | ReservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reservations.
     */
    cursor?: ReservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reservations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reservations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reservations.
     */
    distinct?: ReservationScalarFieldEnum | ReservationScalarFieldEnum[]
  }

  /**
   * Reservation findFirstOrThrow
   */
  export type ReservationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * Filter, which Reservation to fetch.
     */
    where?: ReservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reservations to fetch.
     */
    orderBy?: ReservationOrderByWithRelationInput | ReservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reservations.
     */
    cursor?: ReservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reservations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reservations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reservations.
     */
    distinct?: ReservationScalarFieldEnum | ReservationScalarFieldEnum[]
  }

  /**
   * Reservation findMany
   */
  export type ReservationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * Filter, which Reservations to fetch.
     */
    where?: ReservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reservations to fetch.
     */
    orderBy?: ReservationOrderByWithRelationInput | ReservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reservations.
     */
    cursor?: ReservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reservations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reservations.
     */
    skip?: number
    distinct?: ReservationScalarFieldEnum | ReservationScalarFieldEnum[]
  }

  /**
   * Reservation create
   */
  export type ReservationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * The data needed to create a Reservation.
     */
    data: XOR<ReservationCreateInput, ReservationUncheckedCreateInput>
  }

  /**
   * Reservation createMany
   */
  export type ReservationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reservations.
     */
    data: ReservationCreateManyInput | ReservationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Reservation createManyAndReturn
   */
  export type ReservationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * The data used to create many Reservations.
     */
    data: ReservationCreateManyInput | ReservationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Reservation update
   */
  export type ReservationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * The data needed to update a Reservation.
     */
    data: XOR<ReservationUpdateInput, ReservationUncheckedUpdateInput>
    /**
     * Choose, which Reservation to update.
     */
    where: ReservationWhereUniqueInput
  }

  /**
   * Reservation updateMany
   */
  export type ReservationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reservations.
     */
    data: XOR<ReservationUpdateManyMutationInput, ReservationUncheckedUpdateManyInput>
    /**
     * Filter which Reservations to update
     */
    where?: ReservationWhereInput
    /**
     * Limit how many Reservations to update.
     */
    limit?: number
  }

  /**
   * Reservation updateManyAndReturn
   */
  export type ReservationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * The data used to update Reservations.
     */
    data: XOR<ReservationUpdateManyMutationInput, ReservationUncheckedUpdateManyInput>
    /**
     * Filter which Reservations to update
     */
    where?: ReservationWhereInput
    /**
     * Limit how many Reservations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Reservation upsert
   */
  export type ReservationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * The filter to search for the Reservation to update in case it exists.
     */
    where: ReservationWhereUniqueInput
    /**
     * In case the Reservation found by the `where` argument doesn't exist, create a new Reservation with this data.
     */
    create: XOR<ReservationCreateInput, ReservationUncheckedCreateInput>
    /**
     * In case the Reservation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReservationUpdateInput, ReservationUncheckedUpdateInput>
  }

  /**
   * Reservation delete
   */
  export type ReservationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * Filter which Reservation to delete.
     */
    where: ReservationWhereUniqueInput
  }

  /**
   * Reservation deleteMany
   */
  export type ReservationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reservations to delete
     */
    where?: ReservationWhereInput
    /**
     * Limit how many Reservations to delete.
     */
    limit?: number
  }

  /**
   * Reservation.fournisseur
   */
  export type Reservation$fournisseurArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fournisseur
     */
    select?: FournisseurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fournisseur
     */
    omit?: FournisseurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FournisseurInclude<ExtArgs> | null
    where?: FournisseurWhereInput
  }

  /**
   * Reservation.adresse
   */
  export type Reservation$adresseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adresse
     */
    select?: AdresseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Adresse
     */
    omit?: AdresseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdresseInclude<ExtArgs> | null
    where?: AdresseWhereInput
  }

  /**
   * Reservation.contact
   */
  export type Reservation$contactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
  }

  /**
   * Reservation.Client
   */
  export type Reservation$ClientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
  }

  /**
   * Reservation without action
   */
  export type ReservationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reservation
     */
    omit?: ReservationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
  }


  /**
   * Model Commande
   */

  export type AggregateCommande = {
    _count: CommandeCountAggregateOutputType | null
    _avg: CommandeAvgAggregateOutputType | null
    _sum: CommandeSumAggregateOutputType | null
    _min: CommandeMinAggregateOutputType | null
    _max: CommandeMaxAggregateOutputType | null
  }

  export type CommandeAvgAggregateOutputType = {
    id: number | null
    panierId: number | null
    clientId: number | null
    adresseId: number | null
    contactId: number | null
    fournisseurId: number | null
    commandeId: number | null
    enregistrerParId: number | null
  }

  export type CommandeSumAggregateOutputType = {
    id: number | null
    panierId: number | null
    clientId: number | null
    adresseId: number | null
    contactId: number | null
    fournisseurId: number | null
    commandeId: number | null
    enregistrerParId: number | null
  }

  export type CommandeMinAggregateOutputType = {
    id: number | null
    panierId: number | null
    clientId: number | null
    nom: string | null
    tel: string | null
    type_client: $Enums.TypeClient | null
    adresseId: number | null
    contactId: number | null
    fournisseurId: number | null
    commandeId: number | null
    notes: string | null
    dateLivraisonEffective: Date | null
    adresseLivraison: string | null
    enregistrerParId: number | null
    statut: $Enums.StatutCommande | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommandeMaxAggregateOutputType = {
    id: number | null
    panierId: number | null
    clientId: number | null
    nom: string | null
    tel: string | null
    type_client: $Enums.TypeClient | null
    adresseId: number | null
    contactId: number | null
    fournisseurId: number | null
    commandeId: number | null
    notes: string | null
    dateLivraisonEffective: Date | null
    adresseLivraison: string | null
    enregistrerParId: number | null
    statut: $Enums.StatutCommande | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommandeCountAggregateOutputType = {
    id: number
    panierId: number
    clientId: number
    nom: number
    tel: number
    type_client: number
    adresseId: number
    contactId: number
    fournisseurId: number
    commandeId: number
    notes: number
    dateLivraisonEffective: number
    adresseLivraison: number
    enregistrerParId: number
    statut: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CommandeAvgAggregateInputType = {
    id?: true
    panierId?: true
    clientId?: true
    adresseId?: true
    contactId?: true
    fournisseurId?: true
    commandeId?: true
    enregistrerParId?: true
  }

  export type CommandeSumAggregateInputType = {
    id?: true
    panierId?: true
    clientId?: true
    adresseId?: true
    contactId?: true
    fournisseurId?: true
    commandeId?: true
    enregistrerParId?: true
  }

  export type CommandeMinAggregateInputType = {
    id?: true
    panierId?: true
    clientId?: true
    nom?: true
    tel?: true
    type_client?: true
    adresseId?: true
    contactId?: true
    fournisseurId?: true
    commandeId?: true
    notes?: true
    dateLivraisonEffective?: true
    adresseLivraison?: true
    enregistrerParId?: true
    statut?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommandeMaxAggregateInputType = {
    id?: true
    panierId?: true
    clientId?: true
    nom?: true
    tel?: true
    type_client?: true
    adresseId?: true
    contactId?: true
    fournisseurId?: true
    commandeId?: true
    notes?: true
    dateLivraisonEffective?: true
    adresseLivraison?: true
    enregistrerParId?: true
    statut?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommandeCountAggregateInputType = {
    id?: true
    panierId?: true
    clientId?: true
    nom?: true
    tel?: true
    type_client?: true
    adresseId?: true
    contactId?: true
    fournisseurId?: true
    commandeId?: true
    notes?: true
    dateLivraisonEffective?: true
    adresseLivraison?: true
    enregistrerParId?: true
    statut?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CommandeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Commande to aggregate.
     */
    where?: CommandeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Commandes to fetch.
     */
    orderBy?: CommandeOrderByWithRelationInput | CommandeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommandeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Commandes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Commandes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Commandes
    **/
    _count?: true | CommandeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommandeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommandeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommandeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommandeMaxAggregateInputType
  }

  export type GetCommandeAggregateType<T extends CommandeAggregateArgs> = {
        [P in keyof T & keyof AggregateCommande]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommande[P]>
      : GetScalarType<T[P], AggregateCommande[P]>
  }




  export type CommandeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommandeWhereInput
    orderBy?: CommandeOrderByWithAggregationInput | CommandeOrderByWithAggregationInput[]
    by: CommandeScalarFieldEnum[] | CommandeScalarFieldEnum
    having?: CommandeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommandeCountAggregateInputType | true
    _avg?: CommandeAvgAggregateInputType
    _sum?: CommandeSumAggregateInputType
    _min?: CommandeMinAggregateInputType
    _max?: CommandeMaxAggregateInputType
  }

  export type CommandeGroupByOutputType = {
    id: number
    panierId: number
    clientId: number | null
    nom: string | null
    tel: string | null
    type_client: $Enums.TypeClient
    adresseId: number | null
    contactId: number | null
    fournisseurId: number | null
    commandeId: number | null
    notes: string | null
    dateLivraisonEffective: Date | null
    adresseLivraison: string | null
    enregistrerParId: number | null
    statut: $Enums.StatutCommande
    createdAt: Date
    updatedAt: Date
    _count: CommandeCountAggregateOutputType | null
    _avg: CommandeAvgAggregateOutputType | null
    _sum: CommandeSumAggregateOutputType | null
    _min: CommandeMinAggregateOutputType | null
    _max: CommandeMaxAggregateOutputType | null
  }

  type GetCommandeGroupByPayload<T extends CommandeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommandeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommandeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommandeGroupByOutputType[P]>
            : GetScalarType<T[P], CommandeGroupByOutputType[P]>
        }
      >
    >


  export type CommandeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    panierId?: boolean
    clientId?: boolean
    nom?: boolean
    tel?: boolean
    type_client?: boolean
    adresseId?: boolean
    contactId?: boolean
    fournisseurId?: boolean
    commandeId?: boolean
    notes?: boolean
    dateLivraisonEffective?: boolean
    adresseLivraison?: boolean
    enregistrerParId?: boolean
    statut?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Paiement?: boolean | Commande$PaiementArgs<ExtArgs>
    panier?: boolean | PanierDefaultArgs<ExtArgs>
    fournisseur?: boolean | Commande$fournisseurArgs<ExtArgs>
    adresse?: boolean | Commande$adresseArgs<ExtArgs>
    contact?: boolean | Commande$contactArgs<ExtArgs>
    Client?: boolean | Commande$ClientArgs<ExtArgs>
    _count?: boolean | CommandeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["commande"]>

  export type CommandeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    panierId?: boolean
    clientId?: boolean
    nom?: boolean
    tel?: boolean
    type_client?: boolean
    adresseId?: boolean
    contactId?: boolean
    fournisseurId?: boolean
    commandeId?: boolean
    notes?: boolean
    dateLivraisonEffective?: boolean
    adresseLivraison?: boolean
    enregistrerParId?: boolean
    statut?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    panier?: boolean | PanierDefaultArgs<ExtArgs>
    fournisseur?: boolean | Commande$fournisseurArgs<ExtArgs>
    adresse?: boolean | Commande$adresseArgs<ExtArgs>
    contact?: boolean | Commande$contactArgs<ExtArgs>
    Client?: boolean | Commande$ClientArgs<ExtArgs>
  }, ExtArgs["result"]["commande"]>

  export type CommandeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    panierId?: boolean
    clientId?: boolean
    nom?: boolean
    tel?: boolean
    type_client?: boolean
    adresseId?: boolean
    contactId?: boolean
    fournisseurId?: boolean
    commandeId?: boolean
    notes?: boolean
    dateLivraisonEffective?: boolean
    adresseLivraison?: boolean
    enregistrerParId?: boolean
    statut?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    panier?: boolean | PanierDefaultArgs<ExtArgs>
    fournisseur?: boolean | Commande$fournisseurArgs<ExtArgs>
    adresse?: boolean | Commande$adresseArgs<ExtArgs>
    contact?: boolean | Commande$contactArgs<ExtArgs>
    Client?: boolean | Commande$ClientArgs<ExtArgs>
  }, ExtArgs["result"]["commande"]>

  export type CommandeSelectScalar = {
    id?: boolean
    panierId?: boolean
    clientId?: boolean
    nom?: boolean
    tel?: boolean
    type_client?: boolean
    adresseId?: boolean
    contactId?: boolean
    fournisseurId?: boolean
    commandeId?: boolean
    notes?: boolean
    dateLivraisonEffective?: boolean
    adresseLivraison?: boolean
    enregistrerParId?: boolean
    statut?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CommandeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "panierId" | "clientId" | "nom" | "tel" | "type_client" | "adresseId" | "contactId" | "fournisseurId" | "commandeId" | "notes" | "dateLivraisonEffective" | "adresseLivraison" | "enregistrerParId" | "statut" | "createdAt" | "updatedAt", ExtArgs["result"]["commande"]>
  export type CommandeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Paiement?: boolean | Commande$PaiementArgs<ExtArgs>
    panier?: boolean | PanierDefaultArgs<ExtArgs>
    fournisseur?: boolean | Commande$fournisseurArgs<ExtArgs>
    adresse?: boolean | Commande$adresseArgs<ExtArgs>
    contact?: boolean | Commande$contactArgs<ExtArgs>
    Client?: boolean | Commande$ClientArgs<ExtArgs>
    _count?: boolean | CommandeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CommandeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    panier?: boolean | PanierDefaultArgs<ExtArgs>
    fournisseur?: boolean | Commande$fournisseurArgs<ExtArgs>
    adresse?: boolean | Commande$adresseArgs<ExtArgs>
    contact?: boolean | Commande$contactArgs<ExtArgs>
    Client?: boolean | Commande$ClientArgs<ExtArgs>
  }
  export type CommandeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    panier?: boolean | PanierDefaultArgs<ExtArgs>
    fournisseur?: boolean | Commande$fournisseurArgs<ExtArgs>
    adresse?: boolean | Commande$adresseArgs<ExtArgs>
    contact?: boolean | Commande$contactArgs<ExtArgs>
    Client?: boolean | Commande$ClientArgs<ExtArgs>
  }

  export type $CommandePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Commande"
    objects: {
      Paiement: Prisma.$PaiementPayload<ExtArgs>[]
      panier: Prisma.$PanierPayload<ExtArgs>
      fournisseur: Prisma.$FournisseurPayload<ExtArgs> | null
      adresse: Prisma.$AdressePayload<ExtArgs> | null
      contact: Prisma.$ContactPayload<ExtArgs> | null
      Client: Prisma.$ClientPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      panierId: number
      clientId: number | null
      nom: string | null
      tel: string | null
      type_client: $Enums.TypeClient
      adresseId: number | null
      contactId: number | null
      fournisseurId: number | null
      commandeId: number | null
      notes: string | null
      dateLivraisonEffective: Date | null
      adresseLivraison: string | null
      enregistrerParId: number | null
      statut: $Enums.StatutCommande
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["commande"]>
    composites: {}
  }

  type CommandeGetPayload<S extends boolean | null | undefined | CommandeDefaultArgs> = $Result.GetResult<Prisma.$CommandePayload, S>

  type CommandeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommandeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommandeCountAggregateInputType | true
    }

  export interface CommandeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Commande'], meta: { name: 'Commande' } }
    /**
     * Find zero or one Commande that matches the filter.
     * @param {CommandeFindUniqueArgs} args - Arguments to find a Commande
     * @example
     * // Get one Commande
     * const commande = await prisma.commande.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommandeFindUniqueArgs>(args: SelectSubset<T, CommandeFindUniqueArgs<ExtArgs>>): Prisma__CommandeClient<$Result.GetResult<Prisma.$CommandePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Commande that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommandeFindUniqueOrThrowArgs} args - Arguments to find a Commande
     * @example
     * // Get one Commande
     * const commande = await prisma.commande.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommandeFindUniqueOrThrowArgs>(args: SelectSubset<T, CommandeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommandeClient<$Result.GetResult<Prisma.$CommandePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Commande that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandeFindFirstArgs} args - Arguments to find a Commande
     * @example
     * // Get one Commande
     * const commande = await prisma.commande.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommandeFindFirstArgs>(args?: SelectSubset<T, CommandeFindFirstArgs<ExtArgs>>): Prisma__CommandeClient<$Result.GetResult<Prisma.$CommandePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Commande that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandeFindFirstOrThrowArgs} args - Arguments to find a Commande
     * @example
     * // Get one Commande
     * const commande = await prisma.commande.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommandeFindFirstOrThrowArgs>(args?: SelectSubset<T, CommandeFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommandeClient<$Result.GetResult<Prisma.$CommandePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Commandes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Commandes
     * const commandes = await prisma.commande.findMany()
     * 
     * // Get first 10 Commandes
     * const commandes = await prisma.commande.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commandeWithIdOnly = await prisma.commande.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommandeFindManyArgs>(args?: SelectSubset<T, CommandeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommandePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Commande.
     * @param {CommandeCreateArgs} args - Arguments to create a Commande.
     * @example
     * // Create one Commande
     * const Commande = await prisma.commande.create({
     *   data: {
     *     // ... data to create a Commande
     *   }
     * })
     * 
     */
    create<T extends CommandeCreateArgs>(args: SelectSubset<T, CommandeCreateArgs<ExtArgs>>): Prisma__CommandeClient<$Result.GetResult<Prisma.$CommandePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Commandes.
     * @param {CommandeCreateManyArgs} args - Arguments to create many Commandes.
     * @example
     * // Create many Commandes
     * const commande = await prisma.commande.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommandeCreateManyArgs>(args?: SelectSubset<T, CommandeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Commandes and returns the data saved in the database.
     * @param {CommandeCreateManyAndReturnArgs} args - Arguments to create many Commandes.
     * @example
     * // Create many Commandes
     * const commande = await prisma.commande.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Commandes and only return the `id`
     * const commandeWithIdOnly = await prisma.commande.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommandeCreateManyAndReturnArgs>(args?: SelectSubset<T, CommandeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommandePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Commande.
     * @param {CommandeDeleteArgs} args - Arguments to delete one Commande.
     * @example
     * // Delete one Commande
     * const Commande = await prisma.commande.delete({
     *   where: {
     *     // ... filter to delete one Commande
     *   }
     * })
     * 
     */
    delete<T extends CommandeDeleteArgs>(args: SelectSubset<T, CommandeDeleteArgs<ExtArgs>>): Prisma__CommandeClient<$Result.GetResult<Prisma.$CommandePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Commande.
     * @param {CommandeUpdateArgs} args - Arguments to update one Commande.
     * @example
     * // Update one Commande
     * const commande = await prisma.commande.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommandeUpdateArgs>(args: SelectSubset<T, CommandeUpdateArgs<ExtArgs>>): Prisma__CommandeClient<$Result.GetResult<Prisma.$CommandePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Commandes.
     * @param {CommandeDeleteManyArgs} args - Arguments to filter Commandes to delete.
     * @example
     * // Delete a few Commandes
     * const { count } = await prisma.commande.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommandeDeleteManyArgs>(args?: SelectSubset<T, CommandeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Commandes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Commandes
     * const commande = await prisma.commande.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommandeUpdateManyArgs>(args: SelectSubset<T, CommandeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Commandes and returns the data updated in the database.
     * @param {CommandeUpdateManyAndReturnArgs} args - Arguments to update many Commandes.
     * @example
     * // Update many Commandes
     * const commande = await prisma.commande.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Commandes and only return the `id`
     * const commandeWithIdOnly = await prisma.commande.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CommandeUpdateManyAndReturnArgs>(args: SelectSubset<T, CommandeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommandePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Commande.
     * @param {CommandeUpsertArgs} args - Arguments to update or create a Commande.
     * @example
     * // Update or create a Commande
     * const commande = await prisma.commande.upsert({
     *   create: {
     *     // ... data to create a Commande
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Commande we want to update
     *   }
     * })
     */
    upsert<T extends CommandeUpsertArgs>(args: SelectSubset<T, CommandeUpsertArgs<ExtArgs>>): Prisma__CommandeClient<$Result.GetResult<Prisma.$CommandePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Commandes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandeCountArgs} args - Arguments to filter Commandes to count.
     * @example
     * // Count the number of Commandes
     * const count = await prisma.commande.count({
     *   where: {
     *     // ... the filter for the Commandes we want to count
     *   }
     * })
    **/
    count<T extends CommandeCountArgs>(
      args?: Subset<T, CommandeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommandeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Commande.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommandeAggregateArgs>(args: Subset<T, CommandeAggregateArgs>): Prisma.PrismaPromise<GetCommandeAggregateType<T>>

    /**
     * Group by Commande.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommandeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommandeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommandeGroupByArgs['orderBy'] }
        : { orderBy?: CommandeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommandeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommandeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Commande model
   */
  readonly fields: CommandeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Commande.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommandeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Paiement<T extends Commande$PaiementArgs<ExtArgs> = {}>(args?: Subset<T, Commande$PaiementArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaiementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    panier<T extends PanierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PanierDefaultArgs<ExtArgs>>): Prisma__PanierClient<$Result.GetResult<Prisma.$PanierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    fournisseur<T extends Commande$fournisseurArgs<ExtArgs> = {}>(args?: Subset<T, Commande$fournisseurArgs<ExtArgs>>): Prisma__FournisseurClient<$Result.GetResult<Prisma.$FournisseurPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    adresse<T extends Commande$adresseArgs<ExtArgs> = {}>(args?: Subset<T, Commande$adresseArgs<ExtArgs>>): Prisma__AdresseClient<$Result.GetResult<Prisma.$AdressePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    contact<T extends Commande$contactArgs<ExtArgs> = {}>(args?: Subset<T, Commande$contactArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Client<T extends Commande$ClientArgs<ExtArgs> = {}>(args?: Subset<T, Commande$ClientArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Commande model
   */
  interface CommandeFieldRefs {
    readonly id: FieldRef<"Commande", 'Int'>
    readonly panierId: FieldRef<"Commande", 'Int'>
    readonly clientId: FieldRef<"Commande", 'Int'>
    readonly nom: FieldRef<"Commande", 'String'>
    readonly tel: FieldRef<"Commande", 'String'>
    readonly type_client: FieldRef<"Commande", 'TypeClient'>
    readonly adresseId: FieldRef<"Commande", 'Int'>
    readonly contactId: FieldRef<"Commande", 'Int'>
    readonly fournisseurId: FieldRef<"Commande", 'Int'>
    readonly commandeId: FieldRef<"Commande", 'Int'>
    readonly notes: FieldRef<"Commande", 'String'>
    readonly dateLivraisonEffective: FieldRef<"Commande", 'DateTime'>
    readonly adresseLivraison: FieldRef<"Commande", 'String'>
    readonly enregistrerParId: FieldRef<"Commande", 'Int'>
    readonly statut: FieldRef<"Commande", 'StatutCommande'>
    readonly createdAt: FieldRef<"Commande", 'DateTime'>
    readonly updatedAt: FieldRef<"Commande", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Commande findUnique
   */
  export type CommandeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commande
     */
    select?: CommandeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Commande
     */
    omit?: CommandeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandeInclude<ExtArgs> | null
    /**
     * Filter, which Commande to fetch.
     */
    where: CommandeWhereUniqueInput
  }

  /**
   * Commande findUniqueOrThrow
   */
  export type CommandeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commande
     */
    select?: CommandeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Commande
     */
    omit?: CommandeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandeInclude<ExtArgs> | null
    /**
     * Filter, which Commande to fetch.
     */
    where: CommandeWhereUniqueInput
  }

  /**
   * Commande findFirst
   */
  export type CommandeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commande
     */
    select?: CommandeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Commande
     */
    omit?: CommandeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandeInclude<ExtArgs> | null
    /**
     * Filter, which Commande to fetch.
     */
    where?: CommandeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Commandes to fetch.
     */
    orderBy?: CommandeOrderByWithRelationInput | CommandeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Commandes.
     */
    cursor?: CommandeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Commandes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Commandes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Commandes.
     */
    distinct?: CommandeScalarFieldEnum | CommandeScalarFieldEnum[]
  }

  /**
   * Commande findFirstOrThrow
   */
  export type CommandeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commande
     */
    select?: CommandeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Commande
     */
    omit?: CommandeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandeInclude<ExtArgs> | null
    /**
     * Filter, which Commande to fetch.
     */
    where?: CommandeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Commandes to fetch.
     */
    orderBy?: CommandeOrderByWithRelationInput | CommandeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Commandes.
     */
    cursor?: CommandeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Commandes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Commandes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Commandes.
     */
    distinct?: CommandeScalarFieldEnum | CommandeScalarFieldEnum[]
  }

  /**
   * Commande findMany
   */
  export type CommandeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commande
     */
    select?: CommandeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Commande
     */
    omit?: CommandeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandeInclude<ExtArgs> | null
    /**
     * Filter, which Commandes to fetch.
     */
    where?: CommandeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Commandes to fetch.
     */
    orderBy?: CommandeOrderByWithRelationInput | CommandeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Commandes.
     */
    cursor?: CommandeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Commandes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Commandes.
     */
    skip?: number
    distinct?: CommandeScalarFieldEnum | CommandeScalarFieldEnum[]
  }

  /**
   * Commande create
   */
  export type CommandeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commande
     */
    select?: CommandeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Commande
     */
    omit?: CommandeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandeInclude<ExtArgs> | null
    /**
     * The data needed to create a Commande.
     */
    data: XOR<CommandeCreateInput, CommandeUncheckedCreateInput>
  }

  /**
   * Commande createMany
   */
  export type CommandeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Commandes.
     */
    data: CommandeCreateManyInput | CommandeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Commande createManyAndReturn
   */
  export type CommandeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commande
     */
    select?: CommandeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Commande
     */
    omit?: CommandeOmit<ExtArgs> | null
    /**
     * The data used to create many Commandes.
     */
    data: CommandeCreateManyInput | CommandeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Commande update
   */
  export type CommandeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commande
     */
    select?: CommandeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Commande
     */
    omit?: CommandeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandeInclude<ExtArgs> | null
    /**
     * The data needed to update a Commande.
     */
    data: XOR<CommandeUpdateInput, CommandeUncheckedUpdateInput>
    /**
     * Choose, which Commande to update.
     */
    where: CommandeWhereUniqueInput
  }

  /**
   * Commande updateMany
   */
  export type CommandeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Commandes.
     */
    data: XOR<CommandeUpdateManyMutationInput, CommandeUncheckedUpdateManyInput>
    /**
     * Filter which Commandes to update
     */
    where?: CommandeWhereInput
    /**
     * Limit how many Commandes to update.
     */
    limit?: number
  }

  /**
   * Commande updateManyAndReturn
   */
  export type CommandeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commande
     */
    select?: CommandeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Commande
     */
    omit?: CommandeOmit<ExtArgs> | null
    /**
     * The data used to update Commandes.
     */
    data: XOR<CommandeUpdateManyMutationInput, CommandeUncheckedUpdateManyInput>
    /**
     * Filter which Commandes to update
     */
    where?: CommandeWhereInput
    /**
     * Limit how many Commandes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Commande upsert
   */
  export type CommandeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commande
     */
    select?: CommandeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Commande
     */
    omit?: CommandeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandeInclude<ExtArgs> | null
    /**
     * The filter to search for the Commande to update in case it exists.
     */
    where: CommandeWhereUniqueInput
    /**
     * In case the Commande found by the `where` argument doesn't exist, create a new Commande with this data.
     */
    create: XOR<CommandeCreateInput, CommandeUncheckedCreateInput>
    /**
     * In case the Commande was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommandeUpdateInput, CommandeUncheckedUpdateInput>
  }

  /**
   * Commande delete
   */
  export type CommandeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commande
     */
    select?: CommandeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Commande
     */
    omit?: CommandeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandeInclude<ExtArgs> | null
    /**
     * Filter which Commande to delete.
     */
    where: CommandeWhereUniqueInput
  }

  /**
   * Commande deleteMany
   */
  export type CommandeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Commandes to delete
     */
    where?: CommandeWhereInput
    /**
     * Limit how many Commandes to delete.
     */
    limit?: number
  }

  /**
   * Commande.Paiement
   */
  export type Commande$PaiementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Paiement
     */
    select?: PaiementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Paiement
     */
    omit?: PaiementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaiementInclude<ExtArgs> | null
    where?: PaiementWhereInput
    orderBy?: PaiementOrderByWithRelationInput | PaiementOrderByWithRelationInput[]
    cursor?: PaiementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaiementScalarFieldEnum | PaiementScalarFieldEnum[]
  }

  /**
   * Commande.fournisseur
   */
  export type Commande$fournisseurArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fournisseur
     */
    select?: FournisseurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fournisseur
     */
    omit?: FournisseurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FournisseurInclude<ExtArgs> | null
    where?: FournisseurWhereInput
  }

  /**
   * Commande.adresse
   */
  export type Commande$adresseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adresse
     */
    select?: AdresseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Adresse
     */
    omit?: AdresseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdresseInclude<ExtArgs> | null
    where?: AdresseWhereInput
  }

  /**
   * Commande.contact
   */
  export type Commande$contactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
  }

  /**
   * Commande.Client
   */
  export type Commande$ClientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
  }

  /**
   * Commande without action
   */
  export type CommandeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commande
     */
    select?: CommandeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Commande
     */
    omit?: CommandeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommandeInclude<ExtArgs> | null
  }


  /**
   * Model ClotureCaisse
   */

  export type AggregateClotureCaisse = {
    _count: ClotureCaisseCountAggregateOutputType | null
    _avg: ClotureCaisseAvgAggregateOutputType | null
    _sum: ClotureCaisseSumAggregateOutputType | null
    _min: ClotureCaisseMinAggregateOutputType | null
    _max: ClotureCaisseMaxAggregateOutputType | null
  }

  export type ClotureCaisseAvgAggregateOutputType = {
    id: number | null
    agentId: number | null
    entrepriseId: number | null
  }

  export type ClotureCaisseSumAggregateOutputType = {
    id: number | null
    agentId: number | null
    entrepriseId: number | null
  }

  export type ClotureCaisseMinAggregateOutputType = {
    id: number | null
    dateCloture: Date | null
    agentId: number | null
    entrepriseId: number | null
    updatedAt: Date | null
    notes: string | null
    createdAt: Date | null
  }

  export type ClotureCaisseMaxAggregateOutputType = {
    id: number | null
    dateCloture: Date | null
    agentId: number | null
    entrepriseId: number | null
    updatedAt: Date | null
    notes: string | null
    createdAt: Date | null
  }

  export type ClotureCaisseCountAggregateOutputType = {
    id: number
    dateCloture: number
    agentId: number
    entrepriseId: number
    updatedAt: number
    notes: number
    createdAt: number
    _all: number
  }


  export type ClotureCaisseAvgAggregateInputType = {
    id?: true
    agentId?: true
    entrepriseId?: true
  }

  export type ClotureCaisseSumAggregateInputType = {
    id?: true
    agentId?: true
    entrepriseId?: true
  }

  export type ClotureCaisseMinAggregateInputType = {
    id?: true
    dateCloture?: true
    agentId?: true
    entrepriseId?: true
    updatedAt?: true
    notes?: true
    createdAt?: true
  }

  export type ClotureCaisseMaxAggregateInputType = {
    id?: true
    dateCloture?: true
    agentId?: true
    entrepriseId?: true
    updatedAt?: true
    notes?: true
    createdAt?: true
  }

  export type ClotureCaisseCountAggregateInputType = {
    id?: true
    dateCloture?: true
    agentId?: true
    entrepriseId?: true
    updatedAt?: true
    notes?: true
    createdAt?: true
    _all?: true
  }

  export type ClotureCaisseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClotureCaisse to aggregate.
     */
    where?: ClotureCaisseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClotureCaisses to fetch.
     */
    orderBy?: ClotureCaisseOrderByWithRelationInput | ClotureCaisseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClotureCaisseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClotureCaisses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClotureCaisses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClotureCaisses
    **/
    _count?: true | ClotureCaisseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClotureCaisseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClotureCaisseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClotureCaisseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClotureCaisseMaxAggregateInputType
  }

  export type GetClotureCaisseAggregateType<T extends ClotureCaisseAggregateArgs> = {
        [P in keyof T & keyof AggregateClotureCaisse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClotureCaisse[P]>
      : GetScalarType<T[P], AggregateClotureCaisse[P]>
  }




  export type ClotureCaisseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClotureCaisseWhereInput
    orderBy?: ClotureCaisseOrderByWithAggregationInput | ClotureCaisseOrderByWithAggregationInput[]
    by: ClotureCaisseScalarFieldEnum[] | ClotureCaisseScalarFieldEnum
    having?: ClotureCaisseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClotureCaisseCountAggregateInputType | true
    _avg?: ClotureCaisseAvgAggregateInputType
    _sum?: ClotureCaisseSumAggregateInputType
    _min?: ClotureCaisseMinAggregateInputType
    _max?: ClotureCaisseMaxAggregateInputType
  }

  export type ClotureCaisseGroupByOutputType = {
    id: number
    dateCloture: Date
    agentId: number
    entrepriseId: number | null
    updatedAt: Date
    notes: string | null
    createdAt: Date
    _count: ClotureCaisseCountAggregateOutputType | null
    _avg: ClotureCaisseAvgAggregateOutputType | null
    _sum: ClotureCaisseSumAggregateOutputType | null
    _min: ClotureCaisseMinAggregateOutputType | null
    _max: ClotureCaisseMaxAggregateOutputType | null
  }

  type GetClotureCaisseGroupByPayload<T extends ClotureCaisseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClotureCaisseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClotureCaisseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClotureCaisseGroupByOutputType[P]>
            : GetScalarType<T[P], ClotureCaisseGroupByOutputType[P]>
        }
      >
    >


  export type ClotureCaisseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dateCloture?: boolean
    agentId?: boolean
    entrepriseId?: boolean
    updatedAt?: boolean
    notes?: boolean
    createdAt?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    entreprise?: boolean | ClotureCaisse$entrepriseArgs<ExtArgs>
  }, ExtArgs["result"]["clotureCaisse"]>

  export type ClotureCaisseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dateCloture?: boolean
    agentId?: boolean
    entrepriseId?: boolean
    updatedAt?: boolean
    notes?: boolean
    createdAt?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    entreprise?: boolean | ClotureCaisse$entrepriseArgs<ExtArgs>
  }, ExtArgs["result"]["clotureCaisse"]>

  export type ClotureCaisseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dateCloture?: boolean
    agentId?: boolean
    entrepriseId?: boolean
    updatedAt?: boolean
    notes?: boolean
    createdAt?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    entreprise?: boolean | ClotureCaisse$entrepriseArgs<ExtArgs>
  }, ExtArgs["result"]["clotureCaisse"]>

  export type ClotureCaisseSelectScalar = {
    id?: boolean
    dateCloture?: boolean
    agentId?: boolean
    entrepriseId?: boolean
    updatedAt?: boolean
    notes?: boolean
    createdAt?: boolean
  }

  export type ClotureCaisseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "dateCloture" | "agentId" | "entrepriseId" | "updatedAt" | "notes" | "createdAt", ExtArgs["result"]["clotureCaisse"]>
  export type ClotureCaisseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    entreprise?: boolean | ClotureCaisse$entrepriseArgs<ExtArgs>
  }
  export type ClotureCaisseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    entreprise?: boolean | ClotureCaisse$entrepriseArgs<ExtArgs>
  }
  export type ClotureCaisseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    entreprise?: boolean | ClotureCaisse$entrepriseArgs<ExtArgs>
  }

  export type $ClotureCaissePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClotureCaisse"
    objects: {
      agent: Prisma.$AgentPayload<ExtArgs>
      entreprise: Prisma.$EntreprisePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      dateCloture: Date
      agentId: number
      entrepriseId: number | null
      updatedAt: Date
      notes: string | null
      createdAt: Date
    }, ExtArgs["result"]["clotureCaisse"]>
    composites: {}
  }

  type ClotureCaisseGetPayload<S extends boolean | null | undefined | ClotureCaisseDefaultArgs> = $Result.GetResult<Prisma.$ClotureCaissePayload, S>

  type ClotureCaisseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClotureCaisseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClotureCaisseCountAggregateInputType | true
    }

  export interface ClotureCaisseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClotureCaisse'], meta: { name: 'ClotureCaisse' } }
    /**
     * Find zero or one ClotureCaisse that matches the filter.
     * @param {ClotureCaisseFindUniqueArgs} args - Arguments to find a ClotureCaisse
     * @example
     * // Get one ClotureCaisse
     * const clotureCaisse = await prisma.clotureCaisse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClotureCaisseFindUniqueArgs>(args: SelectSubset<T, ClotureCaisseFindUniqueArgs<ExtArgs>>): Prisma__ClotureCaisseClient<$Result.GetResult<Prisma.$ClotureCaissePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClotureCaisse that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClotureCaisseFindUniqueOrThrowArgs} args - Arguments to find a ClotureCaisse
     * @example
     * // Get one ClotureCaisse
     * const clotureCaisse = await prisma.clotureCaisse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClotureCaisseFindUniqueOrThrowArgs>(args: SelectSubset<T, ClotureCaisseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClotureCaisseClient<$Result.GetResult<Prisma.$ClotureCaissePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClotureCaisse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClotureCaisseFindFirstArgs} args - Arguments to find a ClotureCaisse
     * @example
     * // Get one ClotureCaisse
     * const clotureCaisse = await prisma.clotureCaisse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClotureCaisseFindFirstArgs>(args?: SelectSubset<T, ClotureCaisseFindFirstArgs<ExtArgs>>): Prisma__ClotureCaisseClient<$Result.GetResult<Prisma.$ClotureCaissePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClotureCaisse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClotureCaisseFindFirstOrThrowArgs} args - Arguments to find a ClotureCaisse
     * @example
     * // Get one ClotureCaisse
     * const clotureCaisse = await prisma.clotureCaisse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClotureCaisseFindFirstOrThrowArgs>(args?: SelectSubset<T, ClotureCaisseFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClotureCaisseClient<$Result.GetResult<Prisma.$ClotureCaissePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClotureCaisses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClotureCaisseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClotureCaisses
     * const clotureCaisses = await prisma.clotureCaisse.findMany()
     * 
     * // Get first 10 ClotureCaisses
     * const clotureCaisses = await prisma.clotureCaisse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clotureCaisseWithIdOnly = await prisma.clotureCaisse.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClotureCaisseFindManyArgs>(args?: SelectSubset<T, ClotureCaisseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClotureCaissePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClotureCaisse.
     * @param {ClotureCaisseCreateArgs} args - Arguments to create a ClotureCaisse.
     * @example
     * // Create one ClotureCaisse
     * const ClotureCaisse = await prisma.clotureCaisse.create({
     *   data: {
     *     // ... data to create a ClotureCaisse
     *   }
     * })
     * 
     */
    create<T extends ClotureCaisseCreateArgs>(args: SelectSubset<T, ClotureCaisseCreateArgs<ExtArgs>>): Prisma__ClotureCaisseClient<$Result.GetResult<Prisma.$ClotureCaissePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClotureCaisses.
     * @param {ClotureCaisseCreateManyArgs} args - Arguments to create many ClotureCaisses.
     * @example
     * // Create many ClotureCaisses
     * const clotureCaisse = await prisma.clotureCaisse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClotureCaisseCreateManyArgs>(args?: SelectSubset<T, ClotureCaisseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClotureCaisses and returns the data saved in the database.
     * @param {ClotureCaisseCreateManyAndReturnArgs} args - Arguments to create many ClotureCaisses.
     * @example
     * // Create many ClotureCaisses
     * const clotureCaisse = await prisma.clotureCaisse.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClotureCaisses and only return the `id`
     * const clotureCaisseWithIdOnly = await prisma.clotureCaisse.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClotureCaisseCreateManyAndReturnArgs>(args?: SelectSubset<T, ClotureCaisseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClotureCaissePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ClotureCaisse.
     * @param {ClotureCaisseDeleteArgs} args - Arguments to delete one ClotureCaisse.
     * @example
     * // Delete one ClotureCaisse
     * const ClotureCaisse = await prisma.clotureCaisse.delete({
     *   where: {
     *     // ... filter to delete one ClotureCaisse
     *   }
     * })
     * 
     */
    delete<T extends ClotureCaisseDeleteArgs>(args: SelectSubset<T, ClotureCaisseDeleteArgs<ExtArgs>>): Prisma__ClotureCaisseClient<$Result.GetResult<Prisma.$ClotureCaissePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClotureCaisse.
     * @param {ClotureCaisseUpdateArgs} args - Arguments to update one ClotureCaisse.
     * @example
     * // Update one ClotureCaisse
     * const clotureCaisse = await prisma.clotureCaisse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClotureCaisseUpdateArgs>(args: SelectSubset<T, ClotureCaisseUpdateArgs<ExtArgs>>): Prisma__ClotureCaisseClient<$Result.GetResult<Prisma.$ClotureCaissePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClotureCaisses.
     * @param {ClotureCaisseDeleteManyArgs} args - Arguments to filter ClotureCaisses to delete.
     * @example
     * // Delete a few ClotureCaisses
     * const { count } = await prisma.clotureCaisse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClotureCaisseDeleteManyArgs>(args?: SelectSubset<T, ClotureCaisseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClotureCaisses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClotureCaisseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClotureCaisses
     * const clotureCaisse = await prisma.clotureCaisse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClotureCaisseUpdateManyArgs>(args: SelectSubset<T, ClotureCaisseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClotureCaisses and returns the data updated in the database.
     * @param {ClotureCaisseUpdateManyAndReturnArgs} args - Arguments to update many ClotureCaisses.
     * @example
     * // Update many ClotureCaisses
     * const clotureCaisse = await prisma.clotureCaisse.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ClotureCaisses and only return the `id`
     * const clotureCaisseWithIdOnly = await prisma.clotureCaisse.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClotureCaisseUpdateManyAndReturnArgs>(args: SelectSubset<T, ClotureCaisseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClotureCaissePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ClotureCaisse.
     * @param {ClotureCaisseUpsertArgs} args - Arguments to update or create a ClotureCaisse.
     * @example
     * // Update or create a ClotureCaisse
     * const clotureCaisse = await prisma.clotureCaisse.upsert({
     *   create: {
     *     // ... data to create a ClotureCaisse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClotureCaisse we want to update
     *   }
     * })
     */
    upsert<T extends ClotureCaisseUpsertArgs>(args: SelectSubset<T, ClotureCaisseUpsertArgs<ExtArgs>>): Prisma__ClotureCaisseClient<$Result.GetResult<Prisma.$ClotureCaissePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClotureCaisses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClotureCaisseCountArgs} args - Arguments to filter ClotureCaisses to count.
     * @example
     * // Count the number of ClotureCaisses
     * const count = await prisma.clotureCaisse.count({
     *   where: {
     *     // ... the filter for the ClotureCaisses we want to count
     *   }
     * })
    **/
    count<T extends ClotureCaisseCountArgs>(
      args?: Subset<T, ClotureCaisseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClotureCaisseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClotureCaisse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClotureCaisseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClotureCaisseAggregateArgs>(args: Subset<T, ClotureCaisseAggregateArgs>): Prisma.PrismaPromise<GetClotureCaisseAggregateType<T>>

    /**
     * Group by ClotureCaisse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClotureCaisseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClotureCaisseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClotureCaisseGroupByArgs['orderBy'] }
        : { orderBy?: ClotureCaisseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClotureCaisseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClotureCaisseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClotureCaisse model
   */
  readonly fields: ClotureCaisseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClotureCaisse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClotureCaisseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agent<T extends AgentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgentDefaultArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    entreprise<T extends ClotureCaisse$entrepriseArgs<ExtArgs> = {}>(args?: Subset<T, ClotureCaisse$entrepriseArgs<ExtArgs>>): Prisma__EntrepriseClient<$Result.GetResult<Prisma.$EntreprisePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClotureCaisse model
   */
  interface ClotureCaisseFieldRefs {
    readonly id: FieldRef<"ClotureCaisse", 'Int'>
    readonly dateCloture: FieldRef<"ClotureCaisse", 'DateTime'>
    readonly agentId: FieldRef<"ClotureCaisse", 'Int'>
    readonly entrepriseId: FieldRef<"ClotureCaisse", 'Int'>
    readonly updatedAt: FieldRef<"ClotureCaisse", 'DateTime'>
    readonly notes: FieldRef<"ClotureCaisse", 'String'>
    readonly createdAt: FieldRef<"ClotureCaisse", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ClotureCaisse findUnique
   */
  export type ClotureCaisseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClotureCaisse
     */
    select?: ClotureCaisseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClotureCaisse
     */
    omit?: ClotureCaisseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClotureCaisseInclude<ExtArgs> | null
    /**
     * Filter, which ClotureCaisse to fetch.
     */
    where: ClotureCaisseWhereUniqueInput
  }

  /**
   * ClotureCaisse findUniqueOrThrow
   */
  export type ClotureCaisseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClotureCaisse
     */
    select?: ClotureCaisseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClotureCaisse
     */
    omit?: ClotureCaisseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClotureCaisseInclude<ExtArgs> | null
    /**
     * Filter, which ClotureCaisse to fetch.
     */
    where: ClotureCaisseWhereUniqueInput
  }

  /**
   * ClotureCaisse findFirst
   */
  export type ClotureCaisseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClotureCaisse
     */
    select?: ClotureCaisseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClotureCaisse
     */
    omit?: ClotureCaisseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClotureCaisseInclude<ExtArgs> | null
    /**
     * Filter, which ClotureCaisse to fetch.
     */
    where?: ClotureCaisseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClotureCaisses to fetch.
     */
    orderBy?: ClotureCaisseOrderByWithRelationInput | ClotureCaisseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClotureCaisses.
     */
    cursor?: ClotureCaisseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClotureCaisses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClotureCaisses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClotureCaisses.
     */
    distinct?: ClotureCaisseScalarFieldEnum | ClotureCaisseScalarFieldEnum[]
  }

  /**
   * ClotureCaisse findFirstOrThrow
   */
  export type ClotureCaisseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClotureCaisse
     */
    select?: ClotureCaisseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClotureCaisse
     */
    omit?: ClotureCaisseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClotureCaisseInclude<ExtArgs> | null
    /**
     * Filter, which ClotureCaisse to fetch.
     */
    where?: ClotureCaisseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClotureCaisses to fetch.
     */
    orderBy?: ClotureCaisseOrderByWithRelationInput | ClotureCaisseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClotureCaisses.
     */
    cursor?: ClotureCaisseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClotureCaisses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClotureCaisses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClotureCaisses.
     */
    distinct?: ClotureCaisseScalarFieldEnum | ClotureCaisseScalarFieldEnum[]
  }

  /**
   * ClotureCaisse findMany
   */
  export type ClotureCaisseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClotureCaisse
     */
    select?: ClotureCaisseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClotureCaisse
     */
    omit?: ClotureCaisseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClotureCaisseInclude<ExtArgs> | null
    /**
     * Filter, which ClotureCaisses to fetch.
     */
    where?: ClotureCaisseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClotureCaisses to fetch.
     */
    orderBy?: ClotureCaisseOrderByWithRelationInput | ClotureCaisseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClotureCaisses.
     */
    cursor?: ClotureCaisseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClotureCaisses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClotureCaisses.
     */
    skip?: number
    distinct?: ClotureCaisseScalarFieldEnum | ClotureCaisseScalarFieldEnum[]
  }

  /**
   * ClotureCaisse create
   */
  export type ClotureCaisseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClotureCaisse
     */
    select?: ClotureCaisseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClotureCaisse
     */
    omit?: ClotureCaisseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClotureCaisseInclude<ExtArgs> | null
    /**
     * The data needed to create a ClotureCaisse.
     */
    data: XOR<ClotureCaisseCreateInput, ClotureCaisseUncheckedCreateInput>
  }

  /**
   * ClotureCaisse createMany
   */
  export type ClotureCaisseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClotureCaisses.
     */
    data: ClotureCaisseCreateManyInput | ClotureCaisseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClotureCaisse createManyAndReturn
   */
  export type ClotureCaisseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClotureCaisse
     */
    select?: ClotureCaisseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClotureCaisse
     */
    omit?: ClotureCaisseOmit<ExtArgs> | null
    /**
     * The data used to create many ClotureCaisses.
     */
    data: ClotureCaisseCreateManyInput | ClotureCaisseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClotureCaisseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClotureCaisse update
   */
  export type ClotureCaisseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClotureCaisse
     */
    select?: ClotureCaisseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClotureCaisse
     */
    omit?: ClotureCaisseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClotureCaisseInclude<ExtArgs> | null
    /**
     * The data needed to update a ClotureCaisse.
     */
    data: XOR<ClotureCaisseUpdateInput, ClotureCaisseUncheckedUpdateInput>
    /**
     * Choose, which ClotureCaisse to update.
     */
    where: ClotureCaisseWhereUniqueInput
  }

  /**
   * ClotureCaisse updateMany
   */
  export type ClotureCaisseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClotureCaisses.
     */
    data: XOR<ClotureCaisseUpdateManyMutationInput, ClotureCaisseUncheckedUpdateManyInput>
    /**
     * Filter which ClotureCaisses to update
     */
    where?: ClotureCaisseWhereInput
    /**
     * Limit how many ClotureCaisses to update.
     */
    limit?: number
  }

  /**
   * ClotureCaisse updateManyAndReturn
   */
  export type ClotureCaisseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClotureCaisse
     */
    select?: ClotureCaisseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClotureCaisse
     */
    omit?: ClotureCaisseOmit<ExtArgs> | null
    /**
     * The data used to update ClotureCaisses.
     */
    data: XOR<ClotureCaisseUpdateManyMutationInput, ClotureCaisseUncheckedUpdateManyInput>
    /**
     * Filter which ClotureCaisses to update
     */
    where?: ClotureCaisseWhereInput
    /**
     * Limit how many ClotureCaisses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClotureCaisseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClotureCaisse upsert
   */
  export type ClotureCaisseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClotureCaisse
     */
    select?: ClotureCaisseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClotureCaisse
     */
    omit?: ClotureCaisseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClotureCaisseInclude<ExtArgs> | null
    /**
     * The filter to search for the ClotureCaisse to update in case it exists.
     */
    where: ClotureCaisseWhereUniqueInput
    /**
     * In case the ClotureCaisse found by the `where` argument doesn't exist, create a new ClotureCaisse with this data.
     */
    create: XOR<ClotureCaisseCreateInput, ClotureCaisseUncheckedCreateInput>
    /**
     * In case the ClotureCaisse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClotureCaisseUpdateInput, ClotureCaisseUncheckedUpdateInput>
  }

  /**
   * ClotureCaisse delete
   */
  export type ClotureCaisseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClotureCaisse
     */
    select?: ClotureCaisseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClotureCaisse
     */
    omit?: ClotureCaisseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClotureCaisseInclude<ExtArgs> | null
    /**
     * Filter which ClotureCaisse to delete.
     */
    where: ClotureCaisseWhereUniqueInput
  }

  /**
   * ClotureCaisse deleteMany
   */
  export type ClotureCaisseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClotureCaisses to delete
     */
    where?: ClotureCaisseWhereInput
    /**
     * Limit how many ClotureCaisses to delete.
     */
    limit?: number
  }

  /**
   * ClotureCaisse.entreprise
   */
  export type ClotureCaisse$entrepriseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Entreprise
     */
    select?: EntrepriseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Entreprise
     */
    omit?: EntrepriseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntrepriseInclude<ExtArgs> | null
    where?: EntrepriseWhereInput
  }

  /**
   * ClotureCaisse without action
   */
  export type ClotureCaisseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClotureCaisse
     */
    select?: ClotureCaisseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClotureCaisse
     */
    omit?: ClotureCaisseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClotureCaisseInclude<ExtArgs> | null
  }


  /**
   * Model MouvementCaisse
   */

  export type AggregateMouvementCaisse = {
    _count: MouvementCaisseCountAggregateOutputType | null
    _avg: MouvementCaisseAvgAggregateOutputType | null
    _sum: MouvementCaisseSumAggregateOutputType | null
    _min: MouvementCaisseMinAggregateOutputType | null
    _max: MouvementCaisseMaxAggregateOutputType | null
  }

  export type MouvementCaisseAvgAggregateOutputType = {
    id: number | null
    caisseId: number | null
    montant: number | null
    agentId: number | null
  }

  export type MouvementCaisseSumAggregateOutputType = {
    id: number | null
    caisseId: number | null
    montant: number | null
    agentId: number | null
  }

  export type MouvementCaisseMinAggregateOutputType = {
    id: number | null
    caisseId: number | null
    referenceExterne: string | null
    type_mouvement: $Enums.TypeMouvementCaisse | null
    categorie: $Enums.CategorieMouvement | null
    moyen_paiement: $Enums.ModePaiment | null
    montant: number | null
    description: string | null
    agentId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MouvementCaisseMaxAggregateOutputType = {
    id: number | null
    caisseId: number | null
    referenceExterne: string | null
    type_mouvement: $Enums.TypeMouvementCaisse | null
    categorie: $Enums.CategorieMouvement | null
    moyen_paiement: $Enums.ModePaiment | null
    montant: number | null
    description: string | null
    agentId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MouvementCaisseCountAggregateOutputType = {
    id: number
    caisseId: number
    referenceExterne: number
    type_mouvement: number
    categorie: number
    moyen_paiement: number
    montant: number
    description: number
    agentId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MouvementCaisseAvgAggregateInputType = {
    id?: true
    caisseId?: true
    montant?: true
    agentId?: true
  }

  export type MouvementCaisseSumAggregateInputType = {
    id?: true
    caisseId?: true
    montant?: true
    agentId?: true
  }

  export type MouvementCaisseMinAggregateInputType = {
    id?: true
    caisseId?: true
    referenceExterne?: true
    type_mouvement?: true
    categorie?: true
    moyen_paiement?: true
    montant?: true
    description?: true
    agentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MouvementCaisseMaxAggregateInputType = {
    id?: true
    caisseId?: true
    referenceExterne?: true
    type_mouvement?: true
    categorie?: true
    moyen_paiement?: true
    montant?: true
    description?: true
    agentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MouvementCaisseCountAggregateInputType = {
    id?: true
    caisseId?: true
    referenceExterne?: true
    type_mouvement?: true
    categorie?: true
    moyen_paiement?: true
    montant?: true
    description?: true
    agentId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MouvementCaisseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MouvementCaisse to aggregate.
     */
    where?: MouvementCaisseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MouvementCaisses to fetch.
     */
    orderBy?: MouvementCaisseOrderByWithRelationInput | MouvementCaisseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MouvementCaisseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MouvementCaisses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MouvementCaisses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MouvementCaisses
    **/
    _count?: true | MouvementCaisseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MouvementCaisseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MouvementCaisseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MouvementCaisseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MouvementCaisseMaxAggregateInputType
  }

  export type GetMouvementCaisseAggregateType<T extends MouvementCaisseAggregateArgs> = {
        [P in keyof T & keyof AggregateMouvementCaisse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMouvementCaisse[P]>
      : GetScalarType<T[P], AggregateMouvementCaisse[P]>
  }




  export type MouvementCaisseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MouvementCaisseWhereInput
    orderBy?: MouvementCaisseOrderByWithAggregationInput | MouvementCaisseOrderByWithAggregationInput[]
    by: MouvementCaisseScalarFieldEnum[] | MouvementCaisseScalarFieldEnum
    having?: MouvementCaisseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MouvementCaisseCountAggregateInputType | true
    _avg?: MouvementCaisseAvgAggregateInputType
    _sum?: MouvementCaisseSumAggregateInputType
    _min?: MouvementCaisseMinAggregateInputType
    _max?: MouvementCaisseMaxAggregateInputType
  }

  export type MouvementCaisseGroupByOutputType = {
    id: number
    caisseId: number
    referenceExterne: string | null
    type_mouvement: $Enums.TypeMouvementCaisse
    categorie: $Enums.CategorieMouvement
    moyen_paiement: $Enums.ModePaiment
    montant: number
    description: string | null
    agentId: number
    createdAt: Date
    updatedAt: Date
    _count: MouvementCaisseCountAggregateOutputType | null
    _avg: MouvementCaisseAvgAggregateOutputType | null
    _sum: MouvementCaisseSumAggregateOutputType | null
    _min: MouvementCaisseMinAggregateOutputType | null
    _max: MouvementCaisseMaxAggregateOutputType | null
  }

  type GetMouvementCaisseGroupByPayload<T extends MouvementCaisseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MouvementCaisseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MouvementCaisseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MouvementCaisseGroupByOutputType[P]>
            : GetScalarType<T[P], MouvementCaisseGroupByOutputType[P]>
        }
      >
    >


  export type MouvementCaisseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    caisseId?: boolean
    referenceExterne?: boolean
    type_mouvement?: boolean
    categorie?: boolean
    moyen_paiement?: boolean
    montant?: boolean
    description?: boolean
    agentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    caisse?: boolean | CaisseDefaultArgs<ExtArgs>
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mouvementCaisse"]>

  export type MouvementCaisseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    caisseId?: boolean
    referenceExterne?: boolean
    type_mouvement?: boolean
    categorie?: boolean
    moyen_paiement?: boolean
    montant?: boolean
    description?: boolean
    agentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    caisse?: boolean | CaisseDefaultArgs<ExtArgs>
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mouvementCaisse"]>

  export type MouvementCaisseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    caisseId?: boolean
    referenceExterne?: boolean
    type_mouvement?: boolean
    categorie?: boolean
    moyen_paiement?: boolean
    montant?: boolean
    description?: boolean
    agentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    caisse?: boolean | CaisseDefaultArgs<ExtArgs>
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mouvementCaisse"]>

  export type MouvementCaisseSelectScalar = {
    id?: boolean
    caisseId?: boolean
    referenceExterne?: boolean
    type_mouvement?: boolean
    categorie?: boolean
    moyen_paiement?: boolean
    montant?: boolean
    description?: boolean
    agentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MouvementCaisseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "caisseId" | "referenceExterne" | "type_mouvement" | "categorie" | "moyen_paiement" | "montant" | "description" | "agentId" | "createdAt" | "updatedAt", ExtArgs["result"]["mouvementCaisse"]>
  export type MouvementCaisseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    caisse?: boolean | CaisseDefaultArgs<ExtArgs>
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }
  export type MouvementCaisseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    caisse?: boolean | CaisseDefaultArgs<ExtArgs>
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }
  export type MouvementCaisseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    caisse?: boolean | CaisseDefaultArgs<ExtArgs>
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }

  export type $MouvementCaissePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MouvementCaisse"
    objects: {
      caisse: Prisma.$CaissePayload<ExtArgs>
      agent: Prisma.$AgentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      caisseId: number
      referenceExterne: string | null
      type_mouvement: $Enums.TypeMouvementCaisse
      categorie: $Enums.CategorieMouvement
      moyen_paiement: $Enums.ModePaiment
      montant: number
      description: string | null
      agentId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["mouvementCaisse"]>
    composites: {}
  }

  type MouvementCaisseGetPayload<S extends boolean | null | undefined | MouvementCaisseDefaultArgs> = $Result.GetResult<Prisma.$MouvementCaissePayload, S>

  type MouvementCaisseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MouvementCaisseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MouvementCaisseCountAggregateInputType | true
    }

  export interface MouvementCaisseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MouvementCaisse'], meta: { name: 'MouvementCaisse' } }
    /**
     * Find zero or one MouvementCaisse that matches the filter.
     * @param {MouvementCaisseFindUniqueArgs} args - Arguments to find a MouvementCaisse
     * @example
     * // Get one MouvementCaisse
     * const mouvementCaisse = await prisma.mouvementCaisse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MouvementCaisseFindUniqueArgs>(args: SelectSubset<T, MouvementCaisseFindUniqueArgs<ExtArgs>>): Prisma__MouvementCaisseClient<$Result.GetResult<Prisma.$MouvementCaissePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MouvementCaisse that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MouvementCaisseFindUniqueOrThrowArgs} args - Arguments to find a MouvementCaisse
     * @example
     * // Get one MouvementCaisse
     * const mouvementCaisse = await prisma.mouvementCaisse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MouvementCaisseFindUniqueOrThrowArgs>(args: SelectSubset<T, MouvementCaisseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MouvementCaisseClient<$Result.GetResult<Prisma.$MouvementCaissePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MouvementCaisse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MouvementCaisseFindFirstArgs} args - Arguments to find a MouvementCaisse
     * @example
     * // Get one MouvementCaisse
     * const mouvementCaisse = await prisma.mouvementCaisse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MouvementCaisseFindFirstArgs>(args?: SelectSubset<T, MouvementCaisseFindFirstArgs<ExtArgs>>): Prisma__MouvementCaisseClient<$Result.GetResult<Prisma.$MouvementCaissePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MouvementCaisse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MouvementCaisseFindFirstOrThrowArgs} args - Arguments to find a MouvementCaisse
     * @example
     * // Get one MouvementCaisse
     * const mouvementCaisse = await prisma.mouvementCaisse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MouvementCaisseFindFirstOrThrowArgs>(args?: SelectSubset<T, MouvementCaisseFindFirstOrThrowArgs<ExtArgs>>): Prisma__MouvementCaisseClient<$Result.GetResult<Prisma.$MouvementCaissePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MouvementCaisses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MouvementCaisseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MouvementCaisses
     * const mouvementCaisses = await prisma.mouvementCaisse.findMany()
     * 
     * // Get first 10 MouvementCaisses
     * const mouvementCaisses = await prisma.mouvementCaisse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mouvementCaisseWithIdOnly = await prisma.mouvementCaisse.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MouvementCaisseFindManyArgs>(args?: SelectSubset<T, MouvementCaisseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MouvementCaissePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MouvementCaisse.
     * @param {MouvementCaisseCreateArgs} args - Arguments to create a MouvementCaisse.
     * @example
     * // Create one MouvementCaisse
     * const MouvementCaisse = await prisma.mouvementCaisse.create({
     *   data: {
     *     // ... data to create a MouvementCaisse
     *   }
     * })
     * 
     */
    create<T extends MouvementCaisseCreateArgs>(args: SelectSubset<T, MouvementCaisseCreateArgs<ExtArgs>>): Prisma__MouvementCaisseClient<$Result.GetResult<Prisma.$MouvementCaissePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MouvementCaisses.
     * @param {MouvementCaisseCreateManyArgs} args - Arguments to create many MouvementCaisses.
     * @example
     * // Create many MouvementCaisses
     * const mouvementCaisse = await prisma.mouvementCaisse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MouvementCaisseCreateManyArgs>(args?: SelectSubset<T, MouvementCaisseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MouvementCaisses and returns the data saved in the database.
     * @param {MouvementCaisseCreateManyAndReturnArgs} args - Arguments to create many MouvementCaisses.
     * @example
     * // Create many MouvementCaisses
     * const mouvementCaisse = await prisma.mouvementCaisse.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MouvementCaisses and only return the `id`
     * const mouvementCaisseWithIdOnly = await prisma.mouvementCaisse.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MouvementCaisseCreateManyAndReturnArgs>(args?: SelectSubset<T, MouvementCaisseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MouvementCaissePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MouvementCaisse.
     * @param {MouvementCaisseDeleteArgs} args - Arguments to delete one MouvementCaisse.
     * @example
     * // Delete one MouvementCaisse
     * const MouvementCaisse = await prisma.mouvementCaisse.delete({
     *   where: {
     *     // ... filter to delete one MouvementCaisse
     *   }
     * })
     * 
     */
    delete<T extends MouvementCaisseDeleteArgs>(args: SelectSubset<T, MouvementCaisseDeleteArgs<ExtArgs>>): Prisma__MouvementCaisseClient<$Result.GetResult<Prisma.$MouvementCaissePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MouvementCaisse.
     * @param {MouvementCaisseUpdateArgs} args - Arguments to update one MouvementCaisse.
     * @example
     * // Update one MouvementCaisse
     * const mouvementCaisse = await prisma.mouvementCaisse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MouvementCaisseUpdateArgs>(args: SelectSubset<T, MouvementCaisseUpdateArgs<ExtArgs>>): Prisma__MouvementCaisseClient<$Result.GetResult<Prisma.$MouvementCaissePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MouvementCaisses.
     * @param {MouvementCaisseDeleteManyArgs} args - Arguments to filter MouvementCaisses to delete.
     * @example
     * // Delete a few MouvementCaisses
     * const { count } = await prisma.mouvementCaisse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MouvementCaisseDeleteManyArgs>(args?: SelectSubset<T, MouvementCaisseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MouvementCaisses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MouvementCaisseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MouvementCaisses
     * const mouvementCaisse = await prisma.mouvementCaisse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MouvementCaisseUpdateManyArgs>(args: SelectSubset<T, MouvementCaisseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MouvementCaisses and returns the data updated in the database.
     * @param {MouvementCaisseUpdateManyAndReturnArgs} args - Arguments to update many MouvementCaisses.
     * @example
     * // Update many MouvementCaisses
     * const mouvementCaisse = await prisma.mouvementCaisse.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MouvementCaisses and only return the `id`
     * const mouvementCaisseWithIdOnly = await prisma.mouvementCaisse.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MouvementCaisseUpdateManyAndReturnArgs>(args: SelectSubset<T, MouvementCaisseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MouvementCaissePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MouvementCaisse.
     * @param {MouvementCaisseUpsertArgs} args - Arguments to update or create a MouvementCaisse.
     * @example
     * // Update or create a MouvementCaisse
     * const mouvementCaisse = await prisma.mouvementCaisse.upsert({
     *   create: {
     *     // ... data to create a MouvementCaisse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MouvementCaisse we want to update
     *   }
     * })
     */
    upsert<T extends MouvementCaisseUpsertArgs>(args: SelectSubset<T, MouvementCaisseUpsertArgs<ExtArgs>>): Prisma__MouvementCaisseClient<$Result.GetResult<Prisma.$MouvementCaissePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MouvementCaisses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MouvementCaisseCountArgs} args - Arguments to filter MouvementCaisses to count.
     * @example
     * // Count the number of MouvementCaisses
     * const count = await prisma.mouvementCaisse.count({
     *   where: {
     *     // ... the filter for the MouvementCaisses we want to count
     *   }
     * })
    **/
    count<T extends MouvementCaisseCountArgs>(
      args?: Subset<T, MouvementCaisseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MouvementCaisseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MouvementCaisse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MouvementCaisseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MouvementCaisseAggregateArgs>(args: Subset<T, MouvementCaisseAggregateArgs>): Prisma.PrismaPromise<GetMouvementCaisseAggregateType<T>>

    /**
     * Group by MouvementCaisse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MouvementCaisseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MouvementCaisseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MouvementCaisseGroupByArgs['orderBy'] }
        : { orderBy?: MouvementCaisseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MouvementCaisseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMouvementCaisseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MouvementCaisse model
   */
  readonly fields: MouvementCaisseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MouvementCaisse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MouvementCaisseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    caisse<T extends CaisseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CaisseDefaultArgs<ExtArgs>>): Prisma__CaisseClient<$Result.GetResult<Prisma.$CaissePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    agent<T extends AgentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgentDefaultArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MouvementCaisse model
   */
  interface MouvementCaisseFieldRefs {
    readonly id: FieldRef<"MouvementCaisse", 'Int'>
    readonly caisseId: FieldRef<"MouvementCaisse", 'Int'>
    readonly referenceExterne: FieldRef<"MouvementCaisse", 'String'>
    readonly type_mouvement: FieldRef<"MouvementCaisse", 'TypeMouvementCaisse'>
    readonly categorie: FieldRef<"MouvementCaisse", 'CategorieMouvement'>
    readonly moyen_paiement: FieldRef<"MouvementCaisse", 'ModePaiment'>
    readonly montant: FieldRef<"MouvementCaisse", 'Float'>
    readonly description: FieldRef<"MouvementCaisse", 'String'>
    readonly agentId: FieldRef<"MouvementCaisse", 'Int'>
    readonly createdAt: FieldRef<"MouvementCaisse", 'DateTime'>
    readonly updatedAt: FieldRef<"MouvementCaisse", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MouvementCaisse findUnique
   */
  export type MouvementCaisseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MouvementCaisse
     */
    select?: MouvementCaisseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MouvementCaisse
     */
    omit?: MouvementCaisseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MouvementCaisseInclude<ExtArgs> | null
    /**
     * Filter, which MouvementCaisse to fetch.
     */
    where: MouvementCaisseWhereUniqueInput
  }

  /**
   * MouvementCaisse findUniqueOrThrow
   */
  export type MouvementCaisseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MouvementCaisse
     */
    select?: MouvementCaisseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MouvementCaisse
     */
    omit?: MouvementCaisseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MouvementCaisseInclude<ExtArgs> | null
    /**
     * Filter, which MouvementCaisse to fetch.
     */
    where: MouvementCaisseWhereUniqueInput
  }

  /**
   * MouvementCaisse findFirst
   */
  export type MouvementCaisseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MouvementCaisse
     */
    select?: MouvementCaisseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MouvementCaisse
     */
    omit?: MouvementCaisseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MouvementCaisseInclude<ExtArgs> | null
    /**
     * Filter, which MouvementCaisse to fetch.
     */
    where?: MouvementCaisseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MouvementCaisses to fetch.
     */
    orderBy?: MouvementCaisseOrderByWithRelationInput | MouvementCaisseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MouvementCaisses.
     */
    cursor?: MouvementCaisseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MouvementCaisses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MouvementCaisses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MouvementCaisses.
     */
    distinct?: MouvementCaisseScalarFieldEnum | MouvementCaisseScalarFieldEnum[]
  }

  /**
   * MouvementCaisse findFirstOrThrow
   */
  export type MouvementCaisseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MouvementCaisse
     */
    select?: MouvementCaisseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MouvementCaisse
     */
    omit?: MouvementCaisseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MouvementCaisseInclude<ExtArgs> | null
    /**
     * Filter, which MouvementCaisse to fetch.
     */
    where?: MouvementCaisseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MouvementCaisses to fetch.
     */
    orderBy?: MouvementCaisseOrderByWithRelationInput | MouvementCaisseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MouvementCaisses.
     */
    cursor?: MouvementCaisseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MouvementCaisses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MouvementCaisses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MouvementCaisses.
     */
    distinct?: MouvementCaisseScalarFieldEnum | MouvementCaisseScalarFieldEnum[]
  }

  /**
   * MouvementCaisse findMany
   */
  export type MouvementCaisseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MouvementCaisse
     */
    select?: MouvementCaisseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MouvementCaisse
     */
    omit?: MouvementCaisseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MouvementCaisseInclude<ExtArgs> | null
    /**
     * Filter, which MouvementCaisses to fetch.
     */
    where?: MouvementCaisseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MouvementCaisses to fetch.
     */
    orderBy?: MouvementCaisseOrderByWithRelationInput | MouvementCaisseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MouvementCaisses.
     */
    cursor?: MouvementCaisseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MouvementCaisses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MouvementCaisses.
     */
    skip?: number
    distinct?: MouvementCaisseScalarFieldEnum | MouvementCaisseScalarFieldEnum[]
  }

  /**
   * MouvementCaisse create
   */
  export type MouvementCaisseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MouvementCaisse
     */
    select?: MouvementCaisseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MouvementCaisse
     */
    omit?: MouvementCaisseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MouvementCaisseInclude<ExtArgs> | null
    /**
     * The data needed to create a MouvementCaisse.
     */
    data: XOR<MouvementCaisseCreateInput, MouvementCaisseUncheckedCreateInput>
  }

  /**
   * MouvementCaisse createMany
   */
  export type MouvementCaisseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MouvementCaisses.
     */
    data: MouvementCaisseCreateManyInput | MouvementCaisseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MouvementCaisse createManyAndReturn
   */
  export type MouvementCaisseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MouvementCaisse
     */
    select?: MouvementCaisseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MouvementCaisse
     */
    omit?: MouvementCaisseOmit<ExtArgs> | null
    /**
     * The data used to create many MouvementCaisses.
     */
    data: MouvementCaisseCreateManyInput | MouvementCaisseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MouvementCaisseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MouvementCaisse update
   */
  export type MouvementCaisseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MouvementCaisse
     */
    select?: MouvementCaisseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MouvementCaisse
     */
    omit?: MouvementCaisseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MouvementCaisseInclude<ExtArgs> | null
    /**
     * The data needed to update a MouvementCaisse.
     */
    data: XOR<MouvementCaisseUpdateInput, MouvementCaisseUncheckedUpdateInput>
    /**
     * Choose, which MouvementCaisse to update.
     */
    where: MouvementCaisseWhereUniqueInput
  }

  /**
   * MouvementCaisse updateMany
   */
  export type MouvementCaisseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MouvementCaisses.
     */
    data: XOR<MouvementCaisseUpdateManyMutationInput, MouvementCaisseUncheckedUpdateManyInput>
    /**
     * Filter which MouvementCaisses to update
     */
    where?: MouvementCaisseWhereInput
    /**
     * Limit how many MouvementCaisses to update.
     */
    limit?: number
  }

  /**
   * MouvementCaisse updateManyAndReturn
   */
  export type MouvementCaisseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MouvementCaisse
     */
    select?: MouvementCaisseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MouvementCaisse
     */
    omit?: MouvementCaisseOmit<ExtArgs> | null
    /**
     * The data used to update MouvementCaisses.
     */
    data: XOR<MouvementCaisseUpdateManyMutationInput, MouvementCaisseUncheckedUpdateManyInput>
    /**
     * Filter which MouvementCaisses to update
     */
    where?: MouvementCaisseWhereInput
    /**
     * Limit how many MouvementCaisses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MouvementCaisseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MouvementCaisse upsert
   */
  export type MouvementCaisseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MouvementCaisse
     */
    select?: MouvementCaisseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MouvementCaisse
     */
    omit?: MouvementCaisseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MouvementCaisseInclude<ExtArgs> | null
    /**
     * The filter to search for the MouvementCaisse to update in case it exists.
     */
    where: MouvementCaisseWhereUniqueInput
    /**
     * In case the MouvementCaisse found by the `where` argument doesn't exist, create a new MouvementCaisse with this data.
     */
    create: XOR<MouvementCaisseCreateInput, MouvementCaisseUncheckedCreateInput>
    /**
     * In case the MouvementCaisse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MouvementCaisseUpdateInput, MouvementCaisseUncheckedUpdateInput>
  }

  /**
   * MouvementCaisse delete
   */
  export type MouvementCaisseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MouvementCaisse
     */
    select?: MouvementCaisseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MouvementCaisse
     */
    omit?: MouvementCaisseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MouvementCaisseInclude<ExtArgs> | null
    /**
     * Filter which MouvementCaisse to delete.
     */
    where: MouvementCaisseWhereUniqueInput
  }

  /**
   * MouvementCaisse deleteMany
   */
  export type MouvementCaisseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MouvementCaisses to delete
     */
    where?: MouvementCaisseWhereInput
    /**
     * Limit how many MouvementCaisses to delete.
     */
    limit?: number
  }

  /**
   * MouvementCaisse without action
   */
  export type MouvementCaisseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MouvementCaisse
     */
    select?: MouvementCaisseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MouvementCaisse
     */
    omit?: MouvementCaisseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MouvementCaisseInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const TeneurScalarFieldEnum: {
    id: 'id',
    valeur: 'valeur',
    agentId: 'agentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TeneurScalarFieldEnum = (typeof TeneurScalarFieldEnum)[keyof typeof TeneurScalarFieldEnum]


  export const DeviseScalarFieldEnum: {
    id: 'id',
    nom: 'nom',
    code: 'code',
    symbole: 'symbole',
    tauxDEchange: 'tauxDEchange',
    agentId: 'agentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DeviseScalarFieldEnum = (typeof DeviseScalarFieldEnum)[keyof typeof DeviseScalarFieldEnum]


  export const EntrepriseScalarFieldEnum: {
    id: 'id',
    nom: 'nom',
    email: 'email',
    encronyme: 'encronyme',
    codePostale: 'codePostale',
    site: 'site',
    description: 'description',
    logo: 'logo',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EntrepriseScalarFieldEnum = (typeof EntrepriseScalarFieldEnum)[keyof typeof EntrepriseScalarFieldEnum]


  export const AgentScalarFieldEnum: {
    id: 'id',
    email: 'email',
    nom: 'nom',
    postnom: 'postnom',
    nom_complet: 'nom_complet',
    sexe: 'sexe',
    role: 'role',
    poste: 'poste',
    picture: 'picture',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AgentScalarFieldEnum = (typeof AgentScalarFieldEnum)[keyof typeof AgentScalarFieldEnum]


  export const ClientScalarFieldEnum: {
    id: 'id',
    email: 'email',
    nom: 'nom',
    postnom: 'postnom',
    nom_complet: 'nom_complet',
    sexe: 'sexe',
    picture: 'picture',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClientScalarFieldEnum = (typeof ClientScalarFieldEnum)[keyof typeof ClientScalarFieldEnum]


  export const AdresseScalarFieldEnum: {
    id: 'id',
    ville: 'ville',
    adresse: 'adresse',
    isActive: 'isActive',
    agentId: 'agentId',
    fournisseurId: 'fournisseurId',
    clientId: 'clientId',
    entrepriseId: 'entrepriseId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AdresseScalarFieldEnum = (typeof AdresseScalarFieldEnum)[keyof typeof AdresseScalarFieldEnum]


  export const ContactScalarFieldEnum: {
    id: 'id',
    tel: 'tel',
    isActive: 'isActive',
    agentId: 'agentId',
    fournisseurId: 'fournisseurId',
    clientId: 'clientId',
    entrepriseId: 'entrepriseId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContactScalarFieldEnum = (typeof ContactScalarFieldEnum)[keyof typeof ContactScalarFieldEnum]


  export const FournisseurScalarFieldEnum: {
    id: 'id',
    nom: 'nom',
    email: 'email',
    codePostale: 'codePostale',
    agentId: 'agentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FournisseurScalarFieldEnum = (typeof FournisseurScalarFieldEnum)[keyof typeof FournisseurScalarFieldEnum]


  export const ProduitScalarFieldEnum: {
    id: 'id',
    designation: 'designation',
    prixUnitaire: 'prixUnitaire',
    qtteDisponible: 'qtteDisponible',
    description: 'description',
    deviseId: 'deviseId',
    teneurId: 'teneurId',
    agentId: 'agentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProduitScalarFieldEnum = (typeof ProduitScalarFieldEnum)[keyof typeof ProduitScalarFieldEnum]


  export const PaiementScalarFieldEnum: {
    id: 'id',
    totalHT: 'totalHT',
    totalTTC: 'totalTTC',
    modePaiement: 'modePaiement',
    deviseId: 'deviseId',
    caisseId: 'caisseId',
    venteId: 'venteId',
    achatId: 'achatId',
    commandeId: 'commandeId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaiementScalarFieldEnum = (typeof PaiementScalarFieldEnum)[keyof typeof PaiementScalarFieldEnum]


  export const CaisseScalarFieldEnum: {
    id: 'id',
    nom: 'nom',
    description: 'description',
    soldeActuel: 'soldeActuel',
    deviseId: 'deviseId',
    agentId: 'agentId',
    statut: 'statut',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CaisseScalarFieldEnum = (typeof CaisseScalarFieldEnum)[keyof typeof CaisseScalarFieldEnum]


  export const VenteScalarFieldEnum: {
    id: 'id',
    statut: 'statut',
    typeAcheteur: 'typeAcheteur',
    clientId: 'clientId',
    agentId: 'agentId',
    fournisseurId: 'fournisseurId',
    panierId: 'panierId',
    enregistrerPar: 'enregistrerPar',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VenteScalarFieldEnum = (typeof VenteScalarFieldEnum)[keyof typeof VenteScalarFieldEnum]


  export const PanierScalarFieldEnum: {
    id: 'id',
    agentId: 'agentId',
    clientId: 'clientId',
    statut: 'statut',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PanierScalarFieldEnum = (typeof PanierScalarFieldEnum)[keyof typeof PanierScalarFieldEnum]


  export const DetailPanierScalarFieldEnum: {
    id: 'id',
    produitId: 'produitId',
    qtte: 'qtte',
    modePaiement: 'modePaiement',
    prixUnitaire: 'prixUnitaire',
    prixTotalHT: 'prixTotalHT',
    prixTotalTTC: 'prixTotalTTC',
    panierId: 'panierId',
    deviseId: 'deviseId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DetailPanierScalarFieldEnum = (typeof DetailPanierScalarFieldEnum)[keyof typeof DetailPanierScalarFieldEnum]


  export const AchatScalarFieldEnum: {
    id: 'id',
    statut: 'statut',
    panierId: 'panierId',
    fournisseurId: 'fournisseurId',
    agentId: 'agentId',
    clientId: 'clientId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AchatScalarFieldEnum = (typeof AchatScalarFieldEnum)[keyof typeof AchatScalarFieldEnum]


  export const ReservationScalarFieldEnum: {
    id: 'id',
    dateLivraisonSouhaitee: 'dateLivraisonSouhaitee',
    adresseLivraison: 'adresseLivraison',
    statut: 'statut',
    notes: 'notes',
    typeClient: 'typeClient',
    clientId: 'clientId',
    panierId: 'panierId',
    nom: 'nom',
    tel: 'tel',
    adresseId: 'adresseId',
    contactId: 'contactId',
    enregistrerParId: 'enregistrerParId',
    fournisseurId: 'fournisseurId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReservationScalarFieldEnum = (typeof ReservationScalarFieldEnum)[keyof typeof ReservationScalarFieldEnum]


  export const CommandeScalarFieldEnum: {
    id: 'id',
    panierId: 'panierId',
    clientId: 'clientId',
    nom: 'nom',
    tel: 'tel',
    type_client: 'type_client',
    adresseId: 'adresseId',
    contactId: 'contactId',
    fournisseurId: 'fournisseurId',
    commandeId: 'commandeId',
    notes: 'notes',
    dateLivraisonEffective: 'dateLivraisonEffective',
    adresseLivraison: 'adresseLivraison',
    enregistrerParId: 'enregistrerParId',
    statut: 'statut',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CommandeScalarFieldEnum = (typeof CommandeScalarFieldEnum)[keyof typeof CommandeScalarFieldEnum]


  export const ClotureCaisseScalarFieldEnum: {
    id: 'id',
    dateCloture: 'dateCloture',
    agentId: 'agentId',
    entrepriseId: 'entrepriseId',
    updatedAt: 'updatedAt',
    notes: 'notes',
    createdAt: 'createdAt'
  };

  export type ClotureCaisseScalarFieldEnum = (typeof ClotureCaisseScalarFieldEnum)[keyof typeof ClotureCaisseScalarFieldEnum]


  export const MouvementCaisseScalarFieldEnum: {
    id: 'id',
    caisseId: 'caisseId',
    referenceExterne: 'referenceExterne',
    type_mouvement: 'type_mouvement',
    categorie: 'categorie',
    moyen_paiement: 'moyen_paiement',
    montant: 'montant',
    description: 'description',
    agentId: 'agentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MouvementCaisseScalarFieldEnum = (typeof MouvementCaisseScalarFieldEnum)[keyof typeof MouvementCaisseScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Sexe'
   */
  export type EnumSexeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Sexe'>
    


  /**
   * Reference to a field of type 'Sexe[]'
   */
  export type ListEnumSexeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Sexe[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'Poste'
   */
  export type EnumPosteFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Poste'>
    


  /**
   * Reference to a field of type 'Poste[]'
   */
  export type ListEnumPosteFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Poste[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'ModePaiment'
   */
  export type EnumModePaimentFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ModePaiment'>
    


  /**
   * Reference to a field of type 'ModePaiment[]'
   */
  export type ListEnumModePaimentFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ModePaiment[]'>
    


  /**
   * Reference to a field of type 'StatutCaisse'
   */
  export type EnumStatutCaisseFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatutCaisse'>
    


  /**
   * Reference to a field of type 'StatutCaisse[]'
   */
  export type ListEnumStatutCaisseFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatutCaisse[]'>
    


  /**
   * Reference to a field of type 'StatutVente'
   */
  export type EnumStatutVenteFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatutVente'>
    


  /**
   * Reference to a field of type 'StatutVente[]'
   */
  export type ListEnumStatutVenteFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatutVente[]'>
    


  /**
   * Reference to a field of type 'TypeClient'
   */
  export type EnumTypeClientFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TypeClient'>
    


  /**
   * Reference to a field of type 'TypeClient[]'
   */
  export type ListEnumTypeClientFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TypeClient[]'>
    


  /**
   * Reference to a field of type 'statutPanier'
   */
  export type EnumstatutPanierFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'statutPanier'>
    


  /**
   * Reference to a field of type 'statutPanier[]'
   */
  export type ListEnumstatutPanierFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'statutPanier[]'>
    


  /**
   * Reference to a field of type 'StatutAchat'
   */
  export type EnumStatutAchatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatutAchat'>
    


  /**
   * Reference to a field of type 'StatutAchat[]'
   */
  export type ListEnumStatutAchatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatutAchat[]'>
    


  /**
   * Reference to a field of type 'StatutReservation'
   */
  export type EnumStatutReservationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatutReservation'>
    


  /**
   * Reference to a field of type 'StatutReservation[]'
   */
  export type ListEnumStatutReservationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatutReservation[]'>
    


  /**
   * Reference to a field of type 'StatutCommande'
   */
  export type EnumStatutCommandeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatutCommande'>
    


  /**
   * Reference to a field of type 'StatutCommande[]'
   */
  export type ListEnumStatutCommandeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatutCommande[]'>
    


  /**
   * Reference to a field of type 'TypeMouvementCaisse'
   */
  export type EnumTypeMouvementCaisseFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TypeMouvementCaisse'>
    


  /**
   * Reference to a field of type 'TypeMouvementCaisse[]'
   */
  export type ListEnumTypeMouvementCaisseFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TypeMouvementCaisse[]'>
    


  /**
   * Reference to a field of type 'CategorieMouvement'
   */
  export type EnumCategorieMouvementFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CategorieMouvement'>
    


  /**
   * Reference to a field of type 'CategorieMouvement[]'
   */
  export type ListEnumCategorieMouvementFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CategorieMouvement[]'>
    
  /**
   * Deep Input Types
   */


  export type TeneurWhereInput = {
    AND?: TeneurWhereInput | TeneurWhereInput[]
    OR?: TeneurWhereInput[]
    NOT?: TeneurWhereInput | TeneurWhereInput[]
    id?: IntFilter<"Teneur"> | number
    valeur?: FloatFilter<"Teneur"> | number
    agentId?: IntFilter<"Teneur"> | number
    createdAt?: DateTimeFilter<"Teneur"> | Date | string
    updatedAt?: DateTimeFilter<"Teneur"> | Date | string
    agents?: XOR<AgentScalarRelationFilter, AgentWhereInput>
    produits?: ProduitListRelationFilter
  }

  export type TeneurOrderByWithRelationInput = {
    id?: SortOrder
    valeur?: SortOrder
    agentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    agents?: AgentOrderByWithRelationInput
    produits?: ProduitOrderByRelationAggregateInput
  }

  export type TeneurWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    valeur?: number
    AND?: TeneurWhereInput | TeneurWhereInput[]
    OR?: TeneurWhereInput[]
    NOT?: TeneurWhereInput | TeneurWhereInput[]
    agentId?: IntFilter<"Teneur"> | number
    createdAt?: DateTimeFilter<"Teneur"> | Date | string
    updatedAt?: DateTimeFilter<"Teneur"> | Date | string
    agents?: XOR<AgentScalarRelationFilter, AgentWhereInput>
    produits?: ProduitListRelationFilter
  }, "id" | "valeur">

  export type TeneurOrderByWithAggregationInput = {
    id?: SortOrder
    valeur?: SortOrder
    agentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TeneurCountOrderByAggregateInput
    _avg?: TeneurAvgOrderByAggregateInput
    _max?: TeneurMaxOrderByAggregateInput
    _min?: TeneurMinOrderByAggregateInput
    _sum?: TeneurSumOrderByAggregateInput
  }

  export type TeneurScalarWhereWithAggregatesInput = {
    AND?: TeneurScalarWhereWithAggregatesInput | TeneurScalarWhereWithAggregatesInput[]
    OR?: TeneurScalarWhereWithAggregatesInput[]
    NOT?: TeneurScalarWhereWithAggregatesInput | TeneurScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Teneur"> | number
    valeur?: FloatWithAggregatesFilter<"Teneur"> | number
    agentId?: IntWithAggregatesFilter<"Teneur"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Teneur"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Teneur"> | Date | string
  }

  export type DeviseWhereInput = {
    AND?: DeviseWhereInput | DeviseWhereInput[]
    OR?: DeviseWhereInput[]
    NOT?: DeviseWhereInput | DeviseWhereInput[]
    id?: IntFilter<"Devise"> | number
    nom?: StringFilter<"Devise"> | string
    code?: StringFilter<"Devise"> | string
    symbole?: StringFilter<"Devise"> | string
    tauxDEchange?: IntFilter<"Devise"> | number
    agentId?: IntFilter<"Devise"> | number
    createdAt?: DateTimeFilter<"Devise"> | Date | string
    updatedAt?: DateTimeFilter<"Devise"> | Date | string
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
    produits?: ProduitListRelationFilter
    paiements?: PaiementListRelationFilter
    caisses?: CaisseListRelationFilter
    DetailPanier?: DetailPanierListRelationFilter
  }

  export type DeviseOrderByWithRelationInput = {
    id?: SortOrder
    nom?: SortOrder
    code?: SortOrder
    symbole?: SortOrder
    tauxDEchange?: SortOrder
    agentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    agent?: AgentOrderByWithRelationInput
    produits?: ProduitOrderByRelationAggregateInput
    paiements?: PaiementOrderByRelationAggregateInput
    caisses?: CaisseOrderByRelationAggregateInput
    DetailPanier?: DetailPanierOrderByRelationAggregateInput
  }

  export type DeviseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    nom?: string
    code?: string
    AND?: DeviseWhereInput | DeviseWhereInput[]
    OR?: DeviseWhereInput[]
    NOT?: DeviseWhereInput | DeviseWhereInput[]
    symbole?: StringFilter<"Devise"> | string
    tauxDEchange?: IntFilter<"Devise"> | number
    agentId?: IntFilter<"Devise"> | number
    createdAt?: DateTimeFilter<"Devise"> | Date | string
    updatedAt?: DateTimeFilter<"Devise"> | Date | string
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
    produits?: ProduitListRelationFilter
    paiements?: PaiementListRelationFilter
    caisses?: CaisseListRelationFilter
    DetailPanier?: DetailPanierListRelationFilter
  }, "id" | "nom" | "code">

  export type DeviseOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrder
    code?: SortOrder
    symbole?: SortOrder
    tauxDEchange?: SortOrder
    agentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DeviseCountOrderByAggregateInput
    _avg?: DeviseAvgOrderByAggregateInput
    _max?: DeviseMaxOrderByAggregateInput
    _min?: DeviseMinOrderByAggregateInput
    _sum?: DeviseSumOrderByAggregateInput
  }

  export type DeviseScalarWhereWithAggregatesInput = {
    AND?: DeviseScalarWhereWithAggregatesInput | DeviseScalarWhereWithAggregatesInput[]
    OR?: DeviseScalarWhereWithAggregatesInput[]
    NOT?: DeviseScalarWhereWithAggregatesInput | DeviseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Devise"> | number
    nom?: StringWithAggregatesFilter<"Devise"> | string
    code?: StringWithAggregatesFilter<"Devise"> | string
    symbole?: StringWithAggregatesFilter<"Devise"> | string
    tauxDEchange?: IntWithAggregatesFilter<"Devise"> | number
    agentId?: IntWithAggregatesFilter<"Devise"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Devise"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Devise"> | Date | string
  }

  export type EntrepriseWhereInput = {
    AND?: EntrepriseWhereInput | EntrepriseWhereInput[]
    OR?: EntrepriseWhereInput[]
    NOT?: EntrepriseWhereInput | EntrepriseWhereInput[]
    id?: IntFilter<"Entreprise"> | number
    nom?: StringFilter<"Entreprise"> | string
    email?: StringFilter<"Entreprise"> | string
    encronyme?: StringFilter<"Entreprise"> | string
    codePostale?: StringFilter<"Entreprise"> | string
    site?: StringNullableFilter<"Entreprise"> | string | null
    description?: StringNullableFilter<"Entreprise"> | string | null
    logo?: StringNullableFilter<"Entreprise"> | string | null
    createdAt?: DateTimeFilter<"Entreprise"> | Date | string
    updatedAt?: DateTimeFilter<"Entreprise"> | Date | string
    clotureCaisses?: ClotureCaisseListRelationFilter
    Adresse?: AdresseListRelationFilter
    Contact?: ContactListRelationFilter
  }

  export type EntrepriseOrderByWithRelationInput = {
    id?: SortOrder
    nom?: SortOrder
    email?: SortOrder
    encronyme?: SortOrder
    codePostale?: SortOrder
    site?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clotureCaisses?: ClotureCaisseOrderByRelationAggregateInput
    Adresse?: AdresseOrderByRelationAggregateInput
    Contact?: ContactOrderByRelationAggregateInput
  }

  export type EntrepriseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    nom?: string
    email?: string
    encronyme?: string
    codePostale?: string
    AND?: EntrepriseWhereInput | EntrepriseWhereInput[]
    OR?: EntrepriseWhereInput[]
    NOT?: EntrepriseWhereInput | EntrepriseWhereInput[]
    site?: StringNullableFilter<"Entreprise"> | string | null
    description?: StringNullableFilter<"Entreprise"> | string | null
    logo?: StringNullableFilter<"Entreprise"> | string | null
    createdAt?: DateTimeFilter<"Entreprise"> | Date | string
    updatedAt?: DateTimeFilter<"Entreprise"> | Date | string
    clotureCaisses?: ClotureCaisseListRelationFilter
    Adresse?: AdresseListRelationFilter
    Contact?: ContactListRelationFilter
  }, "id" | "nom" | "email" | "encronyme" | "codePostale">

  export type EntrepriseOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrder
    email?: SortOrder
    encronyme?: SortOrder
    codePostale?: SortOrder
    site?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EntrepriseCountOrderByAggregateInput
    _avg?: EntrepriseAvgOrderByAggregateInput
    _max?: EntrepriseMaxOrderByAggregateInput
    _min?: EntrepriseMinOrderByAggregateInput
    _sum?: EntrepriseSumOrderByAggregateInput
  }

  export type EntrepriseScalarWhereWithAggregatesInput = {
    AND?: EntrepriseScalarWhereWithAggregatesInput | EntrepriseScalarWhereWithAggregatesInput[]
    OR?: EntrepriseScalarWhereWithAggregatesInput[]
    NOT?: EntrepriseScalarWhereWithAggregatesInput | EntrepriseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Entreprise"> | number
    nom?: StringWithAggregatesFilter<"Entreprise"> | string
    email?: StringWithAggregatesFilter<"Entreprise"> | string
    encronyme?: StringWithAggregatesFilter<"Entreprise"> | string
    codePostale?: StringWithAggregatesFilter<"Entreprise"> | string
    site?: StringNullableWithAggregatesFilter<"Entreprise"> | string | null
    description?: StringNullableWithAggregatesFilter<"Entreprise"> | string | null
    logo?: StringNullableWithAggregatesFilter<"Entreprise"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Entreprise"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Entreprise"> | Date | string
  }

  export type AgentWhereInput = {
    AND?: AgentWhereInput | AgentWhereInput[]
    OR?: AgentWhereInput[]
    NOT?: AgentWhereInput | AgentWhereInput[]
    id?: IntFilter<"Agent"> | number
    email?: StringFilter<"Agent"> | string
    nom?: StringFilter<"Agent"> | string
    postnom?: StringNullableFilter<"Agent"> | string | null
    nom_complet?: StringNullableFilter<"Agent"> | string | null
    sexe?: EnumSexeNullableFilter<"Agent"> | $Enums.Sexe | null
    role?: EnumRoleFilter<"Agent"> | $Enums.Role
    poste?: EnumPosteNullableFilter<"Agent"> | $Enums.Poste | null
    picture?: StringNullableFilter<"Agent"> | string | null
    createdAt?: DateTimeFilter<"Agent"> | Date | string
    updatedAt?: DateTimeFilter<"Agent"> | Date | string
    adresses?: AdresseListRelationFilter
    contacts?: ContactListRelationFilter
    produits?: ProduitListRelationFilter
    ventes?: VenteListRelationFilter
    achats?: AchatListRelationFilter
    teneurs?: TeneurListRelationFilter
    devises?: DeviseListRelationFilter
    paniers?: PanierListRelationFilter
    caisses?: CaisseListRelationFilter
    mouvementCaisses?: MouvementCaisseListRelationFilter
    clotureCaisses?: ClotureCaisseListRelationFilter
    Fournisseur?: FournisseurListRelationFilter
  }

  export type AgentOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    nom?: SortOrder
    postnom?: SortOrderInput | SortOrder
    nom_complet?: SortOrderInput | SortOrder
    sexe?: SortOrderInput | SortOrder
    role?: SortOrder
    poste?: SortOrderInput | SortOrder
    picture?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    adresses?: AdresseOrderByRelationAggregateInput
    contacts?: ContactOrderByRelationAggregateInput
    produits?: ProduitOrderByRelationAggregateInput
    ventes?: VenteOrderByRelationAggregateInput
    achats?: AchatOrderByRelationAggregateInput
    teneurs?: TeneurOrderByRelationAggregateInput
    devises?: DeviseOrderByRelationAggregateInput
    paniers?: PanierOrderByRelationAggregateInput
    caisses?: CaisseOrderByRelationAggregateInput
    mouvementCaisses?: MouvementCaisseOrderByRelationAggregateInput
    clotureCaisses?: ClotureCaisseOrderByRelationAggregateInput
    Fournisseur?: FournisseurOrderByRelationAggregateInput
  }

  export type AgentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: AgentWhereInput | AgentWhereInput[]
    OR?: AgentWhereInput[]
    NOT?: AgentWhereInput | AgentWhereInput[]
    nom?: StringFilter<"Agent"> | string
    postnom?: StringNullableFilter<"Agent"> | string | null
    nom_complet?: StringNullableFilter<"Agent"> | string | null
    sexe?: EnumSexeNullableFilter<"Agent"> | $Enums.Sexe | null
    role?: EnumRoleFilter<"Agent"> | $Enums.Role
    poste?: EnumPosteNullableFilter<"Agent"> | $Enums.Poste | null
    picture?: StringNullableFilter<"Agent"> | string | null
    createdAt?: DateTimeFilter<"Agent"> | Date | string
    updatedAt?: DateTimeFilter<"Agent"> | Date | string
    adresses?: AdresseListRelationFilter
    contacts?: ContactListRelationFilter
    produits?: ProduitListRelationFilter
    ventes?: VenteListRelationFilter
    achats?: AchatListRelationFilter
    teneurs?: TeneurListRelationFilter
    devises?: DeviseListRelationFilter
    paniers?: PanierListRelationFilter
    caisses?: CaisseListRelationFilter
    mouvementCaisses?: MouvementCaisseListRelationFilter
    clotureCaisses?: ClotureCaisseListRelationFilter
    Fournisseur?: FournisseurListRelationFilter
  }, "id" | "email">

  export type AgentOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    nom?: SortOrder
    postnom?: SortOrderInput | SortOrder
    nom_complet?: SortOrderInput | SortOrder
    sexe?: SortOrderInput | SortOrder
    role?: SortOrder
    poste?: SortOrderInput | SortOrder
    picture?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AgentCountOrderByAggregateInput
    _avg?: AgentAvgOrderByAggregateInput
    _max?: AgentMaxOrderByAggregateInput
    _min?: AgentMinOrderByAggregateInput
    _sum?: AgentSumOrderByAggregateInput
  }

  export type AgentScalarWhereWithAggregatesInput = {
    AND?: AgentScalarWhereWithAggregatesInput | AgentScalarWhereWithAggregatesInput[]
    OR?: AgentScalarWhereWithAggregatesInput[]
    NOT?: AgentScalarWhereWithAggregatesInput | AgentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Agent"> | number
    email?: StringWithAggregatesFilter<"Agent"> | string
    nom?: StringWithAggregatesFilter<"Agent"> | string
    postnom?: StringNullableWithAggregatesFilter<"Agent"> | string | null
    nom_complet?: StringNullableWithAggregatesFilter<"Agent"> | string | null
    sexe?: EnumSexeNullableWithAggregatesFilter<"Agent"> | $Enums.Sexe | null
    role?: EnumRoleWithAggregatesFilter<"Agent"> | $Enums.Role
    poste?: EnumPosteNullableWithAggregatesFilter<"Agent"> | $Enums.Poste | null
    picture?: StringNullableWithAggregatesFilter<"Agent"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Agent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Agent"> | Date | string
  }

  export type ClientWhereInput = {
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    id?: IntFilter<"Client"> | number
    email?: StringFilter<"Client"> | string
    nom?: StringFilter<"Client"> | string
    postnom?: StringNullableFilter<"Client"> | string | null
    nom_complet?: StringNullableFilter<"Client"> | string | null
    sexe?: EnumSexeNullableFilter<"Client"> | $Enums.Sexe | null
    picture?: StringNullableFilter<"Client"> | string | null
    createdAt?: DateTimeFilter<"Client"> | Date | string
    updatedAt?: DateTimeFilter<"Client"> | Date | string
    adresses?: AdresseListRelationFilter
    contacts?: ContactListRelationFilter
    ventes?: VenteListRelationFilter
    achats?: AchatListRelationFilter
    paniers?: PanierListRelationFilter
    reservations?: ReservationListRelationFilter
    commandes?: CommandeListRelationFilter
  }

  export type ClientOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    nom?: SortOrder
    postnom?: SortOrderInput | SortOrder
    nom_complet?: SortOrderInput | SortOrder
    sexe?: SortOrderInput | SortOrder
    picture?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    adresses?: AdresseOrderByRelationAggregateInput
    contacts?: ContactOrderByRelationAggregateInput
    ventes?: VenteOrderByRelationAggregateInput
    achats?: AchatOrderByRelationAggregateInput
    paniers?: PanierOrderByRelationAggregateInput
    reservations?: ReservationOrderByRelationAggregateInput
    commandes?: CommandeOrderByRelationAggregateInput
  }

  export type ClientWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    nom?: StringFilter<"Client"> | string
    postnom?: StringNullableFilter<"Client"> | string | null
    nom_complet?: StringNullableFilter<"Client"> | string | null
    sexe?: EnumSexeNullableFilter<"Client"> | $Enums.Sexe | null
    picture?: StringNullableFilter<"Client"> | string | null
    createdAt?: DateTimeFilter<"Client"> | Date | string
    updatedAt?: DateTimeFilter<"Client"> | Date | string
    adresses?: AdresseListRelationFilter
    contacts?: ContactListRelationFilter
    ventes?: VenteListRelationFilter
    achats?: AchatListRelationFilter
    paniers?: PanierListRelationFilter
    reservations?: ReservationListRelationFilter
    commandes?: CommandeListRelationFilter
  }, "id" | "email">

  export type ClientOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    nom?: SortOrder
    postnom?: SortOrderInput | SortOrder
    nom_complet?: SortOrderInput | SortOrder
    sexe?: SortOrderInput | SortOrder
    picture?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClientCountOrderByAggregateInput
    _avg?: ClientAvgOrderByAggregateInput
    _max?: ClientMaxOrderByAggregateInput
    _min?: ClientMinOrderByAggregateInput
    _sum?: ClientSumOrderByAggregateInput
  }

  export type ClientScalarWhereWithAggregatesInput = {
    AND?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    OR?: ClientScalarWhereWithAggregatesInput[]
    NOT?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Client"> | number
    email?: StringWithAggregatesFilter<"Client"> | string
    nom?: StringWithAggregatesFilter<"Client"> | string
    postnom?: StringNullableWithAggregatesFilter<"Client"> | string | null
    nom_complet?: StringNullableWithAggregatesFilter<"Client"> | string | null
    sexe?: EnumSexeNullableWithAggregatesFilter<"Client"> | $Enums.Sexe | null
    picture?: StringNullableWithAggregatesFilter<"Client"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Client"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Client"> | Date | string
  }

  export type AdresseWhereInput = {
    AND?: AdresseWhereInput | AdresseWhereInput[]
    OR?: AdresseWhereInput[]
    NOT?: AdresseWhereInput | AdresseWhereInput[]
    id?: IntFilter<"Adresse"> | number
    ville?: StringNullableFilter<"Adresse"> | string | null
    adresse?: StringFilter<"Adresse"> | string
    isActive?: BoolFilter<"Adresse"> | boolean
    agentId?: IntNullableFilter<"Adresse"> | number | null
    fournisseurId?: IntNullableFilter<"Adresse"> | number | null
    clientId?: IntNullableFilter<"Adresse"> | number | null
    entrepriseId?: IntNullableFilter<"Adresse"> | number | null
    createdAt?: DateTimeFilter<"Adresse"> | Date | string
    updatedAt?: DateTimeFilter<"Adresse"> | Date | string
    agent?: XOR<AgentNullableScalarRelationFilter, AgentWhereInput> | null
    entreprise?: XOR<EntrepriseNullableScalarRelationFilter, EntrepriseWhereInput> | null
    fournisseur?: XOR<FournisseurNullableScalarRelationFilter, FournisseurWhereInput> | null
    client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
    reservations?: ReservationListRelationFilter
    commandes?: CommandeListRelationFilter
  }

  export type AdresseOrderByWithRelationInput = {
    id?: SortOrder
    ville?: SortOrderInput | SortOrder
    adresse?: SortOrder
    isActive?: SortOrder
    agentId?: SortOrderInput | SortOrder
    fournisseurId?: SortOrderInput | SortOrder
    clientId?: SortOrderInput | SortOrder
    entrepriseId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    agent?: AgentOrderByWithRelationInput
    entreprise?: EntrepriseOrderByWithRelationInput
    fournisseur?: FournisseurOrderByWithRelationInput
    client?: ClientOrderByWithRelationInput
    reservations?: ReservationOrderByRelationAggregateInput
    commandes?: CommandeOrderByRelationAggregateInput
  }

  export type AdresseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AdresseWhereInput | AdresseWhereInput[]
    OR?: AdresseWhereInput[]
    NOT?: AdresseWhereInput | AdresseWhereInput[]
    ville?: StringNullableFilter<"Adresse"> | string | null
    adresse?: StringFilter<"Adresse"> | string
    isActive?: BoolFilter<"Adresse"> | boolean
    agentId?: IntNullableFilter<"Adresse"> | number | null
    fournisseurId?: IntNullableFilter<"Adresse"> | number | null
    clientId?: IntNullableFilter<"Adresse"> | number | null
    entrepriseId?: IntNullableFilter<"Adresse"> | number | null
    createdAt?: DateTimeFilter<"Adresse"> | Date | string
    updatedAt?: DateTimeFilter<"Adresse"> | Date | string
    agent?: XOR<AgentNullableScalarRelationFilter, AgentWhereInput> | null
    entreprise?: XOR<EntrepriseNullableScalarRelationFilter, EntrepriseWhereInput> | null
    fournisseur?: XOR<FournisseurNullableScalarRelationFilter, FournisseurWhereInput> | null
    client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
    reservations?: ReservationListRelationFilter
    commandes?: CommandeListRelationFilter
  }, "id">

  export type AdresseOrderByWithAggregationInput = {
    id?: SortOrder
    ville?: SortOrderInput | SortOrder
    adresse?: SortOrder
    isActive?: SortOrder
    agentId?: SortOrderInput | SortOrder
    fournisseurId?: SortOrderInput | SortOrder
    clientId?: SortOrderInput | SortOrder
    entrepriseId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AdresseCountOrderByAggregateInput
    _avg?: AdresseAvgOrderByAggregateInput
    _max?: AdresseMaxOrderByAggregateInput
    _min?: AdresseMinOrderByAggregateInput
    _sum?: AdresseSumOrderByAggregateInput
  }

  export type AdresseScalarWhereWithAggregatesInput = {
    AND?: AdresseScalarWhereWithAggregatesInput | AdresseScalarWhereWithAggregatesInput[]
    OR?: AdresseScalarWhereWithAggregatesInput[]
    NOT?: AdresseScalarWhereWithAggregatesInput | AdresseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Adresse"> | number
    ville?: StringNullableWithAggregatesFilter<"Adresse"> | string | null
    adresse?: StringWithAggregatesFilter<"Adresse"> | string
    isActive?: BoolWithAggregatesFilter<"Adresse"> | boolean
    agentId?: IntNullableWithAggregatesFilter<"Adresse"> | number | null
    fournisseurId?: IntNullableWithAggregatesFilter<"Adresse"> | number | null
    clientId?: IntNullableWithAggregatesFilter<"Adresse"> | number | null
    entrepriseId?: IntNullableWithAggregatesFilter<"Adresse"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Adresse"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Adresse"> | Date | string
  }

  export type ContactWhereInput = {
    AND?: ContactWhereInput | ContactWhereInput[]
    OR?: ContactWhereInput[]
    NOT?: ContactWhereInput | ContactWhereInput[]
    id?: IntFilter<"Contact"> | number
    tel?: StringFilter<"Contact"> | string
    isActive?: BoolFilter<"Contact"> | boolean
    agentId?: IntNullableFilter<"Contact"> | number | null
    fournisseurId?: IntNullableFilter<"Contact"> | number | null
    clientId?: IntNullableFilter<"Contact"> | number | null
    entrepriseId?: IntNullableFilter<"Contact"> | number | null
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    updatedAt?: DateTimeFilter<"Contact"> | Date | string
    entreprise?: XOR<EntrepriseNullableScalarRelationFilter, EntrepriseWhereInput> | null
    client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
    agent?: XOR<AgentNullableScalarRelationFilter, AgentWhereInput> | null
    fournisseur?: XOR<FournisseurNullableScalarRelationFilter, FournisseurWhereInput> | null
    reservations?: ReservationListRelationFilter
    commandes?: CommandeListRelationFilter
  }

  export type ContactOrderByWithRelationInput = {
    id?: SortOrder
    tel?: SortOrder
    isActive?: SortOrder
    agentId?: SortOrderInput | SortOrder
    fournisseurId?: SortOrderInput | SortOrder
    clientId?: SortOrderInput | SortOrder
    entrepriseId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    entreprise?: EntrepriseOrderByWithRelationInput
    client?: ClientOrderByWithRelationInput
    agent?: AgentOrderByWithRelationInput
    fournisseur?: FournisseurOrderByWithRelationInput
    reservations?: ReservationOrderByRelationAggregateInput
    commandes?: CommandeOrderByRelationAggregateInput
  }

  export type ContactWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    tel?: string
    AND?: ContactWhereInput | ContactWhereInput[]
    OR?: ContactWhereInput[]
    NOT?: ContactWhereInput | ContactWhereInput[]
    isActive?: BoolFilter<"Contact"> | boolean
    agentId?: IntNullableFilter<"Contact"> | number | null
    fournisseurId?: IntNullableFilter<"Contact"> | number | null
    clientId?: IntNullableFilter<"Contact"> | number | null
    entrepriseId?: IntNullableFilter<"Contact"> | number | null
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    updatedAt?: DateTimeFilter<"Contact"> | Date | string
    entreprise?: XOR<EntrepriseNullableScalarRelationFilter, EntrepriseWhereInput> | null
    client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
    agent?: XOR<AgentNullableScalarRelationFilter, AgentWhereInput> | null
    fournisseur?: XOR<FournisseurNullableScalarRelationFilter, FournisseurWhereInput> | null
    reservations?: ReservationListRelationFilter
    commandes?: CommandeListRelationFilter
  }, "id" | "tel">

  export type ContactOrderByWithAggregationInput = {
    id?: SortOrder
    tel?: SortOrder
    isActive?: SortOrder
    agentId?: SortOrderInput | SortOrder
    fournisseurId?: SortOrderInput | SortOrder
    clientId?: SortOrderInput | SortOrder
    entrepriseId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContactCountOrderByAggregateInput
    _avg?: ContactAvgOrderByAggregateInput
    _max?: ContactMaxOrderByAggregateInput
    _min?: ContactMinOrderByAggregateInput
    _sum?: ContactSumOrderByAggregateInput
  }

  export type ContactScalarWhereWithAggregatesInput = {
    AND?: ContactScalarWhereWithAggregatesInput | ContactScalarWhereWithAggregatesInput[]
    OR?: ContactScalarWhereWithAggregatesInput[]
    NOT?: ContactScalarWhereWithAggregatesInput | ContactScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Contact"> | number
    tel?: StringWithAggregatesFilter<"Contact"> | string
    isActive?: BoolWithAggregatesFilter<"Contact"> | boolean
    agentId?: IntNullableWithAggregatesFilter<"Contact"> | number | null
    fournisseurId?: IntNullableWithAggregatesFilter<"Contact"> | number | null
    clientId?: IntNullableWithAggregatesFilter<"Contact"> | number | null
    entrepriseId?: IntNullableWithAggregatesFilter<"Contact"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Contact"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Contact"> | Date | string
  }

  export type FournisseurWhereInput = {
    AND?: FournisseurWhereInput | FournisseurWhereInput[]
    OR?: FournisseurWhereInput[]
    NOT?: FournisseurWhereInput | FournisseurWhereInput[]
    id?: IntFilter<"Fournisseur"> | number
    nom?: StringFilter<"Fournisseur"> | string
    email?: StringFilter<"Fournisseur"> | string
    codePostale?: StringNullableFilter<"Fournisseur"> | string | null
    agentId?: IntFilter<"Fournisseur"> | number
    createdAt?: DateTimeFilter<"Fournisseur"> | Date | string
    updatedAt?: DateTimeFilter<"Fournisseur"> | Date | string
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
    ventes?: VenteListRelationFilter
    achats?: AchatListRelationFilter
    adresses?: AdresseListRelationFilter
    contacts?: ContactListRelationFilter
    reservations?: ReservationListRelationFilter
    commandes?: CommandeListRelationFilter
  }

  export type FournisseurOrderByWithRelationInput = {
    id?: SortOrder
    nom?: SortOrder
    email?: SortOrder
    codePostale?: SortOrderInput | SortOrder
    agentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    agent?: AgentOrderByWithRelationInput
    ventes?: VenteOrderByRelationAggregateInput
    achats?: AchatOrderByRelationAggregateInput
    adresses?: AdresseOrderByRelationAggregateInput
    contacts?: ContactOrderByRelationAggregateInput
    reservations?: ReservationOrderByRelationAggregateInput
    commandes?: CommandeOrderByRelationAggregateInput
  }

  export type FournisseurWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    nom?: string
    email?: string
    AND?: FournisseurWhereInput | FournisseurWhereInput[]
    OR?: FournisseurWhereInput[]
    NOT?: FournisseurWhereInput | FournisseurWhereInput[]
    codePostale?: StringNullableFilter<"Fournisseur"> | string | null
    agentId?: IntFilter<"Fournisseur"> | number
    createdAt?: DateTimeFilter<"Fournisseur"> | Date | string
    updatedAt?: DateTimeFilter<"Fournisseur"> | Date | string
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
    ventes?: VenteListRelationFilter
    achats?: AchatListRelationFilter
    adresses?: AdresseListRelationFilter
    contacts?: ContactListRelationFilter
    reservations?: ReservationListRelationFilter
    commandes?: CommandeListRelationFilter
  }, "id" | "nom" | "email">

  export type FournisseurOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrder
    email?: SortOrder
    codePostale?: SortOrderInput | SortOrder
    agentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FournisseurCountOrderByAggregateInput
    _avg?: FournisseurAvgOrderByAggregateInput
    _max?: FournisseurMaxOrderByAggregateInput
    _min?: FournisseurMinOrderByAggregateInput
    _sum?: FournisseurSumOrderByAggregateInput
  }

  export type FournisseurScalarWhereWithAggregatesInput = {
    AND?: FournisseurScalarWhereWithAggregatesInput | FournisseurScalarWhereWithAggregatesInput[]
    OR?: FournisseurScalarWhereWithAggregatesInput[]
    NOT?: FournisseurScalarWhereWithAggregatesInput | FournisseurScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Fournisseur"> | number
    nom?: StringWithAggregatesFilter<"Fournisseur"> | string
    email?: StringWithAggregatesFilter<"Fournisseur"> | string
    codePostale?: StringNullableWithAggregatesFilter<"Fournisseur"> | string | null
    agentId?: IntWithAggregatesFilter<"Fournisseur"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Fournisseur"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Fournisseur"> | Date | string
  }

  export type ProduitWhereInput = {
    AND?: ProduitWhereInput | ProduitWhereInput[]
    OR?: ProduitWhereInput[]
    NOT?: ProduitWhereInput | ProduitWhereInput[]
    id?: IntFilter<"Produit"> | number
    designation?: StringFilter<"Produit"> | string
    prixUnitaire?: FloatFilter<"Produit"> | number
    qtteDisponible?: IntFilter<"Produit"> | number
    description?: StringNullableFilter<"Produit"> | string | null
    deviseId?: IntFilter<"Produit"> | number
    teneurId?: IntFilter<"Produit"> | number
    agentId?: IntFilter<"Produit"> | number
    createdAt?: DateTimeFilter<"Produit"> | Date | string
    updatedAt?: DateTimeFilter<"Produit"> | Date | string
    detailsPaniers?: DetailPanierListRelationFilter
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
    devise?: XOR<DeviseScalarRelationFilter, DeviseWhereInput>
    teneur?: XOR<TeneurScalarRelationFilter, TeneurWhereInput>
  }

  export type ProduitOrderByWithRelationInput = {
    id?: SortOrder
    designation?: SortOrder
    prixUnitaire?: SortOrder
    qtteDisponible?: SortOrder
    description?: SortOrderInput | SortOrder
    deviseId?: SortOrder
    teneurId?: SortOrder
    agentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    detailsPaniers?: DetailPanierOrderByRelationAggregateInput
    agent?: AgentOrderByWithRelationInput
    devise?: DeviseOrderByWithRelationInput
    teneur?: TeneurOrderByWithRelationInput
  }

  export type ProduitWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProduitWhereInput | ProduitWhereInput[]
    OR?: ProduitWhereInput[]
    NOT?: ProduitWhereInput | ProduitWhereInput[]
    designation?: StringFilter<"Produit"> | string
    prixUnitaire?: FloatFilter<"Produit"> | number
    qtteDisponible?: IntFilter<"Produit"> | number
    description?: StringNullableFilter<"Produit"> | string | null
    deviseId?: IntFilter<"Produit"> | number
    teneurId?: IntFilter<"Produit"> | number
    agentId?: IntFilter<"Produit"> | number
    createdAt?: DateTimeFilter<"Produit"> | Date | string
    updatedAt?: DateTimeFilter<"Produit"> | Date | string
    detailsPaniers?: DetailPanierListRelationFilter
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
    devise?: XOR<DeviseScalarRelationFilter, DeviseWhereInput>
    teneur?: XOR<TeneurScalarRelationFilter, TeneurWhereInput>
  }, "id">

  export type ProduitOrderByWithAggregationInput = {
    id?: SortOrder
    designation?: SortOrder
    prixUnitaire?: SortOrder
    qtteDisponible?: SortOrder
    description?: SortOrderInput | SortOrder
    deviseId?: SortOrder
    teneurId?: SortOrder
    agentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProduitCountOrderByAggregateInput
    _avg?: ProduitAvgOrderByAggregateInput
    _max?: ProduitMaxOrderByAggregateInput
    _min?: ProduitMinOrderByAggregateInput
    _sum?: ProduitSumOrderByAggregateInput
  }

  export type ProduitScalarWhereWithAggregatesInput = {
    AND?: ProduitScalarWhereWithAggregatesInput | ProduitScalarWhereWithAggregatesInput[]
    OR?: ProduitScalarWhereWithAggregatesInput[]
    NOT?: ProduitScalarWhereWithAggregatesInput | ProduitScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Produit"> | number
    designation?: StringWithAggregatesFilter<"Produit"> | string
    prixUnitaire?: FloatWithAggregatesFilter<"Produit"> | number
    qtteDisponible?: IntWithAggregatesFilter<"Produit"> | number
    description?: StringNullableWithAggregatesFilter<"Produit"> | string | null
    deviseId?: IntWithAggregatesFilter<"Produit"> | number
    teneurId?: IntWithAggregatesFilter<"Produit"> | number
    agentId?: IntWithAggregatesFilter<"Produit"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Produit"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Produit"> | Date | string
  }

  export type PaiementWhereInput = {
    AND?: PaiementWhereInput | PaiementWhereInput[]
    OR?: PaiementWhereInput[]
    NOT?: PaiementWhereInput | PaiementWhereInput[]
    id?: IntFilter<"Paiement"> | number
    totalHT?: FloatNullableFilter<"Paiement"> | number | null
    totalTTC?: FloatNullableFilter<"Paiement"> | number | null
    modePaiement?: EnumModePaimentFilter<"Paiement"> | $Enums.ModePaiment
    deviseId?: IntFilter<"Paiement"> | number
    caisseId?: IntFilter<"Paiement"> | number
    venteId?: IntNullableFilter<"Paiement"> | number | null
    achatId?: IntNullableFilter<"Paiement"> | number | null
    commandeId?: IntNullableFilter<"Paiement"> | number | null
    createdAt?: DateTimeFilter<"Paiement"> | Date | string
    updatedAt?: DateTimeFilter<"Paiement"> | Date | string
    vente?: XOR<VenteNullableScalarRelationFilter, VenteWhereInput> | null
    achat?: XOR<AchatNullableScalarRelationFilter, AchatWhereInput> | null
    commande?: XOR<CommandeNullableScalarRelationFilter, CommandeWhereInput> | null
    caisse?: XOR<CaisseScalarRelationFilter, CaisseWhereInput>
    devise?: XOR<DeviseScalarRelationFilter, DeviseWhereInput>
  }

  export type PaiementOrderByWithRelationInput = {
    id?: SortOrder
    totalHT?: SortOrderInput | SortOrder
    totalTTC?: SortOrderInput | SortOrder
    modePaiement?: SortOrder
    deviseId?: SortOrder
    caisseId?: SortOrder
    venteId?: SortOrderInput | SortOrder
    achatId?: SortOrderInput | SortOrder
    commandeId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vente?: VenteOrderByWithRelationInput
    achat?: AchatOrderByWithRelationInput
    commande?: CommandeOrderByWithRelationInput
    caisse?: CaisseOrderByWithRelationInput
    devise?: DeviseOrderByWithRelationInput
  }

  export type PaiementWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PaiementWhereInput | PaiementWhereInput[]
    OR?: PaiementWhereInput[]
    NOT?: PaiementWhereInput | PaiementWhereInput[]
    totalHT?: FloatNullableFilter<"Paiement"> | number | null
    totalTTC?: FloatNullableFilter<"Paiement"> | number | null
    modePaiement?: EnumModePaimentFilter<"Paiement"> | $Enums.ModePaiment
    deviseId?: IntFilter<"Paiement"> | number
    caisseId?: IntFilter<"Paiement"> | number
    venteId?: IntNullableFilter<"Paiement"> | number | null
    achatId?: IntNullableFilter<"Paiement"> | number | null
    commandeId?: IntNullableFilter<"Paiement"> | number | null
    createdAt?: DateTimeFilter<"Paiement"> | Date | string
    updatedAt?: DateTimeFilter<"Paiement"> | Date | string
    vente?: XOR<VenteNullableScalarRelationFilter, VenteWhereInput> | null
    achat?: XOR<AchatNullableScalarRelationFilter, AchatWhereInput> | null
    commande?: XOR<CommandeNullableScalarRelationFilter, CommandeWhereInput> | null
    caisse?: XOR<CaisseScalarRelationFilter, CaisseWhereInput>
    devise?: XOR<DeviseScalarRelationFilter, DeviseWhereInput>
  }, "id">

  export type PaiementOrderByWithAggregationInput = {
    id?: SortOrder
    totalHT?: SortOrderInput | SortOrder
    totalTTC?: SortOrderInput | SortOrder
    modePaiement?: SortOrder
    deviseId?: SortOrder
    caisseId?: SortOrder
    venteId?: SortOrderInput | SortOrder
    achatId?: SortOrderInput | SortOrder
    commandeId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaiementCountOrderByAggregateInput
    _avg?: PaiementAvgOrderByAggregateInput
    _max?: PaiementMaxOrderByAggregateInput
    _min?: PaiementMinOrderByAggregateInput
    _sum?: PaiementSumOrderByAggregateInput
  }

  export type PaiementScalarWhereWithAggregatesInput = {
    AND?: PaiementScalarWhereWithAggregatesInput | PaiementScalarWhereWithAggregatesInput[]
    OR?: PaiementScalarWhereWithAggregatesInput[]
    NOT?: PaiementScalarWhereWithAggregatesInput | PaiementScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Paiement"> | number
    totalHT?: FloatNullableWithAggregatesFilter<"Paiement"> | number | null
    totalTTC?: FloatNullableWithAggregatesFilter<"Paiement"> | number | null
    modePaiement?: EnumModePaimentWithAggregatesFilter<"Paiement"> | $Enums.ModePaiment
    deviseId?: IntWithAggregatesFilter<"Paiement"> | number
    caisseId?: IntWithAggregatesFilter<"Paiement"> | number
    venteId?: IntNullableWithAggregatesFilter<"Paiement"> | number | null
    achatId?: IntNullableWithAggregatesFilter<"Paiement"> | number | null
    commandeId?: IntNullableWithAggregatesFilter<"Paiement"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Paiement"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Paiement"> | Date | string
  }

  export type CaisseWhereInput = {
    AND?: CaisseWhereInput | CaisseWhereInput[]
    OR?: CaisseWhereInput[]
    NOT?: CaisseWhereInput | CaisseWhereInput[]
    id?: IntFilter<"Caisse"> | number
    nom?: StringFilter<"Caisse"> | string
    description?: StringNullableFilter<"Caisse"> | string | null
    soldeActuel?: FloatNullableFilter<"Caisse"> | number | null
    deviseId?: IntFilter<"Caisse"> | number
    agentId?: IntFilter<"Caisse"> | number
    statut?: EnumStatutCaisseFilter<"Caisse"> | $Enums.StatutCaisse
    createdAt?: DateTimeFilter<"Caisse"> | Date | string
    updatedAt?: DateTimeFilter<"Caisse"> | Date | string
    devise?: XOR<DeviseScalarRelationFilter, DeviseWhereInput>
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
    mouvementCaisses?: MouvementCaisseListRelationFilter
    paiements?: PaiementListRelationFilter
  }

  export type CaisseOrderByWithRelationInput = {
    id?: SortOrder
    nom?: SortOrder
    description?: SortOrderInput | SortOrder
    soldeActuel?: SortOrderInput | SortOrder
    deviseId?: SortOrder
    agentId?: SortOrder
    statut?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    devise?: DeviseOrderByWithRelationInput
    agent?: AgentOrderByWithRelationInput
    mouvementCaisses?: MouvementCaisseOrderByRelationAggregateInput
    paiements?: PaiementOrderByRelationAggregateInput
  }

  export type CaisseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    nom?: string
    AND?: CaisseWhereInput | CaisseWhereInput[]
    OR?: CaisseWhereInput[]
    NOT?: CaisseWhereInput | CaisseWhereInput[]
    description?: StringNullableFilter<"Caisse"> | string | null
    soldeActuel?: FloatNullableFilter<"Caisse"> | number | null
    deviseId?: IntFilter<"Caisse"> | number
    agentId?: IntFilter<"Caisse"> | number
    statut?: EnumStatutCaisseFilter<"Caisse"> | $Enums.StatutCaisse
    createdAt?: DateTimeFilter<"Caisse"> | Date | string
    updatedAt?: DateTimeFilter<"Caisse"> | Date | string
    devise?: XOR<DeviseScalarRelationFilter, DeviseWhereInput>
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
    mouvementCaisses?: MouvementCaisseListRelationFilter
    paiements?: PaiementListRelationFilter
  }, "id" | "nom">

  export type CaisseOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrder
    description?: SortOrderInput | SortOrder
    soldeActuel?: SortOrderInput | SortOrder
    deviseId?: SortOrder
    agentId?: SortOrder
    statut?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CaisseCountOrderByAggregateInput
    _avg?: CaisseAvgOrderByAggregateInput
    _max?: CaisseMaxOrderByAggregateInput
    _min?: CaisseMinOrderByAggregateInput
    _sum?: CaisseSumOrderByAggregateInput
  }

  export type CaisseScalarWhereWithAggregatesInput = {
    AND?: CaisseScalarWhereWithAggregatesInput | CaisseScalarWhereWithAggregatesInput[]
    OR?: CaisseScalarWhereWithAggregatesInput[]
    NOT?: CaisseScalarWhereWithAggregatesInput | CaisseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Caisse"> | number
    nom?: StringWithAggregatesFilter<"Caisse"> | string
    description?: StringNullableWithAggregatesFilter<"Caisse"> | string | null
    soldeActuel?: FloatNullableWithAggregatesFilter<"Caisse"> | number | null
    deviseId?: IntWithAggregatesFilter<"Caisse"> | number
    agentId?: IntWithAggregatesFilter<"Caisse"> | number
    statut?: EnumStatutCaisseWithAggregatesFilter<"Caisse"> | $Enums.StatutCaisse
    createdAt?: DateTimeWithAggregatesFilter<"Caisse"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Caisse"> | Date | string
  }

  export type VenteWhereInput = {
    AND?: VenteWhereInput | VenteWhereInput[]
    OR?: VenteWhereInput[]
    NOT?: VenteWhereInput | VenteWhereInput[]
    id?: IntFilter<"Vente"> | number
    statut?: EnumStatutVenteFilter<"Vente"> | $Enums.StatutVente
    typeAcheteur?: EnumTypeClientFilter<"Vente"> | $Enums.TypeClient
    clientId?: IntNullableFilter<"Vente"> | number | null
    agentId?: IntNullableFilter<"Vente"> | number | null
    fournisseurId?: IntNullableFilter<"Vente"> | number | null
    panierId?: IntFilter<"Vente"> | number
    enregistrerPar?: StringNullableFilter<"Vente"> | string | null
    createdAt?: DateTimeFilter<"Vente"> | Date | string
    updatedAt?: DateTimeFilter<"Vente"> | Date | string
    panier?: XOR<PanierScalarRelationFilter, PanierWhereInput>
    agent?: XOR<AgentNullableScalarRelationFilter, AgentWhereInput> | null
    fournisseur?: XOR<FournisseurNullableScalarRelationFilter, FournisseurWhereInput> | null
    client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
    paiements?: PaiementListRelationFilter
  }

  export type VenteOrderByWithRelationInput = {
    id?: SortOrder
    statut?: SortOrder
    typeAcheteur?: SortOrder
    clientId?: SortOrderInput | SortOrder
    agentId?: SortOrderInput | SortOrder
    fournisseurId?: SortOrderInput | SortOrder
    panierId?: SortOrder
    enregistrerPar?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    panier?: PanierOrderByWithRelationInput
    agent?: AgentOrderByWithRelationInput
    fournisseur?: FournisseurOrderByWithRelationInput
    client?: ClientOrderByWithRelationInput
    paiements?: PaiementOrderByRelationAggregateInput
  }

  export type VenteWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: VenteWhereInput | VenteWhereInput[]
    OR?: VenteWhereInput[]
    NOT?: VenteWhereInput | VenteWhereInput[]
    statut?: EnumStatutVenteFilter<"Vente"> | $Enums.StatutVente
    typeAcheteur?: EnumTypeClientFilter<"Vente"> | $Enums.TypeClient
    clientId?: IntNullableFilter<"Vente"> | number | null
    agentId?: IntNullableFilter<"Vente"> | number | null
    fournisseurId?: IntNullableFilter<"Vente"> | number | null
    panierId?: IntFilter<"Vente"> | number
    enregistrerPar?: StringNullableFilter<"Vente"> | string | null
    createdAt?: DateTimeFilter<"Vente"> | Date | string
    updatedAt?: DateTimeFilter<"Vente"> | Date | string
    panier?: XOR<PanierScalarRelationFilter, PanierWhereInput>
    agent?: XOR<AgentNullableScalarRelationFilter, AgentWhereInput> | null
    fournisseur?: XOR<FournisseurNullableScalarRelationFilter, FournisseurWhereInput> | null
    client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
    paiements?: PaiementListRelationFilter
  }, "id">

  export type VenteOrderByWithAggregationInput = {
    id?: SortOrder
    statut?: SortOrder
    typeAcheteur?: SortOrder
    clientId?: SortOrderInput | SortOrder
    agentId?: SortOrderInput | SortOrder
    fournisseurId?: SortOrderInput | SortOrder
    panierId?: SortOrder
    enregistrerPar?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VenteCountOrderByAggregateInput
    _avg?: VenteAvgOrderByAggregateInput
    _max?: VenteMaxOrderByAggregateInput
    _min?: VenteMinOrderByAggregateInput
    _sum?: VenteSumOrderByAggregateInput
  }

  export type VenteScalarWhereWithAggregatesInput = {
    AND?: VenteScalarWhereWithAggregatesInput | VenteScalarWhereWithAggregatesInput[]
    OR?: VenteScalarWhereWithAggregatesInput[]
    NOT?: VenteScalarWhereWithAggregatesInput | VenteScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Vente"> | number
    statut?: EnumStatutVenteWithAggregatesFilter<"Vente"> | $Enums.StatutVente
    typeAcheteur?: EnumTypeClientWithAggregatesFilter<"Vente"> | $Enums.TypeClient
    clientId?: IntNullableWithAggregatesFilter<"Vente"> | number | null
    agentId?: IntNullableWithAggregatesFilter<"Vente"> | number | null
    fournisseurId?: IntNullableWithAggregatesFilter<"Vente"> | number | null
    panierId?: IntWithAggregatesFilter<"Vente"> | number
    enregistrerPar?: StringNullableWithAggregatesFilter<"Vente"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Vente"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Vente"> | Date | string
  }

  export type PanierWhereInput = {
    AND?: PanierWhereInput | PanierWhereInput[]
    OR?: PanierWhereInput[]
    NOT?: PanierWhereInput | PanierWhereInput[]
    id?: IntFilter<"Panier"> | number
    agentId?: IntNullableFilter<"Panier"> | number | null
    clientId?: IntNullableFilter<"Panier"> | number | null
    statut?: EnumstatutPanierFilter<"Panier"> | $Enums.statutPanier
    createdAt?: DateTimeFilter<"Panier"> | Date | string
    updatedAt?: DateTimeFilter<"Panier"> | Date | string
    agent?: XOR<AgentNullableScalarRelationFilter, AgentWhereInput> | null
    client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
    detailPaniers?: DetailPanierListRelationFilter
    achats?: AchatListRelationFilter
    ventes?: VenteListRelationFilter
    reservations?: ReservationListRelationFilter
    commandes?: CommandeListRelationFilter
  }

  export type PanierOrderByWithRelationInput = {
    id?: SortOrder
    agentId?: SortOrderInput | SortOrder
    clientId?: SortOrderInput | SortOrder
    statut?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    agent?: AgentOrderByWithRelationInput
    client?: ClientOrderByWithRelationInput
    detailPaniers?: DetailPanierOrderByRelationAggregateInput
    achats?: AchatOrderByRelationAggregateInput
    ventes?: VenteOrderByRelationAggregateInput
    reservations?: ReservationOrderByRelationAggregateInput
    commandes?: CommandeOrderByRelationAggregateInput
  }

  export type PanierWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PanierWhereInput | PanierWhereInput[]
    OR?: PanierWhereInput[]
    NOT?: PanierWhereInput | PanierWhereInput[]
    agentId?: IntNullableFilter<"Panier"> | number | null
    clientId?: IntNullableFilter<"Panier"> | number | null
    statut?: EnumstatutPanierFilter<"Panier"> | $Enums.statutPanier
    createdAt?: DateTimeFilter<"Panier"> | Date | string
    updatedAt?: DateTimeFilter<"Panier"> | Date | string
    agent?: XOR<AgentNullableScalarRelationFilter, AgentWhereInput> | null
    client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
    detailPaniers?: DetailPanierListRelationFilter
    achats?: AchatListRelationFilter
    ventes?: VenteListRelationFilter
    reservations?: ReservationListRelationFilter
    commandes?: CommandeListRelationFilter
  }, "id">

  export type PanierOrderByWithAggregationInput = {
    id?: SortOrder
    agentId?: SortOrderInput | SortOrder
    clientId?: SortOrderInput | SortOrder
    statut?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PanierCountOrderByAggregateInput
    _avg?: PanierAvgOrderByAggregateInput
    _max?: PanierMaxOrderByAggregateInput
    _min?: PanierMinOrderByAggregateInput
    _sum?: PanierSumOrderByAggregateInput
  }

  export type PanierScalarWhereWithAggregatesInput = {
    AND?: PanierScalarWhereWithAggregatesInput | PanierScalarWhereWithAggregatesInput[]
    OR?: PanierScalarWhereWithAggregatesInput[]
    NOT?: PanierScalarWhereWithAggregatesInput | PanierScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Panier"> | number
    agentId?: IntNullableWithAggregatesFilter<"Panier"> | number | null
    clientId?: IntNullableWithAggregatesFilter<"Panier"> | number | null
    statut?: EnumstatutPanierWithAggregatesFilter<"Panier"> | $Enums.statutPanier
    createdAt?: DateTimeWithAggregatesFilter<"Panier"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Panier"> | Date | string
  }

  export type DetailPanierWhereInput = {
    AND?: DetailPanierWhereInput | DetailPanierWhereInput[]
    OR?: DetailPanierWhereInput[]
    NOT?: DetailPanierWhereInput | DetailPanierWhereInput[]
    id?: IntFilter<"DetailPanier"> | number
    produitId?: IntFilter<"DetailPanier"> | number
    qtte?: IntFilter<"DetailPanier"> | number
    modePaiement?: EnumModePaimentFilter<"DetailPanier"> | $Enums.ModePaiment
    prixUnitaire?: FloatFilter<"DetailPanier"> | number
    prixTotalHT?: FloatFilter<"DetailPanier"> | number
    prixTotalTTC?: FloatFilter<"DetailPanier"> | number
    panierId?: IntFilter<"DetailPanier"> | number
    deviseId?: IntFilter<"DetailPanier"> | number
    createdAt?: DateTimeFilter<"DetailPanier"> | Date | string
    updatedAt?: DateTimeFilter<"DetailPanier"> | Date | string
    devise?: XOR<DeviseScalarRelationFilter, DeviseWhereInput>
    produit?: XOR<ProduitScalarRelationFilter, ProduitWhereInput>
    panier?: XOR<PanierScalarRelationFilter, PanierWhereInput>
  }

  export type DetailPanierOrderByWithRelationInput = {
    id?: SortOrder
    produitId?: SortOrder
    qtte?: SortOrder
    modePaiement?: SortOrder
    prixUnitaire?: SortOrder
    prixTotalHT?: SortOrder
    prixTotalTTC?: SortOrder
    panierId?: SortOrder
    deviseId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    devise?: DeviseOrderByWithRelationInput
    produit?: ProduitOrderByWithRelationInput
    panier?: PanierOrderByWithRelationInput
  }

  export type DetailPanierWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DetailPanierWhereInput | DetailPanierWhereInput[]
    OR?: DetailPanierWhereInput[]
    NOT?: DetailPanierWhereInput | DetailPanierWhereInput[]
    produitId?: IntFilter<"DetailPanier"> | number
    qtte?: IntFilter<"DetailPanier"> | number
    modePaiement?: EnumModePaimentFilter<"DetailPanier"> | $Enums.ModePaiment
    prixUnitaire?: FloatFilter<"DetailPanier"> | number
    prixTotalHT?: FloatFilter<"DetailPanier"> | number
    prixTotalTTC?: FloatFilter<"DetailPanier"> | number
    panierId?: IntFilter<"DetailPanier"> | number
    deviseId?: IntFilter<"DetailPanier"> | number
    createdAt?: DateTimeFilter<"DetailPanier"> | Date | string
    updatedAt?: DateTimeFilter<"DetailPanier"> | Date | string
    devise?: XOR<DeviseScalarRelationFilter, DeviseWhereInput>
    produit?: XOR<ProduitScalarRelationFilter, ProduitWhereInput>
    panier?: XOR<PanierScalarRelationFilter, PanierWhereInput>
  }, "id">

  export type DetailPanierOrderByWithAggregationInput = {
    id?: SortOrder
    produitId?: SortOrder
    qtte?: SortOrder
    modePaiement?: SortOrder
    prixUnitaire?: SortOrder
    prixTotalHT?: SortOrder
    prixTotalTTC?: SortOrder
    panierId?: SortOrder
    deviseId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DetailPanierCountOrderByAggregateInput
    _avg?: DetailPanierAvgOrderByAggregateInput
    _max?: DetailPanierMaxOrderByAggregateInput
    _min?: DetailPanierMinOrderByAggregateInput
    _sum?: DetailPanierSumOrderByAggregateInput
  }

  export type DetailPanierScalarWhereWithAggregatesInput = {
    AND?: DetailPanierScalarWhereWithAggregatesInput | DetailPanierScalarWhereWithAggregatesInput[]
    OR?: DetailPanierScalarWhereWithAggregatesInput[]
    NOT?: DetailPanierScalarWhereWithAggregatesInput | DetailPanierScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DetailPanier"> | number
    produitId?: IntWithAggregatesFilter<"DetailPanier"> | number
    qtte?: IntWithAggregatesFilter<"DetailPanier"> | number
    modePaiement?: EnumModePaimentWithAggregatesFilter<"DetailPanier"> | $Enums.ModePaiment
    prixUnitaire?: FloatWithAggregatesFilter<"DetailPanier"> | number
    prixTotalHT?: FloatWithAggregatesFilter<"DetailPanier"> | number
    prixTotalTTC?: FloatWithAggregatesFilter<"DetailPanier"> | number
    panierId?: IntWithAggregatesFilter<"DetailPanier"> | number
    deviseId?: IntWithAggregatesFilter<"DetailPanier"> | number
    createdAt?: DateTimeWithAggregatesFilter<"DetailPanier"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DetailPanier"> | Date | string
  }

  export type AchatWhereInput = {
    AND?: AchatWhereInput | AchatWhereInput[]
    OR?: AchatWhereInput[]
    NOT?: AchatWhereInput | AchatWhereInput[]
    id?: IntFilter<"Achat"> | number
    statut?: EnumStatutAchatFilter<"Achat"> | $Enums.StatutAchat
    panierId?: IntFilter<"Achat"> | number
    fournisseurId?: IntFilter<"Achat"> | number
    agentId?: IntFilter<"Achat"> | number
    clientId?: IntNullableFilter<"Achat"> | number | null
    createdAt?: DateTimeFilter<"Achat"> | Date | string
    updatedAt?: DateTimeFilter<"Achat"> | Date | string
    panier?: XOR<PanierScalarRelationFilter, PanierWhereInput>
    fournisseur?: XOR<FournisseurScalarRelationFilter, FournisseurWhereInput>
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
    Client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
    paiements?: PaiementListRelationFilter
  }

  export type AchatOrderByWithRelationInput = {
    id?: SortOrder
    statut?: SortOrder
    panierId?: SortOrder
    fournisseurId?: SortOrder
    agentId?: SortOrder
    clientId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    panier?: PanierOrderByWithRelationInput
    fournisseur?: FournisseurOrderByWithRelationInput
    agent?: AgentOrderByWithRelationInput
    Client?: ClientOrderByWithRelationInput
    paiements?: PaiementOrderByRelationAggregateInput
  }

  export type AchatWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AchatWhereInput | AchatWhereInput[]
    OR?: AchatWhereInput[]
    NOT?: AchatWhereInput | AchatWhereInput[]
    statut?: EnumStatutAchatFilter<"Achat"> | $Enums.StatutAchat
    panierId?: IntFilter<"Achat"> | number
    fournisseurId?: IntFilter<"Achat"> | number
    agentId?: IntFilter<"Achat"> | number
    clientId?: IntNullableFilter<"Achat"> | number | null
    createdAt?: DateTimeFilter<"Achat"> | Date | string
    updatedAt?: DateTimeFilter<"Achat"> | Date | string
    panier?: XOR<PanierScalarRelationFilter, PanierWhereInput>
    fournisseur?: XOR<FournisseurScalarRelationFilter, FournisseurWhereInput>
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
    Client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
    paiements?: PaiementListRelationFilter
  }, "id">

  export type AchatOrderByWithAggregationInput = {
    id?: SortOrder
    statut?: SortOrder
    panierId?: SortOrder
    fournisseurId?: SortOrder
    agentId?: SortOrder
    clientId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AchatCountOrderByAggregateInput
    _avg?: AchatAvgOrderByAggregateInput
    _max?: AchatMaxOrderByAggregateInput
    _min?: AchatMinOrderByAggregateInput
    _sum?: AchatSumOrderByAggregateInput
  }

  export type AchatScalarWhereWithAggregatesInput = {
    AND?: AchatScalarWhereWithAggregatesInput | AchatScalarWhereWithAggregatesInput[]
    OR?: AchatScalarWhereWithAggregatesInput[]
    NOT?: AchatScalarWhereWithAggregatesInput | AchatScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Achat"> | number
    statut?: EnumStatutAchatWithAggregatesFilter<"Achat"> | $Enums.StatutAchat
    panierId?: IntWithAggregatesFilter<"Achat"> | number
    fournisseurId?: IntWithAggregatesFilter<"Achat"> | number
    agentId?: IntWithAggregatesFilter<"Achat"> | number
    clientId?: IntNullableWithAggregatesFilter<"Achat"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Achat"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Achat"> | Date | string
  }

  export type ReservationWhereInput = {
    AND?: ReservationWhereInput | ReservationWhereInput[]
    OR?: ReservationWhereInput[]
    NOT?: ReservationWhereInput | ReservationWhereInput[]
    id?: IntFilter<"Reservation"> | number
    dateLivraisonSouhaitee?: DateTimeFilter<"Reservation"> | Date | string
    adresseLivraison?: StringNullableFilter<"Reservation"> | string | null
    statut?: EnumStatutReservationFilter<"Reservation"> | $Enums.StatutReservation
    notes?: StringNullableFilter<"Reservation"> | string | null
    typeClient?: EnumTypeClientFilter<"Reservation"> | $Enums.TypeClient
    clientId?: IntNullableFilter<"Reservation"> | number | null
    panierId?: IntFilter<"Reservation"> | number
    nom?: StringNullableFilter<"Reservation"> | string | null
    tel?: StringNullableFilter<"Reservation"> | string | null
    adresseId?: IntNullableFilter<"Reservation"> | number | null
    contactId?: IntNullableFilter<"Reservation"> | number | null
    enregistrerParId?: IntNullableFilter<"Reservation"> | number | null
    fournisseurId?: IntNullableFilter<"Reservation"> | number | null
    createdAt?: DateTimeFilter<"Reservation"> | Date | string
    updatedAt?: DateTimeFilter<"Reservation"> | Date | string
    panier?: XOR<PanierScalarRelationFilter, PanierWhereInput>
    fournisseur?: XOR<FournisseurNullableScalarRelationFilter, FournisseurWhereInput> | null
    adresse?: XOR<AdresseNullableScalarRelationFilter, AdresseWhereInput> | null
    contact?: XOR<ContactNullableScalarRelationFilter, ContactWhereInput> | null
    Client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
  }

  export type ReservationOrderByWithRelationInput = {
    id?: SortOrder
    dateLivraisonSouhaitee?: SortOrder
    adresseLivraison?: SortOrderInput | SortOrder
    statut?: SortOrder
    notes?: SortOrderInput | SortOrder
    typeClient?: SortOrder
    clientId?: SortOrderInput | SortOrder
    panierId?: SortOrder
    nom?: SortOrderInput | SortOrder
    tel?: SortOrderInput | SortOrder
    adresseId?: SortOrderInput | SortOrder
    contactId?: SortOrderInput | SortOrder
    enregistrerParId?: SortOrderInput | SortOrder
    fournisseurId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    panier?: PanierOrderByWithRelationInput
    fournisseur?: FournisseurOrderByWithRelationInput
    adresse?: AdresseOrderByWithRelationInput
    contact?: ContactOrderByWithRelationInput
    Client?: ClientOrderByWithRelationInput
  }

  export type ReservationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ReservationWhereInput | ReservationWhereInput[]
    OR?: ReservationWhereInput[]
    NOT?: ReservationWhereInput | ReservationWhereInput[]
    dateLivraisonSouhaitee?: DateTimeFilter<"Reservation"> | Date | string
    adresseLivraison?: StringNullableFilter<"Reservation"> | string | null
    statut?: EnumStatutReservationFilter<"Reservation"> | $Enums.StatutReservation
    notes?: StringNullableFilter<"Reservation"> | string | null
    typeClient?: EnumTypeClientFilter<"Reservation"> | $Enums.TypeClient
    clientId?: IntNullableFilter<"Reservation"> | number | null
    panierId?: IntFilter<"Reservation"> | number
    nom?: StringNullableFilter<"Reservation"> | string | null
    tel?: StringNullableFilter<"Reservation"> | string | null
    adresseId?: IntNullableFilter<"Reservation"> | number | null
    contactId?: IntNullableFilter<"Reservation"> | number | null
    enregistrerParId?: IntNullableFilter<"Reservation"> | number | null
    fournisseurId?: IntNullableFilter<"Reservation"> | number | null
    createdAt?: DateTimeFilter<"Reservation"> | Date | string
    updatedAt?: DateTimeFilter<"Reservation"> | Date | string
    panier?: XOR<PanierScalarRelationFilter, PanierWhereInput>
    fournisseur?: XOR<FournisseurNullableScalarRelationFilter, FournisseurWhereInput> | null
    adresse?: XOR<AdresseNullableScalarRelationFilter, AdresseWhereInput> | null
    contact?: XOR<ContactNullableScalarRelationFilter, ContactWhereInput> | null
    Client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
  }, "id">

  export type ReservationOrderByWithAggregationInput = {
    id?: SortOrder
    dateLivraisonSouhaitee?: SortOrder
    adresseLivraison?: SortOrderInput | SortOrder
    statut?: SortOrder
    notes?: SortOrderInput | SortOrder
    typeClient?: SortOrder
    clientId?: SortOrderInput | SortOrder
    panierId?: SortOrder
    nom?: SortOrderInput | SortOrder
    tel?: SortOrderInput | SortOrder
    adresseId?: SortOrderInput | SortOrder
    contactId?: SortOrderInput | SortOrder
    enregistrerParId?: SortOrderInput | SortOrder
    fournisseurId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReservationCountOrderByAggregateInput
    _avg?: ReservationAvgOrderByAggregateInput
    _max?: ReservationMaxOrderByAggregateInput
    _min?: ReservationMinOrderByAggregateInput
    _sum?: ReservationSumOrderByAggregateInput
  }

  export type ReservationScalarWhereWithAggregatesInput = {
    AND?: ReservationScalarWhereWithAggregatesInput | ReservationScalarWhereWithAggregatesInput[]
    OR?: ReservationScalarWhereWithAggregatesInput[]
    NOT?: ReservationScalarWhereWithAggregatesInput | ReservationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Reservation"> | number
    dateLivraisonSouhaitee?: DateTimeWithAggregatesFilter<"Reservation"> | Date | string
    adresseLivraison?: StringNullableWithAggregatesFilter<"Reservation"> | string | null
    statut?: EnumStatutReservationWithAggregatesFilter<"Reservation"> | $Enums.StatutReservation
    notes?: StringNullableWithAggregatesFilter<"Reservation"> | string | null
    typeClient?: EnumTypeClientWithAggregatesFilter<"Reservation"> | $Enums.TypeClient
    clientId?: IntNullableWithAggregatesFilter<"Reservation"> | number | null
    panierId?: IntWithAggregatesFilter<"Reservation"> | number
    nom?: StringNullableWithAggregatesFilter<"Reservation"> | string | null
    tel?: StringNullableWithAggregatesFilter<"Reservation"> | string | null
    adresseId?: IntNullableWithAggregatesFilter<"Reservation"> | number | null
    contactId?: IntNullableWithAggregatesFilter<"Reservation"> | number | null
    enregistrerParId?: IntNullableWithAggregatesFilter<"Reservation"> | number | null
    fournisseurId?: IntNullableWithAggregatesFilter<"Reservation"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Reservation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Reservation"> | Date | string
  }

  export type CommandeWhereInput = {
    AND?: CommandeWhereInput | CommandeWhereInput[]
    OR?: CommandeWhereInput[]
    NOT?: CommandeWhereInput | CommandeWhereInput[]
    id?: IntFilter<"Commande"> | number
    panierId?: IntFilter<"Commande"> | number
    clientId?: IntNullableFilter<"Commande"> | number | null
    nom?: StringNullableFilter<"Commande"> | string | null
    tel?: StringNullableFilter<"Commande"> | string | null
    type_client?: EnumTypeClientFilter<"Commande"> | $Enums.TypeClient
    adresseId?: IntNullableFilter<"Commande"> | number | null
    contactId?: IntNullableFilter<"Commande"> | number | null
    fournisseurId?: IntNullableFilter<"Commande"> | number | null
    commandeId?: IntNullableFilter<"Commande"> | number | null
    notes?: StringNullableFilter<"Commande"> | string | null
    dateLivraisonEffective?: DateTimeNullableFilter<"Commande"> | Date | string | null
    adresseLivraison?: StringNullableFilter<"Commande"> | string | null
    enregistrerParId?: IntNullableFilter<"Commande"> | number | null
    statut?: EnumStatutCommandeFilter<"Commande"> | $Enums.StatutCommande
    createdAt?: DateTimeFilter<"Commande"> | Date | string
    updatedAt?: DateTimeFilter<"Commande"> | Date | string
    Paiement?: PaiementListRelationFilter
    panier?: XOR<PanierScalarRelationFilter, PanierWhereInput>
    fournisseur?: XOR<FournisseurNullableScalarRelationFilter, FournisseurWhereInput> | null
    adresse?: XOR<AdresseNullableScalarRelationFilter, AdresseWhereInput> | null
    contact?: XOR<ContactNullableScalarRelationFilter, ContactWhereInput> | null
    Client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
  }

  export type CommandeOrderByWithRelationInput = {
    id?: SortOrder
    panierId?: SortOrder
    clientId?: SortOrderInput | SortOrder
    nom?: SortOrderInput | SortOrder
    tel?: SortOrderInput | SortOrder
    type_client?: SortOrder
    adresseId?: SortOrderInput | SortOrder
    contactId?: SortOrderInput | SortOrder
    fournisseurId?: SortOrderInput | SortOrder
    commandeId?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    dateLivraisonEffective?: SortOrderInput | SortOrder
    adresseLivraison?: SortOrderInput | SortOrder
    enregistrerParId?: SortOrderInput | SortOrder
    statut?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Paiement?: PaiementOrderByRelationAggregateInput
    panier?: PanierOrderByWithRelationInput
    fournisseur?: FournisseurOrderByWithRelationInput
    adresse?: AdresseOrderByWithRelationInput
    contact?: ContactOrderByWithRelationInput
    Client?: ClientOrderByWithRelationInput
  }

  export type CommandeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CommandeWhereInput | CommandeWhereInput[]
    OR?: CommandeWhereInput[]
    NOT?: CommandeWhereInput | CommandeWhereInput[]
    panierId?: IntFilter<"Commande"> | number
    clientId?: IntNullableFilter<"Commande"> | number | null
    nom?: StringNullableFilter<"Commande"> | string | null
    tel?: StringNullableFilter<"Commande"> | string | null
    type_client?: EnumTypeClientFilter<"Commande"> | $Enums.TypeClient
    adresseId?: IntNullableFilter<"Commande"> | number | null
    contactId?: IntNullableFilter<"Commande"> | number | null
    fournisseurId?: IntNullableFilter<"Commande"> | number | null
    commandeId?: IntNullableFilter<"Commande"> | number | null
    notes?: StringNullableFilter<"Commande"> | string | null
    dateLivraisonEffective?: DateTimeNullableFilter<"Commande"> | Date | string | null
    adresseLivraison?: StringNullableFilter<"Commande"> | string | null
    enregistrerParId?: IntNullableFilter<"Commande"> | number | null
    statut?: EnumStatutCommandeFilter<"Commande"> | $Enums.StatutCommande
    createdAt?: DateTimeFilter<"Commande"> | Date | string
    updatedAt?: DateTimeFilter<"Commande"> | Date | string
    Paiement?: PaiementListRelationFilter
    panier?: XOR<PanierScalarRelationFilter, PanierWhereInput>
    fournisseur?: XOR<FournisseurNullableScalarRelationFilter, FournisseurWhereInput> | null
    adresse?: XOR<AdresseNullableScalarRelationFilter, AdresseWhereInput> | null
    contact?: XOR<ContactNullableScalarRelationFilter, ContactWhereInput> | null
    Client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
  }, "id">

  export type CommandeOrderByWithAggregationInput = {
    id?: SortOrder
    panierId?: SortOrder
    clientId?: SortOrderInput | SortOrder
    nom?: SortOrderInput | SortOrder
    tel?: SortOrderInput | SortOrder
    type_client?: SortOrder
    adresseId?: SortOrderInput | SortOrder
    contactId?: SortOrderInput | SortOrder
    fournisseurId?: SortOrderInput | SortOrder
    commandeId?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    dateLivraisonEffective?: SortOrderInput | SortOrder
    adresseLivraison?: SortOrderInput | SortOrder
    enregistrerParId?: SortOrderInput | SortOrder
    statut?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CommandeCountOrderByAggregateInput
    _avg?: CommandeAvgOrderByAggregateInput
    _max?: CommandeMaxOrderByAggregateInput
    _min?: CommandeMinOrderByAggregateInput
    _sum?: CommandeSumOrderByAggregateInput
  }

  export type CommandeScalarWhereWithAggregatesInput = {
    AND?: CommandeScalarWhereWithAggregatesInput | CommandeScalarWhereWithAggregatesInput[]
    OR?: CommandeScalarWhereWithAggregatesInput[]
    NOT?: CommandeScalarWhereWithAggregatesInput | CommandeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Commande"> | number
    panierId?: IntWithAggregatesFilter<"Commande"> | number
    clientId?: IntNullableWithAggregatesFilter<"Commande"> | number | null
    nom?: StringNullableWithAggregatesFilter<"Commande"> | string | null
    tel?: StringNullableWithAggregatesFilter<"Commande"> | string | null
    type_client?: EnumTypeClientWithAggregatesFilter<"Commande"> | $Enums.TypeClient
    adresseId?: IntNullableWithAggregatesFilter<"Commande"> | number | null
    contactId?: IntNullableWithAggregatesFilter<"Commande"> | number | null
    fournisseurId?: IntNullableWithAggregatesFilter<"Commande"> | number | null
    commandeId?: IntNullableWithAggregatesFilter<"Commande"> | number | null
    notes?: StringNullableWithAggregatesFilter<"Commande"> | string | null
    dateLivraisonEffective?: DateTimeNullableWithAggregatesFilter<"Commande"> | Date | string | null
    adresseLivraison?: StringNullableWithAggregatesFilter<"Commande"> | string | null
    enregistrerParId?: IntNullableWithAggregatesFilter<"Commande"> | number | null
    statut?: EnumStatutCommandeWithAggregatesFilter<"Commande"> | $Enums.StatutCommande
    createdAt?: DateTimeWithAggregatesFilter<"Commande"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Commande"> | Date | string
  }

  export type ClotureCaisseWhereInput = {
    AND?: ClotureCaisseWhereInput | ClotureCaisseWhereInput[]
    OR?: ClotureCaisseWhereInput[]
    NOT?: ClotureCaisseWhereInput | ClotureCaisseWhereInput[]
    id?: IntFilter<"ClotureCaisse"> | number
    dateCloture?: DateTimeFilter<"ClotureCaisse"> | Date | string
    agentId?: IntFilter<"ClotureCaisse"> | number
    entrepriseId?: IntNullableFilter<"ClotureCaisse"> | number | null
    updatedAt?: DateTimeFilter<"ClotureCaisse"> | Date | string
    notes?: StringNullableFilter<"ClotureCaisse"> | string | null
    createdAt?: DateTimeFilter<"ClotureCaisse"> | Date | string
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
    entreprise?: XOR<EntrepriseNullableScalarRelationFilter, EntrepriseWhereInput> | null
  }

  export type ClotureCaisseOrderByWithRelationInput = {
    id?: SortOrder
    dateCloture?: SortOrder
    agentId?: SortOrder
    entrepriseId?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    agent?: AgentOrderByWithRelationInput
    entreprise?: EntrepriseOrderByWithRelationInput
  }

  export type ClotureCaisseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    dateCloture?: Date | string
    AND?: ClotureCaisseWhereInput | ClotureCaisseWhereInput[]
    OR?: ClotureCaisseWhereInput[]
    NOT?: ClotureCaisseWhereInput | ClotureCaisseWhereInput[]
    agentId?: IntFilter<"ClotureCaisse"> | number
    entrepriseId?: IntNullableFilter<"ClotureCaisse"> | number | null
    updatedAt?: DateTimeFilter<"ClotureCaisse"> | Date | string
    notes?: StringNullableFilter<"ClotureCaisse"> | string | null
    createdAt?: DateTimeFilter<"ClotureCaisse"> | Date | string
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
    entreprise?: XOR<EntrepriseNullableScalarRelationFilter, EntrepriseWhereInput> | null
  }, "id" | "dateCloture">

  export type ClotureCaisseOrderByWithAggregationInput = {
    id?: SortOrder
    dateCloture?: SortOrder
    agentId?: SortOrder
    entrepriseId?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ClotureCaisseCountOrderByAggregateInput
    _avg?: ClotureCaisseAvgOrderByAggregateInput
    _max?: ClotureCaisseMaxOrderByAggregateInput
    _min?: ClotureCaisseMinOrderByAggregateInput
    _sum?: ClotureCaisseSumOrderByAggregateInput
  }

  export type ClotureCaisseScalarWhereWithAggregatesInput = {
    AND?: ClotureCaisseScalarWhereWithAggregatesInput | ClotureCaisseScalarWhereWithAggregatesInput[]
    OR?: ClotureCaisseScalarWhereWithAggregatesInput[]
    NOT?: ClotureCaisseScalarWhereWithAggregatesInput | ClotureCaisseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ClotureCaisse"> | number
    dateCloture?: DateTimeWithAggregatesFilter<"ClotureCaisse"> | Date | string
    agentId?: IntWithAggregatesFilter<"ClotureCaisse"> | number
    entrepriseId?: IntNullableWithAggregatesFilter<"ClotureCaisse"> | number | null
    updatedAt?: DateTimeWithAggregatesFilter<"ClotureCaisse"> | Date | string
    notes?: StringNullableWithAggregatesFilter<"ClotureCaisse"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ClotureCaisse"> | Date | string
  }

  export type MouvementCaisseWhereInput = {
    AND?: MouvementCaisseWhereInput | MouvementCaisseWhereInput[]
    OR?: MouvementCaisseWhereInput[]
    NOT?: MouvementCaisseWhereInput | MouvementCaisseWhereInput[]
    id?: IntFilter<"MouvementCaisse"> | number
    caisseId?: IntFilter<"MouvementCaisse"> | number
    referenceExterne?: StringNullableFilter<"MouvementCaisse"> | string | null
    type_mouvement?: EnumTypeMouvementCaisseFilter<"MouvementCaisse"> | $Enums.TypeMouvementCaisse
    categorie?: EnumCategorieMouvementFilter<"MouvementCaisse"> | $Enums.CategorieMouvement
    moyen_paiement?: EnumModePaimentFilter<"MouvementCaisse"> | $Enums.ModePaiment
    montant?: FloatFilter<"MouvementCaisse"> | number
    description?: StringNullableFilter<"MouvementCaisse"> | string | null
    agentId?: IntFilter<"MouvementCaisse"> | number
    createdAt?: DateTimeFilter<"MouvementCaisse"> | Date | string
    updatedAt?: DateTimeFilter<"MouvementCaisse"> | Date | string
    caisse?: XOR<CaisseScalarRelationFilter, CaisseWhereInput>
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
  }

  export type MouvementCaisseOrderByWithRelationInput = {
    id?: SortOrder
    caisseId?: SortOrder
    referenceExterne?: SortOrderInput | SortOrder
    type_mouvement?: SortOrder
    categorie?: SortOrder
    moyen_paiement?: SortOrder
    montant?: SortOrder
    description?: SortOrderInput | SortOrder
    agentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    caisse?: CaisseOrderByWithRelationInput
    agent?: AgentOrderByWithRelationInput
  }

  export type MouvementCaisseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    referenceExterne?: string
    AND?: MouvementCaisseWhereInput | MouvementCaisseWhereInput[]
    OR?: MouvementCaisseWhereInput[]
    NOT?: MouvementCaisseWhereInput | MouvementCaisseWhereInput[]
    caisseId?: IntFilter<"MouvementCaisse"> | number
    type_mouvement?: EnumTypeMouvementCaisseFilter<"MouvementCaisse"> | $Enums.TypeMouvementCaisse
    categorie?: EnumCategorieMouvementFilter<"MouvementCaisse"> | $Enums.CategorieMouvement
    moyen_paiement?: EnumModePaimentFilter<"MouvementCaisse"> | $Enums.ModePaiment
    montant?: FloatFilter<"MouvementCaisse"> | number
    description?: StringNullableFilter<"MouvementCaisse"> | string | null
    agentId?: IntFilter<"MouvementCaisse"> | number
    createdAt?: DateTimeFilter<"MouvementCaisse"> | Date | string
    updatedAt?: DateTimeFilter<"MouvementCaisse"> | Date | string
    caisse?: XOR<CaisseScalarRelationFilter, CaisseWhereInput>
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
  }, "id" | "referenceExterne">

  export type MouvementCaisseOrderByWithAggregationInput = {
    id?: SortOrder
    caisseId?: SortOrder
    referenceExterne?: SortOrderInput | SortOrder
    type_mouvement?: SortOrder
    categorie?: SortOrder
    moyen_paiement?: SortOrder
    montant?: SortOrder
    description?: SortOrderInput | SortOrder
    agentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MouvementCaisseCountOrderByAggregateInput
    _avg?: MouvementCaisseAvgOrderByAggregateInput
    _max?: MouvementCaisseMaxOrderByAggregateInput
    _min?: MouvementCaisseMinOrderByAggregateInput
    _sum?: MouvementCaisseSumOrderByAggregateInput
  }

  export type MouvementCaisseScalarWhereWithAggregatesInput = {
    AND?: MouvementCaisseScalarWhereWithAggregatesInput | MouvementCaisseScalarWhereWithAggregatesInput[]
    OR?: MouvementCaisseScalarWhereWithAggregatesInput[]
    NOT?: MouvementCaisseScalarWhereWithAggregatesInput | MouvementCaisseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MouvementCaisse"> | number
    caisseId?: IntWithAggregatesFilter<"MouvementCaisse"> | number
    referenceExterne?: StringNullableWithAggregatesFilter<"MouvementCaisse"> | string | null
    type_mouvement?: EnumTypeMouvementCaisseWithAggregatesFilter<"MouvementCaisse"> | $Enums.TypeMouvementCaisse
    categorie?: EnumCategorieMouvementWithAggregatesFilter<"MouvementCaisse"> | $Enums.CategorieMouvement
    moyen_paiement?: EnumModePaimentWithAggregatesFilter<"MouvementCaisse"> | $Enums.ModePaiment
    montant?: FloatWithAggregatesFilter<"MouvementCaisse"> | number
    description?: StringNullableWithAggregatesFilter<"MouvementCaisse"> | string | null
    agentId?: IntWithAggregatesFilter<"MouvementCaisse"> | number
    createdAt?: DateTimeWithAggregatesFilter<"MouvementCaisse"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MouvementCaisse"> | Date | string
  }

  export type TeneurCreateInput = {
    valeur: number
    createdAt?: Date | string
    updatedAt?: Date | string
    agents: AgentCreateNestedOneWithoutTeneursInput
    produits?: ProduitCreateNestedManyWithoutTeneurInput
  }

  export type TeneurUncheckedCreateInput = {
    id?: number
    valeur: number
    agentId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    produits?: ProduitUncheckedCreateNestedManyWithoutTeneurInput
  }

  export type TeneurUpdateInput = {
    valeur?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agents?: AgentUpdateOneRequiredWithoutTeneursNestedInput
    produits?: ProduitUpdateManyWithoutTeneurNestedInput
  }

  export type TeneurUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    valeur?: FloatFieldUpdateOperationsInput | number
    agentId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    produits?: ProduitUncheckedUpdateManyWithoutTeneurNestedInput
  }

  export type TeneurCreateManyInput = {
    id?: number
    valeur: number
    agentId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeneurUpdateManyMutationInput = {
    valeur?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeneurUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    valeur?: FloatFieldUpdateOperationsInput | number
    agentId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviseCreateInput = {
    nom: string
    code: string
    symbole: string
    tauxDEchange: number
    createdAt?: Date | string
    updatedAt?: Date | string
    agent: AgentCreateNestedOneWithoutDevisesInput
    produits?: ProduitCreateNestedManyWithoutDeviseInput
    paiements?: PaiementCreateNestedManyWithoutDeviseInput
    caisses?: CaisseCreateNestedManyWithoutDeviseInput
    DetailPanier?: DetailPanierCreateNestedManyWithoutDeviseInput
  }

  export type DeviseUncheckedCreateInput = {
    id?: number
    nom: string
    code: string
    symbole: string
    tauxDEchange: number
    agentId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    produits?: ProduitUncheckedCreateNestedManyWithoutDeviseInput
    paiements?: PaiementUncheckedCreateNestedManyWithoutDeviseInput
    caisses?: CaisseUncheckedCreateNestedManyWithoutDeviseInput
    DetailPanier?: DetailPanierUncheckedCreateNestedManyWithoutDeviseInput
  }

  export type DeviseUpdateInput = {
    nom?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    symbole?: StringFieldUpdateOperationsInput | string
    tauxDEchange?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUpdateOneRequiredWithoutDevisesNestedInput
    produits?: ProduitUpdateManyWithoutDeviseNestedInput
    paiements?: PaiementUpdateManyWithoutDeviseNestedInput
    caisses?: CaisseUpdateManyWithoutDeviseNestedInput
    DetailPanier?: DetailPanierUpdateManyWithoutDeviseNestedInput
  }

  export type DeviseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    symbole?: StringFieldUpdateOperationsInput | string
    tauxDEchange?: IntFieldUpdateOperationsInput | number
    agentId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    produits?: ProduitUncheckedUpdateManyWithoutDeviseNestedInput
    paiements?: PaiementUncheckedUpdateManyWithoutDeviseNestedInput
    caisses?: CaisseUncheckedUpdateManyWithoutDeviseNestedInput
    DetailPanier?: DetailPanierUncheckedUpdateManyWithoutDeviseNestedInput
  }

  export type DeviseCreateManyInput = {
    id?: number
    nom: string
    code: string
    symbole: string
    tauxDEchange: number
    agentId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeviseUpdateManyMutationInput = {
    nom?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    symbole?: StringFieldUpdateOperationsInput | string
    tauxDEchange?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    symbole?: StringFieldUpdateOperationsInput | string
    tauxDEchange?: IntFieldUpdateOperationsInput | number
    agentId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EntrepriseCreateInput = {
    nom: string
    email: string
    encronyme: string
    codePostale: string
    site?: string | null
    description?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clotureCaisses?: ClotureCaisseCreateNestedManyWithoutEntrepriseInput
    Adresse?: AdresseCreateNestedManyWithoutEntrepriseInput
    Contact?: ContactCreateNestedManyWithoutEntrepriseInput
  }

  export type EntrepriseUncheckedCreateInput = {
    id?: number
    nom: string
    email: string
    encronyme: string
    codePostale: string
    site?: string | null
    description?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clotureCaisses?: ClotureCaisseUncheckedCreateNestedManyWithoutEntrepriseInput
    Adresse?: AdresseUncheckedCreateNestedManyWithoutEntrepriseInput
    Contact?: ContactUncheckedCreateNestedManyWithoutEntrepriseInput
  }

  export type EntrepriseUpdateInput = {
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    encronyme?: StringFieldUpdateOperationsInput | string
    codePostale?: StringFieldUpdateOperationsInput | string
    site?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clotureCaisses?: ClotureCaisseUpdateManyWithoutEntrepriseNestedInput
    Adresse?: AdresseUpdateManyWithoutEntrepriseNestedInput
    Contact?: ContactUpdateManyWithoutEntrepriseNestedInput
  }

  export type EntrepriseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    encronyme?: StringFieldUpdateOperationsInput | string
    codePostale?: StringFieldUpdateOperationsInput | string
    site?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clotureCaisses?: ClotureCaisseUncheckedUpdateManyWithoutEntrepriseNestedInput
    Adresse?: AdresseUncheckedUpdateManyWithoutEntrepriseNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutEntrepriseNestedInput
  }

  export type EntrepriseCreateManyInput = {
    id?: number
    nom: string
    email: string
    encronyme: string
    codePostale: string
    site?: string | null
    description?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EntrepriseUpdateManyMutationInput = {
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    encronyme?: StringFieldUpdateOperationsInput | string
    codePostale?: StringFieldUpdateOperationsInput | string
    site?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EntrepriseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    encronyme?: StringFieldUpdateOperationsInput | string
    codePostale?: StringFieldUpdateOperationsInput | string
    site?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentCreateInput = {
    email: string
    nom: string
    postnom?: string | null
    nom_complet?: string | null
    sexe?: $Enums.Sexe | null
    role?: $Enums.Role
    poste?: $Enums.Poste | null
    picture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    adresses?: AdresseCreateNestedManyWithoutAgentInput
    contacts?: ContactCreateNestedManyWithoutAgentInput
    produits?: ProduitCreateNestedManyWithoutAgentInput
    ventes?: VenteCreateNestedManyWithoutAgentInput
    achats?: AchatCreateNestedManyWithoutAgentInput
    teneurs?: TeneurCreateNestedManyWithoutAgentsInput
    devises?: DeviseCreateNestedManyWithoutAgentInput
    paniers?: PanierCreateNestedManyWithoutAgentInput
    caisses?: CaisseCreateNestedManyWithoutAgentInput
    mouvementCaisses?: MouvementCaisseCreateNestedManyWithoutAgentInput
    clotureCaisses?: ClotureCaisseCreateNestedManyWithoutAgentInput
    Fournisseur?: FournisseurCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateInput = {
    id?: number
    email: string
    nom: string
    postnom?: string | null
    nom_complet?: string | null
    sexe?: $Enums.Sexe | null
    role?: $Enums.Role
    poste?: $Enums.Poste | null
    picture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    adresses?: AdresseUncheckedCreateNestedManyWithoutAgentInput
    contacts?: ContactUncheckedCreateNestedManyWithoutAgentInput
    produits?: ProduitUncheckedCreateNestedManyWithoutAgentInput
    ventes?: VenteUncheckedCreateNestedManyWithoutAgentInput
    achats?: AchatUncheckedCreateNestedManyWithoutAgentInput
    teneurs?: TeneurUncheckedCreateNestedManyWithoutAgentsInput
    devises?: DeviseUncheckedCreateNestedManyWithoutAgentInput
    paniers?: PanierUncheckedCreateNestedManyWithoutAgentInput
    caisses?: CaisseUncheckedCreateNestedManyWithoutAgentInput
    mouvementCaisses?: MouvementCaisseUncheckedCreateNestedManyWithoutAgentInput
    clotureCaisses?: ClotureCaisseUncheckedCreateNestedManyWithoutAgentInput
    Fournisseur?: FournisseurUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    postnom?: NullableStringFieldUpdateOperationsInput | string | null
    nom_complet?: NullableStringFieldUpdateOperationsInput | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    poste?: NullableEnumPosteFieldUpdateOperationsInput | $Enums.Poste | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adresses?: AdresseUpdateManyWithoutAgentNestedInput
    contacts?: ContactUpdateManyWithoutAgentNestedInput
    produits?: ProduitUpdateManyWithoutAgentNestedInput
    ventes?: VenteUpdateManyWithoutAgentNestedInput
    achats?: AchatUpdateManyWithoutAgentNestedInput
    teneurs?: TeneurUpdateManyWithoutAgentsNestedInput
    devises?: DeviseUpdateManyWithoutAgentNestedInput
    paniers?: PanierUpdateManyWithoutAgentNestedInput
    caisses?: CaisseUpdateManyWithoutAgentNestedInput
    mouvementCaisses?: MouvementCaisseUpdateManyWithoutAgentNestedInput
    clotureCaisses?: ClotureCaisseUpdateManyWithoutAgentNestedInput
    Fournisseur?: FournisseurUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    postnom?: NullableStringFieldUpdateOperationsInput | string | null
    nom_complet?: NullableStringFieldUpdateOperationsInput | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    poste?: NullableEnumPosteFieldUpdateOperationsInput | $Enums.Poste | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adresses?: AdresseUncheckedUpdateManyWithoutAgentNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutAgentNestedInput
    produits?: ProduitUncheckedUpdateManyWithoutAgentNestedInput
    ventes?: VenteUncheckedUpdateManyWithoutAgentNestedInput
    achats?: AchatUncheckedUpdateManyWithoutAgentNestedInput
    teneurs?: TeneurUncheckedUpdateManyWithoutAgentsNestedInput
    devises?: DeviseUncheckedUpdateManyWithoutAgentNestedInput
    paniers?: PanierUncheckedUpdateManyWithoutAgentNestedInput
    caisses?: CaisseUncheckedUpdateManyWithoutAgentNestedInput
    mouvementCaisses?: MouvementCaisseUncheckedUpdateManyWithoutAgentNestedInput
    clotureCaisses?: ClotureCaisseUncheckedUpdateManyWithoutAgentNestedInput
    Fournisseur?: FournisseurUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type AgentCreateManyInput = {
    id?: number
    email: string
    nom: string
    postnom?: string | null
    nom_complet?: string | null
    sexe?: $Enums.Sexe | null
    role?: $Enums.Role
    poste?: $Enums.Poste | null
    picture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    postnom?: NullableStringFieldUpdateOperationsInput | string | null
    nom_complet?: NullableStringFieldUpdateOperationsInput | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    poste?: NullableEnumPosteFieldUpdateOperationsInput | $Enums.Poste | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    postnom?: NullableStringFieldUpdateOperationsInput | string | null
    nom_complet?: NullableStringFieldUpdateOperationsInput | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    poste?: NullableEnumPosteFieldUpdateOperationsInput | $Enums.Poste | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientCreateInput = {
    email: string
    nom: string
    postnom?: string | null
    nom_complet?: string | null
    sexe?: $Enums.Sexe | null
    picture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    adresses?: AdresseCreateNestedManyWithoutClientInput
    contacts?: ContactCreateNestedManyWithoutClientInput
    ventes?: VenteCreateNestedManyWithoutClientInput
    achats?: AchatCreateNestedManyWithoutClientInput
    paniers?: PanierCreateNestedManyWithoutClientInput
    reservations?: ReservationCreateNestedManyWithoutClientInput
    commandes?: CommandeCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateInput = {
    id?: number
    email: string
    nom: string
    postnom?: string | null
    nom_complet?: string | null
    sexe?: $Enums.Sexe | null
    picture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    adresses?: AdresseUncheckedCreateNestedManyWithoutClientInput
    contacts?: ContactUncheckedCreateNestedManyWithoutClientInput
    ventes?: VenteUncheckedCreateNestedManyWithoutClientInput
    achats?: AchatUncheckedCreateNestedManyWithoutClientInput
    paniers?: PanierUncheckedCreateNestedManyWithoutClientInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutClientInput
    commandes?: CommandeUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    postnom?: NullableStringFieldUpdateOperationsInput | string | null
    nom_complet?: NullableStringFieldUpdateOperationsInput | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adresses?: AdresseUpdateManyWithoutClientNestedInput
    contacts?: ContactUpdateManyWithoutClientNestedInput
    ventes?: VenteUpdateManyWithoutClientNestedInput
    achats?: AchatUpdateManyWithoutClientNestedInput
    paniers?: PanierUpdateManyWithoutClientNestedInput
    reservations?: ReservationUpdateManyWithoutClientNestedInput
    commandes?: CommandeUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    postnom?: NullableStringFieldUpdateOperationsInput | string | null
    nom_complet?: NullableStringFieldUpdateOperationsInput | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adresses?: AdresseUncheckedUpdateManyWithoutClientNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutClientNestedInput
    ventes?: VenteUncheckedUpdateManyWithoutClientNestedInput
    achats?: AchatUncheckedUpdateManyWithoutClientNestedInput
    paniers?: PanierUncheckedUpdateManyWithoutClientNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutClientNestedInput
    commandes?: CommandeUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientCreateManyInput = {
    id?: number
    email: string
    nom: string
    postnom?: string | null
    nom_complet?: string | null
    sexe?: $Enums.Sexe | null
    picture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    postnom?: NullableStringFieldUpdateOperationsInput | string | null
    nom_complet?: NullableStringFieldUpdateOperationsInput | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    postnom?: NullableStringFieldUpdateOperationsInput | string | null
    nom_complet?: NullableStringFieldUpdateOperationsInput | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdresseCreateInput = {
    ville?: string | null
    adresse: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    agent?: AgentCreateNestedOneWithoutAdressesInput
    entreprise?: EntrepriseCreateNestedOneWithoutAdresseInput
    fournisseur?: FournisseurCreateNestedOneWithoutAdressesInput
    client?: ClientCreateNestedOneWithoutAdressesInput
    reservations?: ReservationCreateNestedManyWithoutAdresseInput
    commandes?: CommandeCreateNestedManyWithoutAdresseInput
  }

  export type AdresseUncheckedCreateInput = {
    id?: number
    ville?: string | null
    adresse: string
    isActive?: boolean
    agentId?: number | null
    fournisseurId?: number | null
    clientId?: number | null
    entrepriseId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reservations?: ReservationUncheckedCreateNestedManyWithoutAdresseInput
    commandes?: CommandeUncheckedCreateNestedManyWithoutAdresseInput
  }

  export type AdresseUpdateInput = {
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUpdateOneWithoutAdressesNestedInput
    entreprise?: EntrepriseUpdateOneWithoutAdresseNestedInput
    fournisseur?: FournisseurUpdateOneWithoutAdressesNestedInput
    client?: ClientUpdateOneWithoutAdressesNestedInput
    reservations?: ReservationUpdateManyWithoutAdresseNestedInput
    commandes?: CommandeUpdateManyWithoutAdresseNestedInput
  }

  export type AdresseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    agentId?: NullableIntFieldUpdateOperationsInput | number | null
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    entrepriseId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reservations?: ReservationUncheckedUpdateManyWithoutAdresseNestedInput
    commandes?: CommandeUncheckedUpdateManyWithoutAdresseNestedInput
  }

  export type AdresseCreateManyInput = {
    id?: number
    ville?: string | null
    adresse: string
    isActive?: boolean
    agentId?: number | null
    fournisseurId?: number | null
    clientId?: number | null
    entrepriseId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdresseUpdateManyMutationInput = {
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdresseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    agentId?: NullableIntFieldUpdateOperationsInput | number | null
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    entrepriseId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactCreateInput = {
    tel: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    entreprise?: EntrepriseCreateNestedOneWithoutContactInput
    client?: ClientCreateNestedOneWithoutContactsInput
    agent?: AgentCreateNestedOneWithoutContactsInput
    fournisseur?: FournisseurCreateNestedOneWithoutContactsInput
    reservations?: ReservationCreateNestedManyWithoutContactInput
    commandes?: CommandeCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateInput = {
    id?: number
    tel: string
    isActive?: boolean
    agentId?: number | null
    fournisseurId?: number | null
    clientId?: number | null
    entrepriseId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reservations?: ReservationUncheckedCreateNestedManyWithoutContactInput
    commandes?: CommandeUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactUpdateInput = {
    tel?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entreprise?: EntrepriseUpdateOneWithoutContactNestedInput
    client?: ClientUpdateOneWithoutContactsNestedInput
    agent?: AgentUpdateOneWithoutContactsNestedInput
    fournisseur?: FournisseurUpdateOneWithoutContactsNestedInput
    reservations?: ReservationUpdateManyWithoutContactNestedInput
    commandes?: CommandeUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tel?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    agentId?: NullableIntFieldUpdateOperationsInput | number | null
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    entrepriseId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reservations?: ReservationUncheckedUpdateManyWithoutContactNestedInput
    commandes?: CommandeUncheckedUpdateManyWithoutContactNestedInput
  }

  export type ContactCreateManyInput = {
    id?: number
    tel: string
    isActive?: boolean
    agentId?: number | null
    fournisseurId?: number | null
    clientId?: number | null
    entrepriseId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactUpdateManyMutationInput = {
    tel?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tel?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    agentId?: NullableIntFieldUpdateOperationsInput | number | null
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    entrepriseId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FournisseurCreateInput = {
    nom: string
    email: string
    codePostale?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agent: AgentCreateNestedOneWithoutFournisseurInput
    ventes?: VenteCreateNestedManyWithoutFournisseurInput
    achats?: AchatCreateNestedManyWithoutFournisseurInput
    adresses?: AdresseCreateNestedManyWithoutFournisseurInput
    contacts?: ContactCreateNestedManyWithoutFournisseurInput
    reservations?: ReservationCreateNestedManyWithoutFournisseurInput
    commandes?: CommandeCreateNestedManyWithoutFournisseurInput
  }

  export type FournisseurUncheckedCreateInput = {
    id?: number
    nom: string
    email: string
    codePostale?: string | null
    agentId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    ventes?: VenteUncheckedCreateNestedManyWithoutFournisseurInput
    achats?: AchatUncheckedCreateNestedManyWithoutFournisseurInput
    adresses?: AdresseUncheckedCreateNestedManyWithoutFournisseurInput
    contacts?: ContactUncheckedCreateNestedManyWithoutFournisseurInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutFournisseurInput
    commandes?: CommandeUncheckedCreateNestedManyWithoutFournisseurInput
  }

  export type FournisseurUpdateInput = {
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    codePostale?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUpdateOneRequiredWithoutFournisseurNestedInput
    ventes?: VenteUpdateManyWithoutFournisseurNestedInput
    achats?: AchatUpdateManyWithoutFournisseurNestedInput
    adresses?: AdresseUpdateManyWithoutFournisseurNestedInput
    contacts?: ContactUpdateManyWithoutFournisseurNestedInput
    reservations?: ReservationUpdateManyWithoutFournisseurNestedInput
    commandes?: CommandeUpdateManyWithoutFournisseurNestedInput
  }

  export type FournisseurUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    codePostale?: NullableStringFieldUpdateOperationsInput | string | null
    agentId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ventes?: VenteUncheckedUpdateManyWithoutFournisseurNestedInput
    achats?: AchatUncheckedUpdateManyWithoutFournisseurNestedInput
    adresses?: AdresseUncheckedUpdateManyWithoutFournisseurNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutFournisseurNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutFournisseurNestedInput
    commandes?: CommandeUncheckedUpdateManyWithoutFournisseurNestedInput
  }

  export type FournisseurCreateManyInput = {
    id?: number
    nom: string
    email: string
    codePostale?: string | null
    agentId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FournisseurUpdateManyMutationInput = {
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    codePostale?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FournisseurUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    codePostale?: NullableStringFieldUpdateOperationsInput | string | null
    agentId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProduitCreateInput = {
    designation: string
    prixUnitaire: number
    qtteDisponible?: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    detailsPaniers?: DetailPanierCreateNestedManyWithoutProduitInput
    agent: AgentCreateNestedOneWithoutProduitsInput
    devise: DeviseCreateNestedOneWithoutProduitsInput
    teneur: TeneurCreateNestedOneWithoutProduitsInput
  }

  export type ProduitUncheckedCreateInput = {
    id?: number
    designation: string
    prixUnitaire: number
    qtteDisponible?: number
    description?: string | null
    deviseId: number
    teneurId: number
    agentId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    detailsPaniers?: DetailPanierUncheckedCreateNestedManyWithoutProduitInput
  }

  export type ProduitUpdateInput = {
    designation?: StringFieldUpdateOperationsInput | string
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    qtteDisponible?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    detailsPaniers?: DetailPanierUpdateManyWithoutProduitNestedInput
    agent?: AgentUpdateOneRequiredWithoutProduitsNestedInput
    devise?: DeviseUpdateOneRequiredWithoutProduitsNestedInput
    teneur?: TeneurUpdateOneRequiredWithoutProduitsNestedInput
  }

  export type ProduitUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    designation?: StringFieldUpdateOperationsInput | string
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    qtteDisponible?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    deviseId?: IntFieldUpdateOperationsInput | number
    teneurId?: IntFieldUpdateOperationsInput | number
    agentId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    detailsPaniers?: DetailPanierUncheckedUpdateManyWithoutProduitNestedInput
  }

  export type ProduitCreateManyInput = {
    id?: number
    designation: string
    prixUnitaire: number
    qtteDisponible?: number
    description?: string | null
    deviseId: number
    teneurId: number
    agentId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProduitUpdateManyMutationInput = {
    designation?: StringFieldUpdateOperationsInput | string
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    qtteDisponible?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProduitUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    designation?: StringFieldUpdateOperationsInput | string
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    qtteDisponible?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    deviseId?: IntFieldUpdateOperationsInput | number
    teneurId?: IntFieldUpdateOperationsInput | number
    agentId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaiementCreateInput = {
    totalHT?: number | null
    totalTTC?: number | null
    modePaiement: $Enums.ModePaiment
    createdAt?: Date | string
    updatedAt?: Date | string
    vente?: VenteCreateNestedOneWithoutPaiementsInput
    achat?: AchatCreateNestedOneWithoutPaiementsInput
    commande?: CommandeCreateNestedOneWithoutPaiementInput
    caisse: CaisseCreateNestedOneWithoutPaiementsInput
    devise: DeviseCreateNestedOneWithoutPaiementsInput
  }

  export type PaiementUncheckedCreateInput = {
    id?: number
    totalHT?: number | null
    totalTTC?: number | null
    modePaiement: $Enums.ModePaiment
    deviseId: number
    caisseId: number
    venteId?: number | null
    achatId?: number | null
    commandeId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaiementUpdateInput = {
    totalHT?: NullableFloatFieldUpdateOperationsInput | number | null
    totalTTC?: NullableFloatFieldUpdateOperationsInput | number | null
    modePaiement?: EnumModePaimentFieldUpdateOperationsInput | $Enums.ModePaiment
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vente?: VenteUpdateOneWithoutPaiementsNestedInput
    achat?: AchatUpdateOneWithoutPaiementsNestedInput
    commande?: CommandeUpdateOneWithoutPaiementNestedInput
    caisse?: CaisseUpdateOneRequiredWithoutPaiementsNestedInput
    devise?: DeviseUpdateOneRequiredWithoutPaiementsNestedInput
  }

  export type PaiementUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalHT?: NullableFloatFieldUpdateOperationsInput | number | null
    totalTTC?: NullableFloatFieldUpdateOperationsInput | number | null
    modePaiement?: EnumModePaimentFieldUpdateOperationsInput | $Enums.ModePaiment
    deviseId?: IntFieldUpdateOperationsInput | number
    caisseId?: IntFieldUpdateOperationsInput | number
    venteId?: NullableIntFieldUpdateOperationsInput | number | null
    achatId?: NullableIntFieldUpdateOperationsInput | number | null
    commandeId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaiementCreateManyInput = {
    id?: number
    totalHT?: number | null
    totalTTC?: number | null
    modePaiement: $Enums.ModePaiment
    deviseId: number
    caisseId: number
    venteId?: number | null
    achatId?: number | null
    commandeId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaiementUpdateManyMutationInput = {
    totalHT?: NullableFloatFieldUpdateOperationsInput | number | null
    totalTTC?: NullableFloatFieldUpdateOperationsInput | number | null
    modePaiement?: EnumModePaimentFieldUpdateOperationsInput | $Enums.ModePaiment
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaiementUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalHT?: NullableFloatFieldUpdateOperationsInput | number | null
    totalTTC?: NullableFloatFieldUpdateOperationsInput | number | null
    modePaiement?: EnumModePaimentFieldUpdateOperationsInput | $Enums.ModePaiment
    deviseId?: IntFieldUpdateOperationsInput | number
    caisseId?: IntFieldUpdateOperationsInput | number
    venteId?: NullableIntFieldUpdateOperationsInput | number | null
    achatId?: NullableIntFieldUpdateOperationsInput | number | null
    commandeId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CaisseCreateInput = {
    nom: string
    description?: string | null
    soldeActuel?: number | null
    statut?: $Enums.StatutCaisse
    createdAt?: Date | string
    updatedAt?: Date | string
    devise: DeviseCreateNestedOneWithoutCaissesInput
    agent: AgentCreateNestedOneWithoutCaissesInput
    mouvementCaisses?: MouvementCaisseCreateNestedManyWithoutCaisseInput
    paiements?: PaiementCreateNestedManyWithoutCaisseInput
  }

  export type CaisseUncheckedCreateInput = {
    id?: number
    nom: string
    description?: string | null
    soldeActuel?: number | null
    deviseId: number
    agentId: number
    statut?: $Enums.StatutCaisse
    createdAt?: Date | string
    updatedAt?: Date | string
    mouvementCaisses?: MouvementCaisseUncheckedCreateNestedManyWithoutCaisseInput
    paiements?: PaiementUncheckedCreateNestedManyWithoutCaisseInput
  }

  export type CaisseUpdateInput = {
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    soldeActuel?: NullableFloatFieldUpdateOperationsInput | number | null
    statut?: EnumStatutCaisseFieldUpdateOperationsInput | $Enums.StatutCaisse
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    devise?: DeviseUpdateOneRequiredWithoutCaissesNestedInput
    agent?: AgentUpdateOneRequiredWithoutCaissesNestedInput
    mouvementCaisses?: MouvementCaisseUpdateManyWithoutCaisseNestedInput
    paiements?: PaiementUpdateManyWithoutCaisseNestedInput
  }

  export type CaisseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    soldeActuel?: NullableFloatFieldUpdateOperationsInput | number | null
    deviseId?: IntFieldUpdateOperationsInput | number
    agentId?: IntFieldUpdateOperationsInput | number
    statut?: EnumStatutCaisseFieldUpdateOperationsInput | $Enums.StatutCaisse
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mouvementCaisses?: MouvementCaisseUncheckedUpdateManyWithoutCaisseNestedInput
    paiements?: PaiementUncheckedUpdateManyWithoutCaisseNestedInput
  }

  export type CaisseCreateManyInput = {
    id?: number
    nom: string
    description?: string | null
    soldeActuel?: number | null
    deviseId: number
    agentId: number
    statut?: $Enums.StatutCaisse
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CaisseUpdateManyMutationInput = {
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    soldeActuel?: NullableFloatFieldUpdateOperationsInput | number | null
    statut?: EnumStatutCaisseFieldUpdateOperationsInput | $Enums.StatutCaisse
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CaisseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    soldeActuel?: NullableFloatFieldUpdateOperationsInput | number | null
    deviseId?: IntFieldUpdateOperationsInput | number
    agentId?: IntFieldUpdateOperationsInput | number
    statut?: EnumStatutCaisseFieldUpdateOperationsInput | $Enums.StatutCaisse
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VenteCreateInput = {
    statut?: $Enums.StatutVente
    typeAcheteur: $Enums.TypeClient
    enregistrerPar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    panier: PanierCreateNestedOneWithoutVentesInput
    agent?: AgentCreateNestedOneWithoutVentesInput
    fournisseur?: FournisseurCreateNestedOneWithoutVentesInput
    client?: ClientCreateNestedOneWithoutVentesInput
    paiements?: PaiementCreateNestedManyWithoutVenteInput
  }

  export type VenteUncheckedCreateInput = {
    id?: number
    statut?: $Enums.StatutVente
    typeAcheteur: $Enums.TypeClient
    clientId?: number | null
    agentId?: number | null
    fournisseurId?: number | null
    panierId: number
    enregistrerPar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    paiements?: PaiementUncheckedCreateNestedManyWithoutVenteInput
  }

  export type VenteUpdateInput = {
    statut?: EnumStatutVenteFieldUpdateOperationsInput | $Enums.StatutVente
    typeAcheteur?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    enregistrerPar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    panier?: PanierUpdateOneRequiredWithoutVentesNestedInput
    agent?: AgentUpdateOneWithoutVentesNestedInput
    fournisseur?: FournisseurUpdateOneWithoutVentesNestedInput
    client?: ClientUpdateOneWithoutVentesNestedInput
    paiements?: PaiementUpdateManyWithoutVenteNestedInput
  }

  export type VenteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    statut?: EnumStatutVenteFieldUpdateOperationsInput | $Enums.StatutVente
    typeAcheteur?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    agentId?: NullableIntFieldUpdateOperationsInput | number | null
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    panierId?: IntFieldUpdateOperationsInput | number
    enregistrerPar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paiements?: PaiementUncheckedUpdateManyWithoutVenteNestedInput
  }

  export type VenteCreateManyInput = {
    id?: number
    statut?: $Enums.StatutVente
    typeAcheteur: $Enums.TypeClient
    clientId?: number | null
    agentId?: number | null
    fournisseurId?: number | null
    panierId: number
    enregistrerPar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VenteUpdateManyMutationInput = {
    statut?: EnumStatutVenteFieldUpdateOperationsInput | $Enums.StatutVente
    typeAcheteur?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    enregistrerPar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VenteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    statut?: EnumStatutVenteFieldUpdateOperationsInput | $Enums.StatutVente
    typeAcheteur?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    agentId?: NullableIntFieldUpdateOperationsInput | number | null
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    panierId?: IntFieldUpdateOperationsInput | number
    enregistrerPar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PanierCreateInput = {
    statut?: $Enums.statutPanier
    createdAt?: Date | string
    updatedAt?: Date | string
    agent?: AgentCreateNestedOneWithoutPaniersInput
    client?: ClientCreateNestedOneWithoutPaniersInput
    detailPaniers?: DetailPanierCreateNestedManyWithoutPanierInput
    achats?: AchatCreateNestedManyWithoutPanierInput
    ventes?: VenteCreateNestedManyWithoutPanierInput
    reservations?: ReservationCreateNestedManyWithoutPanierInput
    commandes?: CommandeCreateNestedManyWithoutPanierInput
  }

  export type PanierUncheckedCreateInput = {
    id?: number
    agentId?: number | null
    clientId?: number | null
    statut?: $Enums.statutPanier
    createdAt?: Date | string
    updatedAt?: Date | string
    detailPaniers?: DetailPanierUncheckedCreateNestedManyWithoutPanierInput
    achats?: AchatUncheckedCreateNestedManyWithoutPanierInput
    ventes?: VenteUncheckedCreateNestedManyWithoutPanierInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutPanierInput
    commandes?: CommandeUncheckedCreateNestedManyWithoutPanierInput
  }

  export type PanierUpdateInput = {
    statut?: EnumstatutPanierFieldUpdateOperationsInput | $Enums.statutPanier
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUpdateOneWithoutPaniersNestedInput
    client?: ClientUpdateOneWithoutPaniersNestedInput
    detailPaniers?: DetailPanierUpdateManyWithoutPanierNestedInput
    achats?: AchatUpdateManyWithoutPanierNestedInput
    ventes?: VenteUpdateManyWithoutPanierNestedInput
    reservations?: ReservationUpdateManyWithoutPanierNestedInput
    commandes?: CommandeUpdateManyWithoutPanierNestedInput
  }

  export type PanierUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    agentId?: NullableIntFieldUpdateOperationsInput | number | null
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    statut?: EnumstatutPanierFieldUpdateOperationsInput | $Enums.statutPanier
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    detailPaniers?: DetailPanierUncheckedUpdateManyWithoutPanierNestedInput
    achats?: AchatUncheckedUpdateManyWithoutPanierNestedInput
    ventes?: VenteUncheckedUpdateManyWithoutPanierNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutPanierNestedInput
    commandes?: CommandeUncheckedUpdateManyWithoutPanierNestedInput
  }

  export type PanierCreateManyInput = {
    id?: number
    agentId?: number | null
    clientId?: number | null
    statut?: $Enums.statutPanier
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PanierUpdateManyMutationInput = {
    statut?: EnumstatutPanierFieldUpdateOperationsInput | $Enums.statutPanier
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PanierUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    agentId?: NullableIntFieldUpdateOperationsInput | number | null
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    statut?: EnumstatutPanierFieldUpdateOperationsInput | $Enums.statutPanier
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DetailPanierCreateInput = {
    qtte: number
    modePaiement: $Enums.ModePaiment
    prixUnitaire: number
    prixTotalHT: number
    prixTotalTTC: number
    createdAt?: Date | string
    updatedAt?: Date | string
    devise: DeviseCreateNestedOneWithoutDetailPanierInput
    produit: ProduitCreateNestedOneWithoutDetailsPaniersInput
    panier: PanierCreateNestedOneWithoutDetailPaniersInput
  }

  export type DetailPanierUncheckedCreateInput = {
    id?: number
    produitId: number
    qtte: number
    modePaiement: $Enums.ModePaiment
    prixUnitaire: number
    prixTotalHT: number
    prixTotalTTC: number
    panierId: number
    deviseId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DetailPanierUpdateInput = {
    qtte?: IntFieldUpdateOperationsInput | number
    modePaiement?: EnumModePaimentFieldUpdateOperationsInput | $Enums.ModePaiment
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    prixTotalHT?: FloatFieldUpdateOperationsInput | number
    prixTotalTTC?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    devise?: DeviseUpdateOneRequiredWithoutDetailPanierNestedInput
    produit?: ProduitUpdateOneRequiredWithoutDetailsPaniersNestedInput
    panier?: PanierUpdateOneRequiredWithoutDetailPaniersNestedInput
  }

  export type DetailPanierUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    produitId?: IntFieldUpdateOperationsInput | number
    qtte?: IntFieldUpdateOperationsInput | number
    modePaiement?: EnumModePaimentFieldUpdateOperationsInput | $Enums.ModePaiment
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    prixTotalHT?: FloatFieldUpdateOperationsInput | number
    prixTotalTTC?: FloatFieldUpdateOperationsInput | number
    panierId?: IntFieldUpdateOperationsInput | number
    deviseId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DetailPanierCreateManyInput = {
    id?: number
    produitId: number
    qtte: number
    modePaiement: $Enums.ModePaiment
    prixUnitaire: number
    prixTotalHT: number
    prixTotalTTC: number
    panierId: number
    deviseId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DetailPanierUpdateManyMutationInput = {
    qtte?: IntFieldUpdateOperationsInput | number
    modePaiement?: EnumModePaimentFieldUpdateOperationsInput | $Enums.ModePaiment
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    prixTotalHT?: FloatFieldUpdateOperationsInput | number
    prixTotalTTC?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DetailPanierUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    produitId?: IntFieldUpdateOperationsInput | number
    qtte?: IntFieldUpdateOperationsInput | number
    modePaiement?: EnumModePaimentFieldUpdateOperationsInput | $Enums.ModePaiment
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    prixTotalHT?: FloatFieldUpdateOperationsInput | number
    prixTotalTTC?: FloatFieldUpdateOperationsInput | number
    panierId?: IntFieldUpdateOperationsInput | number
    deviseId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchatCreateInput = {
    statut?: $Enums.StatutAchat
    createdAt?: Date | string
    updatedAt?: Date | string
    panier: PanierCreateNestedOneWithoutAchatsInput
    fournisseur: FournisseurCreateNestedOneWithoutAchatsInput
    agent: AgentCreateNestedOneWithoutAchatsInput
    Client?: ClientCreateNestedOneWithoutAchatsInput
    paiements?: PaiementCreateNestedManyWithoutAchatInput
  }

  export type AchatUncheckedCreateInput = {
    id?: number
    statut?: $Enums.StatutAchat
    panierId: number
    fournisseurId: number
    agentId: number
    clientId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    paiements?: PaiementUncheckedCreateNestedManyWithoutAchatInput
  }

  export type AchatUpdateInput = {
    statut?: EnumStatutAchatFieldUpdateOperationsInput | $Enums.StatutAchat
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    panier?: PanierUpdateOneRequiredWithoutAchatsNestedInput
    fournisseur?: FournisseurUpdateOneRequiredWithoutAchatsNestedInput
    agent?: AgentUpdateOneRequiredWithoutAchatsNestedInput
    Client?: ClientUpdateOneWithoutAchatsNestedInput
    paiements?: PaiementUpdateManyWithoutAchatNestedInput
  }

  export type AchatUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    statut?: EnumStatutAchatFieldUpdateOperationsInput | $Enums.StatutAchat
    panierId?: IntFieldUpdateOperationsInput | number
    fournisseurId?: IntFieldUpdateOperationsInput | number
    agentId?: IntFieldUpdateOperationsInput | number
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paiements?: PaiementUncheckedUpdateManyWithoutAchatNestedInput
  }

  export type AchatCreateManyInput = {
    id?: number
    statut?: $Enums.StatutAchat
    panierId: number
    fournisseurId: number
    agentId: number
    clientId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AchatUpdateManyMutationInput = {
    statut?: EnumStatutAchatFieldUpdateOperationsInput | $Enums.StatutAchat
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchatUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    statut?: EnumStatutAchatFieldUpdateOperationsInput | $Enums.StatutAchat
    panierId?: IntFieldUpdateOperationsInput | number
    fournisseurId?: IntFieldUpdateOperationsInput | number
    agentId?: IntFieldUpdateOperationsInput | number
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReservationCreateInput = {
    dateLivraisonSouhaitee: Date | string
    adresseLivraison?: string | null
    statut?: $Enums.StatutReservation
    notes?: string | null
    typeClient?: $Enums.TypeClient
    nom?: string | null
    tel?: string | null
    enregistrerParId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    panier: PanierCreateNestedOneWithoutReservationsInput
    fournisseur?: FournisseurCreateNestedOneWithoutReservationsInput
    adresse?: AdresseCreateNestedOneWithoutReservationsInput
    contact?: ContactCreateNestedOneWithoutReservationsInput
    Client?: ClientCreateNestedOneWithoutReservationsInput
  }

  export type ReservationUncheckedCreateInput = {
    id?: number
    dateLivraisonSouhaitee: Date | string
    adresseLivraison?: string | null
    statut?: $Enums.StatutReservation
    notes?: string | null
    typeClient?: $Enums.TypeClient
    clientId?: number | null
    panierId: number
    nom?: string | null
    tel?: string | null
    adresseId?: number | null
    contactId?: number | null
    enregistrerParId?: number | null
    fournisseurId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReservationUpdateInput = {
    dateLivraisonSouhaitee?: DateTimeFieldUpdateOperationsInput | Date | string
    adresseLivraison?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: EnumStatutReservationFieldUpdateOperationsInput | $Enums.StatutReservation
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    typeClient?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    enregistrerParId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    panier?: PanierUpdateOneRequiredWithoutReservationsNestedInput
    fournisseur?: FournisseurUpdateOneWithoutReservationsNestedInput
    adresse?: AdresseUpdateOneWithoutReservationsNestedInput
    contact?: ContactUpdateOneWithoutReservationsNestedInput
    Client?: ClientUpdateOneWithoutReservationsNestedInput
  }

  export type ReservationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateLivraisonSouhaitee?: DateTimeFieldUpdateOperationsInput | Date | string
    adresseLivraison?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: EnumStatutReservationFieldUpdateOperationsInput | $Enums.StatutReservation
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    typeClient?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    panierId?: IntFieldUpdateOperationsInput | number
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    adresseId?: NullableIntFieldUpdateOperationsInput | number | null
    contactId?: NullableIntFieldUpdateOperationsInput | number | null
    enregistrerParId?: NullableIntFieldUpdateOperationsInput | number | null
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReservationCreateManyInput = {
    id?: number
    dateLivraisonSouhaitee: Date | string
    adresseLivraison?: string | null
    statut?: $Enums.StatutReservation
    notes?: string | null
    typeClient?: $Enums.TypeClient
    clientId?: number | null
    panierId: number
    nom?: string | null
    tel?: string | null
    adresseId?: number | null
    contactId?: number | null
    enregistrerParId?: number | null
    fournisseurId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReservationUpdateManyMutationInput = {
    dateLivraisonSouhaitee?: DateTimeFieldUpdateOperationsInput | Date | string
    adresseLivraison?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: EnumStatutReservationFieldUpdateOperationsInput | $Enums.StatutReservation
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    typeClient?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    enregistrerParId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReservationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateLivraisonSouhaitee?: DateTimeFieldUpdateOperationsInput | Date | string
    adresseLivraison?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: EnumStatutReservationFieldUpdateOperationsInput | $Enums.StatutReservation
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    typeClient?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    panierId?: IntFieldUpdateOperationsInput | number
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    adresseId?: NullableIntFieldUpdateOperationsInput | number | null
    contactId?: NullableIntFieldUpdateOperationsInput | number | null
    enregistrerParId?: NullableIntFieldUpdateOperationsInput | number | null
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommandeCreateInput = {
    nom?: string | null
    tel?: string | null
    type_client?: $Enums.TypeClient
    commandeId?: number | null
    notes?: string | null
    dateLivraisonEffective?: Date | string | null
    adresseLivraison?: string | null
    enregistrerParId?: number | null
    statut?: $Enums.StatutCommande
    createdAt?: Date | string
    updatedAt?: Date | string
    Paiement?: PaiementCreateNestedManyWithoutCommandeInput
    panier: PanierCreateNestedOneWithoutCommandesInput
    fournisseur?: FournisseurCreateNestedOneWithoutCommandesInput
    adresse?: AdresseCreateNestedOneWithoutCommandesInput
    contact?: ContactCreateNestedOneWithoutCommandesInput
    Client?: ClientCreateNestedOneWithoutCommandesInput
  }

  export type CommandeUncheckedCreateInput = {
    id?: number
    panierId: number
    clientId?: number | null
    nom?: string | null
    tel?: string | null
    type_client?: $Enums.TypeClient
    adresseId?: number | null
    contactId?: number | null
    fournisseurId?: number | null
    commandeId?: number | null
    notes?: string | null
    dateLivraisonEffective?: Date | string | null
    adresseLivraison?: string | null
    enregistrerParId?: number | null
    statut?: $Enums.StatutCommande
    createdAt?: Date | string
    updatedAt?: Date | string
    Paiement?: PaiementUncheckedCreateNestedManyWithoutCommandeInput
  }

  export type CommandeUpdateInput = {
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    type_client?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    commandeId?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    dateLivraisonEffective?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adresseLivraison?: NullableStringFieldUpdateOperationsInput | string | null
    enregistrerParId?: NullableIntFieldUpdateOperationsInput | number | null
    statut?: EnumStatutCommandeFieldUpdateOperationsInput | $Enums.StatutCommande
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Paiement?: PaiementUpdateManyWithoutCommandeNestedInput
    panier?: PanierUpdateOneRequiredWithoutCommandesNestedInput
    fournisseur?: FournisseurUpdateOneWithoutCommandesNestedInput
    adresse?: AdresseUpdateOneWithoutCommandesNestedInput
    contact?: ContactUpdateOneWithoutCommandesNestedInput
    Client?: ClientUpdateOneWithoutCommandesNestedInput
  }

  export type CommandeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    panierId?: IntFieldUpdateOperationsInput | number
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    type_client?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    adresseId?: NullableIntFieldUpdateOperationsInput | number | null
    contactId?: NullableIntFieldUpdateOperationsInput | number | null
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    commandeId?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    dateLivraisonEffective?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adresseLivraison?: NullableStringFieldUpdateOperationsInput | string | null
    enregistrerParId?: NullableIntFieldUpdateOperationsInput | number | null
    statut?: EnumStatutCommandeFieldUpdateOperationsInput | $Enums.StatutCommande
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Paiement?: PaiementUncheckedUpdateManyWithoutCommandeNestedInput
  }

  export type CommandeCreateManyInput = {
    id?: number
    panierId: number
    clientId?: number | null
    nom?: string | null
    tel?: string | null
    type_client?: $Enums.TypeClient
    adresseId?: number | null
    contactId?: number | null
    fournisseurId?: number | null
    commandeId?: number | null
    notes?: string | null
    dateLivraisonEffective?: Date | string | null
    adresseLivraison?: string | null
    enregistrerParId?: number | null
    statut?: $Enums.StatutCommande
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommandeUpdateManyMutationInput = {
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    type_client?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    commandeId?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    dateLivraisonEffective?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adresseLivraison?: NullableStringFieldUpdateOperationsInput | string | null
    enregistrerParId?: NullableIntFieldUpdateOperationsInput | number | null
    statut?: EnumStatutCommandeFieldUpdateOperationsInput | $Enums.StatutCommande
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommandeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    panierId?: IntFieldUpdateOperationsInput | number
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    type_client?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    adresseId?: NullableIntFieldUpdateOperationsInput | number | null
    contactId?: NullableIntFieldUpdateOperationsInput | number | null
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    commandeId?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    dateLivraisonEffective?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adresseLivraison?: NullableStringFieldUpdateOperationsInput | string | null
    enregistrerParId?: NullableIntFieldUpdateOperationsInput | number | null
    statut?: EnumStatutCommandeFieldUpdateOperationsInput | $Enums.StatutCommande
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClotureCaisseCreateInput = {
    dateCloture?: Date | string
    updatedAt?: Date | string
    notes?: string | null
    createdAt?: Date | string
    agent: AgentCreateNestedOneWithoutClotureCaissesInput
    entreprise?: EntrepriseCreateNestedOneWithoutClotureCaissesInput
  }

  export type ClotureCaisseUncheckedCreateInput = {
    id?: number
    dateCloture?: Date | string
    agentId: number
    entrepriseId?: number | null
    updatedAt?: Date | string
    notes?: string | null
    createdAt?: Date | string
  }

  export type ClotureCaisseUpdateInput = {
    dateCloture?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUpdateOneRequiredWithoutClotureCaissesNestedInput
    entreprise?: EntrepriseUpdateOneWithoutClotureCaissesNestedInput
  }

  export type ClotureCaisseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateCloture?: DateTimeFieldUpdateOperationsInput | Date | string
    agentId?: IntFieldUpdateOperationsInput | number
    entrepriseId?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClotureCaisseCreateManyInput = {
    id?: number
    dateCloture?: Date | string
    agentId: number
    entrepriseId?: number | null
    updatedAt?: Date | string
    notes?: string | null
    createdAt?: Date | string
  }

  export type ClotureCaisseUpdateManyMutationInput = {
    dateCloture?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClotureCaisseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateCloture?: DateTimeFieldUpdateOperationsInput | Date | string
    agentId?: IntFieldUpdateOperationsInput | number
    entrepriseId?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MouvementCaisseCreateInput = {
    referenceExterne?: string | null
    type_mouvement?: $Enums.TypeMouvementCaisse
    categorie?: $Enums.CategorieMouvement
    moyen_paiement: $Enums.ModePaiment
    montant: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    caisse: CaisseCreateNestedOneWithoutMouvementCaissesInput
    agent: AgentCreateNestedOneWithoutMouvementCaissesInput
  }

  export type MouvementCaisseUncheckedCreateInput = {
    id?: number
    caisseId: number
    referenceExterne?: string | null
    type_mouvement?: $Enums.TypeMouvementCaisse
    categorie?: $Enums.CategorieMouvement
    moyen_paiement: $Enums.ModePaiment
    montant: number
    description?: string | null
    agentId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MouvementCaisseUpdateInput = {
    referenceExterne?: NullableStringFieldUpdateOperationsInput | string | null
    type_mouvement?: EnumTypeMouvementCaisseFieldUpdateOperationsInput | $Enums.TypeMouvementCaisse
    categorie?: EnumCategorieMouvementFieldUpdateOperationsInput | $Enums.CategorieMouvement
    moyen_paiement?: EnumModePaimentFieldUpdateOperationsInput | $Enums.ModePaiment
    montant?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    caisse?: CaisseUpdateOneRequiredWithoutMouvementCaissesNestedInput
    agent?: AgentUpdateOneRequiredWithoutMouvementCaissesNestedInput
  }

  export type MouvementCaisseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    caisseId?: IntFieldUpdateOperationsInput | number
    referenceExterne?: NullableStringFieldUpdateOperationsInput | string | null
    type_mouvement?: EnumTypeMouvementCaisseFieldUpdateOperationsInput | $Enums.TypeMouvementCaisse
    categorie?: EnumCategorieMouvementFieldUpdateOperationsInput | $Enums.CategorieMouvement
    moyen_paiement?: EnumModePaimentFieldUpdateOperationsInput | $Enums.ModePaiment
    montant?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    agentId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MouvementCaisseCreateManyInput = {
    id?: number
    caisseId: number
    referenceExterne?: string | null
    type_mouvement?: $Enums.TypeMouvementCaisse
    categorie?: $Enums.CategorieMouvement
    moyen_paiement: $Enums.ModePaiment
    montant: number
    description?: string | null
    agentId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MouvementCaisseUpdateManyMutationInput = {
    referenceExterne?: NullableStringFieldUpdateOperationsInput | string | null
    type_mouvement?: EnumTypeMouvementCaisseFieldUpdateOperationsInput | $Enums.TypeMouvementCaisse
    categorie?: EnumCategorieMouvementFieldUpdateOperationsInput | $Enums.CategorieMouvement
    moyen_paiement?: EnumModePaimentFieldUpdateOperationsInput | $Enums.ModePaiment
    montant?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MouvementCaisseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    caisseId?: IntFieldUpdateOperationsInput | number
    referenceExterne?: NullableStringFieldUpdateOperationsInput | string | null
    type_mouvement?: EnumTypeMouvementCaisseFieldUpdateOperationsInput | $Enums.TypeMouvementCaisse
    categorie?: EnumCategorieMouvementFieldUpdateOperationsInput | $Enums.CategorieMouvement
    moyen_paiement?: EnumModePaimentFieldUpdateOperationsInput | $Enums.ModePaiment
    montant?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    agentId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type AgentScalarRelationFilter = {
    is?: AgentWhereInput
    isNot?: AgentWhereInput
  }

  export type ProduitListRelationFilter = {
    every?: ProduitWhereInput
    some?: ProduitWhereInput
    none?: ProduitWhereInput
  }

  export type ProduitOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeneurCountOrderByAggregateInput = {
    id?: SortOrder
    valeur?: SortOrder
    agentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeneurAvgOrderByAggregateInput = {
    id?: SortOrder
    valeur?: SortOrder
    agentId?: SortOrder
  }

  export type TeneurMaxOrderByAggregateInput = {
    id?: SortOrder
    valeur?: SortOrder
    agentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeneurMinOrderByAggregateInput = {
    id?: SortOrder
    valeur?: SortOrder
    agentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeneurSumOrderByAggregateInput = {
    id?: SortOrder
    valeur?: SortOrder
    agentId?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type PaiementListRelationFilter = {
    every?: PaiementWhereInput
    some?: PaiementWhereInput
    none?: PaiementWhereInput
  }

  export type CaisseListRelationFilter = {
    every?: CaisseWhereInput
    some?: CaisseWhereInput
    none?: CaisseWhereInput
  }

  export type DetailPanierListRelationFilter = {
    every?: DetailPanierWhereInput
    some?: DetailPanierWhereInput
    none?: DetailPanierWhereInput
  }

  export type PaiementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CaisseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DetailPanierOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeviseCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    code?: SortOrder
    symbole?: SortOrder
    tauxDEchange?: SortOrder
    agentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeviseAvgOrderByAggregateInput = {
    id?: SortOrder
    tauxDEchange?: SortOrder
    agentId?: SortOrder
  }

  export type DeviseMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    code?: SortOrder
    symbole?: SortOrder
    tauxDEchange?: SortOrder
    agentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeviseMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    code?: SortOrder
    symbole?: SortOrder
    tauxDEchange?: SortOrder
    agentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeviseSumOrderByAggregateInput = {
    id?: SortOrder
    tauxDEchange?: SortOrder
    agentId?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type ClotureCaisseListRelationFilter = {
    every?: ClotureCaisseWhereInput
    some?: ClotureCaisseWhereInput
    none?: ClotureCaisseWhereInput
  }

  export type AdresseListRelationFilter = {
    every?: AdresseWhereInput
    some?: AdresseWhereInput
    none?: AdresseWhereInput
  }

  export type ContactListRelationFilter = {
    every?: ContactWhereInput
    some?: ContactWhereInput
    none?: ContactWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ClotureCaisseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdresseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContactOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EntrepriseCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    email?: SortOrder
    encronyme?: SortOrder
    codePostale?: SortOrder
    site?: SortOrder
    description?: SortOrder
    logo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EntrepriseAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EntrepriseMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    email?: SortOrder
    encronyme?: SortOrder
    codePostale?: SortOrder
    site?: SortOrder
    description?: SortOrder
    logo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EntrepriseMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    email?: SortOrder
    encronyme?: SortOrder
    codePostale?: SortOrder
    site?: SortOrder
    description?: SortOrder
    logo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EntrepriseSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumSexeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Sexe | EnumSexeFieldRefInput<$PrismaModel> | null
    in?: $Enums.Sexe[] | ListEnumSexeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Sexe[] | ListEnumSexeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSexeNullableFilter<$PrismaModel> | $Enums.Sexe | null
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type EnumPosteNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Poste | EnumPosteFieldRefInput<$PrismaModel> | null
    in?: $Enums.Poste[] | ListEnumPosteFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Poste[] | ListEnumPosteFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPosteNullableFilter<$PrismaModel> | $Enums.Poste | null
  }

  export type VenteListRelationFilter = {
    every?: VenteWhereInput
    some?: VenteWhereInput
    none?: VenteWhereInput
  }

  export type AchatListRelationFilter = {
    every?: AchatWhereInput
    some?: AchatWhereInput
    none?: AchatWhereInput
  }

  export type TeneurListRelationFilter = {
    every?: TeneurWhereInput
    some?: TeneurWhereInput
    none?: TeneurWhereInput
  }

  export type DeviseListRelationFilter = {
    every?: DeviseWhereInput
    some?: DeviseWhereInput
    none?: DeviseWhereInput
  }

  export type PanierListRelationFilter = {
    every?: PanierWhereInput
    some?: PanierWhereInput
    none?: PanierWhereInput
  }

  export type MouvementCaisseListRelationFilter = {
    every?: MouvementCaisseWhereInput
    some?: MouvementCaisseWhereInput
    none?: MouvementCaisseWhereInput
  }

  export type FournisseurListRelationFilter = {
    every?: FournisseurWhereInput
    some?: FournisseurWhereInput
    none?: FournisseurWhereInput
  }

  export type VenteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AchatOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeneurOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeviseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PanierOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MouvementCaisseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FournisseurOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AgentCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    nom?: SortOrder
    postnom?: SortOrder
    nom_complet?: SortOrder
    sexe?: SortOrder
    role?: SortOrder
    poste?: SortOrder
    picture?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgentAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AgentMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    nom?: SortOrder
    postnom?: SortOrder
    nom_complet?: SortOrder
    sexe?: SortOrder
    role?: SortOrder
    poste?: SortOrder
    picture?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgentMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    nom?: SortOrder
    postnom?: SortOrder
    nom_complet?: SortOrder
    sexe?: SortOrder
    role?: SortOrder
    poste?: SortOrder
    picture?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgentSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumSexeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Sexe | EnumSexeFieldRefInput<$PrismaModel> | null
    in?: $Enums.Sexe[] | ListEnumSexeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Sexe[] | ListEnumSexeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSexeNullableWithAggregatesFilter<$PrismaModel> | $Enums.Sexe | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSexeNullableFilter<$PrismaModel>
    _max?: NestedEnumSexeNullableFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type EnumPosteNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Poste | EnumPosteFieldRefInput<$PrismaModel> | null
    in?: $Enums.Poste[] | ListEnumPosteFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Poste[] | ListEnumPosteFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPosteNullableWithAggregatesFilter<$PrismaModel> | $Enums.Poste | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPosteNullableFilter<$PrismaModel>
    _max?: NestedEnumPosteNullableFilter<$PrismaModel>
  }

  export type ReservationListRelationFilter = {
    every?: ReservationWhereInput
    some?: ReservationWhereInput
    none?: ReservationWhereInput
  }

  export type CommandeListRelationFilter = {
    every?: CommandeWhereInput
    some?: CommandeWhereInput
    none?: CommandeWhereInput
  }

  export type ReservationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommandeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    nom?: SortOrder
    postnom?: SortOrder
    nom_complet?: SortOrder
    sexe?: SortOrder
    picture?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ClientMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    nom?: SortOrder
    postnom?: SortOrder
    nom_complet?: SortOrder
    sexe?: SortOrder
    picture?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    nom?: SortOrder
    postnom?: SortOrder
    nom_complet?: SortOrder
    sexe?: SortOrder
    picture?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type AgentNullableScalarRelationFilter = {
    is?: AgentWhereInput | null
    isNot?: AgentWhereInput | null
  }

  export type EntrepriseNullableScalarRelationFilter = {
    is?: EntrepriseWhereInput | null
    isNot?: EntrepriseWhereInput | null
  }

  export type FournisseurNullableScalarRelationFilter = {
    is?: FournisseurWhereInput | null
    isNot?: FournisseurWhereInput | null
  }

  export type ClientNullableScalarRelationFilter = {
    is?: ClientWhereInput | null
    isNot?: ClientWhereInput | null
  }

  export type AdresseCountOrderByAggregateInput = {
    id?: SortOrder
    ville?: SortOrder
    adresse?: SortOrder
    isActive?: SortOrder
    agentId?: SortOrder
    fournisseurId?: SortOrder
    clientId?: SortOrder
    entrepriseId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdresseAvgOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    fournisseurId?: SortOrder
    clientId?: SortOrder
    entrepriseId?: SortOrder
  }

  export type AdresseMaxOrderByAggregateInput = {
    id?: SortOrder
    ville?: SortOrder
    adresse?: SortOrder
    isActive?: SortOrder
    agentId?: SortOrder
    fournisseurId?: SortOrder
    clientId?: SortOrder
    entrepriseId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdresseMinOrderByAggregateInput = {
    id?: SortOrder
    ville?: SortOrder
    adresse?: SortOrder
    isActive?: SortOrder
    agentId?: SortOrder
    fournisseurId?: SortOrder
    clientId?: SortOrder
    entrepriseId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdresseSumOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    fournisseurId?: SortOrder
    clientId?: SortOrder
    entrepriseId?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type ContactCountOrderByAggregateInput = {
    id?: SortOrder
    tel?: SortOrder
    isActive?: SortOrder
    agentId?: SortOrder
    fournisseurId?: SortOrder
    clientId?: SortOrder
    entrepriseId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactAvgOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    fournisseurId?: SortOrder
    clientId?: SortOrder
    entrepriseId?: SortOrder
  }

  export type ContactMaxOrderByAggregateInput = {
    id?: SortOrder
    tel?: SortOrder
    isActive?: SortOrder
    agentId?: SortOrder
    fournisseurId?: SortOrder
    clientId?: SortOrder
    entrepriseId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactMinOrderByAggregateInput = {
    id?: SortOrder
    tel?: SortOrder
    isActive?: SortOrder
    agentId?: SortOrder
    fournisseurId?: SortOrder
    clientId?: SortOrder
    entrepriseId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactSumOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    fournisseurId?: SortOrder
    clientId?: SortOrder
    entrepriseId?: SortOrder
  }

  export type FournisseurCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    email?: SortOrder
    codePostale?: SortOrder
    agentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FournisseurAvgOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
  }

  export type FournisseurMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    email?: SortOrder
    codePostale?: SortOrder
    agentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FournisseurMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    email?: SortOrder
    codePostale?: SortOrder
    agentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FournisseurSumOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
  }

  export type DeviseScalarRelationFilter = {
    is?: DeviseWhereInput
    isNot?: DeviseWhereInput
  }

  export type TeneurScalarRelationFilter = {
    is?: TeneurWhereInput
    isNot?: TeneurWhereInput
  }

  export type ProduitCountOrderByAggregateInput = {
    id?: SortOrder
    designation?: SortOrder
    prixUnitaire?: SortOrder
    qtteDisponible?: SortOrder
    description?: SortOrder
    deviseId?: SortOrder
    teneurId?: SortOrder
    agentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProduitAvgOrderByAggregateInput = {
    id?: SortOrder
    prixUnitaire?: SortOrder
    qtteDisponible?: SortOrder
    deviseId?: SortOrder
    teneurId?: SortOrder
    agentId?: SortOrder
  }

  export type ProduitMaxOrderByAggregateInput = {
    id?: SortOrder
    designation?: SortOrder
    prixUnitaire?: SortOrder
    qtteDisponible?: SortOrder
    description?: SortOrder
    deviseId?: SortOrder
    teneurId?: SortOrder
    agentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProduitMinOrderByAggregateInput = {
    id?: SortOrder
    designation?: SortOrder
    prixUnitaire?: SortOrder
    qtteDisponible?: SortOrder
    description?: SortOrder
    deviseId?: SortOrder
    teneurId?: SortOrder
    agentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProduitSumOrderByAggregateInput = {
    id?: SortOrder
    prixUnitaire?: SortOrder
    qtteDisponible?: SortOrder
    deviseId?: SortOrder
    teneurId?: SortOrder
    agentId?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type EnumModePaimentFilter<$PrismaModel = never> = {
    equals?: $Enums.ModePaiment | EnumModePaimentFieldRefInput<$PrismaModel>
    in?: $Enums.ModePaiment[] | ListEnumModePaimentFieldRefInput<$PrismaModel>
    notIn?: $Enums.ModePaiment[] | ListEnumModePaimentFieldRefInput<$PrismaModel>
    not?: NestedEnumModePaimentFilter<$PrismaModel> | $Enums.ModePaiment
  }

  export type VenteNullableScalarRelationFilter = {
    is?: VenteWhereInput | null
    isNot?: VenteWhereInput | null
  }

  export type AchatNullableScalarRelationFilter = {
    is?: AchatWhereInput | null
    isNot?: AchatWhereInput | null
  }

  export type CommandeNullableScalarRelationFilter = {
    is?: CommandeWhereInput | null
    isNot?: CommandeWhereInput | null
  }

  export type CaisseScalarRelationFilter = {
    is?: CaisseWhereInput
    isNot?: CaisseWhereInput
  }

  export type PaiementCountOrderByAggregateInput = {
    id?: SortOrder
    totalHT?: SortOrder
    totalTTC?: SortOrder
    modePaiement?: SortOrder
    deviseId?: SortOrder
    caisseId?: SortOrder
    venteId?: SortOrder
    achatId?: SortOrder
    commandeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaiementAvgOrderByAggregateInput = {
    id?: SortOrder
    totalHT?: SortOrder
    totalTTC?: SortOrder
    deviseId?: SortOrder
    caisseId?: SortOrder
    venteId?: SortOrder
    achatId?: SortOrder
    commandeId?: SortOrder
  }

  export type PaiementMaxOrderByAggregateInput = {
    id?: SortOrder
    totalHT?: SortOrder
    totalTTC?: SortOrder
    modePaiement?: SortOrder
    deviseId?: SortOrder
    caisseId?: SortOrder
    venteId?: SortOrder
    achatId?: SortOrder
    commandeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaiementMinOrderByAggregateInput = {
    id?: SortOrder
    totalHT?: SortOrder
    totalTTC?: SortOrder
    modePaiement?: SortOrder
    deviseId?: SortOrder
    caisseId?: SortOrder
    venteId?: SortOrder
    achatId?: SortOrder
    commandeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaiementSumOrderByAggregateInput = {
    id?: SortOrder
    totalHT?: SortOrder
    totalTTC?: SortOrder
    deviseId?: SortOrder
    caisseId?: SortOrder
    venteId?: SortOrder
    achatId?: SortOrder
    commandeId?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumModePaimentWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ModePaiment | EnumModePaimentFieldRefInput<$PrismaModel>
    in?: $Enums.ModePaiment[] | ListEnumModePaimentFieldRefInput<$PrismaModel>
    notIn?: $Enums.ModePaiment[] | ListEnumModePaimentFieldRefInput<$PrismaModel>
    not?: NestedEnumModePaimentWithAggregatesFilter<$PrismaModel> | $Enums.ModePaiment
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumModePaimentFilter<$PrismaModel>
    _max?: NestedEnumModePaimentFilter<$PrismaModel>
  }

  export type EnumStatutCaisseFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutCaisse | EnumStatutCaisseFieldRefInput<$PrismaModel>
    in?: $Enums.StatutCaisse[] | ListEnumStatutCaisseFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatutCaisse[] | ListEnumStatutCaisseFieldRefInput<$PrismaModel>
    not?: NestedEnumStatutCaisseFilter<$PrismaModel> | $Enums.StatutCaisse
  }

  export type CaisseCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    description?: SortOrder
    soldeActuel?: SortOrder
    deviseId?: SortOrder
    agentId?: SortOrder
    statut?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CaisseAvgOrderByAggregateInput = {
    id?: SortOrder
    soldeActuel?: SortOrder
    deviseId?: SortOrder
    agentId?: SortOrder
  }

  export type CaisseMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    description?: SortOrder
    soldeActuel?: SortOrder
    deviseId?: SortOrder
    agentId?: SortOrder
    statut?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CaisseMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    description?: SortOrder
    soldeActuel?: SortOrder
    deviseId?: SortOrder
    agentId?: SortOrder
    statut?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CaisseSumOrderByAggregateInput = {
    id?: SortOrder
    soldeActuel?: SortOrder
    deviseId?: SortOrder
    agentId?: SortOrder
  }

  export type EnumStatutCaisseWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutCaisse | EnumStatutCaisseFieldRefInput<$PrismaModel>
    in?: $Enums.StatutCaisse[] | ListEnumStatutCaisseFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatutCaisse[] | ListEnumStatutCaisseFieldRefInput<$PrismaModel>
    not?: NestedEnumStatutCaisseWithAggregatesFilter<$PrismaModel> | $Enums.StatutCaisse
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatutCaisseFilter<$PrismaModel>
    _max?: NestedEnumStatutCaisseFilter<$PrismaModel>
  }

  export type EnumStatutVenteFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutVente | EnumStatutVenteFieldRefInput<$PrismaModel>
    in?: $Enums.StatutVente[] | ListEnumStatutVenteFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatutVente[] | ListEnumStatutVenteFieldRefInput<$PrismaModel>
    not?: NestedEnumStatutVenteFilter<$PrismaModel> | $Enums.StatutVente
  }

  export type EnumTypeClientFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeClient | EnumTypeClientFieldRefInput<$PrismaModel>
    in?: $Enums.TypeClient[] | ListEnumTypeClientFieldRefInput<$PrismaModel>
    notIn?: $Enums.TypeClient[] | ListEnumTypeClientFieldRefInput<$PrismaModel>
    not?: NestedEnumTypeClientFilter<$PrismaModel> | $Enums.TypeClient
  }

  export type PanierScalarRelationFilter = {
    is?: PanierWhereInput
    isNot?: PanierWhereInput
  }

  export type VenteCountOrderByAggregateInput = {
    id?: SortOrder
    statut?: SortOrder
    typeAcheteur?: SortOrder
    clientId?: SortOrder
    agentId?: SortOrder
    fournisseurId?: SortOrder
    panierId?: SortOrder
    enregistrerPar?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VenteAvgOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    agentId?: SortOrder
    fournisseurId?: SortOrder
    panierId?: SortOrder
  }

  export type VenteMaxOrderByAggregateInput = {
    id?: SortOrder
    statut?: SortOrder
    typeAcheteur?: SortOrder
    clientId?: SortOrder
    agentId?: SortOrder
    fournisseurId?: SortOrder
    panierId?: SortOrder
    enregistrerPar?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VenteMinOrderByAggregateInput = {
    id?: SortOrder
    statut?: SortOrder
    typeAcheteur?: SortOrder
    clientId?: SortOrder
    agentId?: SortOrder
    fournisseurId?: SortOrder
    panierId?: SortOrder
    enregistrerPar?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VenteSumOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    agentId?: SortOrder
    fournisseurId?: SortOrder
    panierId?: SortOrder
  }

  export type EnumStatutVenteWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutVente | EnumStatutVenteFieldRefInput<$PrismaModel>
    in?: $Enums.StatutVente[] | ListEnumStatutVenteFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatutVente[] | ListEnumStatutVenteFieldRefInput<$PrismaModel>
    not?: NestedEnumStatutVenteWithAggregatesFilter<$PrismaModel> | $Enums.StatutVente
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatutVenteFilter<$PrismaModel>
    _max?: NestedEnumStatutVenteFilter<$PrismaModel>
  }

  export type EnumTypeClientWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeClient | EnumTypeClientFieldRefInput<$PrismaModel>
    in?: $Enums.TypeClient[] | ListEnumTypeClientFieldRefInput<$PrismaModel>
    notIn?: $Enums.TypeClient[] | ListEnumTypeClientFieldRefInput<$PrismaModel>
    not?: NestedEnumTypeClientWithAggregatesFilter<$PrismaModel> | $Enums.TypeClient
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTypeClientFilter<$PrismaModel>
    _max?: NestedEnumTypeClientFilter<$PrismaModel>
  }

  export type EnumstatutPanierFilter<$PrismaModel = never> = {
    equals?: $Enums.statutPanier | EnumstatutPanierFieldRefInput<$PrismaModel>
    in?: $Enums.statutPanier[] | ListEnumstatutPanierFieldRefInput<$PrismaModel>
    notIn?: $Enums.statutPanier[] | ListEnumstatutPanierFieldRefInput<$PrismaModel>
    not?: NestedEnumstatutPanierFilter<$PrismaModel> | $Enums.statutPanier
  }

  export type PanierCountOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    clientId?: SortOrder
    statut?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PanierAvgOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    clientId?: SortOrder
  }

  export type PanierMaxOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    clientId?: SortOrder
    statut?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PanierMinOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    clientId?: SortOrder
    statut?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PanierSumOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    clientId?: SortOrder
  }

  export type EnumstatutPanierWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.statutPanier | EnumstatutPanierFieldRefInput<$PrismaModel>
    in?: $Enums.statutPanier[] | ListEnumstatutPanierFieldRefInput<$PrismaModel>
    notIn?: $Enums.statutPanier[] | ListEnumstatutPanierFieldRefInput<$PrismaModel>
    not?: NestedEnumstatutPanierWithAggregatesFilter<$PrismaModel> | $Enums.statutPanier
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumstatutPanierFilter<$PrismaModel>
    _max?: NestedEnumstatutPanierFilter<$PrismaModel>
  }

  export type ProduitScalarRelationFilter = {
    is?: ProduitWhereInput
    isNot?: ProduitWhereInput
  }

  export type DetailPanierCountOrderByAggregateInput = {
    id?: SortOrder
    produitId?: SortOrder
    qtte?: SortOrder
    modePaiement?: SortOrder
    prixUnitaire?: SortOrder
    prixTotalHT?: SortOrder
    prixTotalTTC?: SortOrder
    panierId?: SortOrder
    deviseId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DetailPanierAvgOrderByAggregateInput = {
    id?: SortOrder
    produitId?: SortOrder
    qtte?: SortOrder
    prixUnitaire?: SortOrder
    prixTotalHT?: SortOrder
    prixTotalTTC?: SortOrder
    panierId?: SortOrder
    deviseId?: SortOrder
  }

  export type DetailPanierMaxOrderByAggregateInput = {
    id?: SortOrder
    produitId?: SortOrder
    qtte?: SortOrder
    modePaiement?: SortOrder
    prixUnitaire?: SortOrder
    prixTotalHT?: SortOrder
    prixTotalTTC?: SortOrder
    panierId?: SortOrder
    deviseId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DetailPanierMinOrderByAggregateInput = {
    id?: SortOrder
    produitId?: SortOrder
    qtte?: SortOrder
    modePaiement?: SortOrder
    prixUnitaire?: SortOrder
    prixTotalHT?: SortOrder
    prixTotalTTC?: SortOrder
    panierId?: SortOrder
    deviseId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DetailPanierSumOrderByAggregateInput = {
    id?: SortOrder
    produitId?: SortOrder
    qtte?: SortOrder
    prixUnitaire?: SortOrder
    prixTotalHT?: SortOrder
    prixTotalTTC?: SortOrder
    panierId?: SortOrder
    deviseId?: SortOrder
  }

  export type EnumStatutAchatFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutAchat | EnumStatutAchatFieldRefInput<$PrismaModel>
    in?: $Enums.StatutAchat[] | ListEnumStatutAchatFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatutAchat[] | ListEnumStatutAchatFieldRefInput<$PrismaModel>
    not?: NestedEnumStatutAchatFilter<$PrismaModel> | $Enums.StatutAchat
  }

  export type FournisseurScalarRelationFilter = {
    is?: FournisseurWhereInput
    isNot?: FournisseurWhereInput
  }

  export type AchatCountOrderByAggregateInput = {
    id?: SortOrder
    statut?: SortOrder
    panierId?: SortOrder
    fournisseurId?: SortOrder
    agentId?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AchatAvgOrderByAggregateInput = {
    id?: SortOrder
    panierId?: SortOrder
    fournisseurId?: SortOrder
    agentId?: SortOrder
    clientId?: SortOrder
  }

  export type AchatMaxOrderByAggregateInput = {
    id?: SortOrder
    statut?: SortOrder
    panierId?: SortOrder
    fournisseurId?: SortOrder
    agentId?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AchatMinOrderByAggregateInput = {
    id?: SortOrder
    statut?: SortOrder
    panierId?: SortOrder
    fournisseurId?: SortOrder
    agentId?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AchatSumOrderByAggregateInput = {
    id?: SortOrder
    panierId?: SortOrder
    fournisseurId?: SortOrder
    agentId?: SortOrder
    clientId?: SortOrder
  }

  export type EnumStatutAchatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutAchat | EnumStatutAchatFieldRefInput<$PrismaModel>
    in?: $Enums.StatutAchat[] | ListEnumStatutAchatFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatutAchat[] | ListEnumStatutAchatFieldRefInput<$PrismaModel>
    not?: NestedEnumStatutAchatWithAggregatesFilter<$PrismaModel> | $Enums.StatutAchat
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatutAchatFilter<$PrismaModel>
    _max?: NestedEnumStatutAchatFilter<$PrismaModel>
  }

  export type EnumStatutReservationFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutReservation | EnumStatutReservationFieldRefInput<$PrismaModel>
    in?: $Enums.StatutReservation[] | ListEnumStatutReservationFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatutReservation[] | ListEnumStatutReservationFieldRefInput<$PrismaModel>
    not?: NestedEnumStatutReservationFilter<$PrismaModel> | $Enums.StatutReservation
  }

  export type AdresseNullableScalarRelationFilter = {
    is?: AdresseWhereInput | null
    isNot?: AdresseWhereInput | null
  }

  export type ContactNullableScalarRelationFilter = {
    is?: ContactWhereInput | null
    isNot?: ContactWhereInput | null
  }

  export type ReservationCountOrderByAggregateInput = {
    id?: SortOrder
    dateLivraisonSouhaitee?: SortOrder
    adresseLivraison?: SortOrder
    statut?: SortOrder
    notes?: SortOrder
    typeClient?: SortOrder
    clientId?: SortOrder
    panierId?: SortOrder
    nom?: SortOrder
    tel?: SortOrder
    adresseId?: SortOrder
    contactId?: SortOrder
    enregistrerParId?: SortOrder
    fournisseurId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReservationAvgOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    panierId?: SortOrder
    adresseId?: SortOrder
    contactId?: SortOrder
    enregistrerParId?: SortOrder
    fournisseurId?: SortOrder
  }

  export type ReservationMaxOrderByAggregateInput = {
    id?: SortOrder
    dateLivraisonSouhaitee?: SortOrder
    adresseLivraison?: SortOrder
    statut?: SortOrder
    notes?: SortOrder
    typeClient?: SortOrder
    clientId?: SortOrder
    panierId?: SortOrder
    nom?: SortOrder
    tel?: SortOrder
    adresseId?: SortOrder
    contactId?: SortOrder
    enregistrerParId?: SortOrder
    fournisseurId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReservationMinOrderByAggregateInput = {
    id?: SortOrder
    dateLivraisonSouhaitee?: SortOrder
    adresseLivraison?: SortOrder
    statut?: SortOrder
    notes?: SortOrder
    typeClient?: SortOrder
    clientId?: SortOrder
    panierId?: SortOrder
    nom?: SortOrder
    tel?: SortOrder
    adresseId?: SortOrder
    contactId?: SortOrder
    enregistrerParId?: SortOrder
    fournisseurId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReservationSumOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    panierId?: SortOrder
    adresseId?: SortOrder
    contactId?: SortOrder
    enregistrerParId?: SortOrder
    fournisseurId?: SortOrder
  }

  export type EnumStatutReservationWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutReservation | EnumStatutReservationFieldRefInput<$PrismaModel>
    in?: $Enums.StatutReservation[] | ListEnumStatutReservationFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatutReservation[] | ListEnumStatutReservationFieldRefInput<$PrismaModel>
    not?: NestedEnumStatutReservationWithAggregatesFilter<$PrismaModel> | $Enums.StatutReservation
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatutReservationFilter<$PrismaModel>
    _max?: NestedEnumStatutReservationFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumStatutCommandeFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutCommande | EnumStatutCommandeFieldRefInput<$PrismaModel>
    in?: $Enums.StatutCommande[] | ListEnumStatutCommandeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatutCommande[] | ListEnumStatutCommandeFieldRefInput<$PrismaModel>
    not?: NestedEnumStatutCommandeFilter<$PrismaModel> | $Enums.StatutCommande
  }

  export type CommandeCountOrderByAggregateInput = {
    id?: SortOrder
    panierId?: SortOrder
    clientId?: SortOrder
    nom?: SortOrder
    tel?: SortOrder
    type_client?: SortOrder
    adresseId?: SortOrder
    contactId?: SortOrder
    fournisseurId?: SortOrder
    commandeId?: SortOrder
    notes?: SortOrder
    dateLivraisonEffective?: SortOrder
    adresseLivraison?: SortOrder
    enregistrerParId?: SortOrder
    statut?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommandeAvgOrderByAggregateInput = {
    id?: SortOrder
    panierId?: SortOrder
    clientId?: SortOrder
    adresseId?: SortOrder
    contactId?: SortOrder
    fournisseurId?: SortOrder
    commandeId?: SortOrder
    enregistrerParId?: SortOrder
  }

  export type CommandeMaxOrderByAggregateInput = {
    id?: SortOrder
    panierId?: SortOrder
    clientId?: SortOrder
    nom?: SortOrder
    tel?: SortOrder
    type_client?: SortOrder
    adresseId?: SortOrder
    contactId?: SortOrder
    fournisseurId?: SortOrder
    commandeId?: SortOrder
    notes?: SortOrder
    dateLivraisonEffective?: SortOrder
    adresseLivraison?: SortOrder
    enregistrerParId?: SortOrder
    statut?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommandeMinOrderByAggregateInput = {
    id?: SortOrder
    panierId?: SortOrder
    clientId?: SortOrder
    nom?: SortOrder
    tel?: SortOrder
    type_client?: SortOrder
    adresseId?: SortOrder
    contactId?: SortOrder
    fournisseurId?: SortOrder
    commandeId?: SortOrder
    notes?: SortOrder
    dateLivraisonEffective?: SortOrder
    adresseLivraison?: SortOrder
    enregistrerParId?: SortOrder
    statut?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommandeSumOrderByAggregateInput = {
    id?: SortOrder
    panierId?: SortOrder
    clientId?: SortOrder
    adresseId?: SortOrder
    contactId?: SortOrder
    fournisseurId?: SortOrder
    commandeId?: SortOrder
    enregistrerParId?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumStatutCommandeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutCommande | EnumStatutCommandeFieldRefInput<$PrismaModel>
    in?: $Enums.StatutCommande[] | ListEnumStatutCommandeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatutCommande[] | ListEnumStatutCommandeFieldRefInput<$PrismaModel>
    not?: NestedEnumStatutCommandeWithAggregatesFilter<$PrismaModel> | $Enums.StatutCommande
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatutCommandeFilter<$PrismaModel>
    _max?: NestedEnumStatutCommandeFilter<$PrismaModel>
  }

  export type ClotureCaisseCountOrderByAggregateInput = {
    id?: SortOrder
    dateCloture?: SortOrder
    agentId?: SortOrder
    entrepriseId?: SortOrder
    updatedAt?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type ClotureCaisseAvgOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    entrepriseId?: SortOrder
  }

  export type ClotureCaisseMaxOrderByAggregateInput = {
    id?: SortOrder
    dateCloture?: SortOrder
    agentId?: SortOrder
    entrepriseId?: SortOrder
    updatedAt?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type ClotureCaisseMinOrderByAggregateInput = {
    id?: SortOrder
    dateCloture?: SortOrder
    agentId?: SortOrder
    entrepriseId?: SortOrder
    updatedAt?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type ClotureCaisseSumOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    entrepriseId?: SortOrder
  }

  export type EnumTypeMouvementCaisseFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeMouvementCaisse | EnumTypeMouvementCaisseFieldRefInput<$PrismaModel>
    in?: $Enums.TypeMouvementCaisse[] | ListEnumTypeMouvementCaisseFieldRefInput<$PrismaModel>
    notIn?: $Enums.TypeMouvementCaisse[] | ListEnumTypeMouvementCaisseFieldRefInput<$PrismaModel>
    not?: NestedEnumTypeMouvementCaisseFilter<$PrismaModel> | $Enums.TypeMouvementCaisse
  }

  export type EnumCategorieMouvementFilter<$PrismaModel = never> = {
    equals?: $Enums.CategorieMouvement | EnumCategorieMouvementFieldRefInput<$PrismaModel>
    in?: $Enums.CategorieMouvement[] | ListEnumCategorieMouvementFieldRefInput<$PrismaModel>
    notIn?: $Enums.CategorieMouvement[] | ListEnumCategorieMouvementFieldRefInput<$PrismaModel>
    not?: NestedEnumCategorieMouvementFilter<$PrismaModel> | $Enums.CategorieMouvement
  }

  export type MouvementCaisseCountOrderByAggregateInput = {
    id?: SortOrder
    caisseId?: SortOrder
    referenceExterne?: SortOrder
    type_mouvement?: SortOrder
    categorie?: SortOrder
    moyen_paiement?: SortOrder
    montant?: SortOrder
    description?: SortOrder
    agentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MouvementCaisseAvgOrderByAggregateInput = {
    id?: SortOrder
    caisseId?: SortOrder
    montant?: SortOrder
    agentId?: SortOrder
  }

  export type MouvementCaisseMaxOrderByAggregateInput = {
    id?: SortOrder
    caisseId?: SortOrder
    referenceExterne?: SortOrder
    type_mouvement?: SortOrder
    categorie?: SortOrder
    moyen_paiement?: SortOrder
    montant?: SortOrder
    description?: SortOrder
    agentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MouvementCaisseMinOrderByAggregateInput = {
    id?: SortOrder
    caisseId?: SortOrder
    referenceExterne?: SortOrder
    type_mouvement?: SortOrder
    categorie?: SortOrder
    moyen_paiement?: SortOrder
    montant?: SortOrder
    description?: SortOrder
    agentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MouvementCaisseSumOrderByAggregateInput = {
    id?: SortOrder
    caisseId?: SortOrder
    montant?: SortOrder
    agentId?: SortOrder
  }

  export type EnumTypeMouvementCaisseWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeMouvementCaisse | EnumTypeMouvementCaisseFieldRefInput<$PrismaModel>
    in?: $Enums.TypeMouvementCaisse[] | ListEnumTypeMouvementCaisseFieldRefInput<$PrismaModel>
    notIn?: $Enums.TypeMouvementCaisse[] | ListEnumTypeMouvementCaisseFieldRefInput<$PrismaModel>
    not?: NestedEnumTypeMouvementCaisseWithAggregatesFilter<$PrismaModel> | $Enums.TypeMouvementCaisse
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTypeMouvementCaisseFilter<$PrismaModel>
    _max?: NestedEnumTypeMouvementCaisseFilter<$PrismaModel>
  }

  export type EnumCategorieMouvementWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CategorieMouvement | EnumCategorieMouvementFieldRefInput<$PrismaModel>
    in?: $Enums.CategorieMouvement[] | ListEnumCategorieMouvementFieldRefInput<$PrismaModel>
    notIn?: $Enums.CategorieMouvement[] | ListEnumCategorieMouvementFieldRefInput<$PrismaModel>
    not?: NestedEnumCategorieMouvementWithAggregatesFilter<$PrismaModel> | $Enums.CategorieMouvement
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCategorieMouvementFilter<$PrismaModel>
    _max?: NestedEnumCategorieMouvementFilter<$PrismaModel>
  }

  export type AgentCreateNestedOneWithoutTeneursInput = {
    create?: XOR<AgentCreateWithoutTeneursInput, AgentUncheckedCreateWithoutTeneursInput>
    connectOrCreate?: AgentCreateOrConnectWithoutTeneursInput
    connect?: AgentWhereUniqueInput
  }

  export type ProduitCreateNestedManyWithoutTeneurInput = {
    create?: XOR<ProduitCreateWithoutTeneurInput, ProduitUncheckedCreateWithoutTeneurInput> | ProduitCreateWithoutTeneurInput[] | ProduitUncheckedCreateWithoutTeneurInput[]
    connectOrCreate?: ProduitCreateOrConnectWithoutTeneurInput | ProduitCreateOrConnectWithoutTeneurInput[]
    createMany?: ProduitCreateManyTeneurInputEnvelope
    connect?: ProduitWhereUniqueInput | ProduitWhereUniqueInput[]
  }

  export type ProduitUncheckedCreateNestedManyWithoutTeneurInput = {
    create?: XOR<ProduitCreateWithoutTeneurInput, ProduitUncheckedCreateWithoutTeneurInput> | ProduitCreateWithoutTeneurInput[] | ProduitUncheckedCreateWithoutTeneurInput[]
    connectOrCreate?: ProduitCreateOrConnectWithoutTeneurInput | ProduitCreateOrConnectWithoutTeneurInput[]
    createMany?: ProduitCreateManyTeneurInputEnvelope
    connect?: ProduitWhereUniqueInput | ProduitWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type AgentUpdateOneRequiredWithoutTeneursNestedInput = {
    create?: XOR<AgentCreateWithoutTeneursInput, AgentUncheckedCreateWithoutTeneursInput>
    connectOrCreate?: AgentCreateOrConnectWithoutTeneursInput
    upsert?: AgentUpsertWithoutTeneursInput
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutTeneursInput, AgentUpdateWithoutTeneursInput>, AgentUncheckedUpdateWithoutTeneursInput>
  }

  export type ProduitUpdateManyWithoutTeneurNestedInput = {
    create?: XOR<ProduitCreateWithoutTeneurInput, ProduitUncheckedCreateWithoutTeneurInput> | ProduitCreateWithoutTeneurInput[] | ProduitUncheckedCreateWithoutTeneurInput[]
    connectOrCreate?: ProduitCreateOrConnectWithoutTeneurInput | ProduitCreateOrConnectWithoutTeneurInput[]
    upsert?: ProduitUpsertWithWhereUniqueWithoutTeneurInput | ProduitUpsertWithWhereUniqueWithoutTeneurInput[]
    createMany?: ProduitCreateManyTeneurInputEnvelope
    set?: ProduitWhereUniqueInput | ProduitWhereUniqueInput[]
    disconnect?: ProduitWhereUniqueInput | ProduitWhereUniqueInput[]
    delete?: ProduitWhereUniqueInput | ProduitWhereUniqueInput[]
    connect?: ProduitWhereUniqueInput | ProduitWhereUniqueInput[]
    update?: ProduitUpdateWithWhereUniqueWithoutTeneurInput | ProduitUpdateWithWhereUniqueWithoutTeneurInput[]
    updateMany?: ProduitUpdateManyWithWhereWithoutTeneurInput | ProduitUpdateManyWithWhereWithoutTeneurInput[]
    deleteMany?: ProduitScalarWhereInput | ProduitScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProduitUncheckedUpdateManyWithoutTeneurNestedInput = {
    create?: XOR<ProduitCreateWithoutTeneurInput, ProduitUncheckedCreateWithoutTeneurInput> | ProduitCreateWithoutTeneurInput[] | ProduitUncheckedCreateWithoutTeneurInput[]
    connectOrCreate?: ProduitCreateOrConnectWithoutTeneurInput | ProduitCreateOrConnectWithoutTeneurInput[]
    upsert?: ProduitUpsertWithWhereUniqueWithoutTeneurInput | ProduitUpsertWithWhereUniqueWithoutTeneurInput[]
    createMany?: ProduitCreateManyTeneurInputEnvelope
    set?: ProduitWhereUniqueInput | ProduitWhereUniqueInput[]
    disconnect?: ProduitWhereUniqueInput | ProduitWhereUniqueInput[]
    delete?: ProduitWhereUniqueInput | ProduitWhereUniqueInput[]
    connect?: ProduitWhereUniqueInput | ProduitWhereUniqueInput[]
    update?: ProduitUpdateWithWhereUniqueWithoutTeneurInput | ProduitUpdateWithWhereUniqueWithoutTeneurInput[]
    updateMany?: ProduitUpdateManyWithWhereWithoutTeneurInput | ProduitUpdateManyWithWhereWithoutTeneurInput[]
    deleteMany?: ProduitScalarWhereInput | ProduitScalarWhereInput[]
  }

  export type AgentCreateNestedOneWithoutDevisesInput = {
    create?: XOR<AgentCreateWithoutDevisesInput, AgentUncheckedCreateWithoutDevisesInput>
    connectOrCreate?: AgentCreateOrConnectWithoutDevisesInput
    connect?: AgentWhereUniqueInput
  }

  export type ProduitCreateNestedManyWithoutDeviseInput = {
    create?: XOR<ProduitCreateWithoutDeviseInput, ProduitUncheckedCreateWithoutDeviseInput> | ProduitCreateWithoutDeviseInput[] | ProduitUncheckedCreateWithoutDeviseInput[]
    connectOrCreate?: ProduitCreateOrConnectWithoutDeviseInput | ProduitCreateOrConnectWithoutDeviseInput[]
    createMany?: ProduitCreateManyDeviseInputEnvelope
    connect?: ProduitWhereUniqueInput | ProduitWhereUniqueInput[]
  }

  export type PaiementCreateNestedManyWithoutDeviseInput = {
    create?: XOR<PaiementCreateWithoutDeviseInput, PaiementUncheckedCreateWithoutDeviseInput> | PaiementCreateWithoutDeviseInput[] | PaiementUncheckedCreateWithoutDeviseInput[]
    connectOrCreate?: PaiementCreateOrConnectWithoutDeviseInput | PaiementCreateOrConnectWithoutDeviseInput[]
    createMany?: PaiementCreateManyDeviseInputEnvelope
    connect?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
  }

  export type CaisseCreateNestedManyWithoutDeviseInput = {
    create?: XOR<CaisseCreateWithoutDeviseInput, CaisseUncheckedCreateWithoutDeviseInput> | CaisseCreateWithoutDeviseInput[] | CaisseUncheckedCreateWithoutDeviseInput[]
    connectOrCreate?: CaisseCreateOrConnectWithoutDeviseInput | CaisseCreateOrConnectWithoutDeviseInput[]
    createMany?: CaisseCreateManyDeviseInputEnvelope
    connect?: CaisseWhereUniqueInput | CaisseWhereUniqueInput[]
  }

  export type DetailPanierCreateNestedManyWithoutDeviseInput = {
    create?: XOR<DetailPanierCreateWithoutDeviseInput, DetailPanierUncheckedCreateWithoutDeviseInput> | DetailPanierCreateWithoutDeviseInput[] | DetailPanierUncheckedCreateWithoutDeviseInput[]
    connectOrCreate?: DetailPanierCreateOrConnectWithoutDeviseInput | DetailPanierCreateOrConnectWithoutDeviseInput[]
    createMany?: DetailPanierCreateManyDeviseInputEnvelope
    connect?: DetailPanierWhereUniqueInput | DetailPanierWhereUniqueInput[]
  }

  export type ProduitUncheckedCreateNestedManyWithoutDeviseInput = {
    create?: XOR<ProduitCreateWithoutDeviseInput, ProduitUncheckedCreateWithoutDeviseInput> | ProduitCreateWithoutDeviseInput[] | ProduitUncheckedCreateWithoutDeviseInput[]
    connectOrCreate?: ProduitCreateOrConnectWithoutDeviseInput | ProduitCreateOrConnectWithoutDeviseInput[]
    createMany?: ProduitCreateManyDeviseInputEnvelope
    connect?: ProduitWhereUniqueInput | ProduitWhereUniqueInput[]
  }

  export type PaiementUncheckedCreateNestedManyWithoutDeviseInput = {
    create?: XOR<PaiementCreateWithoutDeviseInput, PaiementUncheckedCreateWithoutDeviseInput> | PaiementCreateWithoutDeviseInput[] | PaiementUncheckedCreateWithoutDeviseInput[]
    connectOrCreate?: PaiementCreateOrConnectWithoutDeviseInput | PaiementCreateOrConnectWithoutDeviseInput[]
    createMany?: PaiementCreateManyDeviseInputEnvelope
    connect?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
  }

  export type CaisseUncheckedCreateNestedManyWithoutDeviseInput = {
    create?: XOR<CaisseCreateWithoutDeviseInput, CaisseUncheckedCreateWithoutDeviseInput> | CaisseCreateWithoutDeviseInput[] | CaisseUncheckedCreateWithoutDeviseInput[]
    connectOrCreate?: CaisseCreateOrConnectWithoutDeviseInput | CaisseCreateOrConnectWithoutDeviseInput[]
    createMany?: CaisseCreateManyDeviseInputEnvelope
    connect?: CaisseWhereUniqueInput | CaisseWhereUniqueInput[]
  }

  export type DetailPanierUncheckedCreateNestedManyWithoutDeviseInput = {
    create?: XOR<DetailPanierCreateWithoutDeviseInput, DetailPanierUncheckedCreateWithoutDeviseInput> | DetailPanierCreateWithoutDeviseInput[] | DetailPanierUncheckedCreateWithoutDeviseInput[]
    connectOrCreate?: DetailPanierCreateOrConnectWithoutDeviseInput | DetailPanierCreateOrConnectWithoutDeviseInput[]
    createMany?: DetailPanierCreateManyDeviseInputEnvelope
    connect?: DetailPanierWhereUniqueInput | DetailPanierWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type AgentUpdateOneRequiredWithoutDevisesNestedInput = {
    create?: XOR<AgentCreateWithoutDevisesInput, AgentUncheckedCreateWithoutDevisesInput>
    connectOrCreate?: AgentCreateOrConnectWithoutDevisesInput
    upsert?: AgentUpsertWithoutDevisesInput
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutDevisesInput, AgentUpdateWithoutDevisesInput>, AgentUncheckedUpdateWithoutDevisesInput>
  }

  export type ProduitUpdateManyWithoutDeviseNestedInput = {
    create?: XOR<ProduitCreateWithoutDeviseInput, ProduitUncheckedCreateWithoutDeviseInput> | ProduitCreateWithoutDeviseInput[] | ProduitUncheckedCreateWithoutDeviseInput[]
    connectOrCreate?: ProduitCreateOrConnectWithoutDeviseInput | ProduitCreateOrConnectWithoutDeviseInput[]
    upsert?: ProduitUpsertWithWhereUniqueWithoutDeviseInput | ProduitUpsertWithWhereUniqueWithoutDeviseInput[]
    createMany?: ProduitCreateManyDeviseInputEnvelope
    set?: ProduitWhereUniqueInput | ProduitWhereUniqueInput[]
    disconnect?: ProduitWhereUniqueInput | ProduitWhereUniqueInput[]
    delete?: ProduitWhereUniqueInput | ProduitWhereUniqueInput[]
    connect?: ProduitWhereUniqueInput | ProduitWhereUniqueInput[]
    update?: ProduitUpdateWithWhereUniqueWithoutDeviseInput | ProduitUpdateWithWhereUniqueWithoutDeviseInput[]
    updateMany?: ProduitUpdateManyWithWhereWithoutDeviseInput | ProduitUpdateManyWithWhereWithoutDeviseInput[]
    deleteMany?: ProduitScalarWhereInput | ProduitScalarWhereInput[]
  }

  export type PaiementUpdateManyWithoutDeviseNestedInput = {
    create?: XOR<PaiementCreateWithoutDeviseInput, PaiementUncheckedCreateWithoutDeviseInput> | PaiementCreateWithoutDeviseInput[] | PaiementUncheckedCreateWithoutDeviseInput[]
    connectOrCreate?: PaiementCreateOrConnectWithoutDeviseInput | PaiementCreateOrConnectWithoutDeviseInput[]
    upsert?: PaiementUpsertWithWhereUniqueWithoutDeviseInput | PaiementUpsertWithWhereUniqueWithoutDeviseInput[]
    createMany?: PaiementCreateManyDeviseInputEnvelope
    set?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    disconnect?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    delete?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    connect?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    update?: PaiementUpdateWithWhereUniqueWithoutDeviseInput | PaiementUpdateWithWhereUniqueWithoutDeviseInput[]
    updateMany?: PaiementUpdateManyWithWhereWithoutDeviseInput | PaiementUpdateManyWithWhereWithoutDeviseInput[]
    deleteMany?: PaiementScalarWhereInput | PaiementScalarWhereInput[]
  }

  export type CaisseUpdateManyWithoutDeviseNestedInput = {
    create?: XOR<CaisseCreateWithoutDeviseInput, CaisseUncheckedCreateWithoutDeviseInput> | CaisseCreateWithoutDeviseInput[] | CaisseUncheckedCreateWithoutDeviseInput[]
    connectOrCreate?: CaisseCreateOrConnectWithoutDeviseInput | CaisseCreateOrConnectWithoutDeviseInput[]
    upsert?: CaisseUpsertWithWhereUniqueWithoutDeviseInput | CaisseUpsertWithWhereUniqueWithoutDeviseInput[]
    createMany?: CaisseCreateManyDeviseInputEnvelope
    set?: CaisseWhereUniqueInput | CaisseWhereUniqueInput[]
    disconnect?: CaisseWhereUniqueInput | CaisseWhereUniqueInput[]
    delete?: CaisseWhereUniqueInput | CaisseWhereUniqueInput[]
    connect?: CaisseWhereUniqueInput | CaisseWhereUniqueInput[]
    update?: CaisseUpdateWithWhereUniqueWithoutDeviseInput | CaisseUpdateWithWhereUniqueWithoutDeviseInput[]
    updateMany?: CaisseUpdateManyWithWhereWithoutDeviseInput | CaisseUpdateManyWithWhereWithoutDeviseInput[]
    deleteMany?: CaisseScalarWhereInput | CaisseScalarWhereInput[]
  }

  export type DetailPanierUpdateManyWithoutDeviseNestedInput = {
    create?: XOR<DetailPanierCreateWithoutDeviseInput, DetailPanierUncheckedCreateWithoutDeviseInput> | DetailPanierCreateWithoutDeviseInput[] | DetailPanierUncheckedCreateWithoutDeviseInput[]
    connectOrCreate?: DetailPanierCreateOrConnectWithoutDeviseInput | DetailPanierCreateOrConnectWithoutDeviseInput[]
    upsert?: DetailPanierUpsertWithWhereUniqueWithoutDeviseInput | DetailPanierUpsertWithWhereUniqueWithoutDeviseInput[]
    createMany?: DetailPanierCreateManyDeviseInputEnvelope
    set?: DetailPanierWhereUniqueInput | DetailPanierWhereUniqueInput[]
    disconnect?: DetailPanierWhereUniqueInput | DetailPanierWhereUniqueInput[]
    delete?: DetailPanierWhereUniqueInput | DetailPanierWhereUniqueInput[]
    connect?: DetailPanierWhereUniqueInput | DetailPanierWhereUniqueInput[]
    update?: DetailPanierUpdateWithWhereUniqueWithoutDeviseInput | DetailPanierUpdateWithWhereUniqueWithoutDeviseInput[]
    updateMany?: DetailPanierUpdateManyWithWhereWithoutDeviseInput | DetailPanierUpdateManyWithWhereWithoutDeviseInput[]
    deleteMany?: DetailPanierScalarWhereInput | DetailPanierScalarWhereInput[]
  }

  export type ProduitUncheckedUpdateManyWithoutDeviseNestedInput = {
    create?: XOR<ProduitCreateWithoutDeviseInput, ProduitUncheckedCreateWithoutDeviseInput> | ProduitCreateWithoutDeviseInput[] | ProduitUncheckedCreateWithoutDeviseInput[]
    connectOrCreate?: ProduitCreateOrConnectWithoutDeviseInput | ProduitCreateOrConnectWithoutDeviseInput[]
    upsert?: ProduitUpsertWithWhereUniqueWithoutDeviseInput | ProduitUpsertWithWhereUniqueWithoutDeviseInput[]
    createMany?: ProduitCreateManyDeviseInputEnvelope
    set?: ProduitWhereUniqueInput | ProduitWhereUniqueInput[]
    disconnect?: ProduitWhereUniqueInput | ProduitWhereUniqueInput[]
    delete?: ProduitWhereUniqueInput | ProduitWhereUniqueInput[]
    connect?: ProduitWhereUniqueInput | ProduitWhereUniqueInput[]
    update?: ProduitUpdateWithWhereUniqueWithoutDeviseInput | ProduitUpdateWithWhereUniqueWithoutDeviseInput[]
    updateMany?: ProduitUpdateManyWithWhereWithoutDeviseInput | ProduitUpdateManyWithWhereWithoutDeviseInput[]
    deleteMany?: ProduitScalarWhereInput | ProduitScalarWhereInput[]
  }

  export type PaiementUncheckedUpdateManyWithoutDeviseNestedInput = {
    create?: XOR<PaiementCreateWithoutDeviseInput, PaiementUncheckedCreateWithoutDeviseInput> | PaiementCreateWithoutDeviseInput[] | PaiementUncheckedCreateWithoutDeviseInput[]
    connectOrCreate?: PaiementCreateOrConnectWithoutDeviseInput | PaiementCreateOrConnectWithoutDeviseInput[]
    upsert?: PaiementUpsertWithWhereUniqueWithoutDeviseInput | PaiementUpsertWithWhereUniqueWithoutDeviseInput[]
    createMany?: PaiementCreateManyDeviseInputEnvelope
    set?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    disconnect?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    delete?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    connect?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    update?: PaiementUpdateWithWhereUniqueWithoutDeviseInput | PaiementUpdateWithWhereUniqueWithoutDeviseInput[]
    updateMany?: PaiementUpdateManyWithWhereWithoutDeviseInput | PaiementUpdateManyWithWhereWithoutDeviseInput[]
    deleteMany?: PaiementScalarWhereInput | PaiementScalarWhereInput[]
  }

  export type CaisseUncheckedUpdateManyWithoutDeviseNestedInput = {
    create?: XOR<CaisseCreateWithoutDeviseInput, CaisseUncheckedCreateWithoutDeviseInput> | CaisseCreateWithoutDeviseInput[] | CaisseUncheckedCreateWithoutDeviseInput[]
    connectOrCreate?: CaisseCreateOrConnectWithoutDeviseInput | CaisseCreateOrConnectWithoutDeviseInput[]
    upsert?: CaisseUpsertWithWhereUniqueWithoutDeviseInput | CaisseUpsertWithWhereUniqueWithoutDeviseInput[]
    createMany?: CaisseCreateManyDeviseInputEnvelope
    set?: CaisseWhereUniqueInput | CaisseWhereUniqueInput[]
    disconnect?: CaisseWhereUniqueInput | CaisseWhereUniqueInput[]
    delete?: CaisseWhereUniqueInput | CaisseWhereUniqueInput[]
    connect?: CaisseWhereUniqueInput | CaisseWhereUniqueInput[]
    update?: CaisseUpdateWithWhereUniqueWithoutDeviseInput | CaisseUpdateWithWhereUniqueWithoutDeviseInput[]
    updateMany?: CaisseUpdateManyWithWhereWithoutDeviseInput | CaisseUpdateManyWithWhereWithoutDeviseInput[]
    deleteMany?: CaisseScalarWhereInput | CaisseScalarWhereInput[]
  }

  export type DetailPanierUncheckedUpdateManyWithoutDeviseNestedInput = {
    create?: XOR<DetailPanierCreateWithoutDeviseInput, DetailPanierUncheckedCreateWithoutDeviseInput> | DetailPanierCreateWithoutDeviseInput[] | DetailPanierUncheckedCreateWithoutDeviseInput[]
    connectOrCreate?: DetailPanierCreateOrConnectWithoutDeviseInput | DetailPanierCreateOrConnectWithoutDeviseInput[]
    upsert?: DetailPanierUpsertWithWhereUniqueWithoutDeviseInput | DetailPanierUpsertWithWhereUniqueWithoutDeviseInput[]
    createMany?: DetailPanierCreateManyDeviseInputEnvelope
    set?: DetailPanierWhereUniqueInput | DetailPanierWhereUniqueInput[]
    disconnect?: DetailPanierWhereUniqueInput | DetailPanierWhereUniqueInput[]
    delete?: DetailPanierWhereUniqueInput | DetailPanierWhereUniqueInput[]
    connect?: DetailPanierWhereUniqueInput | DetailPanierWhereUniqueInput[]
    update?: DetailPanierUpdateWithWhereUniqueWithoutDeviseInput | DetailPanierUpdateWithWhereUniqueWithoutDeviseInput[]
    updateMany?: DetailPanierUpdateManyWithWhereWithoutDeviseInput | DetailPanierUpdateManyWithWhereWithoutDeviseInput[]
    deleteMany?: DetailPanierScalarWhereInput | DetailPanierScalarWhereInput[]
  }

  export type ClotureCaisseCreateNestedManyWithoutEntrepriseInput = {
    create?: XOR<ClotureCaisseCreateWithoutEntrepriseInput, ClotureCaisseUncheckedCreateWithoutEntrepriseInput> | ClotureCaisseCreateWithoutEntrepriseInput[] | ClotureCaisseUncheckedCreateWithoutEntrepriseInput[]
    connectOrCreate?: ClotureCaisseCreateOrConnectWithoutEntrepriseInput | ClotureCaisseCreateOrConnectWithoutEntrepriseInput[]
    createMany?: ClotureCaisseCreateManyEntrepriseInputEnvelope
    connect?: ClotureCaisseWhereUniqueInput | ClotureCaisseWhereUniqueInput[]
  }

  export type AdresseCreateNestedManyWithoutEntrepriseInput = {
    create?: XOR<AdresseCreateWithoutEntrepriseInput, AdresseUncheckedCreateWithoutEntrepriseInput> | AdresseCreateWithoutEntrepriseInput[] | AdresseUncheckedCreateWithoutEntrepriseInput[]
    connectOrCreate?: AdresseCreateOrConnectWithoutEntrepriseInput | AdresseCreateOrConnectWithoutEntrepriseInput[]
    createMany?: AdresseCreateManyEntrepriseInputEnvelope
    connect?: AdresseWhereUniqueInput | AdresseWhereUniqueInput[]
  }

  export type ContactCreateNestedManyWithoutEntrepriseInput = {
    create?: XOR<ContactCreateWithoutEntrepriseInput, ContactUncheckedCreateWithoutEntrepriseInput> | ContactCreateWithoutEntrepriseInput[] | ContactUncheckedCreateWithoutEntrepriseInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutEntrepriseInput | ContactCreateOrConnectWithoutEntrepriseInput[]
    createMany?: ContactCreateManyEntrepriseInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type ClotureCaisseUncheckedCreateNestedManyWithoutEntrepriseInput = {
    create?: XOR<ClotureCaisseCreateWithoutEntrepriseInput, ClotureCaisseUncheckedCreateWithoutEntrepriseInput> | ClotureCaisseCreateWithoutEntrepriseInput[] | ClotureCaisseUncheckedCreateWithoutEntrepriseInput[]
    connectOrCreate?: ClotureCaisseCreateOrConnectWithoutEntrepriseInput | ClotureCaisseCreateOrConnectWithoutEntrepriseInput[]
    createMany?: ClotureCaisseCreateManyEntrepriseInputEnvelope
    connect?: ClotureCaisseWhereUniqueInput | ClotureCaisseWhereUniqueInput[]
  }

  export type AdresseUncheckedCreateNestedManyWithoutEntrepriseInput = {
    create?: XOR<AdresseCreateWithoutEntrepriseInput, AdresseUncheckedCreateWithoutEntrepriseInput> | AdresseCreateWithoutEntrepriseInput[] | AdresseUncheckedCreateWithoutEntrepriseInput[]
    connectOrCreate?: AdresseCreateOrConnectWithoutEntrepriseInput | AdresseCreateOrConnectWithoutEntrepriseInput[]
    createMany?: AdresseCreateManyEntrepriseInputEnvelope
    connect?: AdresseWhereUniqueInput | AdresseWhereUniqueInput[]
  }

  export type ContactUncheckedCreateNestedManyWithoutEntrepriseInput = {
    create?: XOR<ContactCreateWithoutEntrepriseInput, ContactUncheckedCreateWithoutEntrepriseInput> | ContactCreateWithoutEntrepriseInput[] | ContactUncheckedCreateWithoutEntrepriseInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutEntrepriseInput | ContactCreateOrConnectWithoutEntrepriseInput[]
    createMany?: ContactCreateManyEntrepriseInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type ClotureCaisseUpdateManyWithoutEntrepriseNestedInput = {
    create?: XOR<ClotureCaisseCreateWithoutEntrepriseInput, ClotureCaisseUncheckedCreateWithoutEntrepriseInput> | ClotureCaisseCreateWithoutEntrepriseInput[] | ClotureCaisseUncheckedCreateWithoutEntrepriseInput[]
    connectOrCreate?: ClotureCaisseCreateOrConnectWithoutEntrepriseInput | ClotureCaisseCreateOrConnectWithoutEntrepriseInput[]
    upsert?: ClotureCaisseUpsertWithWhereUniqueWithoutEntrepriseInput | ClotureCaisseUpsertWithWhereUniqueWithoutEntrepriseInput[]
    createMany?: ClotureCaisseCreateManyEntrepriseInputEnvelope
    set?: ClotureCaisseWhereUniqueInput | ClotureCaisseWhereUniqueInput[]
    disconnect?: ClotureCaisseWhereUniqueInput | ClotureCaisseWhereUniqueInput[]
    delete?: ClotureCaisseWhereUniqueInput | ClotureCaisseWhereUniqueInput[]
    connect?: ClotureCaisseWhereUniqueInput | ClotureCaisseWhereUniqueInput[]
    update?: ClotureCaisseUpdateWithWhereUniqueWithoutEntrepriseInput | ClotureCaisseUpdateWithWhereUniqueWithoutEntrepriseInput[]
    updateMany?: ClotureCaisseUpdateManyWithWhereWithoutEntrepriseInput | ClotureCaisseUpdateManyWithWhereWithoutEntrepriseInput[]
    deleteMany?: ClotureCaisseScalarWhereInput | ClotureCaisseScalarWhereInput[]
  }

  export type AdresseUpdateManyWithoutEntrepriseNestedInput = {
    create?: XOR<AdresseCreateWithoutEntrepriseInput, AdresseUncheckedCreateWithoutEntrepriseInput> | AdresseCreateWithoutEntrepriseInput[] | AdresseUncheckedCreateWithoutEntrepriseInput[]
    connectOrCreate?: AdresseCreateOrConnectWithoutEntrepriseInput | AdresseCreateOrConnectWithoutEntrepriseInput[]
    upsert?: AdresseUpsertWithWhereUniqueWithoutEntrepriseInput | AdresseUpsertWithWhereUniqueWithoutEntrepriseInput[]
    createMany?: AdresseCreateManyEntrepriseInputEnvelope
    set?: AdresseWhereUniqueInput | AdresseWhereUniqueInput[]
    disconnect?: AdresseWhereUniqueInput | AdresseWhereUniqueInput[]
    delete?: AdresseWhereUniqueInput | AdresseWhereUniqueInput[]
    connect?: AdresseWhereUniqueInput | AdresseWhereUniqueInput[]
    update?: AdresseUpdateWithWhereUniqueWithoutEntrepriseInput | AdresseUpdateWithWhereUniqueWithoutEntrepriseInput[]
    updateMany?: AdresseUpdateManyWithWhereWithoutEntrepriseInput | AdresseUpdateManyWithWhereWithoutEntrepriseInput[]
    deleteMany?: AdresseScalarWhereInput | AdresseScalarWhereInput[]
  }

  export type ContactUpdateManyWithoutEntrepriseNestedInput = {
    create?: XOR<ContactCreateWithoutEntrepriseInput, ContactUncheckedCreateWithoutEntrepriseInput> | ContactCreateWithoutEntrepriseInput[] | ContactUncheckedCreateWithoutEntrepriseInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutEntrepriseInput | ContactCreateOrConnectWithoutEntrepriseInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutEntrepriseInput | ContactUpsertWithWhereUniqueWithoutEntrepriseInput[]
    createMany?: ContactCreateManyEntrepriseInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutEntrepriseInput | ContactUpdateWithWhereUniqueWithoutEntrepriseInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutEntrepriseInput | ContactUpdateManyWithWhereWithoutEntrepriseInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type ClotureCaisseUncheckedUpdateManyWithoutEntrepriseNestedInput = {
    create?: XOR<ClotureCaisseCreateWithoutEntrepriseInput, ClotureCaisseUncheckedCreateWithoutEntrepriseInput> | ClotureCaisseCreateWithoutEntrepriseInput[] | ClotureCaisseUncheckedCreateWithoutEntrepriseInput[]
    connectOrCreate?: ClotureCaisseCreateOrConnectWithoutEntrepriseInput | ClotureCaisseCreateOrConnectWithoutEntrepriseInput[]
    upsert?: ClotureCaisseUpsertWithWhereUniqueWithoutEntrepriseInput | ClotureCaisseUpsertWithWhereUniqueWithoutEntrepriseInput[]
    createMany?: ClotureCaisseCreateManyEntrepriseInputEnvelope
    set?: ClotureCaisseWhereUniqueInput | ClotureCaisseWhereUniqueInput[]
    disconnect?: ClotureCaisseWhereUniqueInput | ClotureCaisseWhereUniqueInput[]
    delete?: ClotureCaisseWhereUniqueInput | ClotureCaisseWhereUniqueInput[]
    connect?: ClotureCaisseWhereUniqueInput | ClotureCaisseWhereUniqueInput[]
    update?: ClotureCaisseUpdateWithWhereUniqueWithoutEntrepriseInput | ClotureCaisseUpdateWithWhereUniqueWithoutEntrepriseInput[]
    updateMany?: ClotureCaisseUpdateManyWithWhereWithoutEntrepriseInput | ClotureCaisseUpdateManyWithWhereWithoutEntrepriseInput[]
    deleteMany?: ClotureCaisseScalarWhereInput | ClotureCaisseScalarWhereInput[]
  }

  export type AdresseUncheckedUpdateManyWithoutEntrepriseNestedInput = {
    create?: XOR<AdresseCreateWithoutEntrepriseInput, AdresseUncheckedCreateWithoutEntrepriseInput> | AdresseCreateWithoutEntrepriseInput[] | AdresseUncheckedCreateWithoutEntrepriseInput[]
    connectOrCreate?: AdresseCreateOrConnectWithoutEntrepriseInput | AdresseCreateOrConnectWithoutEntrepriseInput[]
    upsert?: AdresseUpsertWithWhereUniqueWithoutEntrepriseInput | AdresseUpsertWithWhereUniqueWithoutEntrepriseInput[]
    createMany?: AdresseCreateManyEntrepriseInputEnvelope
    set?: AdresseWhereUniqueInput | AdresseWhereUniqueInput[]
    disconnect?: AdresseWhereUniqueInput | AdresseWhereUniqueInput[]
    delete?: AdresseWhereUniqueInput | AdresseWhereUniqueInput[]
    connect?: AdresseWhereUniqueInput | AdresseWhereUniqueInput[]
    update?: AdresseUpdateWithWhereUniqueWithoutEntrepriseInput | AdresseUpdateWithWhereUniqueWithoutEntrepriseInput[]
    updateMany?: AdresseUpdateManyWithWhereWithoutEntrepriseInput | AdresseUpdateManyWithWhereWithoutEntrepriseInput[]
    deleteMany?: AdresseScalarWhereInput | AdresseScalarWhereInput[]
  }

  export type ContactUncheckedUpdateManyWithoutEntrepriseNestedInput = {
    create?: XOR<ContactCreateWithoutEntrepriseInput, ContactUncheckedCreateWithoutEntrepriseInput> | ContactCreateWithoutEntrepriseInput[] | ContactUncheckedCreateWithoutEntrepriseInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutEntrepriseInput | ContactCreateOrConnectWithoutEntrepriseInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutEntrepriseInput | ContactUpsertWithWhereUniqueWithoutEntrepriseInput[]
    createMany?: ContactCreateManyEntrepriseInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutEntrepriseInput | ContactUpdateWithWhereUniqueWithoutEntrepriseInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutEntrepriseInput | ContactUpdateManyWithWhereWithoutEntrepriseInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type AdresseCreateNestedManyWithoutAgentInput = {
    create?: XOR<AdresseCreateWithoutAgentInput, AdresseUncheckedCreateWithoutAgentInput> | AdresseCreateWithoutAgentInput[] | AdresseUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AdresseCreateOrConnectWithoutAgentInput | AdresseCreateOrConnectWithoutAgentInput[]
    createMany?: AdresseCreateManyAgentInputEnvelope
    connect?: AdresseWhereUniqueInput | AdresseWhereUniqueInput[]
  }

  export type ContactCreateNestedManyWithoutAgentInput = {
    create?: XOR<ContactCreateWithoutAgentInput, ContactUncheckedCreateWithoutAgentInput> | ContactCreateWithoutAgentInput[] | ContactUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutAgentInput | ContactCreateOrConnectWithoutAgentInput[]
    createMany?: ContactCreateManyAgentInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type ProduitCreateNestedManyWithoutAgentInput = {
    create?: XOR<ProduitCreateWithoutAgentInput, ProduitUncheckedCreateWithoutAgentInput> | ProduitCreateWithoutAgentInput[] | ProduitUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: ProduitCreateOrConnectWithoutAgentInput | ProduitCreateOrConnectWithoutAgentInput[]
    createMany?: ProduitCreateManyAgentInputEnvelope
    connect?: ProduitWhereUniqueInput | ProduitWhereUniqueInput[]
  }

  export type VenteCreateNestedManyWithoutAgentInput = {
    create?: XOR<VenteCreateWithoutAgentInput, VenteUncheckedCreateWithoutAgentInput> | VenteCreateWithoutAgentInput[] | VenteUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: VenteCreateOrConnectWithoutAgentInput | VenteCreateOrConnectWithoutAgentInput[]
    createMany?: VenteCreateManyAgentInputEnvelope
    connect?: VenteWhereUniqueInput | VenteWhereUniqueInput[]
  }

  export type AchatCreateNestedManyWithoutAgentInput = {
    create?: XOR<AchatCreateWithoutAgentInput, AchatUncheckedCreateWithoutAgentInput> | AchatCreateWithoutAgentInput[] | AchatUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AchatCreateOrConnectWithoutAgentInput | AchatCreateOrConnectWithoutAgentInput[]
    createMany?: AchatCreateManyAgentInputEnvelope
    connect?: AchatWhereUniqueInput | AchatWhereUniqueInput[]
  }

  export type TeneurCreateNestedManyWithoutAgentsInput = {
    create?: XOR<TeneurCreateWithoutAgentsInput, TeneurUncheckedCreateWithoutAgentsInput> | TeneurCreateWithoutAgentsInput[] | TeneurUncheckedCreateWithoutAgentsInput[]
    connectOrCreate?: TeneurCreateOrConnectWithoutAgentsInput | TeneurCreateOrConnectWithoutAgentsInput[]
    createMany?: TeneurCreateManyAgentsInputEnvelope
    connect?: TeneurWhereUniqueInput | TeneurWhereUniqueInput[]
  }

  export type DeviseCreateNestedManyWithoutAgentInput = {
    create?: XOR<DeviseCreateWithoutAgentInput, DeviseUncheckedCreateWithoutAgentInput> | DeviseCreateWithoutAgentInput[] | DeviseUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: DeviseCreateOrConnectWithoutAgentInput | DeviseCreateOrConnectWithoutAgentInput[]
    createMany?: DeviseCreateManyAgentInputEnvelope
    connect?: DeviseWhereUniqueInput | DeviseWhereUniqueInput[]
  }

  export type PanierCreateNestedManyWithoutAgentInput = {
    create?: XOR<PanierCreateWithoutAgentInput, PanierUncheckedCreateWithoutAgentInput> | PanierCreateWithoutAgentInput[] | PanierUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: PanierCreateOrConnectWithoutAgentInput | PanierCreateOrConnectWithoutAgentInput[]
    createMany?: PanierCreateManyAgentInputEnvelope
    connect?: PanierWhereUniqueInput | PanierWhereUniqueInput[]
  }

  export type CaisseCreateNestedManyWithoutAgentInput = {
    create?: XOR<CaisseCreateWithoutAgentInput, CaisseUncheckedCreateWithoutAgentInput> | CaisseCreateWithoutAgentInput[] | CaisseUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: CaisseCreateOrConnectWithoutAgentInput | CaisseCreateOrConnectWithoutAgentInput[]
    createMany?: CaisseCreateManyAgentInputEnvelope
    connect?: CaisseWhereUniqueInput | CaisseWhereUniqueInput[]
  }

  export type MouvementCaisseCreateNestedManyWithoutAgentInput = {
    create?: XOR<MouvementCaisseCreateWithoutAgentInput, MouvementCaisseUncheckedCreateWithoutAgentInput> | MouvementCaisseCreateWithoutAgentInput[] | MouvementCaisseUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: MouvementCaisseCreateOrConnectWithoutAgentInput | MouvementCaisseCreateOrConnectWithoutAgentInput[]
    createMany?: MouvementCaisseCreateManyAgentInputEnvelope
    connect?: MouvementCaisseWhereUniqueInput | MouvementCaisseWhereUniqueInput[]
  }

  export type ClotureCaisseCreateNestedManyWithoutAgentInput = {
    create?: XOR<ClotureCaisseCreateWithoutAgentInput, ClotureCaisseUncheckedCreateWithoutAgentInput> | ClotureCaisseCreateWithoutAgentInput[] | ClotureCaisseUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: ClotureCaisseCreateOrConnectWithoutAgentInput | ClotureCaisseCreateOrConnectWithoutAgentInput[]
    createMany?: ClotureCaisseCreateManyAgentInputEnvelope
    connect?: ClotureCaisseWhereUniqueInput | ClotureCaisseWhereUniqueInput[]
  }

  export type FournisseurCreateNestedManyWithoutAgentInput = {
    create?: XOR<FournisseurCreateWithoutAgentInput, FournisseurUncheckedCreateWithoutAgentInput> | FournisseurCreateWithoutAgentInput[] | FournisseurUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: FournisseurCreateOrConnectWithoutAgentInput | FournisseurCreateOrConnectWithoutAgentInput[]
    createMany?: FournisseurCreateManyAgentInputEnvelope
    connect?: FournisseurWhereUniqueInput | FournisseurWhereUniqueInput[]
  }

  export type AdresseUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<AdresseCreateWithoutAgentInput, AdresseUncheckedCreateWithoutAgentInput> | AdresseCreateWithoutAgentInput[] | AdresseUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AdresseCreateOrConnectWithoutAgentInput | AdresseCreateOrConnectWithoutAgentInput[]
    createMany?: AdresseCreateManyAgentInputEnvelope
    connect?: AdresseWhereUniqueInput | AdresseWhereUniqueInput[]
  }

  export type ContactUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<ContactCreateWithoutAgentInput, ContactUncheckedCreateWithoutAgentInput> | ContactCreateWithoutAgentInput[] | ContactUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutAgentInput | ContactCreateOrConnectWithoutAgentInput[]
    createMany?: ContactCreateManyAgentInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type ProduitUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<ProduitCreateWithoutAgentInput, ProduitUncheckedCreateWithoutAgentInput> | ProduitCreateWithoutAgentInput[] | ProduitUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: ProduitCreateOrConnectWithoutAgentInput | ProduitCreateOrConnectWithoutAgentInput[]
    createMany?: ProduitCreateManyAgentInputEnvelope
    connect?: ProduitWhereUniqueInput | ProduitWhereUniqueInput[]
  }

  export type VenteUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<VenteCreateWithoutAgentInput, VenteUncheckedCreateWithoutAgentInput> | VenteCreateWithoutAgentInput[] | VenteUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: VenteCreateOrConnectWithoutAgentInput | VenteCreateOrConnectWithoutAgentInput[]
    createMany?: VenteCreateManyAgentInputEnvelope
    connect?: VenteWhereUniqueInput | VenteWhereUniqueInput[]
  }

  export type AchatUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<AchatCreateWithoutAgentInput, AchatUncheckedCreateWithoutAgentInput> | AchatCreateWithoutAgentInput[] | AchatUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AchatCreateOrConnectWithoutAgentInput | AchatCreateOrConnectWithoutAgentInput[]
    createMany?: AchatCreateManyAgentInputEnvelope
    connect?: AchatWhereUniqueInput | AchatWhereUniqueInput[]
  }

  export type TeneurUncheckedCreateNestedManyWithoutAgentsInput = {
    create?: XOR<TeneurCreateWithoutAgentsInput, TeneurUncheckedCreateWithoutAgentsInput> | TeneurCreateWithoutAgentsInput[] | TeneurUncheckedCreateWithoutAgentsInput[]
    connectOrCreate?: TeneurCreateOrConnectWithoutAgentsInput | TeneurCreateOrConnectWithoutAgentsInput[]
    createMany?: TeneurCreateManyAgentsInputEnvelope
    connect?: TeneurWhereUniqueInput | TeneurWhereUniqueInput[]
  }

  export type DeviseUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<DeviseCreateWithoutAgentInput, DeviseUncheckedCreateWithoutAgentInput> | DeviseCreateWithoutAgentInput[] | DeviseUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: DeviseCreateOrConnectWithoutAgentInput | DeviseCreateOrConnectWithoutAgentInput[]
    createMany?: DeviseCreateManyAgentInputEnvelope
    connect?: DeviseWhereUniqueInput | DeviseWhereUniqueInput[]
  }

  export type PanierUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<PanierCreateWithoutAgentInput, PanierUncheckedCreateWithoutAgentInput> | PanierCreateWithoutAgentInput[] | PanierUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: PanierCreateOrConnectWithoutAgentInput | PanierCreateOrConnectWithoutAgentInput[]
    createMany?: PanierCreateManyAgentInputEnvelope
    connect?: PanierWhereUniqueInput | PanierWhereUniqueInput[]
  }

  export type CaisseUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<CaisseCreateWithoutAgentInput, CaisseUncheckedCreateWithoutAgentInput> | CaisseCreateWithoutAgentInput[] | CaisseUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: CaisseCreateOrConnectWithoutAgentInput | CaisseCreateOrConnectWithoutAgentInput[]
    createMany?: CaisseCreateManyAgentInputEnvelope
    connect?: CaisseWhereUniqueInput | CaisseWhereUniqueInput[]
  }

  export type MouvementCaisseUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<MouvementCaisseCreateWithoutAgentInput, MouvementCaisseUncheckedCreateWithoutAgentInput> | MouvementCaisseCreateWithoutAgentInput[] | MouvementCaisseUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: MouvementCaisseCreateOrConnectWithoutAgentInput | MouvementCaisseCreateOrConnectWithoutAgentInput[]
    createMany?: MouvementCaisseCreateManyAgentInputEnvelope
    connect?: MouvementCaisseWhereUniqueInput | MouvementCaisseWhereUniqueInput[]
  }

  export type ClotureCaisseUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<ClotureCaisseCreateWithoutAgentInput, ClotureCaisseUncheckedCreateWithoutAgentInput> | ClotureCaisseCreateWithoutAgentInput[] | ClotureCaisseUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: ClotureCaisseCreateOrConnectWithoutAgentInput | ClotureCaisseCreateOrConnectWithoutAgentInput[]
    createMany?: ClotureCaisseCreateManyAgentInputEnvelope
    connect?: ClotureCaisseWhereUniqueInput | ClotureCaisseWhereUniqueInput[]
  }

  export type FournisseurUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<FournisseurCreateWithoutAgentInput, FournisseurUncheckedCreateWithoutAgentInput> | FournisseurCreateWithoutAgentInput[] | FournisseurUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: FournisseurCreateOrConnectWithoutAgentInput | FournisseurCreateOrConnectWithoutAgentInput[]
    createMany?: FournisseurCreateManyAgentInputEnvelope
    connect?: FournisseurWhereUniqueInput | FournisseurWhereUniqueInput[]
  }

  export type NullableEnumSexeFieldUpdateOperationsInput = {
    set?: $Enums.Sexe | null
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type NullableEnumPosteFieldUpdateOperationsInput = {
    set?: $Enums.Poste | null
  }

  export type AdresseUpdateManyWithoutAgentNestedInput = {
    create?: XOR<AdresseCreateWithoutAgentInput, AdresseUncheckedCreateWithoutAgentInput> | AdresseCreateWithoutAgentInput[] | AdresseUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AdresseCreateOrConnectWithoutAgentInput | AdresseCreateOrConnectWithoutAgentInput[]
    upsert?: AdresseUpsertWithWhereUniqueWithoutAgentInput | AdresseUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: AdresseCreateManyAgentInputEnvelope
    set?: AdresseWhereUniqueInput | AdresseWhereUniqueInput[]
    disconnect?: AdresseWhereUniqueInput | AdresseWhereUniqueInput[]
    delete?: AdresseWhereUniqueInput | AdresseWhereUniqueInput[]
    connect?: AdresseWhereUniqueInput | AdresseWhereUniqueInput[]
    update?: AdresseUpdateWithWhereUniqueWithoutAgentInput | AdresseUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: AdresseUpdateManyWithWhereWithoutAgentInput | AdresseUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: AdresseScalarWhereInput | AdresseScalarWhereInput[]
  }

  export type ContactUpdateManyWithoutAgentNestedInput = {
    create?: XOR<ContactCreateWithoutAgentInput, ContactUncheckedCreateWithoutAgentInput> | ContactCreateWithoutAgentInput[] | ContactUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutAgentInput | ContactCreateOrConnectWithoutAgentInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutAgentInput | ContactUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: ContactCreateManyAgentInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutAgentInput | ContactUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutAgentInput | ContactUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type ProduitUpdateManyWithoutAgentNestedInput = {
    create?: XOR<ProduitCreateWithoutAgentInput, ProduitUncheckedCreateWithoutAgentInput> | ProduitCreateWithoutAgentInput[] | ProduitUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: ProduitCreateOrConnectWithoutAgentInput | ProduitCreateOrConnectWithoutAgentInput[]
    upsert?: ProduitUpsertWithWhereUniqueWithoutAgentInput | ProduitUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: ProduitCreateManyAgentInputEnvelope
    set?: ProduitWhereUniqueInput | ProduitWhereUniqueInput[]
    disconnect?: ProduitWhereUniqueInput | ProduitWhereUniqueInput[]
    delete?: ProduitWhereUniqueInput | ProduitWhereUniqueInput[]
    connect?: ProduitWhereUniqueInput | ProduitWhereUniqueInput[]
    update?: ProduitUpdateWithWhereUniqueWithoutAgentInput | ProduitUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: ProduitUpdateManyWithWhereWithoutAgentInput | ProduitUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: ProduitScalarWhereInput | ProduitScalarWhereInput[]
  }

  export type VenteUpdateManyWithoutAgentNestedInput = {
    create?: XOR<VenteCreateWithoutAgentInput, VenteUncheckedCreateWithoutAgentInput> | VenteCreateWithoutAgentInput[] | VenteUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: VenteCreateOrConnectWithoutAgentInput | VenteCreateOrConnectWithoutAgentInput[]
    upsert?: VenteUpsertWithWhereUniqueWithoutAgentInput | VenteUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: VenteCreateManyAgentInputEnvelope
    set?: VenteWhereUniqueInput | VenteWhereUniqueInput[]
    disconnect?: VenteWhereUniqueInput | VenteWhereUniqueInput[]
    delete?: VenteWhereUniqueInput | VenteWhereUniqueInput[]
    connect?: VenteWhereUniqueInput | VenteWhereUniqueInput[]
    update?: VenteUpdateWithWhereUniqueWithoutAgentInput | VenteUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: VenteUpdateManyWithWhereWithoutAgentInput | VenteUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: VenteScalarWhereInput | VenteScalarWhereInput[]
  }

  export type AchatUpdateManyWithoutAgentNestedInput = {
    create?: XOR<AchatCreateWithoutAgentInput, AchatUncheckedCreateWithoutAgentInput> | AchatCreateWithoutAgentInput[] | AchatUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AchatCreateOrConnectWithoutAgentInput | AchatCreateOrConnectWithoutAgentInput[]
    upsert?: AchatUpsertWithWhereUniqueWithoutAgentInput | AchatUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: AchatCreateManyAgentInputEnvelope
    set?: AchatWhereUniqueInput | AchatWhereUniqueInput[]
    disconnect?: AchatWhereUniqueInput | AchatWhereUniqueInput[]
    delete?: AchatWhereUniqueInput | AchatWhereUniqueInput[]
    connect?: AchatWhereUniqueInput | AchatWhereUniqueInput[]
    update?: AchatUpdateWithWhereUniqueWithoutAgentInput | AchatUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: AchatUpdateManyWithWhereWithoutAgentInput | AchatUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: AchatScalarWhereInput | AchatScalarWhereInput[]
  }

  export type TeneurUpdateManyWithoutAgentsNestedInput = {
    create?: XOR<TeneurCreateWithoutAgentsInput, TeneurUncheckedCreateWithoutAgentsInput> | TeneurCreateWithoutAgentsInput[] | TeneurUncheckedCreateWithoutAgentsInput[]
    connectOrCreate?: TeneurCreateOrConnectWithoutAgentsInput | TeneurCreateOrConnectWithoutAgentsInput[]
    upsert?: TeneurUpsertWithWhereUniqueWithoutAgentsInput | TeneurUpsertWithWhereUniqueWithoutAgentsInput[]
    createMany?: TeneurCreateManyAgentsInputEnvelope
    set?: TeneurWhereUniqueInput | TeneurWhereUniqueInput[]
    disconnect?: TeneurWhereUniqueInput | TeneurWhereUniqueInput[]
    delete?: TeneurWhereUniqueInput | TeneurWhereUniqueInput[]
    connect?: TeneurWhereUniqueInput | TeneurWhereUniqueInput[]
    update?: TeneurUpdateWithWhereUniqueWithoutAgentsInput | TeneurUpdateWithWhereUniqueWithoutAgentsInput[]
    updateMany?: TeneurUpdateManyWithWhereWithoutAgentsInput | TeneurUpdateManyWithWhereWithoutAgentsInput[]
    deleteMany?: TeneurScalarWhereInput | TeneurScalarWhereInput[]
  }

  export type DeviseUpdateManyWithoutAgentNestedInput = {
    create?: XOR<DeviseCreateWithoutAgentInput, DeviseUncheckedCreateWithoutAgentInput> | DeviseCreateWithoutAgentInput[] | DeviseUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: DeviseCreateOrConnectWithoutAgentInput | DeviseCreateOrConnectWithoutAgentInput[]
    upsert?: DeviseUpsertWithWhereUniqueWithoutAgentInput | DeviseUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: DeviseCreateManyAgentInputEnvelope
    set?: DeviseWhereUniqueInput | DeviseWhereUniqueInput[]
    disconnect?: DeviseWhereUniqueInput | DeviseWhereUniqueInput[]
    delete?: DeviseWhereUniqueInput | DeviseWhereUniqueInput[]
    connect?: DeviseWhereUniqueInput | DeviseWhereUniqueInput[]
    update?: DeviseUpdateWithWhereUniqueWithoutAgentInput | DeviseUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: DeviseUpdateManyWithWhereWithoutAgentInput | DeviseUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: DeviseScalarWhereInput | DeviseScalarWhereInput[]
  }

  export type PanierUpdateManyWithoutAgentNestedInput = {
    create?: XOR<PanierCreateWithoutAgentInput, PanierUncheckedCreateWithoutAgentInput> | PanierCreateWithoutAgentInput[] | PanierUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: PanierCreateOrConnectWithoutAgentInput | PanierCreateOrConnectWithoutAgentInput[]
    upsert?: PanierUpsertWithWhereUniqueWithoutAgentInput | PanierUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: PanierCreateManyAgentInputEnvelope
    set?: PanierWhereUniqueInput | PanierWhereUniqueInput[]
    disconnect?: PanierWhereUniqueInput | PanierWhereUniqueInput[]
    delete?: PanierWhereUniqueInput | PanierWhereUniqueInput[]
    connect?: PanierWhereUniqueInput | PanierWhereUniqueInput[]
    update?: PanierUpdateWithWhereUniqueWithoutAgentInput | PanierUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: PanierUpdateManyWithWhereWithoutAgentInput | PanierUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: PanierScalarWhereInput | PanierScalarWhereInput[]
  }

  export type CaisseUpdateManyWithoutAgentNestedInput = {
    create?: XOR<CaisseCreateWithoutAgentInput, CaisseUncheckedCreateWithoutAgentInput> | CaisseCreateWithoutAgentInput[] | CaisseUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: CaisseCreateOrConnectWithoutAgentInput | CaisseCreateOrConnectWithoutAgentInput[]
    upsert?: CaisseUpsertWithWhereUniqueWithoutAgentInput | CaisseUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: CaisseCreateManyAgentInputEnvelope
    set?: CaisseWhereUniqueInput | CaisseWhereUniqueInput[]
    disconnect?: CaisseWhereUniqueInput | CaisseWhereUniqueInput[]
    delete?: CaisseWhereUniqueInput | CaisseWhereUniqueInput[]
    connect?: CaisseWhereUniqueInput | CaisseWhereUniqueInput[]
    update?: CaisseUpdateWithWhereUniqueWithoutAgentInput | CaisseUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: CaisseUpdateManyWithWhereWithoutAgentInput | CaisseUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: CaisseScalarWhereInput | CaisseScalarWhereInput[]
  }

  export type MouvementCaisseUpdateManyWithoutAgentNestedInput = {
    create?: XOR<MouvementCaisseCreateWithoutAgentInput, MouvementCaisseUncheckedCreateWithoutAgentInput> | MouvementCaisseCreateWithoutAgentInput[] | MouvementCaisseUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: MouvementCaisseCreateOrConnectWithoutAgentInput | MouvementCaisseCreateOrConnectWithoutAgentInput[]
    upsert?: MouvementCaisseUpsertWithWhereUniqueWithoutAgentInput | MouvementCaisseUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: MouvementCaisseCreateManyAgentInputEnvelope
    set?: MouvementCaisseWhereUniqueInput | MouvementCaisseWhereUniqueInput[]
    disconnect?: MouvementCaisseWhereUniqueInput | MouvementCaisseWhereUniqueInput[]
    delete?: MouvementCaisseWhereUniqueInput | MouvementCaisseWhereUniqueInput[]
    connect?: MouvementCaisseWhereUniqueInput | MouvementCaisseWhereUniqueInput[]
    update?: MouvementCaisseUpdateWithWhereUniqueWithoutAgentInput | MouvementCaisseUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: MouvementCaisseUpdateManyWithWhereWithoutAgentInput | MouvementCaisseUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: MouvementCaisseScalarWhereInput | MouvementCaisseScalarWhereInput[]
  }

  export type ClotureCaisseUpdateManyWithoutAgentNestedInput = {
    create?: XOR<ClotureCaisseCreateWithoutAgentInput, ClotureCaisseUncheckedCreateWithoutAgentInput> | ClotureCaisseCreateWithoutAgentInput[] | ClotureCaisseUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: ClotureCaisseCreateOrConnectWithoutAgentInput | ClotureCaisseCreateOrConnectWithoutAgentInput[]
    upsert?: ClotureCaisseUpsertWithWhereUniqueWithoutAgentInput | ClotureCaisseUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: ClotureCaisseCreateManyAgentInputEnvelope
    set?: ClotureCaisseWhereUniqueInput | ClotureCaisseWhereUniqueInput[]
    disconnect?: ClotureCaisseWhereUniqueInput | ClotureCaisseWhereUniqueInput[]
    delete?: ClotureCaisseWhereUniqueInput | ClotureCaisseWhereUniqueInput[]
    connect?: ClotureCaisseWhereUniqueInput | ClotureCaisseWhereUniqueInput[]
    update?: ClotureCaisseUpdateWithWhereUniqueWithoutAgentInput | ClotureCaisseUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: ClotureCaisseUpdateManyWithWhereWithoutAgentInput | ClotureCaisseUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: ClotureCaisseScalarWhereInput | ClotureCaisseScalarWhereInput[]
  }

  export type FournisseurUpdateManyWithoutAgentNestedInput = {
    create?: XOR<FournisseurCreateWithoutAgentInput, FournisseurUncheckedCreateWithoutAgentInput> | FournisseurCreateWithoutAgentInput[] | FournisseurUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: FournisseurCreateOrConnectWithoutAgentInput | FournisseurCreateOrConnectWithoutAgentInput[]
    upsert?: FournisseurUpsertWithWhereUniqueWithoutAgentInput | FournisseurUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: FournisseurCreateManyAgentInputEnvelope
    set?: FournisseurWhereUniqueInput | FournisseurWhereUniqueInput[]
    disconnect?: FournisseurWhereUniqueInput | FournisseurWhereUniqueInput[]
    delete?: FournisseurWhereUniqueInput | FournisseurWhereUniqueInput[]
    connect?: FournisseurWhereUniqueInput | FournisseurWhereUniqueInput[]
    update?: FournisseurUpdateWithWhereUniqueWithoutAgentInput | FournisseurUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: FournisseurUpdateManyWithWhereWithoutAgentInput | FournisseurUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: FournisseurScalarWhereInput | FournisseurScalarWhereInput[]
  }

  export type AdresseUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<AdresseCreateWithoutAgentInput, AdresseUncheckedCreateWithoutAgentInput> | AdresseCreateWithoutAgentInput[] | AdresseUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AdresseCreateOrConnectWithoutAgentInput | AdresseCreateOrConnectWithoutAgentInput[]
    upsert?: AdresseUpsertWithWhereUniqueWithoutAgentInput | AdresseUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: AdresseCreateManyAgentInputEnvelope
    set?: AdresseWhereUniqueInput | AdresseWhereUniqueInput[]
    disconnect?: AdresseWhereUniqueInput | AdresseWhereUniqueInput[]
    delete?: AdresseWhereUniqueInput | AdresseWhereUniqueInput[]
    connect?: AdresseWhereUniqueInput | AdresseWhereUniqueInput[]
    update?: AdresseUpdateWithWhereUniqueWithoutAgentInput | AdresseUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: AdresseUpdateManyWithWhereWithoutAgentInput | AdresseUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: AdresseScalarWhereInput | AdresseScalarWhereInput[]
  }

  export type ContactUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<ContactCreateWithoutAgentInput, ContactUncheckedCreateWithoutAgentInput> | ContactCreateWithoutAgentInput[] | ContactUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutAgentInput | ContactCreateOrConnectWithoutAgentInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutAgentInput | ContactUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: ContactCreateManyAgentInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutAgentInput | ContactUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutAgentInput | ContactUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type ProduitUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<ProduitCreateWithoutAgentInput, ProduitUncheckedCreateWithoutAgentInput> | ProduitCreateWithoutAgentInput[] | ProduitUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: ProduitCreateOrConnectWithoutAgentInput | ProduitCreateOrConnectWithoutAgentInput[]
    upsert?: ProduitUpsertWithWhereUniqueWithoutAgentInput | ProduitUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: ProduitCreateManyAgentInputEnvelope
    set?: ProduitWhereUniqueInput | ProduitWhereUniqueInput[]
    disconnect?: ProduitWhereUniqueInput | ProduitWhereUniqueInput[]
    delete?: ProduitWhereUniqueInput | ProduitWhereUniqueInput[]
    connect?: ProduitWhereUniqueInput | ProduitWhereUniqueInput[]
    update?: ProduitUpdateWithWhereUniqueWithoutAgentInput | ProduitUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: ProduitUpdateManyWithWhereWithoutAgentInput | ProduitUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: ProduitScalarWhereInput | ProduitScalarWhereInput[]
  }

  export type VenteUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<VenteCreateWithoutAgentInput, VenteUncheckedCreateWithoutAgentInput> | VenteCreateWithoutAgentInput[] | VenteUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: VenteCreateOrConnectWithoutAgentInput | VenteCreateOrConnectWithoutAgentInput[]
    upsert?: VenteUpsertWithWhereUniqueWithoutAgentInput | VenteUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: VenteCreateManyAgentInputEnvelope
    set?: VenteWhereUniqueInput | VenteWhereUniqueInput[]
    disconnect?: VenteWhereUniqueInput | VenteWhereUniqueInput[]
    delete?: VenteWhereUniqueInput | VenteWhereUniqueInput[]
    connect?: VenteWhereUniqueInput | VenteWhereUniqueInput[]
    update?: VenteUpdateWithWhereUniqueWithoutAgentInput | VenteUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: VenteUpdateManyWithWhereWithoutAgentInput | VenteUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: VenteScalarWhereInput | VenteScalarWhereInput[]
  }

  export type AchatUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<AchatCreateWithoutAgentInput, AchatUncheckedCreateWithoutAgentInput> | AchatCreateWithoutAgentInput[] | AchatUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AchatCreateOrConnectWithoutAgentInput | AchatCreateOrConnectWithoutAgentInput[]
    upsert?: AchatUpsertWithWhereUniqueWithoutAgentInput | AchatUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: AchatCreateManyAgentInputEnvelope
    set?: AchatWhereUniqueInput | AchatWhereUniqueInput[]
    disconnect?: AchatWhereUniqueInput | AchatWhereUniqueInput[]
    delete?: AchatWhereUniqueInput | AchatWhereUniqueInput[]
    connect?: AchatWhereUniqueInput | AchatWhereUniqueInput[]
    update?: AchatUpdateWithWhereUniqueWithoutAgentInput | AchatUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: AchatUpdateManyWithWhereWithoutAgentInput | AchatUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: AchatScalarWhereInput | AchatScalarWhereInput[]
  }

  export type TeneurUncheckedUpdateManyWithoutAgentsNestedInput = {
    create?: XOR<TeneurCreateWithoutAgentsInput, TeneurUncheckedCreateWithoutAgentsInput> | TeneurCreateWithoutAgentsInput[] | TeneurUncheckedCreateWithoutAgentsInput[]
    connectOrCreate?: TeneurCreateOrConnectWithoutAgentsInput | TeneurCreateOrConnectWithoutAgentsInput[]
    upsert?: TeneurUpsertWithWhereUniqueWithoutAgentsInput | TeneurUpsertWithWhereUniqueWithoutAgentsInput[]
    createMany?: TeneurCreateManyAgentsInputEnvelope
    set?: TeneurWhereUniqueInput | TeneurWhereUniqueInput[]
    disconnect?: TeneurWhereUniqueInput | TeneurWhereUniqueInput[]
    delete?: TeneurWhereUniqueInput | TeneurWhereUniqueInput[]
    connect?: TeneurWhereUniqueInput | TeneurWhereUniqueInput[]
    update?: TeneurUpdateWithWhereUniqueWithoutAgentsInput | TeneurUpdateWithWhereUniqueWithoutAgentsInput[]
    updateMany?: TeneurUpdateManyWithWhereWithoutAgentsInput | TeneurUpdateManyWithWhereWithoutAgentsInput[]
    deleteMany?: TeneurScalarWhereInput | TeneurScalarWhereInput[]
  }

  export type DeviseUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<DeviseCreateWithoutAgentInput, DeviseUncheckedCreateWithoutAgentInput> | DeviseCreateWithoutAgentInput[] | DeviseUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: DeviseCreateOrConnectWithoutAgentInput | DeviseCreateOrConnectWithoutAgentInput[]
    upsert?: DeviseUpsertWithWhereUniqueWithoutAgentInput | DeviseUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: DeviseCreateManyAgentInputEnvelope
    set?: DeviseWhereUniqueInput | DeviseWhereUniqueInput[]
    disconnect?: DeviseWhereUniqueInput | DeviseWhereUniqueInput[]
    delete?: DeviseWhereUniqueInput | DeviseWhereUniqueInput[]
    connect?: DeviseWhereUniqueInput | DeviseWhereUniqueInput[]
    update?: DeviseUpdateWithWhereUniqueWithoutAgentInput | DeviseUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: DeviseUpdateManyWithWhereWithoutAgentInput | DeviseUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: DeviseScalarWhereInput | DeviseScalarWhereInput[]
  }

  export type PanierUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<PanierCreateWithoutAgentInput, PanierUncheckedCreateWithoutAgentInput> | PanierCreateWithoutAgentInput[] | PanierUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: PanierCreateOrConnectWithoutAgentInput | PanierCreateOrConnectWithoutAgentInput[]
    upsert?: PanierUpsertWithWhereUniqueWithoutAgentInput | PanierUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: PanierCreateManyAgentInputEnvelope
    set?: PanierWhereUniqueInput | PanierWhereUniqueInput[]
    disconnect?: PanierWhereUniqueInput | PanierWhereUniqueInput[]
    delete?: PanierWhereUniqueInput | PanierWhereUniqueInput[]
    connect?: PanierWhereUniqueInput | PanierWhereUniqueInput[]
    update?: PanierUpdateWithWhereUniqueWithoutAgentInput | PanierUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: PanierUpdateManyWithWhereWithoutAgentInput | PanierUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: PanierScalarWhereInput | PanierScalarWhereInput[]
  }

  export type CaisseUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<CaisseCreateWithoutAgentInput, CaisseUncheckedCreateWithoutAgentInput> | CaisseCreateWithoutAgentInput[] | CaisseUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: CaisseCreateOrConnectWithoutAgentInput | CaisseCreateOrConnectWithoutAgentInput[]
    upsert?: CaisseUpsertWithWhereUniqueWithoutAgentInput | CaisseUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: CaisseCreateManyAgentInputEnvelope
    set?: CaisseWhereUniqueInput | CaisseWhereUniqueInput[]
    disconnect?: CaisseWhereUniqueInput | CaisseWhereUniqueInput[]
    delete?: CaisseWhereUniqueInput | CaisseWhereUniqueInput[]
    connect?: CaisseWhereUniqueInput | CaisseWhereUniqueInput[]
    update?: CaisseUpdateWithWhereUniqueWithoutAgentInput | CaisseUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: CaisseUpdateManyWithWhereWithoutAgentInput | CaisseUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: CaisseScalarWhereInput | CaisseScalarWhereInput[]
  }

  export type MouvementCaisseUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<MouvementCaisseCreateWithoutAgentInput, MouvementCaisseUncheckedCreateWithoutAgentInput> | MouvementCaisseCreateWithoutAgentInput[] | MouvementCaisseUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: MouvementCaisseCreateOrConnectWithoutAgentInput | MouvementCaisseCreateOrConnectWithoutAgentInput[]
    upsert?: MouvementCaisseUpsertWithWhereUniqueWithoutAgentInput | MouvementCaisseUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: MouvementCaisseCreateManyAgentInputEnvelope
    set?: MouvementCaisseWhereUniqueInput | MouvementCaisseWhereUniqueInput[]
    disconnect?: MouvementCaisseWhereUniqueInput | MouvementCaisseWhereUniqueInput[]
    delete?: MouvementCaisseWhereUniqueInput | MouvementCaisseWhereUniqueInput[]
    connect?: MouvementCaisseWhereUniqueInput | MouvementCaisseWhereUniqueInput[]
    update?: MouvementCaisseUpdateWithWhereUniqueWithoutAgentInput | MouvementCaisseUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: MouvementCaisseUpdateManyWithWhereWithoutAgentInput | MouvementCaisseUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: MouvementCaisseScalarWhereInput | MouvementCaisseScalarWhereInput[]
  }

  export type ClotureCaisseUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<ClotureCaisseCreateWithoutAgentInput, ClotureCaisseUncheckedCreateWithoutAgentInput> | ClotureCaisseCreateWithoutAgentInput[] | ClotureCaisseUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: ClotureCaisseCreateOrConnectWithoutAgentInput | ClotureCaisseCreateOrConnectWithoutAgentInput[]
    upsert?: ClotureCaisseUpsertWithWhereUniqueWithoutAgentInput | ClotureCaisseUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: ClotureCaisseCreateManyAgentInputEnvelope
    set?: ClotureCaisseWhereUniqueInput | ClotureCaisseWhereUniqueInput[]
    disconnect?: ClotureCaisseWhereUniqueInput | ClotureCaisseWhereUniqueInput[]
    delete?: ClotureCaisseWhereUniqueInput | ClotureCaisseWhereUniqueInput[]
    connect?: ClotureCaisseWhereUniqueInput | ClotureCaisseWhereUniqueInput[]
    update?: ClotureCaisseUpdateWithWhereUniqueWithoutAgentInput | ClotureCaisseUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: ClotureCaisseUpdateManyWithWhereWithoutAgentInput | ClotureCaisseUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: ClotureCaisseScalarWhereInput | ClotureCaisseScalarWhereInput[]
  }

  export type FournisseurUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<FournisseurCreateWithoutAgentInput, FournisseurUncheckedCreateWithoutAgentInput> | FournisseurCreateWithoutAgentInput[] | FournisseurUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: FournisseurCreateOrConnectWithoutAgentInput | FournisseurCreateOrConnectWithoutAgentInput[]
    upsert?: FournisseurUpsertWithWhereUniqueWithoutAgentInput | FournisseurUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: FournisseurCreateManyAgentInputEnvelope
    set?: FournisseurWhereUniqueInput | FournisseurWhereUniqueInput[]
    disconnect?: FournisseurWhereUniqueInput | FournisseurWhereUniqueInput[]
    delete?: FournisseurWhereUniqueInput | FournisseurWhereUniqueInput[]
    connect?: FournisseurWhereUniqueInput | FournisseurWhereUniqueInput[]
    update?: FournisseurUpdateWithWhereUniqueWithoutAgentInput | FournisseurUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: FournisseurUpdateManyWithWhereWithoutAgentInput | FournisseurUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: FournisseurScalarWhereInput | FournisseurScalarWhereInput[]
  }

  export type AdresseCreateNestedManyWithoutClientInput = {
    create?: XOR<AdresseCreateWithoutClientInput, AdresseUncheckedCreateWithoutClientInput> | AdresseCreateWithoutClientInput[] | AdresseUncheckedCreateWithoutClientInput[]
    connectOrCreate?: AdresseCreateOrConnectWithoutClientInput | AdresseCreateOrConnectWithoutClientInput[]
    createMany?: AdresseCreateManyClientInputEnvelope
    connect?: AdresseWhereUniqueInput | AdresseWhereUniqueInput[]
  }

  export type ContactCreateNestedManyWithoutClientInput = {
    create?: XOR<ContactCreateWithoutClientInput, ContactUncheckedCreateWithoutClientInput> | ContactCreateWithoutClientInput[] | ContactUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutClientInput | ContactCreateOrConnectWithoutClientInput[]
    createMany?: ContactCreateManyClientInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type VenteCreateNestedManyWithoutClientInput = {
    create?: XOR<VenteCreateWithoutClientInput, VenteUncheckedCreateWithoutClientInput> | VenteCreateWithoutClientInput[] | VenteUncheckedCreateWithoutClientInput[]
    connectOrCreate?: VenteCreateOrConnectWithoutClientInput | VenteCreateOrConnectWithoutClientInput[]
    createMany?: VenteCreateManyClientInputEnvelope
    connect?: VenteWhereUniqueInput | VenteWhereUniqueInput[]
  }

  export type AchatCreateNestedManyWithoutClientInput = {
    create?: XOR<AchatCreateWithoutClientInput, AchatUncheckedCreateWithoutClientInput> | AchatCreateWithoutClientInput[] | AchatUncheckedCreateWithoutClientInput[]
    connectOrCreate?: AchatCreateOrConnectWithoutClientInput | AchatCreateOrConnectWithoutClientInput[]
    createMany?: AchatCreateManyClientInputEnvelope
    connect?: AchatWhereUniqueInput | AchatWhereUniqueInput[]
  }

  export type PanierCreateNestedManyWithoutClientInput = {
    create?: XOR<PanierCreateWithoutClientInput, PanierUncheckedCreateWithoutClientInput> | PanierCreateWithoutClientInput[] | PanierUncheckedCreateWithoutClientInput[]
    connectOrCreate?: PanierCreateOrConnectWithoutClientInput | PanierCreateOrConnectWithoutClientInput[]
    createMany?: PanierCreateManyClientInputEnvelope
    connect?: PanierWhereUniqueInput | PanierWhereUniqueInput[]
  }

  export type ReservationCreateNestedManyWithoutClientInput = {
    create?: XOR<ReservationCreateWithoutClientInput, ReservationUncheckedCreateWithoutClientInput> | ReservationCreateWithoutClientInput[] | ReservationUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutClientInput | ReservationCreateOrConnectWithoutClientInput[]
    createMany?: ReservationCreateManyClientInputEnvelope
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
  }

  export type CommandeCreateNestedManyWithoutClientInput = {
    create?: XOR<CommandeCreateWithoutClientInput, CommandeUncheckedCreateWithoutClientInput> | CommandeCreateWithoutClientInput[] | CommandeUncheckedCreateWithoutClientInput[]
    connectOrCreate?: CommandeCreateOrConnectWithoutClientInput | CommandeCreateOrConnectWithoutClientInput[]
    createMany?: CommandeCreateManyClientInputEnvelope
    connect?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
  }

  export type AdresseUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<AdresseCreateWithoutClientInput, AdresseUncheckedCreateWithoutClientInput> | AdresseCreateWithoutClientInput[] | AdresseUncheckedCreateWithoutClientInput[]
    connectOrCreate?: AdresseCreateOrConnectWithoutClientInput | AdresseCreateOrConnectWithoutClientInput[]
    createMany?: AdresseCreateManyClientInputEnvelope
    connect?: AdresseWhereUniqueInput | AdresseWhereUniqueInput[]
  }

  export type ContactUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<ContactCreateWithoutClientInput, ContactUncheckedCreateWithoutClientInput> | ContactCreateWithoutClientInput[] | ContactUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutClientInput | ContactCreateOrConnectWithoutClientInput[]
    createMany?: ContactCreateManyClientInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type VenteUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<VenteCreateWithoutClientInput, VenteUncheckedCreateWithoutClientInput> | VenteCreateWithoutClientInput[] | VenteUncheckedCreateWithoutClientInput[]
    connectOrCreate?: VenteCreateOrConnectWithoutClientInput | VenteCreateOrConnectWithoutClientInput[]
    createMany?: VenteCreateManyClientInputEnvelope
    connect?: VenteWhereUniqueInput | VenteWhereUniqueInput[]
  }

  export type AchatUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<AchatCreateWithoutClientInput, AchatUncheckedCreateWithoutClientInput> | AchatCreateWithoutClientInput[] | AchatUncheckedCreateWithoutClientInput[]
    connectOrCreate?: AchatCreateOrConnectWithoutClientInput | AchatCreateOrConnectWithoutClientInput[]
    createMany?: AchatCreateManyClientInputEnvelope
    connect?: AchatWhereUniqueInput | AchatWhereUniqueInput[]
  }

  export type PanierUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<PanierCreateWithoutClientInput, PanierUncheckedCreateWithoutClientInput> | PanierCreateWithoutClientInput[] | PanierUncheckedCreateWithoutClientInput[]
    connectOrCreate?: PanierCreateOrConnectWithoutClientInput | PanierCreateOrConnectWithoutClientInput[]
    createMany?: PanierCreateManyClientInputEnvelope
    connect?: PanierWhereUniqueInput | PanierWhereUniqueInput[]
  }

  export type ReservationUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<ReservationCreateWithoutClientInput, ReservationUncheckedCreateWithoutClientInput> | ReservationCreateWithoutClientInput[] | ReservationUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutClientInput | ReservationCreateOrConnectWithoutClientInput[]
    createMany?: ReservationCreateManyClientInputEnvelope
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
  }

  export type CommandeUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<CommandeCreateWithoutClientInput, CommandeUncheckedCreateWithoutClientInput> | CommandeCreateWithoutClientInput[] | CommandeUncheckedCreateWithoutClientInput[]
    connectOrCreate?: CommandeCreateOrConnectWithoutClientInput | CommandeCreateOrConnectWithoutClientInput[]
    createMany?: CommandeCreateManyClientInputEnvelope
    connect?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
  }

  export type AdresseUpdateManyWithoutClientNestedInput = {
    create?: XOR<AdresseCreateWithoutClientInput, AdresseUncheckedCreateWithoutClientInput> | AdresseCreateWithoutClientInput[] | AdresseUncheckedCreateWithoutClientInput[]
    connectOrCreate?: AdresseCreateOrConnectWithoutClientInput | AdresseCreateOrConnectWithoutClientInput[]
    upsert?: AdresseUpsertWithWhereUniqueWithoutClientInput | AdresseUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: AdresseCreateManyClientInputEnvelope
    set?: AdresseWhereUniqueInput | AdresseWhereUniqueInput[]
    disconnect?: AdresseWhereUniqueInput | AdresseWhereUniqueInput[]
    delete?: AdresseWhereUniqueInput | AdresseWhereUniqueInput[]
    connect?: AdresseWhereUniqueInput | AdresseWhereUniqueInput[]
    update?: AdresseUpdateWithWhereUniqueWithoutClientInput | AdresseUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: AdresseUpdateManyWithWhereWithoutClientInput | AdresseUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: AdresseScalarWhereInput | AdresseScalarWhereInput[]
  }

  export type ContactUpdateManyWithoutClientNestedInput = {
    create?: XOR<ContactCreateWithoutClientInput, ContactUncheckedCreateWithoutClientInput> | ContactCreateWithoutClientInput[] | ContactUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutClientInput | ContactCreateOrConnectWithoutClientInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutClientInput | ContactUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ContactCreateManyClientInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutClientInput | ContactUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutClientInput | ContactUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type VenteUpdateManyWithoutClientNestedInput = {
    create?: XOR<VenteCreateWithoutClientInput, VenteUncheckedCreateWithoutClientInput> | VenteCreateWithoutClientInput[] | VenteUncheckedCreateWithoutClientInput[]
    connectOrCreate?: VenteCreateOrConnectWithoutClientInput | VenteCreateOrConnectWithoutClientInput[]
    upsert?: VenteUpsertWithWhereUniqueWithoutClientInput | VenteUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: VenteCreateManyClientInputEnvelope
    set?: VenteWhereUniqueInput | VenteWhereUniqueInput[]
    disconnect?: VenteWhereUniqueInput | VenteWhereUniqueInput[]
    delete?: VenteWhereUniqueInput | VenteWhereUniqueInput[]
    connect?: VenteWhereUniqueInput | VenteWhereUniqueInput[]
    update?: VenteUpdateWithWhereUniqueWithoutClientInput | VenteUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: VenteUpdateManyWithWhereWithoutClientInput | VenteUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: VenteScalarWhereInput | VenteScalarWhereInput[]
  }

  export type AchatUpdateManyWithoutClientNestedInput = {
    create?: XOR<AchatCreateWithoutClientInput, AchatUncheckedCreateWithoutClientInput> | AchatCreateWithoutClientInput[] | AchatUncheckedCreateWithoutClientInput[]
    connectOrCreate?: AchatCreateOrConnectWithoutClientInput | AchatCreateOrConnectWithoutClientInput[]
    upsert?: AchatUpsertWithWhereUniqueWithoutClientInput | AchatUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: AchatCreateManyClientInputEnvelope
    set?: AchatWhereUniqueInput | AchatWhereUniqueInput[]
    disconnect?: AchatWhereUniqueInput | AchatWhereUniqueInput[]
    delete?: AchatWhereUniqueInput | AchatWhereUniqueInput[]
    connect?: AchatWhereUniqueInput | AchatWhereUniqueInput[]
    update?: AchatUpdateWithWhereUniqueWithoutClientInput | AchatUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: AchatUpdateManyWithWhereWithoutClientInput | AchatUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: AchatScalarWhereInput | AchatScalarWhereInput[]
  }

  export type PanierUpdateManyWithoutClientNestedInput = {
    create?: XOR<PanierCreateWithoutClientInput, PanierUncheckedCreateWithoutClientInput> | PanierCreateWithoutClientInput[] | PanierUncheckedCreateWithoutClientInput[]
    connectOrCreate?: PanierCreateOrConnectWithoutClientInput | PanierCreateOrConnectWithoutClientInput[]
    upsert?: PanierUpsertWithWhereUniqueWithoutClientInput | PanierUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: PanierCreateManyClientInputEnvelope
    set?: PanierWhereUniqueInput | PanierWhereUniqueInput[]
    disconnect?: PanierWhereUniqueInput | PanierWhereUniqueInput[]
    delete?: PanierWhereUniqueInput | PanierWhereUniqueInput[]
    connect?: PanierWhereUniqueInput | PanierWhereUniqueInput[]
    update?: PanierUpdateWithWhereUniqueWithoutClientInput | PanierUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: PanierUpdateManyWithWhereWithoutClientInput | PanierUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: PanierScalarWhereInput | PanierScalarWhereInput[]
  }

  export type ReservationUpdateManyWithoutClientNestedInput = {
    create?: XOR<ReservationCreateWithoutClientInput, ReservationUncheckedCreateWithoutClientInput> | ReservationCreateWithoutClientInput[] | ReservationUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutClientInput | ReservationCreateOrConnectWithoutClientInput[]
    upsert?: ReservationUpsertWithWhereUniqueWithoutClientInput | ReservationUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ReservationCreateManyClientInputEnvelope
    set?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    disconnect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    delete?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    update?: ReservationUpdateWithWhereUniqueWithoutClientInput | ReservationUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ReservationUpdateManyWithWhereWithoutClientInput | ReservationUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
  }

  export type CommandeUpdateManyWithoutClientNestedInput = {
    create?: XOR<CommandeCreateWithoutClientInput, CommandeUncheckedCreateWithoutClientInput> | CommandeCreateWithoutClientInput[] | CommandeUncheckedCreateWithoutClientInput[]
    connectOrCreate?: CommandeCreateOrConnectWithoutClientInput | CommandeCreateOrConnectWithoutClientInput[]
    upsert?: CommandeUpsertWithWhereUniqueWithoutClientInput | CommandeUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: CommandeCreateManyClientInputEnvelope
    set?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    disconnect?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    delete?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    connect?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    update?: CommandeUpdateWithWhereUniqueWithoutClientInput | CommandeUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: CommandeUpdateManyWithWhereWithoutClientInput | CommandeUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: CommandeScalarWhereInput | CommandeScalarWhereInput[]
  }

  export type AdresseUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<AdresseCreateWithoutClientInput, AdresseUncheckedCreateWithoutClientInput> | AdresseCreateWithoutClientInput[] | AdresseUncheckedCreateWithoutClientInput[]
    connectOrCreate?: AdresseCreateOrConnectWithoutClientInput | AdresseCreateOrConnectWithoutClientInput[]
    upsert?: AdresseUpsertWithWhereUniqueWithoutClientInput | AdresseUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: AdresseCreateManyClientInputEnvelope
    set?: AdresseWhereUniqueInput | AdresseWhereUniqueInput[]
    disconnect?: AdresseWhereUniqueInput | AdresseWhereUniqueInput[]
    delete?: AdresseWhereUniqueInput | AdresseWhereUniqueInput[]
    connect?: AdresseWhereUniqueInput | AdresseWhereUniqueInput[]
    update?: AdresseUpdateWithWhereUniqueWithoutClientInput | AdresseUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: AdresseUpdateManyWithWhereWithoutClientInput | AdresseUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: AdresseScalarWhereInput | AdresseScalarWhereInput[]
  }

  export type ContactUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<ContactCreateWithoutClientInput, ContactUncheckedCreateWithoutClientInput> | ContactCreateWithoutClientInput[] | ContactUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutClientInput | ContactCreateOrConnectWithoutClientInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutClientInput | ContactUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ContactCreateManyClientInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutClientInput | ContactUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutClientInput | ContactUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type VenteUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<VenteCreateWithoutClientInput, VenteUncheckedCreateWithoutClientInput> | VenteCreateWithoutClientInput[] | VenteUncheckedCreateWithoutClientInput[]
    connectOrCreate?: VenteCreateOrConnectWithoutClientInput | VenteCreateOrConnectWithoutClientInput[]
    upsert?: VenteUpsertWithWhereUniqueWithoutClientInput | VenteUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: VenteCreateManyClientInputEnvelope
    set?: VenteWhereUniqueInput | VenteWhereUniqueInput[]
    disconnect?: VenteWhereUniqueInput | VenteWhereUniqueInput[]
    delete?: VenteWhereUniqueInput | VenteWhereUniqueInput[]
    connect?: VenteWhereUniqueInput | VenteWhereUniqueInput[]
    update?: VenteUpdateWithWhereUniqueWithoutClientInput | VenteUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: VenteUpdateManyWithWhereWithoutClientInput | VenteUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: VenteScalarWhereInput | VenteScalarWhereInput[]
  }

  export type AchatUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<AchatCreateWithoutClientInput, AchatUncheckedCreateWithoutClientInput> | AchatCreateWithoutClientInput[] | AchatUncheckedCreateWithoutClientInput[]
    connectOrCreate?: AchatCreateOrConnectWithoutClientInput | AchatCreateOrConnectWithoutClientInput[]
    upsert?: AchatUpsertWithWhereUniqueWithoutClientInput | AchatUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: AchatCreateManyClientInputEnvelope
    set?: AchatWhereUniqueInput | AchatWhereUniqueInput[]
    disconnect?: AchatWhereUniqueInput | AchatWhereUniqueInput[]
    delete?: AchatWhereUniqueInput | AchatWhereUniqueInput[]
    connect?: AchatWhereUniqueInput | AchatWhereUniqueInput[]
    update?: AchatUpdateWithWhereUniqueWithoutClientInput | AchatUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: AchatUpdateManyWithWhereWithoutClientInput | AchatUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: AchatScalarWhereInput | AchatScalarWhereInput[]
  }

  export type PanierUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<PanierCreateWithoutClientInput, PanierUncheckedCreateWithoutClientInput> | PanierCreateWithoutClientInput[] | PanierUncheckedCreateWithoutClientInput[]
    connectOrCreate?: PanierCreateOrConnectWithoutClientInput | PanierCreateOrConnectWithoutClientInput[]
    upsert?: PanierUpsertWithWhereUniqueWithoutClientInput | PanierUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: PanierCreateManyClientInputEnvelope
    set?: PanierWhereUniqueInput | PanierWhereUniqueInput[]
    disconnect?: PanierWhereUniqueInput | PanierWhereUniqueInput[]
    delete?: PanierWhereUniqueInput | PanierWhereUniqueInput[]
    connect?: PanierWhereUniqueInput | PanierWhereUniqueInput[]
    update?: PanierUpdateWithWhereUniqueWithoutClientInput | PanierUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: PanierUpdateManyWithWhereWithoutClientInput | PanierUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: PanierScalarWhereInput | PanierScalarWhereInput[]
  }

  export type ReservationUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<ReservationCreateWithoutClientInput, ReservationUncheckedCreateWithoutClientInput> | ReservationCreateWithoutClientInput[] | ReservationUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutClientInput | ReservationCreateOrConnectWithoutClientInput[]
    upsert?: ReservationUpsertWithWhereUniqueWithoutClientInput | ReservationUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ReservationCreateManyClientInputEnvelope
    set?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    disconnect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    delete?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    update?: ReservationUpdateWithWhereUniqueWithoutClientInput | ReservationUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ReservationUpdateManyWithWhereWithoutClientInput | ReservationUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
  }

  export type CommandeUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<CommandeCreateWithoutClientInput, CommandeUncheckedCreateWithoutClientInput> | CommandeCreateWithoutClientInput[] | CommandeUncheckedCreateWithoutClientInput[]
    connectOrCreate?: CommandeCreateOrConnectWithoutClientInput | CommandeCreateOrConnectWithoutClientInput[]
    upsert?: CommandeUpsertWithWhereUniqueWithoutClientInput | CommandeUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: CommandeCreateManyClientInputEnvelope
    set?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    disconnect?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    delete?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    connect?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    update?: CommandeUpdateWithWhereUniqueWithoutClientInput | CommandeUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: CommandeUpdateManyWithWhereWithoutClientInput | CommandeUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: CommandeScalarWhereInput | CommandeScalarWhereInput[]
  }

  export type AgentCreateNestedOneWithoutAdressesInput = {
    create?: XOR<AgentCreateWithoutAdressesInput, AgentUncheckedCreateWithoutAdressesInput>
    connectOrCreate?: AgentCreateOrConnectWithoutAdressesInput
    connect?: AgentWhereUniqueInput
  }

  export type EntrepriseCreateNestedOneWithoutAdresseInput = {
    create?: XOR<EntrepriseCreateWithoutAdresseInput, EntrepriseUncheckedCreateWithoutAdresseInput>
    connectOrCreate?: EntrepriseCreateOrConnectWithoutAdresseInput
    connect?: EntrepriseWhereUniqueInput
  }

  export type FournisseurCreateNestedOneWithoutAdressesInput = {
    create?: XOR<FournisseurCreateWithoutAdressesInput, FournisseurUncheckedCreateWithoutAdressesInput>
    connectOrCreate?: FournisseurCreateOrConnectWithoutAdressesInput
    connect?: FournisseurWhereUniqueInput
  }

  export type ClientCreateNestedOneWithoutAdressesInput = {
    create?: XOR<ClientCreateWithoutAdressesInput, ClientUncheckedCreateWithoutAdressesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutAdressesInput
    connect?: ClientWhereUniqueInput
  }

  export type ReservationCreateNestedManyWithoutAdresseInput = {
    create?: XOR<ReservationCreateWithoutAdresseInput, ReservationUncheckedCreateWithoutAdresseInput> | ReservationCreateWithoutAdresseInput[] | ReservationUncheckedCreateWithoutAdresseInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutAdresseInput | ReservationCreateOrConnectWithoutAdresseInput[]
    createMany?: ReservationCreateManyAdresseInputEnvelope
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
  }

  export type CommandeCreateNestedManyWithoutAdresseInput = {
    create?: XOR<CommandeCreateWithoutAdresseInput, CommandeUncheckedCreateWithoutAdresseInput> | CommandeCreateWithoutAdresseInput[] | CommandeUncheckedCreateWithoutAdresseInput[]
    connectOrCreate?: CommandeCreateOrConnectWithoutAdresseInput | CommandeCreateOrConnectWithoutAdresseInput[]
    createMany?: CommandeCreateManyAdresseInputEnvelope
    connect?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
  }

  export type ReservationUncheckedCreateNestedManyWithoutAdresseInput = {
    create?: XOR<ReservationCreateWithoutAdresseInput, ReservationUncheckedCreateWithoutAdresseInput> | ReservationCreateWithoutAdresseInput[] | ReservationUncheckedCreateWithoutAdresseInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutAdresseInput | ReservationCreateOrConnectWithoutAdresseInput[]
    createMany?: ReservationCreateManyAdresseInputEnvelope
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
  }

  export type CommandeUncheckedCreateNestedManyWithoutAdresseInput = {
    create?: XOR<CommandeCreateWithoutAdresseInput, CommandeUncheckedCreateWithoutAdresseInput> | CommandeCreateWithoutAdresseInput[] | CommandeUncheckedCreateWithoutAdresseInput[]
    connectOrCreate?: CommandeCreateOrConnectWithoutAdresseInput | CommandeCreateOrConnectWithoutAdresseInput[]
    createMany?: CommandeCreateManyAdresseInputEnvelope
    connect?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type AgentUpdateOneWithoutAdressesNestedInput = {
    create?: XOR<AgentCreateWithoutAdressesInput, AgentUncheckedCreateWithoutAdressesInput>
    connectOrCreate?: AgentCreateOrConnectWithoutAdressesInput
    upsert?: AgentUpsertWithoutAdressesInput
    disconnect?: AgentWhereInput | boolean
    delete?: AgentWhereInput | boolean
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutAdressesInput, AgentUpdateWithoutAdressesInput>, AgentUncheckedUpdateWithoutAdressesInput>
  }

  export type EntrepriseUpdateOneWithoutAdresseNestedInput = {
    create?: XOR<EntrepriseCreateWithoutAdresseInput, EntrepriseUncheckedCreateWithoutAdresseInput>
    connectOrCreate?: EntrepriseCreateOrConnectWithoutAdresseInput
    upsert?: EntrepriseUpsertWithoutAdresseInput
    disconnect?: EntrepriseWhereInput | boolean
    delete?: EntrepriseWhereInput | boolean
    connect?: EntrepriseWhereUniqueInput
    update?: XOR<XOR<EntrepriseUpdateToOneWithWhereWithoutAdresseInput, EntrepriseUpdateWithoutAdresseInput>, EntrepriseUncheckedUpdateWithoutAdresseInput>
  }

  export type FournisseurUpdateOneWithoutAdressesNestedInput = {
    create?: XOR<FournisseurCreateWithoutAdressesInput, FournisseurUncheckedCreateWithoutAdressesInput>
    connectOrCreate?: FournisseurCreateOrConnectWithoutAdressesInput
    upsert?: FournisseurUpsertWithoutAdressesInput
    disconnect?: FournisseurWhereInput | boolean
    delete?: FournisseurWhereInput | boolean
    connect?: FournisseurWhereUniqueInput
    update?: XOR<XOR<FournisseurUpdateToOneWithWhereWithoutAdressesInput, FournisseurUpdateWithoutAdressesInput>, FournisseurUncheckedUpdateWithoutAdressesInput>
  }

  export type ClientUpdateOneWithoutAdressesNestedInput = {
    create?: XOR<ClientCreateWithoutAdressesInput, ClientUncheckedCreateWithoutAdressesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutAdressesInput
    upsert?: ClientUpsertWithoutAdressesInput
    disconnect?: ClientWhereInput | boolean
    delete?: ClientWhereInput | boolean
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutAdressesInput, ClientUpdateWithoutAdressesInput>, ClientUncheckedUpdateWithoutAdressesInput>
  }

  export type ReservationUpdateManyWithoutAdresseNestedInput = {
    create?: XOR<ReservationCreateWithoutAdresseInput, ReservationUncheckedCreateWithoutAdresseInput> | ReservationCreateWithoutAdresseInput[] | ReservationUncheckedCreateWithoutAdresseInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutAdresseInput | ReservationCreateOrConnectWithoutAdresseInput[]
    upsert?: ReservationUpsertWithWhereUniqueWithoutAdresseInput | ReservationUpsertWithWhereUniqueWithoutAdresseInput[]
    createMany?: ReservationCreateManyAdresseInputEnvelope
    set?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    disconnect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    delete?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    update?: ReservationUpdateWithWhereUniqueWithoutAdresseInput | ReservationUpdateWithWhereUniqueWithoutAdresseInput[]
    updateMany?: ReservationUpdateManyWithWhereWithoutAdresseInput | ReservationUpdateManyWithWhereWithoutAdresseInput[]
    deleteMany?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
  }

  export type CommandeUpdateManyWithoutAdresseNestedInput = {
    create?: XOR<CommandeCreateWithoutAdresseInput, CommandeUncheckedCreateWithoutAdresseInput> | CommandeCreateWithoutAdresseInput[] | CommandeUncheckedCreateWithoutAdresseInput[]
    connectOrCreate?: CommandeCreateOrConnectWithoutAdresseInput | CommandeCreateOrConnectWithoutAdresseInput[]
    upsert?: CommandeUpsertWithWhereUniqueWithoutAdresseInput | CommandeUpsertWithWhereUniqueWithoutAdresseInput[]
    createMany?: CommandeCreateManyAdresseInputEnvelope
    set?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    disconnect?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    delete?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    connect?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    update?: CommandeUpdateWithWhereUniqueWithoutAdresseInput | CommandeUpdateWithWhereUniqueWithoutAdresseInput[]
    updateMany?: CommandeUpdateManyWithWhereWithoutAdresseInput | CommandeUpdateManyWithWhereWithoutAdresseInput[]
    deleteMany?: CommandeScalarWhereInput | CommandeScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ReservationUncheckedUpdateManyWithoutAdresseNestedInput = {
    create?: XOR<ReservationCreateWithoutAdresseInput, ReservationUncheckedCreateWithoutAdresseInput> | ReservationCreateWithoutAdresseInput[] | ReservationUncheckedCreateWithoutAdresseInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutAdresseInput | ReservationCreateOrConnectWithoutAdresseInput[]
    upsert?: ReservationUpsertWithWhereUniqueWithoutAdresseInput | ReservationUpsertWithWhereUniqueWithoutAdresseInput[]
    createMany?: ReservationCreateManyAdresseInputEnvelope
    set?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    disconnect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    delete?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    update?: ReservationUpdateWithWhereUniqueWithoutAdresseInput | ReservationUpdateWithWhereUniqueWithoutAdresseInput[]
    updateMany?: ReservationUpdateManyWithWhereWithoutAdresseInput | ReservationUpdateManyWithWhereWithoutAdresseInput[]
    deleteMany?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
  }

  export type CommandeUncheckedUpdateManyWithoutAdresseNestedInput = {
    create?: XOR<CommandeCreateWithoutAdresseInput, CommandeUncheckedCreateWithoutAdresseInput> | CommandeCreateWithoutAdresseInput[] | CommandeUncheckedCreateWithoutAdresseInput[]
    connectOrCreate?: CommandeCreateOrConnectWithoutAdresseInput | CommandeCreateOrConnectWithoutAdresseInput[]
    upsert?: CommandeUpsertWithWhereUniqueWithoutAdresseInput | CommandeUpsertWithWhereUniqueWithoutAdresseInput[]
    createMany?: CommandeCreateManyAdresseInputEnvelope
    set?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    disconnect?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    delete?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    connect?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    update?: CommandeUpdateWithWhereUniqueWithoutAdresseInput | CommandeUpdateWithWhereUniqueWithoutAdresseInput[]
    updateMany?: CommandeUpdateManyWithWhereWithoutAdresseInput | CommandeUpdateManyWithWhereWithoutAdresseInput[]
    deleteMany?: CommandeScalarWhereInput | CommandeScalarWhereInput[]
  }

  export type EntrepriseCreateNestedOneWithoutContactInput = {
    create?: XOR<EntrepriseCreateWithoutContactInput, EntrepriseUncheckedCreateWithoutContactInput>
    connectOrCreate?: EntrepriseCreateOrConnectWithoutContactInput
    connect?: EntrepriseWhereUniqueInput
  }

  export type ClientCreateNestedOneWithoutContactsInput = {
    create?: XOR<ClientCreateWithoutContactsInput, ClientUncheckedCreateWithoutContactsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutContactsInput
    connect?: ClientWhereUniqueInput
  }

  export type AgentCreateNestedOneWithoutContactsInput = {
    create?: XOR<AgentCreateWithoutContactsInput, AgentUncheckedCreateWithoutContactsInput>
    connectOrCreate?: AgentCreateOrConnectWithoutContactsInput
    connect?: AgentWhereUniqueInput
  }

  export type FournisseurCreateNestedOneWithoutContactsInput = {
    create?: XOR<FournisseurCreateWithoutContactsInput, FournisseurUncheckedCreateWithoutContactsInput>
    connectOrCreate?: FournisseurCreateOrConnectWithoutContactsInput
    connect?: FournisseurWhereUniqueInput
  }

  export type ReservationCreateNestedManyWithoutContactInput = {
    create?: XOR<ReservationCreateWithoutContactInput, ReservationUncheckedCreateWithoutContactInput> | ReservationCreateWithoutContactInput[] | ReservationUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutContactInput | ReservationCreateOrConnectWithoutContactInput[]
    createMany?: ReservationCreateManyContactInputEnvelope
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
  }

  export type CommandeCreateNestedManyWithoutContactInput = {
    create?: XOR<CommandeCreateWithoutContactInput, CommandeUncheckedCreateWithoutContactInput> | CommandeCreateWithoutContactInput[] | CommandeUncheckedCreateWithoutContactInput[]
    connectOrCreate?: CommandeCreateOrConnectWithoutContactInput | CommandeCreateOrConnectWithoutContactInput[]
    createMany?: CommandeCreateManyContactInputEnvelope
    connect?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
  }

  export type ReservationUncheckedCreateNestedManyWithoutContactInput = {
    create?: XOR<ReservationCreateWithoutContactInput, ReservationUncheckedCreateWithoutContactInput> | ReservationCreateWithoutContactInput[] | ReservationUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutContactInput | ReservationCreateOrConnectWithoutContactInput[]
    createMany?: ReservationCreateManyContactInputEnvelope
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
  }

  export type CommandeUncheckedCreateNestedManyWithoutContactInput = {
    create?: XOR<CommandeCreateWithoutContactInput, CommandeUncheckedCreateWithoutContactInput> | CommandeCreateWithoutContactInput[] | CommandeUncheckedCreateWithoutContactInput[]
    connectOrCreate?: CommandeCreateOrConnectWithoutContactInput | CommandeCreateOrConnectWithoutContactInput[]
    createMany?: CommandeCreateManyContactInputEnvelope
    connect?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
  }

  export type EntrepriseUpdateOneWithoutContactNestedInput = {
    create?: XOR<EntrepriseCreateWithoutContactInput, EntrepriseUncheckedCreateWithoutContactInput>
    connectOrCreate?: EntrepriseCreateOrConnectWithoutContactInput
    upsert?: EntrepriseUpsertWithoutContactInput
    disconnect?: EntrepriseWhereInput | boolean
    delete?: EntrepriseWhereInput | boolean
    connect?: EntrepriseWhereUniqueInput
    update?: XOR<XOR<EntrepriseUpdateToOneWithWhereWithoutContactInput, EntrepriseUpdateWithoutContactInput>, EntrepriseUncheckedUpdateWithoutContactInput>
  }

  export type ClientUpdateOneWithoutContactsNestedInput = {
    create?: XOR<ClientCreateWithoutContactsInput, ClientUncheckedCreateWithoutContactsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutContactsInput
    upsert?: ClientUpsertWithoutContactsInput
    disconnect?: ClientWhereInput | boolean
    delete?: ClientWhereInput | boolean
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutContactsInput, ClientUpdateWithoutContactsInput>, ClientUncheckedUpdateWithoutContactsInput>
  }

  export type AgentUpdateOneWithoutContactsNestedInput = {
    create?: XOR<AgentCreateWithoutContactsInput, AgentUncheckedCreateWithoutContactsInput>
    connectOrCreate?: AgentCreateOrConnectWithoutContactsInput
    upsert?: AgentUpsertWithoutContactsInput
    disconnect?: AgentWhereInput | boolean
    delete?: AgentWhereInput | boolean
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutContactsInput, AgentUpdateWithoutContactsInput>, AgentUncheckedUpdateWithoutContactsInput>
  }

  export type FournisseurUpdateOneWithoutContactsNestedInput = {
    create?: XOR<FournisseurCreateWithoutContactsInput, FournisseurUncheckedCreateWithoutContactsInput>
    connectOrCreate?: FournisseurCreateOrConnectWithoutContactsInput
    upsert?: FournisseurUpsertWithoutContactsInput
    disconnect?: FournisseurWhereInput | boolean
    delete?: FournisseurWhereInput | boolean
    connect?: FournisseurWhereUniqueInput
    update?: XOR<XOR<FournisseurUpdateToOneWithWhereWithoutContactsInput, FournisseurUpdateWithoutContactsInput>, FournisseurUncheckedUpdateWithoutContactsInput>
  }

  export type ReservationUpdateManyWithoutContactNestedInput = {
    create?: XOR<ReservationCreateWithoutContactInput, ReservationUncheckedCreateWithoutContactInput> | ReservationCreateWithoutContactInput[] | ReservationUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutContactInput | ReservationCreateOrConnectWithoutContactInput[]
    upsert?: ReservationUpsertWithWhereUniqueWithoutContactInput | ReservationUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: ReservationCreateManyContactInputEnvelope
    set?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    disconnect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    delete?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    update?: ReservationUpdateWithWhereUniqueWithoutContactInput | ReservationUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: ReservationUpdateManyWithWhereWithoutContactInput | ReservationUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
  }

  export type CommandeUpdateManyWithoutContactNestedInput = {
    create?: XOR<CommandeCreateWithoutContactInput, CommandeUncheckedCreateWithoutContactInput> | CommandeCreateWithoutContactInput[] | CommandeUncheckedCreateWithoutContactInput[]
    connectOrCreate?: CommandeCreateOrConnectWithoutContactInput | CommandeCreateOrConnectWithoutContactInput[]
    upsert?: CommandeUpsertWithWhereUniqueWithoutContactInput | CommandeUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: CommandeCreateManyContactInputEnvelope
    set?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    disconnect?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    delete?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    connect?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    update?: CommandeUpdateWithWhereUniqueWithoutContactInput | CommandeUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: CommandeUpdateManyWithWhereWithoutContactInput | CommandeUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: CommandeScalarWhereInput | CommandeScalarWhereInput[]
  }

  export type ReservationUncheckedUpdateManyWithoutContactNestedInput = {
    create?: XOR<ReservationCreateWithoutContactInput, ReservationUncheckedCreateWithoutContactInput> | ReservationCreateWithoutContactInput[] | ReservationUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutContactInput | ReservationCreateOrConnectWithoutContactInput[]
    upsert?: ReservationUpsertWithWhereUniqueWithoutContactInput | ReservationUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: ReservationCreateManyContactInputEnvelope
    set?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    disconnect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    delete?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    update?: ReservationUpdateWithWhereUniqueWithoutContactInput | ReservationUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: ReservationUpdateManyWithWhereWithoutContactInput | ReservationUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
  }

  export type CommandeUncheckedUpdateManyWithoutContactNestedInput = {
    create?: XOR<CommandeCreateWithoutContactInput, CommandeUncheckedCreateWithoutContactInput> | CommandeCreateWithoutContactInput[] | CommandeUncheckedCreateWithoutContactInput[]
    connectOrCreate?: CommandeCreateOrConnectWithoutContactInput | CommandeCreateOrConnectWithoutContactInput[]
    upsert?: CommandeUpsertWithWhereUniqueWithoutContactInput | CommandeUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: CommandeCreateManyContactInputEnvelope
    set?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    disconnect?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    delete?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    connect?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    update?: CommandeUpdateWithWhereUniqueWithoutContactInput | CommandeUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: CommandeUpdateManyWithWhereWithoutContactInput | CommandeUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: CommandeScalarWhereInput | CommandeScalarWhereInput[]
  }

  export type AgentCreateNestedOneWithoutFournisseurInput = {
    create?: XOR<AgentCreateWithoutFournisseurInput, AgentUncheckedCreateWithoutFournisseurInput>
    connectOrCreate?: AgentCreateOrConnectWithoutFournisseurInput
    connect?: AgentWhereUniqueInput
  }

  export type VenteCreateNestedManyWithoutFournisseurInput = {
    create?: XOR<VenteCreateWithoutFournisseurInput, VenteUncheckedCreateWithoutFournisseurInput> | VenteCreateWithoutFournisseurInput[] | VenteUncheckedCreateWithoutFournisseurInput[]
    connectOrCreate?: VenteCreateOrConnectWithoutFournisseurInput | VenteCreateOrConnectWithoutFournisseurInput[]
    createMany?: VenteCreateManyFournisseurInputEnvelope
    connect?: VenteWhereUniqueInput | VenteWhereUniqueInput[]
  }

  export type AchatCreateNestedManyWithoutFournisseurInput = {
    create?: XOR<AchatCreateWithoutFournisseurInput, AchatUncheckedCreateWithoutFournisseurInput> | AchatCreateWithoutFournisseurInput[] | AchatUncheckedCreateWithoutFournisseurInput[]
    connectOrCreate?: AchatCreateOrConnectWithoutFournisseurInput | AchatCreateOrConnectWithoutFournisseurInput[]
    createMany?: AchatCreateManyFournisseurInputEnvelope
    connect?: AchatWhereUniqueInput | AchatWhereUniqueInput[]
  }

  export type AdresseCreateNestedManyWithoutFournisseurInput = {
    create?: XOR<AdresseCreateWithoutFournisseurInput, AdresseUncheckedCreateWithoutFournisseurInput> | AdresseCreateWithoutFournisseurInput[] | AdresseUncheckedCreateWithoutFournisseurInput[]
    connectOrCreate?: AdresseCreateOrConnectWithoutFournisseurInput | AdresseCreateOrConnectWithoutFournisseurInput[]
    createMany?: AdresseCreateManyFournisseurInputEnvelope
    connect?: AdresseWhereUniqueInput | AdresseWhereUniqueInput[]
  }

  export type ContactCreateNestedManyWithoutFournisseurInput = {
    create?: XOR<ContactCreateWithoutFournisseurInput, ContactUncheckedCreateWithoutFournisseurInput> | ContactCreateWithoutFournisseurInput[] | ContactUncheckedCreateWithoutFournisseurInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutFournisseurInput | ContactCreateOrConnectWithoutFournisseurInput[]
    createMany?: ContactCreateManyFournisseurInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type ReservationCreateNestedManyWithoutFournisseurInput = {
    create?: XOR<ReservationCreateWithoutFournisseurInput, ReservationUncheckedCreateWithoutFournisseurInput> | ReservationCreateWithoutFournisseurInput[] | ReservationUncheckedCreateWithoutFournisseurInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutFournisseurInput | ReservationCreateOrConnectWithoutFournisseurInput[]
    createMany?: ReservationCreateManyFournisseurInputEnvelope
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
  }

  export type CommandeCreateNestedManyWithoutFournisseurInput = {
    create?: XOR<CommandeCreateWithoutFournisseurInput, CommandeUncheckedCreateWithoutFournisseurInput> | CommandeCreateWithoutFournisseurInput[] | CommandeUncheckedCreateWithoutFournisseurInput[]
    connectOrCreate?: CommandeCreateOrConnectWithoutFournisseurInput | CommandeCreateOrConnectWithoutFournisseurInput[]
    createMany?: CommandeCreateManyFournisseurInputEnvelope
    connect?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
  }

  export type VenteUncheckedCreateNestedManyWithoutFournisseurInput = {
    create?: XOR<VenteCreateWithoutFournisseurInput, VenteUncheckedCreateWithoutFournisseurInput> | VenteCreateWithoutFournisseurInput[] | VenteUncheckedCreateWithoutFournisseurInput[]
    connectOrCreate?: VenteCreateOrConnectWithoutFournisseurInput | VenteCreateOrConnectWithoutFournisseurInput[]
    createMany?: VenteCreateManyFournisseurInputEnvelope
    connect?: VenteWhereUniqueInput | VenteWhereUniqueInput[]
  }

  export type AchatUncheckedCreateNestedManyWithoutFournisseurInput = {
    create?: XOR<AchatCreateWithoutFournisseurInput, AchatUncheckedCreateWithoutFournisseurInput> | AchatCreateWithoutFournisseurInput[] | AchatUncheckedCreateWithoutFournisseurInput[]
    connectOrCreate?: AchatCreateOrConnectWithoutFournisseurInput | AchatCreateOrConnectWithoutFournisseurInput[]
    createMany?: AchatCreateManyFournisseurInputEnvelope
    connect?: AchatWhereUniqueInput | AchatWhereUniqueInput[]
  }

  export type AdresseUncheckedCreateNestedManyWithoutFournisseurInput = {
    create?: XOR<AdresseCreateWithoutFournisseurInput, AdresseUncheckedCreateWithoutFournisseurInput> | AdresseCreateWithoutFournisseurInput[] | AdresseUncheckedCreateWithoutFournisseurInput[]
    connectOrCreate?: AdresseCreateOrConnectWithoutFournisseurInput | AdresseCreateOrConnectWithoutFournisseurInput[]
    createMany?: AdresseCreateManyFournisseurInputEnvelope
    connect?: AdresseWhereUniqueInput | AdresseWhereUniqueInput[]
  }

  export type ContactUncheckedCreateNestedManyWithoutFournisseurInput = {
    create?: XOR<ContactCreateWithoutFournisseurInput, ContactUncheckedCreateWithoutFournisseurInput> | ContactCreateWithoutFournisseurInput[] | ContactUncheckedCreateWithoutFournisseurInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutFournisseurInput | ContactCreateOrConnectWithoutFournisseurInput[]
    createMany?: ContactCreateManyFournisseurInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type ReservationUncheckedCreateNestedManyWithoutFournisseurInput = {
    create?: XOR<ReservationCreateWithoutFournisseurInput, ReservationUncheckedCreateWithoutFournisseurInput> | ReservationCreateWithoutFournisseurInput[] | ReservationUncheckedCreateWithoutFournisseurInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutFournisseurInput | ReservationCreateOrConnectWithoutFournisseurInput[]
    createMany?: ReservationCreateManyFournisseurInputEnvelope
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
  }

  export type CommandeUncheckedCreateNestedManyWithoutFournisseurInput = {
    create?: XOR<CommandeCreateWithoutFournisseurInput, CommandeUncheckedCreateWithoutFournisseurInput> | CommandeCreateWithoutFournisseurInput[] | CommandeUncheckedCreateWithoutFournisseurInput[]
    connectOrCreate?: CommandeCreateOrConnectWithoutFournisseurInput | CommandeCreateOrConnectWithoutFournisseurInput[]
    createMany?: CommandeCreateManyFournisseurInputEnvelope
    connect?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
  }

  export type AgentUpdateOneRequiredWithoutFournisseurNestedInput = {
    create?: XOR<AgentCreateWithoutFournisseurInput, AgentUncheckedCreateWithoutFournisseurInput>
    connectOrCreate?: AgentCreateOrConnectWithoutFournisseurInput
    upsert?: AgentUpsertWithoutFournisseurInput
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutFournisseurInput, AgentUpdateWithoutFournisseurInput>, AgentUncheckedUpdateWithoutFournisseurInput>
  }

  export type VenteUpdateManyWithoutFournisseurNestedInput = {
    create?: XOR<VenteCreateWithoutFournisseurInput, VenteUncheckedCreateWithoutFournisseurInput> | VenteCreateWithoutFournisseurInput[] | VenteUncheckedCreateWithoutFournisseurInput[]
    connectOrCreate?: VenteCreateOrConnectWithoutFournisseurInput | VenteCreateOrConnectWithoutFournisseurInput[]
    upsert?: VenteUpsertWithWhereUniqueWithoutFournisseurInput | VenteUpsertWithWhereUniqueWithoutFournisseurInput[]
    createMany?: VenteCreateManyFournisseurInputEnvelope
    set?: VenteWhereUniqueInput | VenteWhereUniqueInput[]
    disconnect?: VenteWhereUniqueInput | VenteWhereUniqueInput[]
    delete?: VenteWhereUniqueInput | VenteWhereUniqueInput[]
    connect?: VenteWhereUniqueInput | VenteWhereUniqueInput[]
    update?: VenteUpdateWithWhereUniqueWithoutFournisseurInput | VenteUpdateWithWhereUniqueWithoutFournisseurInput[]
    updateMany?: VenteUpdateManyWithWhereWithoutFournisseurInput | VenteUpdateManyWithWhereWithoutFournisseurInput[]
    deleteMany?: VenteScalarWhereInput | VenteScalarWhereInput[]
  }

  export type AchatUpdateManyWithoutFournisseurNestedInput = {
    create?: XOR<AchatCreateWithoutFournisseurInput, AchatUncheckedCreateWithoutFournisseurInput> | AchatCreateWithoutFournisseurInput[] | AchatUncheckedCreateWithoutFournisseurInput[]
    connectOrCreate?: AchatCreateOrConnectWithoutFournisseurInput | AchatCreateOrConnectWithoutFournisseurInput[]
    upsert?: AchatUpsertWithWhereUniqueWithoutFournisseurInput | AchatUpsertWithWhereUniqueWithoutFournisseurInput[]
    createMany?: AchatCreateManyFournisseurInputEnvelope
    set?: AchatWhereUniqueInput | AchatWhereUniqueInput[]
    disconnect?: AchatWhereUniqueInput | AchatWhereUniqueInput[]
    delete?: AchatWhereUniqueInput | AchatWhereUniqueInput[]
    connect?: AchatWhereUniqueInput | AchatWhereUniqueInput[]
    update?: AchatUpdateWithWhereUniqueWithoutFournisseurInput | AchatUpdateWithWhereUniqueWithoutFournisseurInput[]
    updateMany?: AchatUpdateManyWithWhereWithoutFournisseurInput | AchatUpdateManyWithWhereWithoutFournisseurInput[]
    deleteMany?: AchatScalarWhereInput | AchatScalarWhereInput[]
  }

  export type AdresseUpdateManyWithoutFournisseurNestedInput = {
    create?: XOR<AdresseCreateWithoutFournisseurInput, AdresseUncheckedCreateWithoutFournisseurInput> | AdresseCreateWithoutFournisseurInput[] | AdresseUncheckedCreateWithoutFournisseurInput[]
    connectOrCreate?: AdresseCreateOrConnectWithoutFournisseurInput | AdresseCreateOrConnectWithoutFournisseurInput[]
    upsert?: AdresseUpsertWithWhereUniqueWithoutFournisseurInput | AdresseUpsertWithWhereUniqueWithoutFournisseurInput[]
    createMany?: AdresseCreateManyFournisseurInputEnvelope
    set?: AdresseWhereUniqueInput | AdresseWhereUniqueInput[]
    disconnect?: AdresseWhereUniqueInput | AdresseWhereUniqueInput[]
    delete?: AdresseWhereUniqueInput | AdresseWhereUniqueInput[]
    connect?: AdresseWhereUniqueInput | AdresseWhereUniqueInput[]
    update?: AdresseUpdateWithWhereUniqueWithoutFournisseurInput | AdresseUpdateWithWhereUniqueWithoutFournisseurInput[]
    updateMany?: AdresseUpdateManyWithWhereWithoutFournisseurInput | AdresseUpdateManyWithWhereWithoutFournisseurInput[]
    deleteMany?: AdresseScalarWhereInput | AdresseScalarWhereInput[]
  }

  export type ContactUpdateManyWithoutFournisseurNestedInput = {
    create?: XOR<ContactCreateWithoutFournisseurInput, ContactUncheckedCreateWithoutFournisseurInput> | ContactCreateWithoutFournisseurInput[] | ContactUncheckedCreateWithoutFournisseurInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutFournisseurInput | ContactCreateOrConnectWithoutFournisseurInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutFournisseurInput | ContactUpsertWithWhereUniqueWithoutFournisseurInput[]
    createMany?: ContactCreateManyFournisseurInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutFournisseurInput | ContactUpdateWithWhereUniqueWithoutFournisseurInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutFournisseurInput | ContactUpdateManyWithWhereWithoutFournisseurInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type ReservationUpdateManyWithoutFournisseurNestedInput = {
    create?: XOR<ReservationCreateWithoutFournisseurInput, ReservationUncheckedCreateWithoutFournisseurInput> | ReservationCreateWithoutFournisseurInput[] | ReservationUncheckedCreateWithoutFournisseurInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutFournisseurInput | ReservationCreateOrConnectWithoutFournisseurInput[]
    upsert?: ReservationUpsertWithWhereUniqueWithoutFournisseurInput | ReservationUpsertWithWhereUniqueWithoutFournisseurInput[]
    createMany?: ReservationCreateManyFournisseurInputEnvelope
    set?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    disconnect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    delete?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    update?: ReservationUpdateWithWhereUniqueWithoutFournisseurInput | ReservationUpdateWithWhereUniqueWithoutFournisseurInput[]
    updateMany?: ReservationUpdateManyWithWhereWithoutFournisseurInput | ReservationUpdateManyWithWhereWithoutFournisseurInput[]
    deleteMany?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
  }

  export type CommandeUpdateManyWithoutFournisseurNestedInput = {
    create?: XOR<CommandeCreateWithoutFournisseurInput, CommandeUncheckedCreateWithoutFournisseurInput> | CommandeCreateWithoutFournisseurInput[] | CommandeUncheckedCreateWithoutFournisseurInput[]
    connectOrCreate?: CommandeCreateOrConnectWithoutFournisseurInput | CommandeCreateOrConnectWithoutFournisseurInput[]
    upsert?: CommandeUpsertWithWhereUniqueWithoutFournisseurInput | CommandeUpsertWithWhereUniqueWithoutFournisseurInput[]
    createMany?: CommandeCreateManyFournisseurInputEnvelope
    set?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    disconnect?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    delete?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    connect?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    update?: CommandeUpdateWithWhereUniqueWithoutFournisseurInput | CommandeUpdateWithWhereUniqueWithoutFournisseurInput[]
    updateMany?: CommandeUpdateManyWithWhereWithoutFournisseurInput | CommandeUpdateManyWithWhereWithoutFournisseurInput[]
    deleteMany?: CommandeScalarWhereInput | CommandeScalarWhereInput[]
  }

  export type VenteUncheckedUpdateManyWithoutFournisseurNestedInput = {
    create?: XOR<VenteCreateWithoutFournisseurInput, VenteUncheckedCreateWithoutFournisseurInput> | VenteCreateWithoutFournisseurInput[] | VenteUncheckedCreateWithoutFournisseurInput[]
    connectOrCreate?: VenteCreateOrConnectWithoutFournisseurInput | VenteCreateOrConnectWithoutFournisseurInput[]
    upsert?: VenteUpsertWithWhereUniqueWithoutFournisseurInput | VenteUpsertWithWhereUniqueWithoutFournisseurInput[]
    createMany?: VenteCreateManyFournisseurInputEnvelope
    set?: VenteWhereUniqueInput | VenteWhereUniqueInput[]
    disconnect?: VenteWhereUniqueInput | VenteWhereUniqueInput[]
    delete?: VenteWhereUniqueInput | VenteWhereUniqueInput[]
    connect?: VenteWhereUniqueInput | VenteWhereUniqueInput[]
    update?: VenteUpdateWithWhereUniqueWithoutFournisseurInput | VenteUpdateWithWhereUniqueWithoutFournisseurInput[]
    updateMany?: VenteUpdateManyWithWhereWithoutFournisseurInput | VenteUpdateManyWithWhereWithoutFournisseurInput[]
    deleteMany?: VenteScalarWhereInput | VenteScalarWhereInput[]
  }

  export type AchatUncheckedUpdateManyWithoutFournisseurNestedInput = {
    create?: XOR<AchatCreateWithoutFournisseurInput, AchatUncheckedCreateWithoutFournisseurInput> | AchatCreateWithoutFournisseurInput[] | AchatUncheckedCreateWithoutFournisseurInput[]
    connectOrCreate?: AchatCreateOrConnectWithoutFournisseurInput | AchatCreateOrConnectWithoutFournisseurInput[]
    upsert?: AchatUpsertWithWhereUniqueWithoutFournisseurInput | AchatUpsertWithWhereUniqueWithoutFournisseurInput[]
    createMany?: AchatCreateManyFournisseurInputEnvelope
    set?: AchatWhereUniqueInput | AchatWhereUniqueInput[]
    disconnect?: AchatWhereUniqueInput | AchatWhereUniqueInput[]
    delete?: AchatWhereUniqueInput | AchatWhereUniqueInput[]
    connect?: AchatWhereUniqueInput | AchatWhereUniqueInput[]
    update?: AchatUpdateWithWhereUniqueWithoutFournisseurInput | AchatUpdateWithWhereUniqueWithoutFournisseurInput[]
    updateMany?: AchatUpdateManyWithWhereWithoutFournisseurInput | AchatUpdateManyWithWhereWithoutFournisseurInput[]
    deleteMany?: AchatScalarWhereInput | AchatScalarWhereInput[]
  }

  export type AdresseUncheckedUpdateManyWithoutFournisseurNestedInput = {
    create?: XOR<AdresseCreateWithoutFournisseurInput, AdresseUncheckedCreateWithoutFournisseurInput> | AdresseCreateWithoutFournisseurInput[] | AdresseUncheckedCreateWithoutFournisseurInput[]
    connectOrCreate?: AdresseCreateOrConnectWithoutFournisseurInput | AdresseCreateOrConnectWithoutFournisseurInput[]
    upsert?: AdresseUpsertWithWhereUniqueWithoutFournisseurInput | AdresseUpsertWithWhereUniqueWithoutFournisseurInput[]
    createMany?: AdresseCreateManyFournisseurInputEnvelope
    set?: AdresseWhereUniqueInput | AdresseWhereUniqueInput[]
    disconnect?: AdresseWhereUniqueInput | AdresseWhereUniqueInput[]
    delete?: AdresseWhereUniqueInput | AdresseWhereUniqueInput[]
    connect?: AdresseWhereUniqueInput | AdresseWhereUniqueInput[]
    update?: AdresseUpdateWithWhereUniqueWithoutFournisseurInput | AdresseUpdateWithWhereUniqueWithoutFournisseurInput[]
    updateMany?: AdresseUpdateManyWithWhereWithoutFournisseurInput | AdresseUpdateManyWithWhereWithoutFournisseurInput[]
    deleteMany?: AdresseScalarWhereInput | AdresseScalarWhereInput[]
  }

  export type ContactUncheckedUpdateManyWithoutFournisseurNestedInput = {
    create?: XOR<ContactCreateWithoutFournisseurInput, ContactUncheckedCreateWithoutFournisseurInput> | ContactCreateWithoutFournisseurInput[] | ContactUncheckedCreateWithoutFournisseurInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutFournisseurInput | ContactCreateOrConnectWithoutFournisseurInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutFournisseurInput | ContactUpsertWithWhereUniqueWithoutFournisseurInput[]
    createMany?: ContactCreateManyFournisseurInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutFournisseurInput | ContactUpdateWithWhereUniqueWithoutFournisseurInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutFournisseurInput | ContactUpdateManyWithWhereWithoutFournisseurInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type ReservationUncheckedUpdateManyWithoutFournisseurNestedInput = {
    create?: XOR<ReservationCreateWithoutFournisseurInput, ReservationUncheckedCreateWithoutFournisseurInput> | ReservationCreateWithoutFournisseurInput[] | ReservationUncheckedCreateWithoutFournisseurInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutFournisseurInput | ReservationCreateOrConnectWithoutFournisseurInput[]
    upsert?: ReservationUpsertWithWhereUniqueWithoutFournisseurInput | ReservationUpsertWithWhereUniqueWithoutFournisseurInput[]
    createMany?: ReservationCreateManyFournisseurInputEnvelope
    set?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    disconnect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    delete?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    update?: ReservationUpdateWithWhereUniqueWithoutFournisseurInput | ReservationUpdateWithWhereUniqueWithoutFournisseurInput[]
    updateMany?: ReservationUpdateManyWithWhereWithoutFournisseurInput | ReservationUpdateManyWithWhereWithoutFournisseurInput[]
    deleteMany?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
  }

  export type CommandeUncheckedUpdateManyWithoutFournisseurNestedInput = {
    create?: XOR<CommandeCreateWithoutFournisseurInput, CommandeUncheckedCreateWithoutFournisseurInput> | CommandeCreateWithoutFournisseurInput[] | CommandeUncheckedCreateWithoutFournisseurInput[]
    connectOrCreate?: CommandeCreateOrConnectWithoutFournisseurInput | CommandeCreateOrConnectWithoutFournisseurInput[]
    upsert?: CommandeUpsertWithWhereUniqueWithoutFournisseurInput | CommandeUpsertWithWhereUniqueWithoutFournisseurInput[]
    createMany?: CommandeCreateManyFournisseurInputEnvelope
    set?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    disconnect?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    delete?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    connect?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    update?: CommandeUpdateWithWhereUniqueWithoutFournisseurInput | CommandeUpdateWithWhereUniqueWithoutFournisseurInput[]
    updateMany?: CommandeUpdateManyWithWhereWithoutFournisseurInput | CommandeUpdateManyWithWhereWithoutFournisseurInput[]
    deleteMany?: CommandeScalarWhereInput | CommandeScalarWhereInput[]
  }

  export type DetailPanierCreateNestedManyWithoutProduitInput = {
    create?: XOR<DetailPanierCreateWithoutProduitInput, DetailPanierUncheckedCreateWithoutProduitInput> | DetailPanierCreateWithoutProduitInput[] | DetailPanierUncheckedCreateWithoutProduitInput[]
    connectOrCreate?: DetailPanierCreateOrConnectWithoutProduitInput | DetailPanierCreateOrConnectWithoutProduitInput[]
    createMany?: DetailPanierCreateManyProduitInputEnvelope
    connect?: DetailPanierWhereUniqueInput | DetailPanierWhereUniqueInput[]
  }

  export type AgentCreateNestedOneWithoutProduitsInput = {
    create?: XOR<AgentCreateWithoutProduitsInput, AgentUncheckedCreateWithoutProduitsInput>
    connectOrCreate?: AgentCreateOrConnectWithoutProduitsInput
    connect?: AgentWhereUniqueInput
  }

  export type DeviseCreateNestedOneWithoutProduitsInput = {
    create?: XOR<DeviseCreateWithoutProduitsInput, DeviseUncheckedCreateWithoutProduitsInput>
    connectOrCreate?: DeviseCreateOrConnectWithoutProduitsInput
    connect?: DeviseWhereUniqueInput
  }

  export type TeneurCreateNestedOneWithoutProduitsInput = {
    create?: XOR<TeneurCreateWithoutProduitsInput, TeneurUncheckedCreateWithoutProduitsInput>
    connectOrCreate?: TeneurCreateOrConnectWithoutProduitsInput
    connect?: TeneurWhereUniqueInput
  }

  export type DetailPanierUncheckedCreateNestedManyWithoutProduitInput = {
    create?: XOR<DetailPanierCreateWithoutProduitInput, DetailPanierUncheckedCreateWithoutProduitInput> | DetailPanierCreateWithoutProduitInput[] | DetailPanierUncheckedCreateWithoutProduitInput[]
    connectOrCreate?: DetailPanierCreateOrConnectWithoutProduitInput | DetailPanierCreateOrConnectWithoutProduitInput[]
    createMany?: DetailPanierCreateManyProduitInputEnvelope
    connect?: DetailPanierWhereUniqueInput | DetailPanierWhereUniqueInput[]
  }

  export type DetailPanierUpdateManyWithoutProduitNestedInput = {
    create?: XOR<DetailPanierCreateWithoutProduitInput, DetailPanierUncheckedCreateWithoutProduitInput> | DetailPanierCreateWithoutProduitInput[] | DetailPanierUncheckedCreateWithoutProduitInput[]
    connectOrCreate?: DetailPanierCreateOrConnectWithoutProduitInput | DetailPanierCreateOrConnectWithoutProduitInput[]
    upsert?: DetailPanierUpsertWithWhereUniqueWithoutProduitInput | DetailPanierUpsertWithWhereUniqueWithoutProduitInput[]
    createMany?: DetailPanierCreateManyProduitInputEnvelope
    set?: DetailPanierWhereUniqueInput | DetailPanierWhereUniqueInput[]
    disconnect?: DetailPanierWhereUniqueInput | DetailPanierWhereUniqueInput[]
    delete?: DetailPanierWhereUniqueInput | DetailPanierWhereUniqueInput[]
    connect?: DetailPanierWhereUniqueInput | DetailPanierWhereUniqueInput[]
    update?: DetailPanierUpdateWithWhereUniqueWithoutProduitInput | DetailPanierUpdateWithWhereUniqueWithoutProduitInput[]
    updateMany?: DetailPanierUpdateManyWithWhereWithoutProduitInput | DetailPanierUpdateManyWithWhereWithoutProduitInput[]
    deleteMany?: DetailPanierScalarWhereInput | DetailPanierScalarWhereInput[]
  }

  export type AgentUpdateOneRequiredWithoutProduitsNestedInput = {
    create?: XOR<AgentCreateWithoutProduitsInput, AgentUncheckedCreateWithoutProduitsInput>
    connectOrCreate?: AgentCreateOrConnectWithoutProduitsInput
    upsert?: AgentUpsertWithoutProduitsInput
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutProduitsInput, AgentUpdateWithoutProduitsInput>, AgentUncheckedUpdateWithoutProduitsInput>
  }

  export type DeviseUpdateOneRequiredWithoutProduitsNestedInput = {
    create?: XOR<DeviseCreateWithoutProduitsInput, DeviseUncheckedCreateWithoutProduitsInput>
    connectOrCreate?: DeviseCreateOrConnectWithoutProduitsInput
    upsert?: DeviseUpsertWithoutProduitsInput
    connect?: DeviseWhereUniqueInput
    update?: XOR<XOR<DeviseUpdateToOneWithWhereWithoutProduitsInput, DeviseUpdateWithoutProduitsInput>, DeviseUncheckedUpdateWithoutProduitsInput>
  }

  export type TeneurUpdateOneRequiredWithoutProduitsNestedInput = {
    create?: XOR<TeneurCreateWithoutProduitsInput, TeneurUncheckedCreateWithoutProduitsInput>
    connectOrCreate?: TeneurCreateOrConnectWithoutProduitsInput
    upsert?: TeneurUpsertWithoutProduitsInput
    connect?: TeneurWhereUniqueInput
    update?: XOR<XOR<TeneurUpdateToOneWithWhereWithoutProduitsInput, TeneurUpdateWithoutProduitsInput>, TeneurUncheckedUpdateWithoutProduitsInput>
  }

  export type DetailPanierUncheckedUpdateManyWithoutProduitNestedInput = {
    create?: XOR<DetailPanierCreateWithoutProduitInput, DetailPanierUncheckedCreateWithoutProduitInput> | DetailPanierCreateWithoutProduitInput[] | DetailPanierUncheckedCreateWithoutProduitInput[]
    connectOrCreate?: DetailPanierCreateOrConnectWithoutProduitInput | DetailPanierCreateOrConnectWithoutProduitInput[]
    upsert?: DetailPanierUpsertWithWhereUniqueWithoutProduitInput | DetailPanierUpsertWithWhereUniqueWithoutProduitInput[]
    createMany?: DetailPanierCreateManyProduitInputEnvelope
    set?: DetailPanierWhereUniqueInput | DetailPanierWhereUniqueInput[]
    disconnect?: DetailPanierWhereUniqueInput | DetailPanierWhereUniqueInput[]
    delete?: DetailPanierWhereUniqueInput | DetailPanierWhereUniqueInput[]
    connect?: DetailPanierWhereUniqueInput | DetailPanierWhereUniqueInput[]
    update?: DetailPanierUpdateWithWhereUniqueWithoutProduitInput | DetailPanierUpdateWithWhereUniqueWithoutProduitInput[]
    updateMany?: DetailPanierUpdateManyWithWhereWithoutProduitInput | DetailPanierUpdateManyWithWhereWithoutProduitInput[]
    deleteMany?: DetailPanierScalarWhereInput | DetailPanierScalarWhereInput[]
  }

  export type VenteCreateNestedOneWithoutPaiementsInput = {
    create?: XOR<VenteCreateWithoutPaiementsInput, VenteUncheckedCreateWithoutPaiementsInput>
    connectOrCreate?: VenteCreateOrConnectWithoutPaiementsInput
    connect?: VenteWhereUniqueInput
  }

  export type AchatCreateNestedOneWithoutPaiementsInput = {
    create?: XOR<AchatCreateWithoutPaiementsInput, AchatUncheckedCreateWithoutPaiementsInput>
    connectOrCreate?: AchatCreateOrConnectWithoutPaiementsInput
    connect?: AchatWhereUniqueInput
  }

  export type CommandeCreateNestedOneWithoutPaiementInput = {
    create?: XOR<CommandeCreateWithoutPaiementInput, CommandeUncheckedCreateWithoutPaiementInput>
    connectOrCreate?: CommandeCreateOrConnectWithoutPaiementInput
    connect?: CommandeWhereUniqueInput
  }

  export type CaisseCreateNestedOneWithoutPaiementsInput = {
    create?: XOR<CaisseCreateWithoutPaiementsInput, CaisseUncheckedCreateWithoutPaiementsInput>
    connectOrCreate?: CaisseCreateOrConnectWithoutPaiementsInput
    connect?: CaisseWhereUniqueInput
  }

  export type DeviseCreateNestedOneWithoutPaiementsInput = {
    create?: XOR<DeviseCreateWithoutPaiementsInput, DeviseUncheckedCreateWithoutPaiementsInput>
    connectOrCreate?: DeviseCreateOrConnectWithoutPaiementsInput
    connect?: DeviseWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumModePaimentFieldUpdateOperationsInput = {
    set?: $Enums.ModePaiment
  }

  export type VenteUpdateOneWithoutPaiementsNestedInput = {
    create?: XOR<VenteCreateWithoutPaiementsInput, VenteUncheckedCreateWithoutPaiementsInput>
    connectOrCreate?: VenteCreateOrConnectWithoutPaiementsInput
    upsert?: VenteUpsertWithoutPaiementsInput
    disconnect?: VenteWhereInput | boolean
    delete?: VenteWhereInput | boolean
    connect?: VenteWhereUniqueInput
    update?: XOR<XOR<VenteUpdateToOneWithWhereWithoutPaiementsInput, VenteUpdateWithoutPaiementsInput>, VenteUncheckedUpdateWithoutPaiementsInput>
  }

  export type AchatUpdateOneWithoutPaiementsNestedInput = {
    create?: XOR<AchatCreateWithoutPaiementsInput, AchatUncheckedCreateWithoutPaiementsInput>
    connectOrCreate?: AchatCreateOrConnectWithoutPaiementsInput
    upsert?: AchatUpsertWithoutPaiementsInput
    disconnect?: AchatWhereInput | boolean
    delete?: AchatWhereInput | boolean
    connect?: AchatWhereUniqueInput
    update?: XOR<XOR<AchatUpdateToOneWithWhereWithoutPaiementsInput, AchatUpdateWithoutPaiementsInput>, AchatUncheckedUpdateWithoutPaiementsInput>
  }

  export type CommandeUpdateOneWithoutPaiementNestedInput = {
    create?: XOR<CommandeCreateWithoutPaiementInput, CommandeUncheckedCreateWithoutPaiementInput>
    connectOrCreate?: CommandeCreateOrConnectWithoutPaiementInput
    upsert?: CommandeUpsertWithoutPaiementInput
    disconnect?: CommandeWhereInput | boolean
    delete?: CommandeWhereInput | boolean
    connect?: CommandeWhereUniqueInput
    update?: XOR<XOR<CommandeUpdateToOneWithWhereWithoutPaiementInput, CommandeUpdateWithoutPaiementInput>, CommandeUncheckedUpdateWithoutPaiementInput>
  }

  export type CaisseUpdateOneRequiredWithoutPaiementsNestedInput = {
    create?: XOR<CaisseCreateWithoutPaiementsInput, CaisseUncheckedCreateWithoutPaiementsInput>
    connectOrCreate?: CaisseCreateOrConnectWithoutPaiementsInput
    upsert?: CaisseUpsertWithoutPaiementsInput
    connect?: CaisseWhereUniqueInput
    update?: XOR<XOR<CaisseUpdateToOneWithWhereWithoutPaiementsInput, CaisseUpdateWithoutPaiementsInput>, CaisseUncheckedUpdateWithoutPaiementsInput>
  }

  export type DeviseUpdateOneRequiredWithoutPaiementsNestedInput = {
    create?: XOR<DeviseCreateWithoutPaiementsInput, DeviseUncheckedCreateWithoutPaiementsInput>
    connectOrCreate?: DeviseCreateOrConnectWithoutPaiementsInput
    upsert?: DeviseUpsertWithoutPaiementsInput
    connect?: DeviseWhereUniqueInput
    update?: XOR<XOR<DeviseUpdateToOneWithWhereWithoutPaiementsInput, DeviseUpdateWithoutPaiementsInput>, DeviseUncheckedUpdateWithoutPaiementsInput>
  }

  export type DeviseCreateNestedOneWithoutCaissesInput = {
    create?: XOR<DeviseCreateWithoutCaissesInput, DeviseUncheckedCreateWithoutCaissesInput>
    connectOrCreate?: DeviseCreateOrConnectWithoutCaissesInput
    connect?: DeviseWhereUniqueInput
  }

  export type AgentCreateNestedOneWithoutCaissesInput = {
    create?: XOR<AgentCreateWithoutCaissesInput, AgentUncheckedCreateWithoutCaissesInput>
    connectOrCreate?: AgentCreateOrConnectWithoutCaissesInput
    connect?: AgentWhereUniqueInput
  }

  export type MouvementCaisseCreateNestedManyWithoutCaisseInput = {
    create?: XOR<MouvementCaisseCreateWithoutCaisseInput, MouvementCaisseUncheckedCreateWithoutCaisseInput> | MouvementCaisseCreateWithoutCaisseInput[] | MouvementCaisseUncheckedCreateWithoutCaisseInput[]
    connectOrCreate?: MouvementCaisseCreateOrConnectWithoutCaisseInput | MouvementCaisseCreateOrConnectWithoutCaisseInput[]
    createMany?: MouvementCaisseCreateManyCaisseInputEnvelope
    connect?: MouvementCaisseWhereUniqueInput | MouvementCaisseWhereUniqueInput[]
  }

  export type PaiementCreateNestedManyWithoutCaisseInput = {
    create?: XOR<PaiementCreateWithoutCaisseInput, PaiementUncheckedCreateWithoutCaisseInput> | PaiementCreateWithoutCaisseInput[] | PaiementUncheckedCreateWithoutCaisseInput[]
    connectOrCreate?: PaiementCreateOrConnectWithoutCaisseInput | PaiementCreateOrConnectWithoutCaisseInput[]
    createMany?: PaiementCreateManyCaisseInputEnvelope
    connect?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
  }

  export type MouvementCaisseUncheckedCreateNestedManyWithoutCaisseInput = {
    create?: XOR<MouvementCaisseCreateWithoutCaisseInput, MouvementCaisseUncheckedCreateWithoutCaisseInput> | MouvementCaisseCreateWithoutCaisseInput[] | MouvementCaisseUncheckedCreateWithoutCaisseInput[]
    connectOrCreate?: MouvementCaisseCreateOrConnectWithoutCaisseInput | MouvementCaisseCreateOrConnectWithoutCaisseInput[]
    createMany?: MouvementCaisseCreateManyCaisseInputEnvelope
    connect?: MouvementCaisseWhereUniqueInput | MouvementCaisseWhereUniqueInput[]
  }

  export type PaiementUncheckedCreateNestedManyWithoutCaisseInput = {
    create?: XOR<PaiementCreateWithoutCaisseInput, PaiementUncheckedCreateWithoutCaisseInput> | PaiementCreateWithoutCaisseInput[] | PaiementUncheckedCreateWithoutCaisseInput[]
    connectOrCreate?: PaiementCreateOrConnectWithoutCaisseInput | PaiementCreateOrConnectWithoutCaisseInput[]
    createMany?: PaiementCreateManyCaisseInputEnvelope
    connect?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
  }

  export type EnumStatutCaisseFieldUpdateOperationsInput = {
    set?: $Enums.StatutCaisse
  }

  export type DeviseUpdateOneRequiredWithoutCaissesNestedInput = {
    create?: XOR<DeviseCreateWithoutCaissesInput, DeviseUncheckedCreateWithoutCaissesInput>
    connectOrCreate?: DeviseCreateOrConnectWithoutCaissesInput
    upsert?: DeviseUpsertWithoutCaissesInput
    connect?: DeviseWhereUniqueInput
    update?: XOR<XOR<DeviseUpdateToOneWithWhereWithoutCaissesInput, DeviseUpdateWithoutCaissesInput>, DeviseUncheckedUpdateWithoutCaissesInput>
  }

  export type AgentUpdateOneRequiredWithoutCaissesNestedInput = {
    create?: XOR<AgentCreateWithoutCaissesInput, AgentUncheckedCreateWithoutCaissesInput>
    connectOrCreate?: AgentCreateOrConnectWithoutCaissesInput
    upsert?: AgentUpsertWithoutCaissesInput
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutCaissesInput, AgentUpdateWithoutCaissesInput>, AgentUncheckedUpdateWithoutCaissesInput>
  }

  export type MouvementCaisseUpdateManyWithoutCaisseNestedInput = {
    create?: XOR<MouvementCaisseCreateWithoutCaisseInput, MouvementCaisseUncheckedCreateWithoutCaisseInput> | MouvementCaisseCreateWithoutCaisseInput[] | MouvementCaisseUncheckedCreateWithoutCaisseInput[]
    connectOrCreate?: MouvementCaisseCreateOrConnectWithoutCaisseInput | MouvementCaisseCreateOrConnectWithoutCaisseInput[]
    upsert?: MouvementCaisseUpsertWithWhereUniqueWithoutCaisseInput | MouvementCaisseUpsertWithWhereUniqueWithoutCaisseInput[]
    createMany?: MouvementCaisseCreateManyCaisseInputEnvelope
    set?: MouvementCaisseWhereUniqueInput | MouvementCaisseWhereUniqueInput[]
    disconnect?: MouvementCaisseWhereUniqueInput | MouvementCaisseWhereUniqueInput[]
    delete?: MouvementCaisseWhereUniqueInput | MouvementCaisseWhereUniqueInput[]
    connect?: MouvementCaisseWhereUniqueInput | MouvementCaisseWhereUniqueInput[]
    update?: MouvementCaisseUpdateWithWhereUniqueWithoutCaisseInput | MouvementCaisseUpdateWithWhereUniqueWithoutCaisseInput[]
    updateMany?: MouvementCaisseUpdateManyWithWhereWithoutCaisseInput | MouvementCaisseUpdateManyWithWhereWithoutCaisseInput[]
    deleteMany?: MouvementCaisseScalarWhereInput | MouvementCaisseScalarWhereInput[]
  }

  export type PaiementUpdateManyWithoutCaisseNestedInput = {
    create?: XOR<PaiementCreateWithoutCaisseInput, PaiementUncheckedCreateWithoutCaisseInput> | PaiementCreateWithoutCaisseInput[] | PaiementUncheckedCreateWithoutCaisseInput[]
    connectOrCreate?: PaiementCreateOrConnectWithoutCaisseInput | PaiementCreateOrConnectWithoutCaisseInput[]
    upsert?: PaiementUpsertWithWhereUniqueWithoutCaisseInput | PaiementUpsertWithWhereUniqueWithoutCaisseInput[]
    createMany?: PaiementCreateManyCaisseInputEnvelope
    set?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    disconnect?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    delete?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    connect?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    update?: PaiementUpdateWithWhereUniqueWithoutCaisseInput | PaiementUpdateWithWhereUniqueWithoutCaisseInput[]
    updateMany?: PaiementUpdateManyWithWhereWithoutCaisseInput | PaiementUpdateManyWithWhereWithoutCaisseInput[]
    deleteMany?: PaiementScalarWhereInput | PaiementScalarWhereInput[]
  }

  export type MouvementCaisseUncheckedUpdateManyWithoutCaisseNestedInput = {
    create?: XOR<MouvementCaisseCreateWithoutCaisseInput, MouvementCaisseUncheckedCreateWithoutCaisseInput> | MouvementCaisseCreateWithoutCaisseInput[] | MouvementCaisseUncheckedCreateWithoutCaisseInput[]
    connectOrCreate?: MouvementCaisseCreateOrConnectWithoutCaisseInput | MouvementCaisseCreateOrConnectWithoutCaisseInput[]
    upsert?: MouvementCaisseUpsertWithWhereUniqueWithoutCaisseInput | MouvementCaisseUpsertWithWhereUniqueWithoutCaisseInput[]
    createMany?: MouvementCaisseCreateManyCaisseInputEnvelope
    set?: MouvementCaisseWhereUniqueInput | MouvementCaisseWhereUniqueInput[]
    disconnect?: MouvementCaisseWhereUniqueInput | MouvementCaisseWhereUniqueInput[]
    delete?: MouvementCaisseWhereUniqueInput | MouvementCaisseWhereUniqueInput[]
    connect?: MouvementCaisseWhereUniqueInput | MouvementCaisseWhereUniqueInput[]
    update?: MouvementCaisseUpdateWithWhereUniqueWithoutCaisseInput | MouvementCaisseUpdateWithWhereUniqueWithoutCaisseInput[]
    updateMany?: MouvementCaisseUpdateManyWithWhereWithoutCaisseInput | MouvementCaisseUpdateManyWithWhereWithoutCaisseInput[]
    deleteMany?: MouvementCaisseScalarWhereInput | MouvementCaisseScalarWhereInput[]
  }

  export type PaiementUncheckedUpdateManyWithoutCaisseNestedInput = {
    create?: XOR<PaiementCreateWithoutCaisseInput, PaiementUncheckedCreateWithoutCaisseInput> | PaiementCreateWithoutCaisseInput[] | PaiementUncheckedCreateWithoutCaisseInput[]
    connectOrCreate?: PaiementCreateOrConnectWithoutCaisseInput | PaiementCreateOrConnectWithoutCaisseInput[]
    upsert?: PaiementUpsertWithWhereUniqueWithoutCaisseInput | PaiementUpsertWithWhereUniqueWithoutCaisseInput[]
    createMany?: PaiementCreateManyCaisseInputEnvelope
    set?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    disconnect?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    delete?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    connect?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    update?: PaiementUpdateWithWhereUniqueWithoutCaisseInput | PaiementUpdateWithWhereUniqueWithoutCaisseInput[]
    updateMany?: PaiementUpdateManyWithWhereWithoutCaisseInput | PaiementUpdateManyWithWhereWithoutCaisseInput[]
    deleteMany?: PaiementScalarWhereInput | PaiementScalarWhereInput[]
  }

  export type PanierCreateNestedOneWithoutVentesInput = {
    create?: XOR<PanierCreateWithoutVentesInput, PanierUncheckedCreateWithoutVentesInput>
    connectOrCreate?: PanierCreateOrConnectWithoutVentesInput
    connect?: PanierWhereUniqueInput
  }

  export type AgentCreateNestedOneWithoutVentesInput = {
    create?: XOR<AgentCreateWithoutVentesInput, AgentUncheckedCreateWithoutVentesInput>
    connectOrCreate?: AgentCreateOrConnectWithoutVentesInput
    connect?: AgentWhereUniqueInput
  }

  export type FournisseurCreateNestedOneWithoutVentesInput = {
    create?: XOR<FournisseurCreateWithoutVentesInput, FournisseurUncheckedCreateWithoutVentesInput>
    connectOrCreate?: FournisseurCreateOrConnectWithoutVentesInput
    connect?: FournisseurWhereUniqueInput
  }

  export type ClientCreateNestedOneWithoutVentesInput = {
    create?: XOR<ClientCreateWithoutVentesInput, ClientUncheckedCreateWithoutVentesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutVentesInput
    connect?: ClientWhereUniqueInput
  }

  export type PaiementCreateNestedManyWithoutVenteInput = {
    create?: XOR<PaiementCreateWithoutVenteInput, PaiementUncheckedCreateWithoutVenteInput> | PaiementCreateWithoutVenteInput[] | PaiementUncheckedCreateWithoutVenteInput[]
    connectOrCreate?: PaiementCreateOrConnectWithoutVenteInput | PaiementCreateOrConnectWithoutVenteInput[]
    createMany?: PaiementCreateManyVenteInputEnvelope
    connect?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
  }

  export type PaiementUncheckedCreateNestedManyWithoutVenteInput = {
    create?: XOR<PaiementCreateWithoutVenteInput, PaiementUncheckedCreateWithoutVenteInput> | PaiementCreateWithoutVenteInput[] | PaiementUncheckedCreateWithoutVenteInput[]
    connectOrCreate?: PaiementCreateOrConnectWithoutVenteInput | PaiementCreateOrConnectWithoutVenteInput[]
    createMany?: PaiementCreateManyVenteInputEnvelope
    connect?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
  }

  export type EnumStatutVenteFieldUpdateOperationsInput = {
    set?: $Enums.StatutVente
  }

  export type EnumTypeClientFieldUpdateOperationsInput = {
    set?: $Enums.TypeClient
  }

  export type PanierUpdateOneRequiredWithoutVentesNestedInput = {
    create?: XOR<PanierCreateWithoutVentesInput, PanierUncheckedCreateWithoutVentesInput>
    connectOrCreate?: PanierCreateOrConnectWithoutVentesInput
    upsert?: PanierUpsertWithoutVentesInput
    connect?: PanierWhereUniqueInput
    update?: XOR<XOR<PanierUpdateToOneWithWhereWithoutVentesInput, PanierUpdateWithoutVentesInput>, PanierUncheckedUpdateWithoutVentesInput>
  }

  export type AgentUpdateOneWithoutVentesNestedInput = {
    create?: XOR<AgentCreateWithoutVentesInput, AgentUncheckedCreateWithoutVentesInput>
    connectOrCreate?: AgentCreateOrConnectWithoutVentesInput
    upsert?: AgentUpsertWithoutVentesInput
    disconnect?: AgentWhereInput | boolean
    delete?: AgentWhereInput | boolean
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutVentesInput, AgentUpdateWithoutVentesInput>, AgentUncheckedUpdateWithoutVentesInput>
  }

  export type FournisseurUpdateOneWithoutVentesNestedInput = {
    create?: XOR<FournisseurCreateWithoutVentesInput, FournisseurUncheckedCreateWithoutVentesInput>
    connectOrCreate?: FournisseurCreateOrConnectWithoutVentesInput
    upsert?: FournisseurUpsertWithoutVentesInput
    disconnect?: FournisseurWhereInput | boolean
    delete?: FournisseurWhereInput | boolean
    connect?: FournisseurWhereUniqueInput
    update?: XOR<XOR<FournisseurUpdateToOneWithWhereWithoutVentesInput, FournisseurUpdateWithoutVentesInput>, FournisseurUncheckedUpdateWithoutVentesInput>
  }

  export type ClientUpdateOneWithoutVentesNestedInput = {
    create?: XOR<ClientCreateWithoutVentesInput, ClientUncheckedCreateWithoutVentesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutVentesInput
    upsert?: ClientUpsertWithoutVentesInput
    disconnect?: ClientWhereInput | boolean
    delete?: ClientWhereInput | boolean
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutVentesInput, ClientUpdateWithoutVentesInput>, ClientUncheckedUpdateWithoutVentesInput>
  }

  export type PaiementUpdateManyWithoutVenteNestedInput = {
    create?: XOR<PaiementCreateWithoutVenteInput, PaiementUncheckedCreateWithoutVenteInput> | PaiementCreateWithoutVenteInput[] | PaiementUncheckedCreateWithoutVenteInput[]
    connectOrCreate?: PaiementCreateOrConnectWithoutVenteInput | PaiementCreateOrConnectWithoutVenteInput[]
    upsert?: PaiementUpsertWithWhereUniqueWithoutVenteInput | PaiementUpsertWithWhereUniqueWithoutVenteInput[]
    createMany?: PaiementCreateManyVenteInputEnvelope
    set?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    disconnect?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    delete?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    connect?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    update?: PaiementUpdateWithWhereUniqueWithoutVenteInput | PaiementUpdateWithWhereUniqueWithoutVenteInput[]
    updateMany?: PaiementUpdateManyWithWhereWithoutVenteInput | PaiementUpdateManyWithWhereWithoutVenteInput[]
    deleteMany?: PaiementScalarWhereInput | PaiementScalarWhereInput[]
  }

  export type PaiementUncheckedUpdateManyWithoutVenteNestedInput = {
    create?: XOR<PaiementCreateWithoutVenteInput, PaiementUncheckedCreateWithoutVenteInput> | PaiementCreateWithoutVenteInput[] | PaiementUncheckedCreateWithoutVenteInput[]
    connectOrCreate?: PaiementCreateOrConnectWithoutVenteInput | PaiementCreateOrConnectWithoutVenteInput[]
    upsert?: PaiementUpsertWithWhereUniqueWithoutVenteInput | PaiementUpsertWithWhereUniqueWithoutVenteInput[]
    createMany?: PaiementCreateManyVenteInputEnvelope
    set?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    disconnect?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    delete?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    connect?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    update?: PaiementUpdateWithWhereUniqueWithoutVenteInput | PaiementUpdateWithWhereUniqueWithoutVenteInput[]
    updateMany?: PaiementUpdateManyWithWhereWithoutVenteInput | PaiementUpdateManyWithWhereWithoutVenteInput[]
    deleteMany?: PaiementScalarWhereInput | PaiementScalarWhereInput[]
  }

  export type AgentCreateNestedOneWithoutPaniersInput = {
    create?: XOR<AgentCreateWithoutPaniersInput, AgentUncheckedCreateWithoutPaniersInput>
    connectOrCreate?: AgentCreateOrConnectWithoutPaniersInput
    connect?: AgentWhereUniqueInput
  }

  export type ClientCreateNestedOneWithoutPaniersInput = {
    create?: XOR<ClientCreateWithoutPaniersInput, ClientUncheckedCreateWithoutPaniersInput>
    connectOrCreate?: ClientCreateOrConnectWithoutPaniersInput
    connect?: ClientWhereUniqueInput
  }

  export type DetailPanierCreateNestedManyWithoutPanierInput = {
    create?: XOR<DetailPanierCreateWithoutPanierInput, DetailPanierUncheckedCreateWithoutPanierInput> | DetailPanierCreateWithoutPanierInput[] | DetailPanierUncheckedCreateWithoutPanierInput[]
    connectOrCreate?: DetailPanierCreateOrConnectWithoutPanierInput | DetailPanierCreateOrConnectWithoutPanierInput[]
    createMany?: DetailPanierCreateManyPanierInputEnvelope
    connect?: DetailPanierWhereUniqueInput | DetailPanierWhereUniqueInput[]
  }

  export type AchatCreateNestedManyWithoutPanierInput = {
    create?: XOR<AchatCreateWithoutPanierInput, AchatUncheckedCreateWithoutPanierInput> | AchatCreateWithoutPanierInput[] | AchatUncheckedCreateWithoutPanierInput[]
    connectOrCreate?: AchatCreateOrConnectWithoutPanierInput | AchatCreateOrConnectWithoutPanierInput[]
    createMany?: AchatCreateManyPanierInputEnvelope
    connect?: AchatWhereUniqueInput | AchatWhereUniqueInput[]
  }

  export type VenteCreateNestedManyWithoutPanierInput = {
    create?: XOR<VenteCreateWithoutPanierInput, VenteUncheckedCreateWithoutPanierInput> | VenteCreateWithoutPanierInput[] | VenteUncheckedCreateWithoutPanierInput[]
    connectOrCreate?: VenteCreateOrConnectWithoutPanierInput | VenteCreateOrConnectWithoutPanierInput[]
    createMany?: VenteCreateManyPanierInputEnvelope
    connect?: VenteWhereUniqueInput | VenteWhereUniqueInput[]
  }

  export type ReservationCreateNestedManyWithoutPanierInput = {
    create?: XOR<ReservationCreateWithoutPanierInput, ReservationUncheckedCreateWithoutPanierInput> | ReservationCreateWithoutPanierInput[] | ReservationUncheckedCreateWithoutPanierInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutPanierInput | ReservationCreateOrConnectWithoutPanierInput[]
    createMany?: ReservationCreateManyPanierInputEnvelope
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
  }

  export type CommandeCreateNestedManyWithoutPanierInput = {
    create?: XOR<CommandeCreateWithoutPanierInput, CommandeUncheckedCreateWithoutPanierInput> | CommandeCreateWithoutPanierInput[] | CommandeUncheckedCreateWithoutPanierInput[]
    connectOrCreate?: CommandeCreateOrConnectWithoutPanierInput | CommandeCreateOrConnectWithoutPanierInput[]
    createMany?: CommandeCreateManyPanierInputEnvelope
    connect?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
  }

  export type DetailPanierUncheckedCreateNestedManyWithoutPanierInput = {
    create?: XOR<DetailPanierCreateWithoutPanierInput, DetailPanierUncheckedCreateWithoutPanierInput> | DetailPanierCreateWithoutPanierInput[] | DetailPanierUncheckedCreateWithoutPanierInput[]
    connectOrCreate?: DetailPanierCreateOrConnectWithoutPanierInput | DetailPanierCreateOrConnectWithoutPanierInput[]
    createMany?: DetailPanierCreateManyPanierInputEnvelope
    connect?: DetailPanierWhereUniqueInput | DetailPanierWhereUniqueInput[]
  }

  export type AchatUncheckedCreateNestedManyWithoutPanierInput = {
    create?: XOR<AchatCreateWithoutPanierInput, AchatUncheckedCreateWithoutPanierInput> | AchatCreateWithoutPanierInput[] | AchatUncheckedCreateWithoutPanierInput[]
    connectOrCreate?: AchatCreateOrConnectWithoutPanierInput | AchatCreateOrConnectWithoutPanierInput[]
    createMany?: AchatCreateManyPanierInputEnvelope
    connect?: AchatWhereUniqueInput | AchatWhereUniqueInput[]
  }

  export type VenteUncheckedCreateNestedManyWithoutPanierInput = {
    create?: XOR<VenteCreateWithoutPanierInput, VenteUncheckedCreateWithoutPanierInput> | VenteCreateWithoutPanierInput[] | VenteUncheckedCreateWithoutPanierInput[]
    connectOrCreate?: VenteCreateOrConnectWithoutPanierInput | VenteCreateOrConnectWithoutPanierInput[]
    createMany?: VenteCreateManyPanierInputEnvelope
    connect?: VenteWhereUniqueInput | VenteWhereUniqueInput[]
  }

  export type ReservationUncheckedCreateNestedManyWithoutPanierInput = {
    create?: XOR<ReservationCreateWithoutPanierInput, ReservationUncheckedCreateWithoutPanierInput> | ReservationCreateWithoutPanierInput[] | ReservationUncheckedCreateWithoutPanierInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutPanierInput | ReservationCreateOrConnectWithoutPanierInput[]
    createMany?: ReservationCreateManyPanierInputEnvelope
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
  }

  export type CommandeUncheckedCreateNestedManyWithoutPanierInput = {
    create?: XOR<CommandeCreateWithoutPanierInput, CommandeUncheckedCreateWithoutPanierInput> | CommandeCreateWithoutPanierInput[] | CommandeUncheckedCreateWithoutPanierInput[]
    connectOrCreate?: CommandeCreateOrConnectWithoutPanierInput | CommandeCreateOrConnectWithoutPanierInput[]
    createMany?: CommandeCreateManyPanierInputEnvelope
    connect?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
  }

  export type EnumstatutPanierFieldUpdateOperationsInput = {
    set?: $Enums.statutPanier
  }

  export type AgentUpdateOneWithoutPaniersNestedInput = {
    create?: XOR<AgentCreateWithoutPaniersInput, AgentUncheckedCreateWithoutPaniersInput>
    connectOrCreate?: AgentCreateOrConnectWithoutPaniersInput
    upsert?: AgentUpsertWithoutPaniersInput
    disconnect?: AgentWhereInput | boolean
    delete?: AgentWhereInput | boolean
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutPaniersInput, AgentUpdateWithoutPaniersInput>, AgentUncheckedUpdateWithoutPaniersInput>
  }

  export type ClientUpdateOneWithoutPaniersNestedInput = {
    create?: XOR<ClientCreateWithoutPaniersInput, ClientUncheckedCreateWithoutPaniersInput>
    connectOrCreate?: ClientCreateOrConnectWithoutPaniersInput
    upsert?: ClientUpsertWithoutPaniersInput
    disconnect?: ClientWhereInput | boolean
    delete?: ClientWhereInput | boolean
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutPaniersInput, ClientUpdateWithoutPaniersInput>, ClientUncheckedUpdateWithoutPaniersInput>
  }

  export type DetailPanierUpdateManyWithoutPanierNestedInput = {
    create?: XOR<DetailPanierCreateWithoutPanierInput, DetailPanierUncheckedCreateWithoutPanierInput> | DetailPanierCreateWithoutPanierInput[] | DetailPanierUncheckedCreateWithoutPanierInput[]
    connectOrCreate?: DetailPanierCreateOrConnectWithoutPanierInput | DetailPanierCreateOrConnectWithoutPanierInput[]
    upsert?: DetailPanierUpsertWithWhereUniqueWithoutPanierInput | DetailPanierUpsertWithWhereUniqueWithoutPanierInput[]
    createMany?: DetailPanierCreateManyPanierInputEnvelope
    set?: DetailPanierWhereUniqueInput | DetailPanierWhereUniqueInput[]
    disconnect?: DetailPanierWhereUniqueInput | DetailPanierWhereUniqueInput[]
    delete?: DetailPanierWhereUniqueInput | DetailPanierWhereUniqueInput[]
    connect?: DetailPanierWhereUniqueInput | DetailPanierWhereUniqueInput[]
    update?: DetailPanierUpdateWithWhereUniqueWithoutPanierInput | DetailPanierUpdateWithWhereUniqueWithoutPanierInput[]
    updateMany?: DetailPanierUpdateManyWithWhereWithoutPanierInput | DetailPanierUpdateManyWithWhereWithoutPanierInput[]
    deleteMany?: DetailPanierScalarWhereInput | DetailPanierScalarWhereInput[]
  }

  export type AchatUpdateManyWithoutPanierNestedInput = {
    create?: XOR<AchatCreateWithoutPanierInput, AchatUncheckedCreateWithoutPanierInput> | AchatCreateWithoutPanierInput[] | AchatUncheckedCreateWithoutPanierInput[]
    connectOrCreate?: AchatCreateOrConnectWithoutPanierInput | AchatCreateOrConnectWithoutPanierInput[]
    upsert?: AchatUpsertWithWhereUniqueWithoutPanierInput | AchatUpsertWithWhereUniqueWithoutPanierInput[]
    createMany?: AchatCreateManyPanierInputEnvelope
    set?: AchatWhereUniqueInput | AchatWhereUniqueInput[]
    disconnect?: AchatWhereUniqueInput | AchatWhereUniqueInput[]
    delete?: AchatWhereUniqueInput | AchatWhereUniqueInput[]
    connect?: AchatWhereUniqueInput | AchatWhereUniqueInput[]
    update?: AchatUpdateWithWhereUniqueWithoutPanierInput | AchatUpdateWithWhereUniqueWithoutPanierInput[]
    updateMany?: AchatUpdateManyWithWhereWithoutPanierInput | AchatUpdateManyWithWhereWithoutPanierInput[]
    deleteMany?: AchatScalarWhereInput | AchatScalarWhereInput[]
  }

  export type VenteUpdateManyWithoutPanierNestedInput = {
    create?: XOR<VenteCreateWithoutPanierInput, VenteUncheckedCreateWithoutPanierInput> | VenteCreateWithoutPanierInput[] | VenteUncheckedCreateWithoutPanierInput[]
    connectOrCreate?: VenteCreateOrConnectWithoutPanierInput | VenteCreateOrConnectWithoutPanierInput[]
    upsert?: VenteUpsertWithWhereUniqueWithoutPanierInput | VenteUpsertWithWhereUniqueWithoutPanierInput[]
    createMany?: VenteCreateManyPanierInputEnvelope
    set?: VenteWhereUniqueInput | VenteWhereUniqueInput[]
    disconnect?: VenteWhereUniqueInput | VenteWhereUniqueInput[]
    delete?: VenteWhereUniqueInput | VenteWhereUniqueInput[]
    connect?: VenteWhereUniqueInput | VenteWhereUniqueInput[]
    update?: VenteUpdateWithWhereUniqueWithoutPanierInput | VenteUpdateWithWhereUniqueWithoutPanierInput[]
    updateMany?: VenteUpdateManyWithWhereWithoutPanierInput | VenteUpdateManyWithWhereWithoutPanierInput[]
    deleteMany?: VenteScalarWhereInput | VenteScalarWhereInput[]
  }

  export type ReservationUpdateManyWithoutPanierNestedInput = {
    create?: XOR<ReservationCreateWithoutPanierInput, ReservationUncheckedCreateWithoutPanierInput> | ReservationCreateWithoutPanierInput[] | ReservationUncheckedCreateWithoutPanierInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutPanierInput | ReservationCreateOrConnectWithoutPanierInput[]
    upsert?: ReservationUpsertWithWhereUniqueWithoutPanierInput | ReservationUpsertWithWhereUniqueWithoutPanierInput[]
    createMany?: ReservationCreateManyPanierInputEnvelope
    set?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    disconnect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    delete?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    update?: ReservationUpdateWithWhereUniqueWithoutPanierInput | ReservationUpdateWithWhereUniqueWithoutPanierInput[]
    updateMany?: ReservationUpdateManyWithWhereWithoutPanierInput | ReservationUpdateManyWithWhereWithoutPanierInput[]
    deleteMany?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
  }

  export type CommandeUpdateManyWithoutPanierNestedInput = {
    create?: XOR<CommandeCreateWithoutPanierInput, CommandeUncheckedCreateWithoutPanierInput> | CommandeCreateWithoutPanierInput[] | CommandeUncheckedCreateWithoutPanierInput[]
    connectOrCreate?: CommandeCreateOrConnectWithoutPanierInput | CommandeCreateOrConnectWithoutPanierInput[]
    upsert?: CommandeUpsertWithWhereUniqueWithoutPanierInput | CommandeUpsertWithWhereUniqueWithoutPanierInput[]
    createMany?: CommandeCreateManyPanierInputEnvelope
    set?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    disconnect?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    delete?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    connect?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    update?: CommandeUpdateWithWhereUniqueWithoutPanierInput | CommandeUpdateWithWhereUniqueWithoutPanierInput[]
    updateMany?: CommandeUpdateManyWithWhereWithoutPanierInput | CommandeUpdateManyWithWhereWithoutPanierInput[]
    deleteMany?: CommandeScalarWhereInput | CommandeScalarWhereInput[]
  }

  export type DetailPanierUncheckedUpdateManyWithoutPanierNestedInput = {
    create?: XOR<DetailPanierCreateWithoutPanierInput, DetailPanierUncheckedCreateWithoutPanierInput> | DetailPanierCreateWithoutPanierInput[] | DetailPanierUncheckedCreateWithoutPanierInput[]
    connectOrCreate?: DetailPanierCreateOrConnectWithoutPanierInput | DetailPanierCreateOrConnectWithoutPanierInput[]
    upsert?: DetailPanierUpsertWithWhereUniqueWithoutPanierInput | DetailPanierUpsertWithWhereUniqueWithoutPanierInput[]
    createMany?: DetailPanierCreateManyPanierInputEnvelope
    set?: DetailPanierWhereUniqueInput | DetailPanierWhereUniqueInput[]
    disconnect?: DetailPanierWhereUniqueInput | DetailPanierWhereUniqueInput[]
    delete?: DetailPanierWhereUniqueInput | DetailPanierWhereUniqueInput[]
    connect?: DetailPanierWhereUniqueInput | DetailPanierWhereUniqueInput[]
    update?: DetailPanierUpdateWithWhereUniqueWithoutPanierInput | DetailPanierUpdateWithWhereUniqueWithoutPanierInput[]
    updateMany?: DetailPanierUpdateManyWithWhereWithoutPanierInput | DetailPanierUpdateManyWithWhereWithoutPanierInput[]
    deleteMany?: DetailPanierScalarWhereInput | DetailPanierScalarWhereInput[]
  }

  export type AchatUncheckedUpdateManyWithoutPanierNestedInput = {
    create?: XOR<AchatCreateWithoutPanierInput, AchatUncheckedCreateWithoutPanierInput> | AchatCreateWithoutPanierInput[] | AchatUncheckedCreateWithoutPanierInput[]
    connectOrCreate?: AchatCreateOrConnectWithoutPanierInput | AchatCreateOrConnectWithoutPanierInput[]
    upsert?: AchatUpsertWithWhereUniqueWithoutPanierInput | AchatUpsertWithWhereUniqueWithoutPanierInput[]
    createMany?: AchatCreateManyPanierInputEnvelope
    set?: AchatWhereUniqueInput | AchatWhereUniqueInput[]
    disconnect?: AchatWhereUniqueInput | AchatWhereUniqueInput[]
    delete?: AchatWhereUniqueInput | AchatWhereUniqueInput[]
    connect?: AchatWhereUniqueInput | AchatWhereUniqueInput[]
    update?: AchatUpdateWithWhereUniqueWithoutPanierInput | AchatUpdateWithWhereUniqueWithoutPanierInput[]
    updateMany?: AchatUpdateManyWithWhereWithoutPanierInput | AchatUpdateManyWithWhereWithoutPanierInput[]
    deleteMany?: AchatScalarWhereInput | AchatScalarWhereInput[]
  }

  export type VenteUncheckedUpdateManyWithoutPanierNestedInput = {
    create?: XOR<VenteCreateWithoutPanierInput, VenteUncheckedCreateWithoutPanierInput> | VenteCreateWithoutPanierInput[] | VenteUncheckedCreateWithoutPanierInput[]
    connectOrCreate?: VenteCreateOrConnectWithoutPanierInput | VenteCreateOrConnectWithoutPanierInput[]
    upsert?: VenteUpsertWithWhereUniqueWithoutPanierInput | VenteUpsertWithWhereUniqueWithoutPanierInput[]
    createMany?: VenteCreateManyPanierInputEnvelope
    set?: VenteWhereUniqueInput | VenteWhereUniqueInput[]
    disconnect?: VenteWhereUniqueInput | VenteWhereUniqueInput[]
    delete?: VenteWhereUniqueInput | VenteWhereUniqueInput[]
    connect?: VenteWhereUniqueInput | VenteWhereUniqueInput[]
    update?: VenteUpdateWithWhereUniqueWithoutPanierInput | VenteUpdateWithWhereUniqueWithoutPanierInput[]
    updateMany?: VenteUpdateManyWithWhereWithoutPanierInput | VenteUpdateManyWithWhereWithoutPanierInput[]
    deleteMany?: VenteScalarWhereInput | VenteScalarWhereInput[]
  }

  export type ReservationUncheckedUpdateManyWithoutPanierNestedInput = {
    create?: XOR<ReservationCreateWithoutPanierInput, ReservationUncheckedCreateWithoutPanierInput> | ReservationCreateWithoutPanierInput[] | ReservationUncheckedCreateWithoutPanierInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutPanierInput | ReservationCreateOrConnectWithoutPanierInput[]
    upsert?: ReservationUpsertWithWhereUniqueWithoutPanierInput | ReservationUpsertWithWhereUniqueWithoutPanierInput[]
    createMany?: ReservationCreateManyPanierInputEnvelope
    set?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    disconnect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    delete?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    update?: ReservationUpdateWithWhereUniqueWithoutPanierInput | ReservationUpdateWithWhereUniqueWithoutPanierInput[]
    updateMany?: ReservationUpdateManyWithWhereWithoutPanierInput | ReservationUpdateManyWithWhereWithoutPanierInput[]
    deleteMany?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
  }

  export type CommandeUncheckedUpdateManyWithoutPanierNestedInput = {
    create?: XOR<CommandeCreateWithoutPanierInput, CommandeUncheckedCreateWithoutPanierInput> | CommandeCreateWithoutPanierInput[] | CommandeUncheckedCreateWithoutPanierInput[]
    connectOrCreate?: CommandeCreateOrConnectWithoutPanierInput | CommandeCreateOrConnectWithoutPanierInput[]
    upsert?: CommandeUpsertWithWhereUniqueWithoutPanierInput | CommandeUpsertWithWhereUniqueWithoutPanierInput[]
    createMany?: CommandeCreateManyPanierInputEnvelope
    set?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    disconnect?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    delete?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    connect?: CommandeWhereUniqueInput | CommandeWhereUniqueInput[]
    update?: CommandeUpdateWithWhereUniqueWithoutPanierInput | CommandeUpdateWithWhereUniqueWithoutPanierInput[]
    updateMany?: CommandeUpdateManyWithWhereWithoutPanierInput | CommandeUpdateManyWithWhereWithoutPanierInput[]
    deleteMany?: CommandeScalarWhereInput | CommandeScalarWhereInput[]
  }

  export type DeviseCreateNestedOneWithoutDetailPanierInput = {
    create?: XOR<DeviseCreateWithoutDetailPanierInput, DeviseUncheckedCreateWithoutDetailPanierInput>
    connectOrCreate?: DeviseCreateOrConnectWithoutDetailPanierInput
    connect?: DeviseWhereUniqueInput
  }

  export type ProduitCreateNestedOneWithoutDetailsPaniersInput = {
    create?: XOR<ProduitCreateWithoutDetailsPaniersInput, ProduitUncheckedCreateWithoutDetailsPaniersInput>
    connectOrCreate?: ProduitCreateOrConnectWithoutDetailsPaniersInput
    connect?: ProduitWhereUniqueInput
  }

  export type PanierCreateNestedOneWithoutDetailPaniersInput = {
    create?: XOR<PanierCreateWithoutDetailPaniersInput, PanierUncheckedCreateWithoutDetailPaniersInput>
    connectOrCreate?: PanierCreateOrConnectWithoutDetailPaniersInput
    connect?: PanierWhereUniqueInput
  }

  export type DeviseUpdateOneRequiredWithoutDetailPanierNestedInput = {
    create?: XOR<DeviseCreateWithoutDetailPanierInput, DeviseUncheckedCreateWithoutDetailPanierInput>
    connectOrCreate?: DeviseCreateOrConnectWithoutDetailPanierInput
    upsert?: DeviseUpsertWithoutDetailPanierInput
    connect?: DeviseWhereUniqueInput
    update?: XOR<XOR<DeviseUpdateToOneWithWhereWithoutDetailPanierInput, DeviseUpdateWithoutDetailPanierInput>, DeviseUncheckedUpdateWithoutDetailPanierInput>
  }

  export type ProduitUpdateOneRequiredWithoutDetailsPaniersNestedInput = {
    create?: XOR<ProduitCreateWithoutDetailsPaniersInput, ProduitUncheckedCreateWithoutDetailsPaniersInput>
    connectOrCreate?: ProduitCreateOrConnectWithoutDetailsPaniersInput
    upsert?: ProduitUpsertWithoutDetailsPaniersInput
    connect?: ProduitWhereUniqueInput
    update?: XOR<XOR<ProduitUpdateToOneWithWhereWithoutDetailsPaniersInput, ProduitUpdateWithoutDetailsPaniersInput>, ProduitUncheckedUpdateWithoutDetailsPaniersInput>
  }

  export type PanierUpdateOneRequiredWithoutDetailPaniersNestedInput = {
    create?: XOR<PanierCreateWithoutDetailPaniersInput, PanierUncheckedCreateWithoutDetailPaniersInput>
    connectOrCreate?: PanierCreateOrConnectWithoutDetailPaniersInput
    upsert?: PanierUpsertWithoutDetailPaniersInput
    connect?: PanierWhereUniqueInput
    update?: XOR<XOR<PanierUpdateToOneWithWhereWithoutDetailPaniersInput, PanierUpdateWithoutDetailPaniersInput>, PanierUncheckedUpdateWithoutDetailPaniersInput>
  }

  export type PanierCreateNestedOneWithoutAchatsInput = {
    create?: XOR<PanierCreateWithoutAchatsInput, PanierUncheckedCreateWithoutAchatsInput>
    connectOrCreate?: PanierCreateOrConnectWithoutAchatsInput
    connect?: PanierWhereUniqueInput
  }

  export type FournisseurCreateNestedOneWithoutAchatsInput = {
    create?: XOR<FournisseurCreateWithoutAchatsInput, FournisseurUncheckedCreateWithoutAchatsInput>
    connectOrCreate?: FournisseurCreateOrConnectWithoutAchatsInput
    connect?: FournisseurWhereUniqueInput
  }

  export type AgentCreateNestedOneWithoutAchatsInput = {
    create?: XOR<AgentCreateWithoutAchatsInput, AgentUncheckedCreateWithoutAchatsInput>
    connectOrCreate?: AgentCreateOrConnectWithoutAchatsInput
    connect?: AgentWhereUniqueInput
  }

  export type ClientCreateNestedOneWithoutAchatsInput = {
    create?: XOR<ClientCreateWithoutAchatsInput, ClientUncheckedCreateWithoutAchatsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutAchatsInput
    connect?: ClientWhereUniqueInput
  }

  export type PaiementCreateNestedManyWithoutAchatInput = {
    create?: XOR<PaiementCreateWithoutAchatInput, PaiementUncheckedCreateWithoutAchatInput> | PaiementCreateWithoutAchatInput[] | PaiementUncheckedCreateWithoutAchatInput[]
    connectOrCreate?: PaiementCreateOrConnectWithoutAchatInput | PaiementCreateOrConnectWithoutAchatInput[]
    createMany?: PaiementCreateManyAchatInputEnvelope
    connect?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
  }

  export type PaiementUncheckedCreateNestedManyWithoutAchatInput = {
    create?: XOR<PaiementCreateWithoutAchatInput, PaiementUncheckedCreateWithoutAchatInput> | PaiementCreateWithoutAchatInput[] | PaiementUncheckedCreateWithoutAchatInput[]
    connectOrCreate?: PaiementCreateOrConnectWithoutAchatInput | PaiementCreateOrConnectWithoutAchatInput[]
    createMany?: PaiementCreateManyAchatInputEnvelope
    connect?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
  }

  export type EnumStatutAchatFieldUpdateOperationsInput = {
    set?: $Enums.StatutAchat
  }

  export type PanierUpdateOneRequiredWithoutAchatsNestedInput = {
    create?: XOR<PanierCreateWithoutAchatsInput, PanierUncheckedCreateWithoutAchatsInput>
    connectOrCreate?: PanierCreateOrConnectWithoutAchatsInput
    upsert?: PanierUpsertWithoutAchatsInput
    connect?: PanierWhereUniqueInput
    update?: XOR<XOR<PanierUpdateToOneWithWhereWithoutAchatsInput, PanierUpdateWithoutAchatsInput>, PanierUncheckedUpdateWithoutAchatsInput>
  }

  export type FournisseurUpdateOneRequiredWithoutAchatsNestedInput = {
    create?: XOR<FournisseurCreateWithoutAchatsInput, FournisseurUncheckedCreateWithoutAchatsInput>
    connectOrCreate?: FournisseurCreateOrConnectWithoutAchatsInput
    upsert?: FournisseurUpsertWithoutAchatsInput
    connect?: FournisseurWhereUniqueInput
    update?: XOR<XOR<FournisseurUpdateToOneWithWhereWithoutAchatsInput, FournisseurUpdateWithoutAchatsInput>, FournisseurUncheckedUpdateWithoutAchatsInput>
  }

  export type AgentUpdateOneRequiredWithoutAchatsNestedInput = {
    create?: XOR<AgentCreateWithoutAchatsInput, AgentUncheckedCreateWithoutAchatsInput>
    connectOrCreate?: AgentCreateOrConnectWithoutAchatsInput
    upsert?: AgentUpsertWithoutAchatsInput
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutAchatsInput, AgentUpdateWithoutAchatsInput>, AgentUncheckedUpdateWithoutAchatsInput>
  }

  export type ClientUpdateOneWithoutAchatsNestedInput = {
    create?: XOR<ClientCreateWithoutAchatsInput, ClientUncheckedCreateWithoutAchatsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutAchatsInput
    upsert?: ClientUpsertWithoutAchatsInput
    disconnect?: ClientWhereInput | boolean
    delete?: ClientWhereInput | boolean
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutAchatsInput, ClientUpdateWithoutAchatsInput>, ClientUncheckedUpdateWithoutAchatsInput>
  }

  export type PaiementUpdateManyWithoutAchatNestedInput = {
    create?: XOR<PaiementCreateWithoutAchatInput, PaiementUncheckedCreateWithoutAchatInput> | PaiementCreateWithoutAchatInput[] | PaiementUncheckedCreateWithoutAchatInput[]
    connectOrCreate?: PaiementCreateOrConnectWithoutAchatInput | PaiementCreateOrConnectWithoutAchatInput[]
    upsert?: PaiementUpsertWithWhereUniqueWithoutAchatInput | PaiementUpsertWithWhereUniqueWithoutAchatInput[]
    createMany?: PaiementCreateManyAchatInputEnvelope
    set?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    disconnect?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    delete?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    connect?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    update?: PaiementUpdateWithWhereUniqueWithoutAchatInput | PaiementUpdateWithWhereUniqueWithoutAchatInput[]
    updateMany?: PaiementUpdateManyWithWhereWithoutAchatInput | PaiementUpdateManyWithWhereWithoutAchatInput[]
    deleteMany?: PaiementScalarWhereInput | PaiementScalarWhereInput[]
  }

  export type PaiementUncheckedUpdateManyWithoutAchatNestedInput = {
    create?: XOR<PaiementCreateWithoutAchatInput, PaiementUncheckedCreateWithoutAchatInput> | PaiementCreateWithoutAchatInput[] | PaiementUncheckedCreateWithoutAchatInput[]
    connectOrCreate?: PaiementCreateOrConnectWithoutAchatInput | PaiementCreateOrConnectWithoutAchatInput[]
    upsert?: PaiementUpsertWithWhereUniqueWithoutAchatInput | PaiementUpsertWithWhereUniqueWithoutAchatInput[]
    createMany?: PaiementCreateManyAchatInputEnvelope
    set?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    disconnect?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    delete?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    connect?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    update?: PaiementUpdateWithWhereUniqueWithoutAchatInput | PaiementUpdateWithWhereUniqueWithoutAchatInput[]
    updateMany?: PaiementUpdateManyWithWhereWithoutAchatInput | PaiementUpdateManyWithWhereWithoutAchatInput[]
    deleteMany?: PaiementScalarWhereInput | PaiementScalarWhereInput[]
  }

  export type PanierCreateNestedOneWithoutReservationsInput = {
    create?: XOR<PanierCreateWithoutReservationsInput, PanierUncheckedCreateWithoutReservationsInput>
    connectOrCreate?: PanierCreateOrConnectWithoutReservationsInput
    connect?: PanierWhereUniqueInput
  }

  export type FournisseurCreateNestedOneWithoutReservationsInput = {
    create?: XOR<FournisseurCreateWithoutReservationsInput, FournisseurUncheckedCreateWithoutReservationsInput>
    connectOrCreate?: FournisseurCreateOrConnectWithoutReservationsInput
    connect?: FournisseurWhereUniqueInput
  }

  export type AdresseCreateNestedOneWithoutReservationsInput = {
    create?: XOR<AdresseCreateWithoutReservationsInput, AdresseUncheckedCreateWithoutReservationsInput>
    connectOrCreate?: AdresseCreateOrConnectWithoutReservationsInput
    connect?: AdresseWhereUniqueInput
  }

  export type ContactCreateNestedOneWithoutReservationsInput = {
    create?: XOR<ContactCreateWithoutReservationsInput, ContactUncheckedCreateWithoutReservationsInput>
    connectOrCreate?: ContactCreateOrConnectWithoutReservationsInput
    connect?: ContactWhereUniqueInput
  }

  export type ClientCreateNestedOneWithoutReservationsInput = {
    create?: XOR<ClientCreateWithoutReservationsInput, ClientUncheckedCreateWithoutReservationsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutReservationsInput
    connect?: ClientWhereUniqueInput
  }

  export type EnumStatutReservationFieldUpdateOperationsInput = {
    set?: $Enums.StatutReservation
  }

  export type PanierUpdateOneRequiredWithoutReservationsNestedInput = {
    create?: XOR<PanierCreateWithoutReservationsInput, PanierUncheckedCreateWithoutReservationsInput>
    connectOrCreate?: PanierCreateOrConnectWithoutReservationsInput
    upsert?: PanierUpsertWithoutReservationsInput
    connect?: PanierWhereUniqueInput
    update?: XOR<XOR<PanierUpdateToOneWithWhereWithoutReservationsInput, PanierUpdateWithoutReservationsInput>, PanierUncheckedUpdateWithoutReservationsInput>
  }

  export type FournisseurUpdateOneWithoutReservationsNestedInput = {
    create?: XOR<FournisseurCreateWithoutReservationsInput, FournisseurUncheckedCreateWithoutReservationsInput>
    connectOrCreate?: FournisseurCreateOrConnectWithoutReservationsInput
    upsert?: FournisseurUpsertWithoutReservationsInput
    disconnect?: FournisseurWhereInput | boolean
    delete?: FournisseurWhereInput | boolean
    connect?: FournisseurWhereUniqueInput
    update?: XOR<XOR<FournisseurUpdateToOneWithWhereWithoutReservationsInput, FournisseurUpdateWithoutReservationsInput>, FournisseurUncheckedUpdateWithoutReservationsInput>
  }

  export type AdresseUpdateOneWithoutReservationsNestedInput = {
    create?: XOR<AdresseCreateWithoutReservationsInput, AdresseUncheckedCreateWithoutReservationsInput>
    connectOrCreate?: AdresseCreateOrConnectWithoutReservationsInput
    upsert?: AdresseUpsertWithoutReservationsInput
    disconnect?: AdresseWhereInput | boolean
    delete?: AdresseWhereInput | boolean
    connect?: AdresseWhereUniqueInput
    update?: XOR<XOR<AdresseUpdateToOneWithWhereWithoutReservationsInput, AdresseUpdateWithoutReservationsInput>, AdresseUncheckedUpdateWithoutReservationsInput>
  }

  export type ContactUpdateOneWithoutReservationsNestedInput = {
    create?: XOR<ContactCreateWithoutReservationsInput, ContactUncheckedCreateWithoutReservationsInput>
    connectOrCreate?: ContactCreateOrConnectWithoutReservationsInput
    upsert?: ContactUpsertWithoutReservationsInput
    disconnect?: ContactWhereInput | boolean
    delete?: ContactWhereInput | boolean
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutReservationsInput, ContactUpdateWithoutReservationsInput>, ContactUncheckedUpdateWithoutReservationsInput>
  }

  export type ClientUpdateOneWithoutReservationsNestedInput = {
    create?: XOR<ClientCreateWithoutReservationsInput, ClientUncheckedCreateWithoutReservationsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutReservationsInput
    upsert?: ClientUpsertWithoutReservationsInput
    disconnect?: ClientWhereInput | boolean
    delete?: ClientWhereInput | boolean
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutReservationsInput, ClientUpdateWithoutReservationsInput>, ClientUncheckedUpdateWithoutReservationsInput>
  }

  export type PaiementCreateNestedManyWithoutCommandeInput = {
    create?: XOR<PaiementCreateWithoutCommandeInput, PaiementUncheckedCreateWithoutCommandeInput> | PaiementCreateWithoutCommandeInput[] | PaiementUncheckedCreateWithoutCommandeInput[]
    connectOrCreate?: PaiementCreateOrConnectWithoutCommandeInput | PaiementCreateOrConnectWithoutCommandeInput[]
    createMany?: PaiementCreateManyCommandeInputEnvelope
    connect?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
  }

  export type PanierCreateNestedOneWithoutCommandesInput = {
    create?: XOR<PanierCreateWithoutCommandesInput, PanierUncheckedCreateWithoutCommandesInput>
    connectOrCreate?: PanierCreateOrConnectWithoutCommandesInput
    connect?: PanierWhereUniqueInput
  }

  export type FournisseurCreateNestedOneWithoutCommandesInput = {
    create?: XOR<FournisseurCreateWithoutCommandesInput, FournisseurUncheckedCreateWithoutCommandesInput>
    connectOrCreate?: FournisseurCreateOrConnectWithoutCommandesInput
    connect?: FournisseurWhereUniqueInput
  }

  export type AdresseCreateNestedOneWithoutCommandesInput = {
    create?: XOR<AdresseCreateWithoutCommandesInput, AdresseUncheckedCreateWithoutCommandesInput>
    connectOrCreate?: AdresseCreateOrConnectWithoutCommandesInput
    connect?: AdresseWhereUniqueInput
  }

  export type ContactCreateNestedOneWithoutCommandesInput = {
    create?: XOR<ContactCreateWithoutCommandesInput, ContactUncheckedCreateWithoutCommandesInput>
    connectOrCreate?: ContactCreateOrConnectWithoutCommandesInput
    connect?: ContactWhereUniqueInput
  }

  export type ClientCreateNestedOneWithoutCommandesInput = {
    create?: XOR<ClientCreateWithoutCommandesInput, ClientUncheckedCreateWithoutCommandesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutCommandesInput
    connect?: ClientWhereUniqueInput
  }

  export type PaiementUncheckedCreateNestedManyWithoutCommandeInput = {
    create?: XOR<PaiementCreateWithoutCommandeInput, PaiementUncheckedCreateWithoutCommandeInput> | PaiementCreateWithoutCommandeInput[] | PaiementUncheckedCreateWithoutCommandeInput[]
    connectOrCreate?: PaiementCreateOrConnectWithoutCommandeInput | PaiementCreateOrConnectWithoutCommandeInput[]
    createMany?: PaiementCreateManyCommandeInputEnvelope
    connect?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumStatutCommandeFieldUpdateOperationsInput = {
    set?: $Enums.StatutCommande
  }

  export type PaiementUpdateManyWithoutCommandeNestedInput = {
    create?: XOR<PaiementCreateWithoutCommandeInput, PaiementUncheckedCreateWithoutCommandeInput> | PaiementCreateWithoutCommandeInput[] | PaiementUncheckedCreateWithoutCommandeInput[]
    connectOrCreate?: PaiementCreateOrConnectWithoutCommandeInput | PaiementCreateOrConnectWithoutCommandeInput[]
    upsert?: PaiementUpsertWithWhereUniqueWithoutCommandeInput | PaiementUpsertWithWhereUniqueWithoutCommandeInput[]
    createMany?: PaiementCreateManyCommandeInputEnvelope
    set?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    disconnect?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    delete?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    connect?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    update?: PaiementUpdateWithWhereUniqueWithoutCommandeInput | PaiementUpdateWithWhereUniqueWithoutCommandeInput[]
    updateMany?: PaiementUpdateManyWithWhereWithoutCommandeInput | PaiementUpdateManyWithWhereWithoutCommandeInput[]
    deleteMany?: PaiementScalarWhereInput | PaiementScalarWhereInput[]
  }

  export type PanierUpdateOneRequiredWithoutCommandesNestedInput = {
    create?: XOR<PanierCreateWithoutCommandesInput, PanierUncheckedCreateWithoutCommandesInput>
    connectOrCreate?: PanierCreateOrConnectWithoutCommandesInput
    upsert?: PanierUpsertWithoutCommandesInput
    connect?: PanierWhereUniqueInput
    update?: XOR<XOR<PanierUpdateToOneWithWhereWithoutCommandesInput, PanierUpdateWithoutCommandesInput>, PanierUncheckedUpdateWithoutCommandesInput>
  }

  export type FournisseurUpdateOneWithoutCommandesNestedInput = {
    create?: XOR<FournisseurCreateWithoutCommandesInput, FournisseurUncheckedCreateWithoutCommandesInput>
    connectOrCreate?: FournisseurCreateOrConnectWithoutCommandesInput
    upsert?: FournisseurUpsertWithoutCommandesInput
    disconnect?: FournisseurWhereInput | boolean
    delete?: FournisseurWhereInput | boolean
    connect?: FournisseurWhereUniqueInput
    update?: XOR<XOR<FournisseurUpdateToOneWithWhereWithoutCommandesInput, FournisseurUpdateWithoutCommandesInput>, FournisseurUncheckedUpdateWithoutCommandesInput>
  }

  export type AdresseUpdateOneWithoutCommandesNestedInput = {
    create?: XOR<AdresseCreateWithoutCommandesInput, AdresseUncheckedCreateWithoutCommandesInput>
    connectOrCreate?: AdresseCreateOrConnectWithoutCommandesInput
    upsert?: AdresseUpsertWithoutCommandesInput
    disconnect?: AdresseWhereInput | boolean
    delete?: AdresseWhereInput | boolean
    connect?: AdresseWhereUniqueInput
    update?: XOR<XOR<AdresseUpdateToOneWithWhereWithoutCommandesInput, AdresseUpdateWithoutCommandesInput>, AdresseUncheckedUpdateWithoutCommandesInput>
  }

  export type ContactUpdateOneWithoutCommandesNestedInput = {
    create?: XOR<ContactCreateWithoutCommandesInput, ContactUncheckedCreateWithoutCommandesInput>
    connectOrCreate?: ContactCreateOrConnectWithoutCommandesInput
    upsert?: ContactUpsertWithoutCommandesInput
    disconnect?: ContactWhereInput | boolean
    delete?: ContactWhereInput | boolean
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutCommandesInput, ContactUpdateWithoutCommandesInput>, ContactUncheckedUpdateWithoutCommandesInput>
  }

  export type ClientUpdateOneWithoutCommandesNestedInput = {
    create?: XOR<ClientCreateWithoutCommandesInput, ClientUncheckedCreateWithoutCommandesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutCommandesInput
    upsert?: ClientUpsertWithoutCommandesInput
    disconnect?: ClientWhereInput | boolean
    delete?: ClientWhereInput | boolean
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutCommandesInput, ClientUpdateWithoutCommandesInput>, ClientUncheckedUpdateWithoutCommandesInput>
  }

  export type PaiementUncheckedUpdateManyWithoutCommandeNestedInput = {
    create?: XOR<PaiementCreateWithoutCommandeInput, PaiementUncheckedCreateWithoutCommandeInput> | PaiementCreateWithoutCommandeInput[] | PaiementUncheckedCreateWithoutCommandeInput[]
    connectOrCreate?: PaiementCreateOrConnectWithoutCommandeInput | PaiementCreateOrConnectWithoutCommandeInput[]
    upsert?: PaiementUpsertWithWhereUniqueWithoutCommandeInput | PaiementUpsertWithWhereUniqueWithoutCommandeInput[]
    createMany?: PaiementCreateManyCommandeInputEnvelope
    set?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    disconnect?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    delete?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    connect?: PaiementWhereUniqueInput | PaiementWhereUniqueInput[]
    update?: PaiementUpdateWithWhereUniqueWithoutCommandeInput | PaiementUpdateWithWhereUniqueWithoutCommandeInput[]
    updateMany?: PaiementUpdateManyWithWhereWithoutCommandeInput | PaiementUpdateManyWithWhereWithoutCommandeInput[]
    deleteMany?: PaiementScalarWhereInput | PaiementScalarWhereInput[]
  }

  export type AgentCreateNestedOneWithoutClotureCaissesInput = {
    create?: XOR<AgentCreateWithoutClotureCaissesInput, AgentUncheckedCreateWithoutClotureCaissesInput>
    connectOrCreate?: AgentCreateOrConnectWithoutClotureCaissesInput
    connect?: AgentWhereUniqueInput
  }

  export type EntrepriseCreateNestedOneWithoutClotureCaissesInput = {
    create?: XOR<EntrepriseCreateWithoutClotureCaissesInput, EntrepriseUncheckedCreateWithoutClotureCaissesInput>
    connectOrCreate?: EntrepriseCreateOrConnectWithoutClotureCaissesInput
    connect?: EntrepriseWhereUniqueInput
  }

  export type AgentUpdateOneRequiredWithoutClotureCaissesNestedInput = {
    create?: XOR<AgentCreateWithoutClotureCaissesInput, AgentUncheckedCreateWithoutClotureCaissesInput>
    connectOrCreate?: AgentCreateOrConnectWithoutClotureCaissesInput
    upsert?: AgentUpsertWithoutClotureCaissesInput
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutClotureCaissesInput, AgentUpdateWithoutClotureCaissesInput>, AgentUncheckedUpdateWithoutClotureCaissesInput>
  }

  export type EntrepriseUpdateOneWithoutClotureCaissesNestedInput = {
    create?: XOR<EntrepriseCreateWithoutClotureCaissesInput, EntrepriseUncheckedCreateWithoutClotureCaissesInput>
    connectOrCreate?: EntrepriseCreateOrConnectWithoutClotureCaissesInput
    upsert?: EntrepriseUpsertWithoutClotureCaissesInput
    disconnect?: EntrepriseWhereInput | boolean
    delete?: EntrepriseWhereInput | boolean
    connect?: EntrepriseWhereUniqueInput
    update?: XOR<XOR<EntrepriseUpdateToOneWithWhereWithoutClotureCaissesInput, EntrepriseUpdateWithoutClotureCaissesInput>, EntrepriseUncheckedUpdateWithoutClotureCaissesInput>
  }

  export type CaisseCreateNestedOneWithoutMouvementCaissesInput = {
    create?: XOR<CaisseCreateWithoutMouvementCaissesInput, CaisseUncheckedCreateWithoutMouvementCaissesInput>
    connectOrCreate?: CaisseCreateOrConnectWithoutMouvementCaissesInput
    connect?: CaisseWhereUniqueInput
  }

  export type AgentCreateNestedOneWithoutMouvementCaissesInput = {
    create?: XOR<AgentCreateWithoutMouvementCaissesInput, AgentUncheckedCreateWithoutMouvementCaissesInput>
    connectOrCreate?: AgentCreateOrConnectWithoutMouvementCaissesInput
    connect?: AgentWhereUniqueInput
  }

  export type EnumTypeMouvementCaisseFieldUpdateOperationsInput = {
    set?: $Enums.TypeMouvementCaisse
  }

  export type EnumCategorieMouvementFieldUpdateOperationsInput = {
    set?: $Enums.CategorieMouvement
  }

  export type CaisseUpdateOneRequiredWithoutMouvementCaissesNestedInput = {
    create?: XOR<CaisseCreateWithoutMouvementCaissesInput, CaisseUncheckedCreateWithoutMouvementCaissesInput>
    connectOrCreate?: CaisseCreateOrConnectWithoutMouvementCaissesInput
    upsert?: CaisseUpsertWithoutMouvementCaissesInput
    connect?: CaisseWhereUniqueInput
    update?: XOR<XOR<CaisseUpdateToOneWithWhereWithoutMouvementCaissesInput, CaisseUpdateWithoutMouvementCaissesInput>, CaisseUncheckedUpdateWithoutMouvementCaissesInput>
  }

  export type AgentUpdateOneRequiredWithoutMouvementCaissesNestedInput = {
    create?: XOR<AgentCreateWithoutMouvementCaissesInput, AgentUncheckedCreateWithoutMouvementCaissesInput>
    connectOrCreate?: AgentCreateOrConnectWithoutMouvementCaissesInput
    upsert?: AgentUpsertWithoutMouvementCaissesInput
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutMouvementCaissesInput, AgentUpdateWithoutMouvementCaissesInput>, AgentUncheckedUpdateWithoutMouvementCaissesInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumSexeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Sexe | EnumSexeFieldRefInput<$PrismaModel> | null
    in?: $Enums.Sexe[] | ListEnumSexeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Sexe[] | ListEnumSexeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSexeNullableFilter<$PrismaModel> | $Enums.Sexe | null
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedEnumPosteNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Poste | EnumPosteFieldRefInput<$PrismaModel> | null
    in?: $Enums.Poste[] | ListEnumPosteFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Poste[] | ListEnumPosteFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPosteNullableFilter<$PrismaModel> | $Enums.Poste | null
  }

  export type NestedEnumSexeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Sexe | EnumSexeFieldRefInput<$PrismaModel> | null
    in?: $Enums.Sexe[] | ListEnumSexeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Sexe[] | ListEnumSexeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSexeNullableWithAggregatesFilter<$PrismaModel> | $Enums.Sexe | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSexeNullableFilter<$PrismaModel>
    _max?: NestedEnumSexeNullableFilter<$PrismaModel>
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedEnumPosteNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Poste | EnumPosteFieldRefInput<$PrismaModel> | null
    in?: $Enums.Poste[] | ListEnumPosteFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Poste[] | ListEnumPosteFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPosteNullableWithAggregatesFilter<$PrismaModel> | $Enums.Poste | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPosteNullableFilter<$PrismaModel>
    _max?: NestedEnumPosteNullableFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumModePaimentFilter<$PrismaModel = never> = {
    equals?: $Enums.ModePaiment | EnumModePaimentFieldRefInput<$PrismaModel>
    in?: $Enums.ModePaiment[] | ListEnumModePaimentFieldRefInput<$PrismaModel>
    notIn?: $Enums.ModePaiment[] | ListEnumModePaimentFieldRefInput<$PrismaModel>
    not?: NestedEnumModePaimentFilter<$PrismaModel> | $Enums.ModePaiment
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumModePaimentWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ModePaiment | EnumModePaimentFieldRefInput<$PrismaModel>
    in?: $Enums.ModePaiment[] | ListEnumModePaimentFieldRefInput<$PrismaModel>
    notIn?: $Enums.ModePaiment[] | ListEnumModePaimentFieldRefInput<$PrismaModel>
    not?: NestedEnumModePaimentWithAggregatesFilter<$PrismaModel> | $Enums.ModePaiment
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumModePaimentFilter<$PrismaModel>
    _max?: NestedEnumModePaimentFilter<$PrismaModel>
  }

  export type NestedEnumStatutCaisseFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutCaisse | EnumStatutCaisseFieldRefInput<$PrismaModel>
    in?: $Enums.StatutCaisse[] | ListEnumStatutCaisseFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatutCaisse[] | ListEnumStatutCaisseFieldRefInput<$PrismaModel>
    not?: NestedEnumStatutCaisseFilter<$PrismaModel> | $Enums.StatutCaisse
  }

  export type NestedEnumStatutCaisseWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutCaisse | EnumStatutCaisseFieldRefInput<$PrismaModel>
    in?: $Enums.StatutCaisse[] | ListEnumStatutCaisseFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatutCaisse[] | ListEnumStatutCaisseFieldRefInput<$PrismaModel>
    not?: NestedEnumStatutCaisseWithAggregatesFilter<$PrismaModel> | $Enums.StatutCaisse
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatutCaisseFilter<$PrismaModel>
    _max?: NestedEnumStatutCaisseFilter<$PrismaModel>
  }

  export type NestedEnumStatutVenteFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutVente | EnumStatutVenteFieldRefInput<$PrismaModel>
    in?: $Enums.StatutVente[] | ListEnumStatutVenteFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatutVente[] | ListEnumStatutVenteFieldRefInput<$PrismaModel>
    not?: NestedEnumStatutVenteFilter<$PrismaModel> | $Enums.StatutVente
  }

  export type NestedEnumTypeClientFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeClient | EnumTypeClientFieldRefInput<$PrismaModel>
    in?: $Enums.TypeClient[] | ListEnumTypeClientFieldRefInput<$PrismaModel>
    notIn?: $Enums.TypeClient[] | ListEnumTypeClientFieldRefInput<$PrismaModel>
    not?: NestedEnumTypeClientFilter<$PrismaModel> | $Enums.TypeClient
  }

  export type NestedEnumStatutVenteWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutVente | EnumStatutVenteFieldRefInput<$PrismaModel>
    in?: $Enums.StatutVente[] | ListEnumStatutVenteFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatutVente[] | ListEnumStatutVenteFieldRefInput<$PrismaModel>
    not?: NestedEnumStatutVenteWithAggregatesFilter<$PrismaModel> | $Enums.StatutVente
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatutVenteFilter<$PrismaModel>
    _max?: NestedEnumStatutVenteFilter<$PrismaModel>
  }

  export type NestedEnumTypeClientWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeClient | EnumTypeClientFieldRefInput<$PrismaModel>
    in?: $Enums.TypeClient[] | ListEnumTypeClientFieldRefInput<$PrismaModel>
    notIn?: $Enums.TypeClient[] | ListEnumTypeClientFieldRefInput<$PrismaModel>
    not?: NestedEnumTypeClientWithAggregatesFilter<$PrismaModel> | $Enums.TypeClient
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTypeClientFilter<$PrismaModel>
    _max?: NestedEnumTypeClientFilter<$PrismaModel>
  }

  export type NestedEnumstatutPanierFilter<$PrismaModel = never> = {
    equals?: $Enums.statutPanier | EnumstatutPanierFieldRefInput<$PrismaModel>
    in?: $Enums.statutPanier[] | ListEnumstatutPanierFieldRefInput<$PrismaModel>
    notIn?: $Enums.statutPanier[] | ListEnumstatutPanierFieldRefInput<$PrismaModel>
    not?: NestedEnumstatutPanierFilter<$PrismaModel> | $Enums.statutPanier
  }

  export type NestedEnumstatutPanierWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.statutPanier | EnumstatutPanierFieldRefInput<$PrismaModel>
    in?: $Enums.statutPanier[] | ListEnumstatutPanierFieldRefInput<$PrismaModel>
    notIn?: $Enums.statutPanier[] | ListEnumstatutPanierFieldRefInput<$PrismaModel>
    not?: NestedEnumstatutPanierWithAggregatesFilter<$PrismaModel> | $Enums.statutPanier
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumstatutPanierFilter<$PrismaModel>
    _max?: NestedEnumstatutPanierFilter<$PrismaModel>
  }

  export type NestedEnumStatutAchatFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutAchat | EnumStatutAchatFieldRefInput<$PrismaModel>
    in?: $Enums.StatutAchat[] | ListEnumStatutAchatFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatutAchat[] | ListEnumStatutAchatFieldRefInput<$PrismaModel>
    not?: NestedEnumStatutAchatFilter<$PrismaModel> | $Enums.StatutAchat
  }

  export type NestedEnumStatutAchatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutAchat | EnumStatutAchatFieldRefInput<$PrismaModel>
    in?: $Enums.StatutAchat[] | ListEnumStatutAchatFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatutAchat[] | ListEnumStatutAchatFieldRefInput<$PrismaModel>
    not?: NestedEnumStatutAchatWithAggregatesFilter<$PrismaModel> | $Enums.StatutAchat
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatutAchatFilter<$PrismaModel>
    _max?: NestedEnumStatutAchatFilter<$PrismaModel>
  }

  export type NestedEnumStatutReservationFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutReservation | EnumStatutReservationFieldRefInput<$PrismaModel>
    in?: $Enums.StatutReservation[] | ListEnumStatutReservationFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatutReservation[] | ListEnumStatutReservationFieldRefInput<$PrismaModel>
    not?: NestedEnumStatutReservationFilter<$PrismaModel> | $Enums.StatutReservation
  }

  export type NestedEnumStatutReservationWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutReservation | EnumStatutReservationFieldRefInput<$PrismaModel>
    in?: $Enums.StatutReservation[] | ListEnumStatutReservationFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatutReservation[] | ListEnumStatutReservationFieldRefInput<$PrismaModel>
    not?: NestedEnumStatutReservationWithAggregatesFilter<$PrismaModel> | $Enums.StatutReservation
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatutReservationFilter<$PrismaModel>
    _max?: NestedEnumStatutReservationFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumStatutCommandeFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutCommande | EnumStatutCommandeFieldRefInput<$PrismaModel>
    in?: $Enums.StatutCommande[] | ListEnumStatutCommandeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatutCommande[] | ListEnumStatutCommandeFieldRefInput<$PrismaModel>
    not?: NestedEnumStatutCommandeFilter<$PrismaModel> | $Enums.StatutCommande
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumStatutCommandeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutCommande | EnumStatutCommandeFieldRefInput<$PrismaModel>
    in?: $Enums.StatutCommande[] | ListEnumStatutCommandeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatutCommande[] | ListEnumStatutCommandeFieldRefInput<$PrismaModel>
    not?: NestedEnumStatutCommandeWithAggregatesFilter<$PrismaModel> | $Enums.StatutCommande
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatutCommandeFilter<$PrismaModel>
    _max?: NestedEnumStatutCommandeFilter<$PrismaModel>
  }

  export type NestedEnumTypeMouvementCaisseFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeMouvementCaisse | EnumTypeMouvementCaisseFieldRefInput<$PrismaModel>
    in?: $Enums.TypeMouvementCaisse[] | ListEnumTypeMouvementCaisseFieldRefInput<$PrismaModel>
    notIn?: $Enums.TypeMouvementCaisse[] | ListEnumTypeMouvementCaisseFieldRefInput<$PrismaModel>
    not?: NestedEnumTypeMouvementCaisseFilter<$PrismaModel> | $Enums.TypeMouvementCaisse
  }

  export type NestedEnumCategorieMouvementFilter<$PrismaModel = never> = {
    equals?: $Enums.CategorieMouvement | EnumCategorieMouvementFieldRefInput<$PrismaModel>
    in?: $Enums.CategorieMouvement[] | ListEnumCategorieMouvementFieldRefInput<$PrismaModel>
    notIn?: $Enums.CategorieMouvement[] | ListEnumCategorieMouvementFieldRefInput<$PrismaModel>
    not?: NestedEnumCategorieMouvementFilter<$PrismaModel> | $Enums.CategorieMouvement
  }

  export type NestedEnumTypeMouvementCaisseWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeMouvementCaisse | EnumTypeMouvementCaisseFieldRefInput<$PrismaModel>
    in?: $Enums.TypeMouvementCaisse[] | ListEnumTypeMouvementCaisseFieldRefInput<$PrismaModel>
    notIn?: $Enums.TypeMouvementCaisse[] | ListEnumTypeMouvementCaisseFieldRefInput<$PrismaModel>
    not?: NestedEnumTypeMouvementCaisseWithAggregatesFilter<$PrismaModel> | $Enums.TypeMouvementCaisse
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTypeMouvementCaisseFilter<$PrismaModel>
    _max?: NestedEnumTypeMouvementCaisseFilter<$PrismaModel>
  }

  export type NestedEnumCategorieMouvementWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CategorieMouvement | EnumCategorieMouvementFieldRefInput<$PrismaModel>
    in?: $Enums.CategorieMouvement[] | ListEnumCategorieMouvementFieldRefInput<$PrismaModel>
    notIn?: $Enums.CategorieMouvement[] | ListEnumCategorieMouvementFieldRefInput<$PrismaModel>
    not?: NestedEnumCategorieMouvementWithAggregatesFilter<$PrismaModel> | $Enums.CategorieMouvement
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCategorieMouvementFilter<$PrismaModel>
    _max?: NestedEnumCategorieMouvementFilter<$PrismaModel>
  }

  export type AgentCreateWithoutTeneursInput = {
    email: string
    nom: string
    postnom?: string | null
    nom_complet?: string | null
    sexe?: $Enums.Sexe | null
    role?: $Enums.Role
    poste?: $Enums.Poste | null
    picture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    adresses?: AdresseCreateNestedManyWithoutAgentInput
    contacts?: ContactCreateNestedManyWithoutAgentInput
    produits?: ProduitCreateNestedManyWithoutAgentInput
    ventes?: VenteCreateNestedManyWithoutAgentInput
    achats?: AchatCreateNestedManyWithoutAgentInput
    devises?: DeviseCreateNestedManyWithoutAgentInput
    paniers?: PanierCreateNestedManyWithoutAgentInput
    caisses?: CaisseCreateNestedManyWithoutAgentInput
    mouvementCaisses?: MouvementCaisseCreateNestedManyWithoutAgentInput
    clotureCaisses?: ClotureCaisseCreateNestedManyWithoutAgentInput
    Fournisseur?: FournisseurCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateWithoutTeneursInput = {
    id?: number
    email: string
    nom: string
    postnom?: string | null
    nom_complet?: string | null
    sexe?: $Enums.Sexe | null
    role?: $Enums.Role
    poste?: $Enums.Poste | null
    picture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    adresses?: AdresseUncheckedCreateNestedManyWithoutAgentInput
    contacts?: ContactUncheckedCreateNestedManyWithoutAgentInput
    produits?: ProduitUncheckedCreateNestedManyWithoutAgentInput
    ventes?: VenteUncheckedCreateNestedManyWithoutAgentInput
    achats?: AchatUncheckedCreateNestedManyWithoutAgentInput
    devises?: DeviseUncheckedCreateNestedManyWithoutAgentInput
    paniers?: PanierUncheckedCreateNestedManyWithoutAgentInput
    caisses?: CaisseUncheckedCreateNestedManyWithoutAgentInput
    mouvementCaisses?: MouvementCaisseUncheckedCreateNestedManyWithoutAgentInput
    clotureCaisses?: ClotureCaisseUncheckedCreateNestedManyWithoutAgentInput
    Fournisseur?: FournisseurUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentCreateOrConnectWithoutTeneursInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutTeneursInput, AgentUncheckedCreateWithoutTeneursInput>
  }

  export type ProduitCreateWithoutTeneurInput = {
    designation: string
    prixUnitaire: number
    qtteDisponible?: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    detailsPaniers?: DetailPanierCreateNestedManyWithoutProduitInput
    agent: AgentCreateNestedOneWithoutProduitsInput
    devise: DeviseCreateNestedOneWithoutProduitsInput
  }

  export type ProduitUncheckedCreateWithoutTeneurInput = {
    id?: number
    designation: string
    prixUnitaire: number
    qtteDisponible?: number
    description?: string | null
    deviseId: number
    agentId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    detailsPaniers?: DetailPanierUncheckedCreateNestedManyWithoutProduitInput
  }

  export type ProduitCreateOrConnectWithoutTeneurInput = {
    where: ProduitWhereUniqueInput
    create: XOR<ProduitCreateWithoutTeneurInput, ProduitUncheckedCreateWithoutTeneurInput>
  }

  export type ProduitCreateManyTeneurInputEnvelope = {
    data: ProduitCreateManyTeneurInput | ProduitCreateManyTeneurInput[]
    skipDuplicates?: boolean
  }

  export type AgentUpsertWithoutTeneursInput = {
    update: XOR<AgentUpdateWithoutTeneursInput, AgentUncheckedUpdateWithoutTeneursInput>
    create: XOR<AgentCreateWithoutTeneursInput, AgentUncheckedCreateWithoutTeneursInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutTeneursInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutTeneursInput, AgentUncheckedUpdateWithoutTeneursInput>
  }

  export type AgentUpdateWithoutTeneursInput = {
    email?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    postnom?: NullableStringFieldUpdateOperationsInput | string | null
    nom_complet?: NullableStringFieldUpdateOperationsInput | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    poste?: NullableEnumPosteFieldUpdateOperationsInput | $Enums.Poste | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adresses?: AdresseUpdateManyWithoutAgentNestedInput
    contacts?: ContactUpdateManyWithoutAgentNestedInput
    produits?: ProduitUpdateManyWithoutAgentNestedInput
    ventes?: VenteUpdateManyWithoutAgentNestedInput
    achats?: AchatUpdateManyWithoutAgentNestedInput
    devises?: DeviseUpdateManyWithoutAgentNestedInput
    paniers?: PanierUpdateManyWithoutAgentNestedInput
    caisses?: CaisseUpdateManyWithoutAgentNestedInput
    mouvementCaisses?: MouvementCaisseUpdateManyWithoutAgentNestedInput
    clotureCaisses?: ClotureCaisseUpdateManyWithoutAgentNestedInput
    Fournisseur?: FournisseurUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateWithoutTeneursInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    postnom?: NullableStringFieldUpdateOperationsInput | string | null
    nom_complet?: NullableStringFieldUpdateOperationsInput | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    poste?: NullableEnumPosteFieldUpdateOperationsInput | $Enums.Poste | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adresses?: AdresseUncheckedUpdateManyWithoutAgentNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutAgentNestedInput
    produits?: ProduitUncheckedUpdateManyWithoutAgentNestedInput
    ventes?: VenteUncheckedUpdateManyWithoutAgentNestedInput
    achats?: AchatUncheckedUpdateManyWithoutAgentNestedInput
    devises?: DeviseUncheckedUpdateManyWithoutAgentNestedInput
    paniers?: PanierUncheckedUpdateManyWithoutAgentNestedInput
    caisses?: CaisseUncheckedUpdateManyWithoutAgentNestedInput
    mouvementCaisses?: MouvementCaisseUncheckedUpdateManyWithoutAgentNestedInput
    clotureCaisses?: ClotureCaisseUncheckedUpdateManyWithoutAgentNestedInput
    Fournisseur?: FournisseurUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type ProduitUpsertWithWhereUniqueWithoutTeneurInput = {
    where: ProduitWhereUniqueInput
    update: XOR<ProduitUpdateWithoutTeneurInput, ProduitUncheckedUpdateWithoutTeneurInput>
    create: XOR<ProduitCreateWithoutTeneurInput, ProduitUncheckedCreateWithoutTeneurInput>
  }

  export type ProduitUpdateWithWhereUniqueWithoutTeneurInput = {
    where: ProduitWhereUniqueInput
    data: XOR<ProduitUpdateWithoutTeneurInput, ProduitUncheckedUpdateWithoutTeneurInput>
  }

  export type ProduitUpdateManyWithWhereWithoutTeneurInput = {
    where: ProduitScalarWhereInput
    data: XOR<ProduitUpdateManyMutationInput, ProduitUncheckedUpdateManyWithoutTeneurInput>
  }

  export type ProduitScalarWhereInput = {
    AND?: ProduitScalarWhereInput | ProduitScalarWhereInput[]
    OR?: ProduitScalarWhereInput[]
    NOT?: ProduitScalarWhereInput | ProduitScalarWhereInput[]
    id?: IntFilter<"Produit"> | number
    designation?: StringFilter<"Produit"> | string
    prixUnitaire?: FloatFilter<"Produit"> | number
    qtteDisponible?: IntFilter<"Produit"> | number
    description?: StringNullableFilter<"Produit"> | string | null
    deviseId?: IntFilter<"Produit"> | number
    teneurId?: IntFilter<"Produit"> | number
    agentId?: IntFilter<"Produit"> | number
    createdAt?: DateTimeFilter<"Produit"> | Date | string
    updatedAt?: DateTimeFilter<"Produit"> | Date | string
  }

  export type AgentCreateWithoutDevisesInput = {
    email: string
    nom: string
    postnom?: string | null
    nom_complet?: string | null
    sexe?: $Enums.Sexe | null
    role?: $Enums.Role
    poste?: $Enums.Poste | null
    picture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    adresses?: AdresseCreateNestedManyWithoutAgentInput
    contacts?: ContactCreateNestedManyWithoutAgentInput
    produits?: ProduitCreateNestedManyWithoutAgentInput
    ventes?: VenteCreateNestedManyWithoutAgentInput
    achats?: AchatCreateNestedManyWithoutAgentInput
    teneurs?: TeneurCreateNestedManyWithoutAgentsInput
    paniers?: PanierCreateNestedManyWithoutAgentInput
    caisses?: CaisseCreateNestedManyWithoutAgentInput
    mouvementCaisses?: MouvementCaisseCreateNestedManyWithoutAgentInput
    clotureCaisses?: ClotureCaisseCreateNestedManyWithoutAgentInput
    Fournisseur?: FournisseurCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateWithoutDevisesInput = {
    id?: number
    email: string
    nom: string
    postnom?: string | null
    nom_complet?: string | null
    sexe?: $Enums.Sexe | null
    role?: $Enums.Role
    poste?: $Enums.Poste | null
    picture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    adresses?: AdresseUncheckedCreateNestedManyWithoutAgentInput
    contacts?: ContactUncheckedCreateNestedManyWithoutAgentInput
    produits?: ProduitUncheckedCreateNestedManyWithoutAgentInput
    ventes?: VenteUncheckedCreateNestedManyWithoutAgentInput
    achats?: AchatUncheckedCreateNestedManyWithoutAgentInput
    teneurs?: TeneurUncheckedCreateNestedManyWithoutAgentsInput
    paniers?: PanierUncheckedCreateNestedManyWithoutAgentInput
    caisses?: CaisseUncheckedCreateNestedManyWithoutAgentInput
    mouvementCaisses?: MouvementCaisseUncheckedCreateNestedManyWithoutAgentInput
    clotureCaisses?: ClotureCaisseUncheckedCreateNestedManyWithoutAgentInput
    Fournisseur?: FournisseurUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentCreateOrConnectWithoutDevisesInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutDevisesInput, AgentUncheckedCreateWithoutDevisesInput>
  }

  export type ProduitCreateWithoutDeviseInput = {
    designation: string
    prixUnitaire: number
    qtteDisponible?: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    detailsPaniers?: DetailPanierCreateNestedManyWithoutProduitInput
    agent: AgentCreateNestedOneWithoutProduitsInput
    teneur: TeneurCreateNestedOneWithoutProduitsInput
  }

  export type ProduitUncheckedCreateWithoutDeviseInput = {
    id?: number
    designation: string
    prixUnitaire: number
    qtteDisponible?: number
    description?: string | null
    teneurId: number
    agentId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    detailsPaniers?: DetailPanierUncheckedCreateNestedManyWithoutProduitInput
  }

  export type ProduitCreateOrConnectWithoutDeviseInput = {
    where: ProduitWhereUniqueInput
    create: XOR<ProduitCreateWithoutDeviseInput, ProduitUncheckedCreateWithoutDeviseInput>
  }

  export type ProduitCreateManyDeviseInputEnvelope = {
    data: ProduitCreateManyDeviseInput | ProduitCreateManyDeviseInput[]
    skipDuplicates?: boolean
  }

  export type PaiementCreateWithoutDeviseInput = {
    totalHT?: number | null
    totalTTC?: number | null
    modePaiement: $Enums.ModePaiment
    createdAt?: Date | string
    updatedAt?: Date | string
    vente?: VenteCreateNestedOneWithoutPaiementsInput
    achat?: AchatCreateNestedOneWithoutPaiementsInput
    commande?: CommandeCreateNestedOneWithoutPaiementInput
    caisse: CaisseCreateNestedOneWithoutPaiementsInput
  }

  export type PaiementUncheckedCreateWithoutDeviseInput = {
    id?: number
    totalHT?: number | null
    totalTTC?: number | null
    modePaiement: $Enums.ModePaiment
    caisseId: number
    venteId?: number | null
    achatId?: number | null
    commandeId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaiementCreateOrConnectWithoutDeviseInput = {
    where: PaiementWhereUniqueInput
    create: XOR<PaiementCreateWithoutDeviseInput, PaiementUncheckedCreateWithoutDeviseInput>
  }

  export type PaiementCreateManyDeviseInputEnvelope = {
    data: PaiementCreateManyDeviseInput | PaiementCreateManyDeviseInput[]
    skipDuplicates?: boolean
  }

  export type CaisseCreateWithoutDeviseInput = {
    nom: string
    description?: string | null
    soldeActuel?: number | null
    statut?: $Enums.StatutCaisse
    createdAt?: Date | string
    updatedAt?: Date | string
    agent: AgentCreateNestedOneWithoutCaissesInput
    mouvementCaisses?: MouvementCaisseCreateNestedManyWithoutCaisseInput
    paiements?: PaiementCreateNestedManyWithoutCaisseInput
  }

  export type CaisseUncheckedCreateWithoutDeviseInput = {
    id?: number
    nom: string
    description?: string | null
    soldeActuel?: number | null
    agentId: number
    statut?: $Enums.StatutCaisse
    createdAt?: Date | string
    updatedAt?: Date | string
    mouvementCaisses?: MouvementCaisseUncheckedCreateNestedManyWithoutCaisseInput
    paiements?: PaiementUncheckedCreateNestedManyWithoutCaisseInput
  }

  export type CaisseCreateOrConnectWithoutDeviseInput = {
    where: CaisseWhereUniqueInput
    create: XOR<CaisseCreateWithoutDeviseInput, CaisseUncheckedCreateWithoutDeviseInput>
  }

  export type CaisseCreateManyDeviseInputEnvelope = {
    data: CaisseCreateManyDeviseInput | CaisseCreateManyDeviseInput[]
    skipDuplicates?: boolean
  }

  export type DetailPanierCreateWithoutDeviseInput = {
    qtte: number
    modePaiement: $Enums.ModePaiment
    prixUnitaire: number
    prixTotalHT: number
    prixTotalTTC: number
    createdAt?: Date | string
    updatedAt?: Date | string
    produit: ProduitCreateNestedOneWithoutDetailsPaniersInput
    panier: PanierCreateNestedOneWithoutDetailPaniersInput
  }

  export type DetailPanierUncheckedCreateWithoutDeviseInput = {
    id?: number
    produitId: number
    qtte: number
    modePaiement: $Enums.ModePaiment
    prixUnitaire: number
    prixTotalHT: number
    prixTotalTTC: number
    panierId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DetailPanierCreateOrConnectWithoutDeviseInput = {
    where: DetailPanierWhereUniqueInput
    create: XOR<DetailPanierCreateWithoutDeviseInput, DetailPanierUncheckedCreateWithoutDeviseInput>
  }

  export type DetailPanierCreateManyDeviseInputEnvelope = {
    data: DetailPanierCreateManyDeviseInput | DetailPanierCreateManyDeviseInput[]
    skipDuplicates?: boolean
  }

  export type AgentUpsertWithoutDevisesInput = {
    update: XOR<AgentUpdateWithoutDevisesInput, AgentUncheckedUpdateWithoutDevisesInput>
    create: XOR<AgentCreateWithoutDevisesInput, AgentUncheckedCreateWithoutDevisesInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutDevisesInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutDevisesInput, AgentUncheckedUpdateWithoutDevisesInput>
  }

  export type AgentUpdateWithoutDevisesInput = {
    email?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    postnom?: NullableStringFieldUpdateOperationsInput | string | null
    nom_complet?: NullableStringFieldUpdateOperationsInput | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    poste?: NullableEnumPosteFieldUpdateOperationsInput | $Enums.Poste | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adresses?: AdresseUpdateManyWithoutAgentNestedInput
    contacts?: ContactUpdateManyWithoutAgentNestedInput
    produits?: ProduitUpdateManyWithoutAgentNestedInput
    ventes?: VenteUpdateManyWithoutAgentNestedInput
    achats?: AchatUpdateManyWithoutAgentNestedInput
    teneurs?: TeneurUpdateManyWithoutAgentsNestedInput
    paniers?: PanierUpdateManyWithoutAgentNestedInput
    caisses?: CaisseUpdateManyWithoutAgentNestedInput
    mouvementCaisses?: MouvementCaisseUpdateManyWithoutAgentNestedInput
    clotureCaisses?: ClotureCaisseUpdateManyWithoutAgentNestedInput
    Fournisseur?: FournisseurUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateWithoutDevisesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    postnom?: NullableStringFieldUpdateOperationsInput | string | null
    nom_complet?: NullableStringFieldUpdateOperationsInput | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    poste?: NullableEnumPosteFieldUpdateOperationsInput | $Enums.Poste | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adresses?: AdresseUncheckedUpdateManyWithoutAgentNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutAgentNestedInput
    produits?: ProduitUncheckedUpdateManyWithoutAgentNestedInput
    ventes?: VenteUncheckedUpdateManyWithoutAgentNestedInput
    achats?: AchatUncheckedUpdateManyWithoutAgentNestedInput
    teneurs?: TeneurUncheckedUpdateManyWithoutAgentsNestedInput
    paniers?: PanierUncheckedUpdateManyWithoutAgentNestedInput
    caisses?: CaisseUncheckedUpdateManyWithoutAgentNestedInput
    mouvementCaisses?: MouvementCaisseUncheckedUpdateManyWithoutAgentNestedInput
    clotureCaisses?: ClotureCaisseUncheckedUpdateManyWithoutAgentNestedInput
    Fournisseur?: FournisseurUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type ProduitUpsertWithWhereUniqueWithoutDeviseInput = {
    where: ProduitWhereUniqueInput
    update: XOR<ProduitUpdateWithoutDeviseInput, ProduitUncheckedUpdateWithoutDeviseInput>
    create: XOR<ProduitCreateWithoutDeviseInput, ProduitUncheckedCreateWithoutDeviseInput>
  }

  export type ProduitUpdateWithWhereUniqueWithoutDeviseInput = {
    where: ProduitWhereUniqueInput
    data: XOR<ProduitUpdateWithoutDeviseInput, ProduitUncheckedUpdateWithoutDeviseInput>
  }

  export type ProduitUpdateManyWithWhereWithoutDeviseInput = {
    where: ProduitScalarWhereInput
    data: XOR<ProduitUpdateManyMutationInput, ProduitUncheckedUpdateManyWithoutDeviseInput>
  }

  export type PaiementUpsertWithWhereUniqueWithoutDeviseInput = {
    where: PaiementWhereUniqueInput
    update: XOR<PaiementUpdateWithoutDeviseInput, PaiementUncheckedUpdateWithoutDeviseInput>
    create: XOR<PaiementCreateWithoutDeviseInput, PaiementUncheckedCreateWithoutDeviseInput>
  }

  export type PaiementUpdateWithWhereUniqueWithoutDeviseInput = {
    where: PaiementWhereUniqueInput
    data: XOR<PaiementUpdateWithoutDeviseInput, PaiementUncheckedUpdateWithoutDeviseInput>
  }

  export type PaiementUpdateManyWithWhereWithoutDeviseInput = {
    where: PaiementScalarWhereInput
    data: XOR<PaiementUpdateManyMutationInput, PaiementUncheckedUpdateManyWithoutDeviseInput>
  }

  export type PaiementScalarWhereInput = {
    AND?: PaiementScalarWhereInput | PaiementScalarWhereInput[]
    OR?: PaiementScalarWhereInput[]
    NOT?: PaiementScalarWhereInput | PaiementScalarWhereInput[]
    id?: IntFilter<"Paiement"> | number
    totalHT?: FloatNullableFilter<"Paiement"> | number | null
    totalTTC?: FloatNullableFilter<"Paiement"> | number | null
    modePaiement?: EnumModePaimentFilter<"Paiement"> | $Enums.ModePaiment
    deviseId?: IntFilter<"Paiement"> | number
    caisseId?: IntFilter<"Paiement"> | number
    venteId?: IntNullableFilter<"Paiement"> | number | null
    achatId?: IntNullableFilter<"Paiement"> | number | null
    commandeId?: IntNullableFilter<"Paiement"> | number | null
    createdAt?: DateTimeFilter<"Paiement"> | Date | string
    updatedAt?: DateTimeFilter<"Paiement"> | Date | string
  }

  export type CaisseUpsertWithWhereUniqueWithoutDeviseInput = {
    where: CaisseWhereUniqueInput
    update: XOR<CaisseUpdateWithoutDeviseInput, CaisseUncheckedUpdateWithoutDeviseInput>
    create: XOR<CaisseCreateWithoutDeviseInput, CaisseUncheckedCreateWithoutDeviseInput>
  }

  export type CaisseUpdateWithWhereUniqueWithoutDeviseInput = {
    where: CaisseWhereUniqueInput
    data: XOR<CaisseUpdateWithoutDeviseInput, CaisseUncheckedUpdateWithoutDeviseInput>
  }

  export type CaisseUpdateManyWithWhereWithoutDeviseInput = {
    where: CaisseScalarWhereInput
    data: XOR<CaisseUpdateManyMutationInput, CaisseUncheckedUpdateManyWithoutDeviseInput>
  }

  export type CaisseScalarWhereInput = {
    AND?: CaisseScalarWhereInput | CaisseScalarWhereInput[]
    OR?: CaisseScalarWhereInput[]
    NOT?: CaisseScalarWhereInput | CaisseScalarWhereInput[]
    id?: IntFilter<"Caisse"> | number
    nom?: StringFilter<"Caisse"> | string
    description?: StringNullableFilter<"Caisse"> | string | null
    soldeActuel?: FloatNullableFilter<"Caisse"> | number | null
    deviseId?: IntFilter<"Caisse"> | number
    agentId?: IntFilter<"Caisse"> | number
    statut?: EnumStatutCaisseFilter<"Caisse"> | $Enums.StatutCaisse
    createdAt?: DateTimeFilter<"Caisse"> | Date | string
    updatedAt?: DateTimeFilter<"Caisse"> | Date | string
  }

  export type DetailPanierUpsertWithWhereUniqueWithoutDeviseInput = {
    where: DetailPanierWhereUniqueInput
    update: XOR<DetailPanierUpdateWithoutDeviseInput, DetailPanierUncheckedUpdateWithoutDeviseInput>
    create: XOR<DetailPanierCreateWithoutDeviseInput, DetailPanierUncheckedCreateWithoutDeviseInput>
  }

  export type DetailPanierUpdateWithWhereUniqueWithoutDeviseInput = {
    where: DetailPanierWhereUniqueInput
    data: XOR<DetailPanierUpdateWithoutDeviseInput, DetailPanierUncheckedUpdateWithoutDeviseInput>
  }

  export type DetailPanierUpdateManyWithWhereWithoutDeviseInput = {
    where: DetailPanierScalarWhereInput
    data: XOR<DetailPanierUpdateManyMutationInput, DetailPanierUncheckedUpdateManyWithoutDeviseInput>
  }

  export type DetailPanierScalarWhereInput = {
    AND?: DetailPanierScalarWhereInput | DetailPanierScalarWhereInput[]
    OR?: DetailPanierScalarWhereInput[]
    NOT?: DetailPanierScalarWhereInput | DetailPanierScalarWhereInput[]
    id?: IntFilter<"DetailPanier"> | number
    produitId?: IntFilter<"DetailPanier"> | number
    qtte?: IntFilter<"DetailPanier"> | number
    modePaiement?: EnumModePaimentFilter<"DetailPanier"> | $Enums.ModePaiment
    prixUnitaire?: FloatFilter<"DetailPanier"> | number
    prixTotalHT?: FloatFilter<"DetailPanier"> | number
    prixTotalTTC?: FloatFilter<"DetailPanier"> | number
    panierId?: IntFilter<"DetailPanier"> | number
    deviseId?: IntFilter<"DetailPanier"> | number
    createdAt?: DateTimeFilter<"DetailPanier"> | Date | string
    updatedAt?: DateTimeFilter<"DetailPanier"> | Date | string
  }

  export type ClotureCaisseCreateWithoutEntrepriseInput = {
    dateCloture?: Date | string
    updatedAt?: Date | string
    notes?: string | null
    createdAt?: Date | string
    agent: AgentCreateNestedOneWithoutClotureCaissesInput
  }

  export type ClotureCaisseUncheckedCreateWithoutEntrepriseInput = {
    id?: number
    dateCloture?: Date | string
    agentId: number
    updatedAt?: Date | string
    notes?: string | null
    createdAt?: Date | string
  }

  export type ClotureCaisseCreateOrConnectWithoutEntrepriseInput = {
    where: ClotureCaisseWhereUniqueInput
    create: XOR<ClotureCaisseCreateWithoutEntrepriseInput, ClotureCaisseUncheckedCreateWithoutEntrepriseInput>
  }

  export type ClotureCaisseCreateManyEntrepriseInputEnvelope = {
    data: ClotureCaisseCreateManyEntrepriseInput | ClotureCaisseCreateManyEntrepriseInput[]
    skipDuplicates?: boolean
  }

  export type AdresseCreateWithoutEntrepriseInput = {
    ville?: string | null
    adresse: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    agent?: AgentCreateNestedOneWithoutAdressesInput
    fournisseur?: FournisseurCreateNestedOneWithoutAdressesInput
    client?: ClientCreateNestedOneWithoutAdressesInput
    reservations?: ReservationCreateNestedManyWithoutAdresseInput
    commandes?: CommandeCreateNestedManyWithoutAdresseInput
  }

  export type AdresseUncheckedCreateWithoutEntrepriseInput = {
    id?: number
    ville?: string | null
    adresse: string
    isActive?: boolean
    agentId?: number | null
    fournisseurId?: number | null
    clientId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reservations?: ReservationUncheckedCreateNestedManyWithoutAdresseInput
    commandes?: CommandeUncheckedCreateNestedManyWithoutAdresseInput
  }

  export type AdresseCreateOrConnectWithoutEntrepriseInput = {
    where: AdresseWhereUniqueInput
    create: XOR<AdresseCreateWithoutEntrepriseInput, AdresseUncheckedCreateWithoutEntrepriseInput>
  }

  export type AdresseCreateManyEntrepriseInputEnvelope = {
    data: AdresseCreateManyEntrepriseInput | AdresseCreateManyEntrepriseInput[]
    skipDuplicates?: boolean
  }

  export type ContactCreateWithoutEntrepriseInput = {
    tel: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    client?: ClientCreateNestedOneWithoutContactsInput
    agent?: AgentCreateNestedOneWithoutContactsInput
    fournisseur?: FournisseurCreateNestedOneWithoutContactsInput
    reservations?: ReservationCreateNestedManyWithoutContactInput
    commandes?: CommandeCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutEntrepriseInput = {
    id?: number
    tel: string
    isActive?: boolean
    agentId?: number | null
    fournisseurId?: number | null
    clientId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reservations?: ReservationUncheckedCreateNestedManyWithoutContactInput
    commandes?: CommandeUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutEntrepriseInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutEntrepriseInput, ContactUncheckedCreateWithoutEntrepriseInput>
  }

  export type ContactCreateManyEntrepriseInputEnvelope = {
    data: ContactCreateManyEntrepriseInput | ContactCreateManyEntrepriseInput[]
    skipDuplicates?: boolean
  }

  export type ClotureCaisseUpsertWithWhereUniqueWithoutEntrepriseInput = {
    where: ClotureCaisseWhereUniqueInput
    update: XOR<ClotureCaisseUpdateWithoutEntrepriseInput, ClotureCaisseUncheckedUpdateWithoutEntrepriseInput>
    create: XOR<ClotureCaisseCreateWithoutEntrepriseInput, ClotureCaisseUncheckedCreateWithoutEntrepriseInput>
  }

  export type ClotureCaisseUpdateWithWhereUniqueWithoutEntrepriseInput = {
    where: ClotureCaisseWhereUniqueInput
    data: XOR<ClotureCaisseUpdateWithoutEntrepriseInput, ClotureCaisseUncheckedUpdateWithoutEntrepriseInput>
  }

  export type ClotureCaisseUpdateManyWithWhereWithoutEntrepriseInput = {
    where: ClotureCaisseScalarWhereInput
    data: XOR<ClotureCaisseUpdateManyMutationInput, ClotureCaisseUncheckedUpdateManyWithoutEntrepriseInput>
  }

  export type ClotureCaisseScalarWhereInput = {
    AND?: ClotureCaisseScalarWhereInput | ClotureCaisseScalarWhereInput[]
    OR?: ClotureCaisseScalarWhereInput[]
    NOT?: ClotureCaisseScalarWhereInput | ClotureCaisseScalarWhereInput[]
    id?: IntFilter<"ClotureCaisse"> | number
    dateCloture?: DateTimeFilter<"ClotureCaisse"> | Date | string
    agentId?: IntFilter<"ClotureCaisse"> | number
    entrepriseId?: IntNullableFilter<"ClotureCaisse"> | number | null
    updatedAt?: DateTimeFilter<"ClotureCaisse"> | Date | string
    notes?: StringNullableFilter<"ClotureCaisse"> | string | null
    createdAt?: DateTimeFilter<"ClotureCaisse"> | Date | string
  }

  export type AdresseUpsertWithWhereUniqueWithoutEntrepriseInput = {
    where: AdresseWhereUniqueInput
    update: XOR<AdresseUpdateWithoutEntrepriseInput, AdresseUncheckedUpdateWithoutEntrepriseInput>
    create: XOR<AdresseCreateWithoutEntrepriseInput, AdresseUncheckedCreateWithoutEntrepriseInput>
  }

  export type AdresseUpdateWithWhereUniqueWithoutEntrepriseInput = {
    where: AdresseWhereUniqueInput
    data: XOR<AdresseUpdateWithoutEntrepriseInput, AdresseUncheckedUpdateWithoutEntrepriseInput>
  }

  export type AdresseUpdateManyWithWhereWithoutEntrepriseInput = {
    where: AdresseScalarWhereInput
    data: XOR<AdresseUpdateManyMutationInput, AdresseUncheckedUpdateManyWithoutEntrepriseInput>
  }

  export type AdresseScalarWhereInput = {
    AND?: AdresseScalarWhereInput | AdresseScalarWhereInput[]
    OR?: AdresseScalarWhereInput[]
    NOT?: AdresseScalarWhereInput | AdresseScalarWhereInput[]
    id?: IntFilter<"Adresse"> | number
    ville?: StringNullableFilter<"Adresse"> | string | null
    adresse?: StringFilter<"Adresse"> | string
    isActive?: BoolFilter<"Adresse"> | boolean
    agentId?: IntNullableFilter<"Adresse"> | number | null
    fournisseurId?: IntNullableFilter<"Adresse"> | number | null
    clientId?: IntNullableFilter<"Adresse"> | number | null
    entrepriseId?: IntNullableFilter<"Adresse"> | number | null
    createdAt?: DateTimeFilter<"Adresse"> | Date | string
    updatedAt?: DateTimeFilter<"Adresse"> | Date | string
  }

  export type ContactUpsertWithWhereUniqueWithoutEntrepriseInput = {
    where: ContactWhereUniqueInput
    update: XOR<ContactUpdateWithoutEntrepriseInput, ContactUncheckedUpdateWithoutEntrepriseInput>
    create: XOR<ContactCreateWithoutEntrepriseInput, ContactUncheckedCreateWithoutEntrepriseInput>
  }

  export type ContactUpdateWithWhereUniqueWithoutEntrepriseInput = {
    where: ContactWhereUniqueInput
    data: XOR<ContactUpdateWithoutEntrepriseInput, ContactUncheckedUpdateWithoutEntrepriseInput>
  }

  export type ContactUpdateManyWithWhereWithoutEntrepriseInput = {
    where: ContactScalarWhereInput
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyWithoutEntrepriseInput>
  }

  export type ContactScalarWhereInput = {
    AND?: ContactScalarWhereInput | ContactScalarWhereInput[]
    OR?: ContactScalarWhereInput[]
    NOT?: ContactScalarWhereInput | ContactScalarWhereInput[]
    id?: IntFilter<"Contact"> | number
    tel?: StringFilter<"Contact"> | string
    isActive?: BoolFilter<"Contact"> | boolean
    agentId?: IntNullableFilter<"Contact"> | number | null
    fournisseurId?: IntNullableFilter<"Contact"> | number | null
    clientId?: IntNullableFilter<"Contact"> | number | null
    entrepriseId?: IntNullableFilter<"Contact"> | number | null
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    updatedAt?: DateTimeFilter<"Contact"> | Date | string
  }

  export type AdresseCreateWithoutAgentInput = {
    ville?: string | null
    adresse: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    entreprise?: EntrepriseCreateNestedOneWithoutAdresseInput
    fournisseur?: FournisseurCreateNestedOneWithoutAdressesInput
    client?: ClientCreateNestedOneWithoutAdressesInput
    reservations?: ReservationCreateNestedManyWithoutAdresseInput
    commandes?: CommandeCreateNestedManyWithoutAdresseInput
  }

  export type AdresseUncheckedCreateWithoutAgentInput = {
    id?: number
    ville?: string | null
    adresse: string
    isActive?: boolean
    fournisseurId?: number | null
    clientId?: number | null
    entrepriseId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reservations?: ReservationUncheckedCreateNestedManyWithoutAdresseInput
    commandes?: CommandeUncheckedCreateNestedManyWithoutAdresseInput
  }

  export type AdresseCreateOrConnectWithoutAgentInput = {
    where: AdresseWhereUniqueInput
    create: XOR<AdresseCreateWithoutAgentInput, AdresseUncheckedCreateWithoutAgentInput>
  }

  export type AdresseCreateManyAgentInputEnvelope = {
    data: AdresseCreateManyAgentInput | AdresseCreateManyAgentInput[]
    skipDuplicates?: boolean
  }

  export type ContactCreateWithoutAgentInput = {
    tel: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    entreprise?: EntrepriseCreateNestedOneWithoutContactInput
    client?: ClientCreateNestedOneWithoutContactsInput
    fournisseur?: FournisseurCreateNestedOneWithoutContactsInput
    reservations?: ReservationCreateNestedManyWithoutContactInput
    commandes?: CommandeCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutAgentInput = {
    id?: number
    tel: string
    isActive?: boolean
    fournisseurId?: number | null
    clientId?: number | null
    entrepriseId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reservations?: ReservationUncheckedCreateNestedManyWithoutContactInput
    commandes?: CommandeUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutAgentInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutAgentInput, ContactUncheckedCreateWithoutAgentInput>
  }

  export type ContactCreateManyAgentInputEnvelope = {
    data: ContactCreateManyAgentInput | ContactCreateManyAgentInput[]
    skipDuplicates?: boolean
  }

  export type ProduitCreateWithoutAgentInput = {
    designation: string
    prixUnitaire: number
    qtteDisponible?: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    detailsPaniers?: DetailPanierCreateNestedManyWithoutProduitInput
    devise: DeviseCreateNestedOneWithoutProduitsInput
    teneur: TeneurCreateNestedOneWithoutProduitsInput
  }

  export type ProduitUncheckedCreateWithoutAgentInput = {
    id?: number
    designation: string
    prixUnitaire: number
    qtteDisponible?: number
    description?: string | null
    deviseId: number
    teneurId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    detailsPaniers?: DetailPanierUncheckedCreateNestedManyWithoutProduitInput
  }

  export type ProduitCreateOrConnectWithoutAgentInput = {
    where: ProduitWhereUniqueInput
    create: XOR<ProduitCreateWithoutAgentInput, ProduitUncheckedCreateWithoutAgentInput>
  }

  export type ProduitCreateManyAgentInputEnvelope = {
    data: ProduitCreateManyAgentInput | ProduitCreateManyAgentInput[]
    skipDuplicates?: boolean
  }

  export type VenteCreateWithoutAgentInput = {
    statut?: $Enums.StatutVente
    typeAcheteur: $Enums.TypeClient
    enregistrerPar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    panier: PanierCreateNestedOneWithoutVentesInput
    fournisseur?: FournisseurCreateNestedOneWithoutVentesInput
    client?: ClientCreateNestedOneWithoutVentesInput
    paiements?: PaiementCreateNestedManyWithoutVenteInput
  }

  export type VenteUncheckedCreateWithoutAgentInput = {
    id?: number
    statut?: $Enums.StatutVente
    typeAcheteur: $Enums.TypeClient
    clientId?: number | null
    fournisseurId?: number | null
    panierId: number
    enregistrerPar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    paiements?: PaiementUncheckedCreateNestedManyWithoutVenteInput
  }

  export type VenteCreateOrConnectWithoutAgentInput = {
    where: VenteWhereUniqueInput
    create: XOR<VenteCreateWithoutAgentInput, VenteUncheckedCreateWithoutAgentInput>
  }

  export type VenteCreateManyAgentInputEnvelope = {
    data: VenteCreateManyAgentInput | VenteCreateManyAgentInput[]
    skipDuplicates?: boolean
  }

  export type AchatCreateWithoutAgentInput = {
    statut?: $Enums.StatutAchat
    createdAt?: Date | string
    updatedAt?: Date | string
    panier: PanierCreateNestedOneWithoutAchatsInput
    fournisseur: FournisseurCreateNestedOneWithoutAchatsInput
    Client?: ClientCreateNestedOneWithoutAchatsInput
    paiements?: PaiementCreateNestedManyWithoutAchatInput
  }

  export type AchatUncheckedCreateWithoutAgentInput = {
    id?: number
    statut?: $Enums.StatutAchat
    panierId: number
    fournisseurId: number
    clientId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    paiements?: PaiementUncheckedCreateNestedManyWithoutAchatInput
  }

  export type AchatCreateOrConnectWithoutAgentInput = {
    where: AchatWhereUniqueInput
    create: XOR<AchatCreateWithoutAgentInput, AchatUncheckedCreateWithoutAgentInput>
  }

  export type AchatCreateManyAgentInputEnvelope = {
    data: AchatCreateManyAgentInput | AchatCreateManyAgentInput[]
    skipDuplicates?: boolean
  }

  export type TeneurCreateWithoutAgentsInput = {
    valeur: number
    createdAt?: Date | string
    updatedAt?: Date | string
    produits?: ProduitCreateNestedManyWithoutTeneurInput
  }

  export type TeneurUncheckedCreateWithoutAgentsInput = {
    id?: number
    valeur: number
    createdAt?: Date | string
    updatedAt?: Date | string
    produits?: ProduitUncheckedCreateNestedManyWithoutTeneurInput
  }

  export type TeneurCreateOrConnectWithoutAgentsInput = {
    where: TeneurWhereUniqueInput
    create: XOR<TeneurCreateWithoutAgentsInput, TeneurUncheckedCreateWithoutAgentsInput>
  }

  export type TeneurCreateManyAgentsInputEnvelope = {
    data: TeneurCreateManyAgentsInput | TeneurCreateManyAgentsInput[]
    skipDuplicates?: boolean
  }

  export type DeviseCreateWithoutAgentInput = {
    nom: string
    code: string
    symbole: string
    tauxDEchange: number
    createdAt?: Date | string
    updatedAt?: Date | string
    produits?: ProduitCreateNestedManyWithoutDeviseInput
    paiements?: PaiementCreateNestedManyWithoutDeviseInput
    caisses?: CaisseCreateNestedManyWithoutDeviseInput
    DetailPanier?: DetailPanierCreateNestedManyWithoutDeviseInput
  }

  export type DeviseUncheckedCreateWithoutAgentInput = {
    id?: number
    nom: string
    code: string
    symbole: string
    tauxDEchange: number
    createdAt?: Date | string
    updatedAt?: Date | string
    produits?: ProduitUncheckedCreateNestedManyWithoutDeviseInput
    paiements?: PaiementUncheckedCreateNestedManyWithoutDeviseInput
    caisses?: CaisseUncheckedCreateNestedManyWithoutDeviseInput
    DetailPanier?: DetailPanierUncheckedCreateNestedManyWithoutDeviseInput
  }

  export type DeviseCreateOrConnectWithoutAgentInput = {
    where: DeviseWhereUniqueInput
    create: XOR<DeviseCreateWithoutAgentInput, DeviseUncheckedCreateWithoutAgentInput>
  }

  export type DeviseCreateManyAgentInputEnvelope = {
    data: DeviseCreateManyAgentInput | DeviseCreateManyAgentInput[]
    skipDuplicates?: boolean
  }

  export type PanierCreateWithoutAgentInput = {
    statut?: $Enums.statutPanier
    createdAt?: Date | string
    updatedAt?: Date | string
    client?: ClientCreateNestedOneWithoutPaniersInput
    detailPaniers?: DetailPanierCreateNestedManyWithoutPanierInput
    achats?: AchatCreateNestedManyWithoutPanierInput
    ventes?: VenteCreateNestedManyWithoutPanierInput
    reservations?: ReservationCreateNestedManyWithoutPanierInput
    commandes?: CommandeCreateNestedManyWithoutPanierInput
  }

  export type PanierUncheckedCreateWithoutAgentInput = {
    id?: number
    clientId?: number | null
    statut?: $Enums.statutPanier
    createdAt?: Date | string
    updatedAt?: Date | string
    detailPaniers?: DetailPanierUncheckedCreateNestedManyWithoutPanierInput
    achats?: AchatUncheckedCreateNestedManyWithoutPanierInput
    ventes?: VenteUncheckedCreateNestedManyWithoutPanierInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutPanierInput
    commandes?: CommandeUncheckedCreateNestedManyWithoutPanierInput
  }

  export type PanierCreateOrConnectWithoutAgentInput = {
    where: PanierWhereUniqueInput
    create: XOR<PanierCreateWithoutAgentInput, PanierUncheckedCreateWithoutAgentInput>
  }

  export type PanierCreateManyAgentInputEnvelope = {
    data: PanierCreateManyAgentInput | PanierCreateManyAgentInput[]
    skipDuplicates?: boolean
  }

  export type CaisseCreateWithoutAgentInput = {
    nom: string
    description?: string | null
    soldeActuel?: number | null
    statut?: $Enums.StatutCaisse
    createdAt?: Date | string
    updatedAt?: Date | string
    devise: DeviseCreateNestedOneWithoutCaissesInput
    mouvementCaisses?: MouvementCaisseCreateNestedManyWithoutCaisseInput
    paiements?: PaiementCreateNestedManyWithoutCaisseInput
  }

  export type CaisseUncheckedCreateWithoutAgentInput = {
    id?: number
    nom: string
    description?: string | null
    soldeActuel?: number | null
    deviseId: number
    statut?: $Enums.StatutCaisse
    createdAt?: Date | string
    updatedAt?: Date | string
    mouvementCaisses?: MouvementCaisseUncheckedCreateNestedManyWithoutCaisseInput
    paiements?: PaiementUncheckedCreateNestedManyWithoutCaisseInput
  }

  export type CaisseCreateOrConnectWithoutAgentInput = {
    where: CaisseWhereUniqueInput
    create: XOR<CaisseCreateWithoutAgentInput, CaisseUncheckedCreateWithoutAgentInput>
  }

  export type CaisseCreateManyAgentInputEnvelope = {
    data: CaisseCreateManyAgentInput | CaisseCreateManyAgentInput[]
    skipDuplicates?: boolean
  }

  export type MouvementCaisseCreateWithoutAgentInput = {
    referenceExterne?: string | null
    type_mouvement?: $Enums.TypeMouvementCaisse
    categorie?: $Enums.CategorieMouvement
    moyen_paiement: $Enums.ModePaiment
    montant: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    caisse: CaisseCreateNestedOneWithoutMouvementCaissesInput
  }

  export type MouvementCaisseUncheckedCreateWithoutAgentInput = {
    id?: number
    caisseId: number
    referenceExterne?: string | null
    type_mouvement?: $Enums.TypeMouvementCaisse
    categorie?: $Enums.CategorieMouvement
    moyen_paiement: $Enums.ModePaiment
    montant: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MouvementCaisseCreateOrConnectWithoutAgentInput = {
    where: MouvementCaisseWhereUniqueInput
    create: XOR<MouvementCaisseCreateWithoutAgentInput, MouvementCaisseUncheckedCreateWithoutAgentInput>
  }

  export type MouvementCaisseCreateManyAgentInputEnvelope = {
    data: MouvementCaisseCreateManyAgentInput | MouvementCaisseCreateManyAgentInput[]
    skipDuplicates?: boolean
  }

  export type ClotureCaisseCreateWithoutAgentInput = {
    dateCloture?: Date | string
    updatedAt?: Date | string
    notes?: string | null
    createdAt?: Date | string
    entreprise?: EntrepriseCreateNestedOneWithoutClotureCaissesInput
  }

  export type ClotureCaisseUncheckedCreateWithoutAgentInput = {
    id?: number
    dateCloture?: Date | string
    entrepriseId?: number | null
    updatedAt?: Date | string
    notes?: string | null
    createdAt?: Date | string
  }

  export type ClotureCaisseCreateOrConnectWithoutAgentInput = {
    where: ClotureCaisseWhereUniqueInput
    create: XOR<ClotureCaisseCreateWithoutAgentInput, ClotureCaisseUncheckedCreateWithoutAgentInput>
  }

  export type ClotureCaisseCreateManyAgentInputEnvelope = {
    data: ClotureCaisseCreateManyAgentInput | ClotureCaisseCreateManyAgentInput[]
    skipDuplicates?: boolean
  }

  export type FournisseurCreateWithoutAgentInput = {
    nom: string
    email: string
    codePostale?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ventes?: VenteCreateNestedManyWithoutFournisseurInput
    achats?: AchatCreateNestedManyWithoutFournisseurInput
    adresses?: AdresseCreateNestedManyWithoutFournisseurInput
    contacts?: ContactCreateNestedManyWithoutFournisseurInput
    reservations?: ReservationCreateNestedManyWithoutFournisseurInput
    commandes?: CommandeCreateNestedManyWithoutFournisseurInput
  }

  export type FournisseurUncheckedCreateWithoutAgentInput = {
    id?: number
    nom: string
    email: string
    codePostale?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ventes?: VenteUncheckedCreateNestedManyWithoutFournisseurInput
    achats?: AchatUncheckedCreateNestedManyWithoutFournisseurInput
    adresses?: AdresseUncheckedCreateNestedManyWithoutFournisseurInput
    contacts?: ContactUncheckedCreateNestedManyWithoutFournisseurInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutFournisseurInput
    commandes?: CommandeUncheckedCreateNestedManyWithoutFournisseurInput
  }

  export type FournisseurCreateOrConnectWithoutAgentInput = {
    where: FournisseurWhereUniqueInput
    create: XOR<FournisseurCreateWithoutAgentInput, FournisseurUncheckedCreateWithoutAgentInput>
  }

  export type FournisseurCreateManyAgentInputEnvelope = {
    data: FournisseurCreateManyAgentInput | FournisseurCreateManyAgentInput[]
    skipDuplicates?: boolean
  }

  export type AdresseUpsertWithWhereUniqueWithoutAgentInput = {
    where: AdresseWhereUniqueInput
    update: XOR<AdresseUpdateWithoutAgentInput, AdresseUncheckedUpdateWithoutAgentInput>
    create: XOR<AdresseCreateWithoutAgentInput, AdresseUncheckedCreateWithoutAgentInput>
  }

  export type AdresseUpdateWithWhereUniqueWithoutAgentInput = {
    where: AdresseWhereUniqueInput
    data: XOR<AdresseUpdateWithoutAgentInput, AdresseUncheckedUpdateWithoutAgentInput>
  }

  export type AdresseUpdateManyWithWhereWithoutAgentInput = {
    where: AdresseScalarWhereInput
    data: XOR<AdresseUpdateManyMutationInput, AdresseUncheckedUpdateManyWithoutAgentInput>
  }

  export type ContactUpsertWithWhereUniqueWithoutAgentInput = {
    where: ContactWhereUniqueInput
    update: XOR<ContactUpdateWithoutAgentInput, ContactUncheckedUpdateWithoutAgentInput>
    create: XOR<ContactCreateWithoutAgentInput, ContactUncheckedCreateWithoutAgentInput>
  }

  export type ContactUpdateWithWhereUniqueWithoutAgentInput = {
    where: ContactWhereUniqueInput
    data: XOR<ContactUpdateWithoutAgentInput, ContactUncheckedUpdateWithoutAgentInput>
  }

  export type ContactUpdateManyWithWhereWithoutAgentInput = {
    where: ContactScalarWhereInput
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyWithoutAgentInput>
  }

  export type ProduitUpsertWithWhereUniqueWithoutAgentInput = {
    where: ProduitWhereUniqueInput
    update: XOR<ProduitUpdateWithoutAgentInput, ProduitUncheckedUpdateWithoutAgentInput>
    create: XOR<ProduitCreateWithoutAgentInput, ProduitUncheckedCreateWithoutAgentInput>
  }

  export type ProduitUpdateWithWhereUniqueWithoutAgentInput = {
    where: ProduitWhereUniqueInput
    data: XOR<ProduitUpdateWithoutAgentInput, ProduitUncheckedUpdateWithoutAgentInput>
  }

  export type ProduitUpdateManyWithWhereWithoutAgentInput = {
    where: ProduitScalarWhereInput
    data: XOR<ProduitUpdateManyMutationInput, ProduitUncheckedUpdateManyWithoutAgentInput>
  }

  export type VenteUpsertWithWhereUniqueWithoutAgentInput = {
    where: VenteWhereUniqueInput
    update: XOR<VenteUpdateWithoutAgentInput, VenteUncheckedUpdateWithoutAgentInput>
    create: XOR<VenteCreateWithoutAgentInput, VenteUncheckedCreateWithoutAgentInput>
  }

  export type VenteUpdateWithWhereUniqueWithoutAgentInput = {
    where: VenteWhereUniqueInput
    data: XOR<VenteUpdateWithoutAgentInput, VenteUncheckedUpdateWithoutAgentInput>
  }

  export type VenteUpdateManyWithWhereWithoutAgentInput = {
    where: VenteScalarWhereInput
    data: XOR<VenteUpdateManyMutationInput, VenteUncheckedUpdateManyWithoutAgentInput>
  }

  export type VenteScalarWhereInput = {
    AND?: VenteScalarWhereInput | VenteScalarWhereInput[]
    OR?: VenteScalarWhereInput[]
    NOT?: VenteScalarWhereInput | VenteScalarWhereInput[]
    id?: IntFilter<"Vente"> | number
    statut?: EnumStatutVenteFilter<"Vente"> | $Enums.StatutVente
    typeAcheteur?: EnumTypeClientFilter<"Vente"> | $Enums.TypeClient
    clientId?: IntNullableFilter<"Vente"> | number | null
    agentId?: IntNullableFilter<"Vente"> | number | null
    fournisseurId?: IntNullableFilter<"Vente"> | number | null
    panierId?: IntFilter<"Vente"> | number
    enregistrerPar?: StringNullableFilter<"Vente"> | string | null
    createdAt?: DateTimeFilter<"Vente"> | Date | string
    updatedAt?: DateTimeFilter<"Vente"> | Date | string
  }

  export type AchatUpsertWithWhereUniqueWithoutAgentInput = {
    where: AchatWhereUniqueInput
    update: XOR<AchatUpdateWithoutAgentInput, AchatUncheckedUpdateWithoutAgentInput>
    create: XOR<AchatCreateWithoutAgentInput, AchatUncheckedCreateWithoutAgentInput>
  }

  export type AchatUpdateWithWhereUniqueWithoutAgentInput = {
    where: AchatWhereUniqueInput
    data: XOR<AchatUpdateWithoutAgentInput, AchatUncheckedUpdateWithoutAgentInput>
  }

  export type AchatUpdateManyWithWhereWithoutAgentInput = {
    where: AchatScalarWhereInput
    data: XOR<AchatUpdateManyMutationInput, AchatUncheckedUpdateManyWithoutAgentInput>
  }

  export type AchatScalarWhereInput = {
    AND?: AchatScalarWhereInput | AchatScalarWhereInput[]
    OR?: AchatScalarWhereInput[]
    NOT?: AchatScalarWhereInput | AchatScalarWhereInput[]
    id?: IntFilter<"Achat"> | number
    statut?: EnumStatutAchatFilter<"Achat"> | $Enums.StatutAchat
    panierId?: IntFilter<"Achat"> | number
    fournisseurId?: IntFilter<"Achat"> | number
    agentId?: IntFilter<"Achat"> | number
    clientId?: IntNullableFilter<"Achat"> | number | null
    createdAt?: DateTimeFilter<"Achat"> | Date | string
    updatedAt?: DateTimeFilter<"Achat"> | Date | string
  }

  export type TeneurUpsertWithWhereUniqueWithoutAgentsInput = {
    where: TeneurWhereUniqueInput
    update: XOR<TeneurUpdateWithoutAgentsInput, TeneurUncheckedUpdateWithoutAgentsInput>
    create: XOR<TeneurCreateWithoutAgentsInput, TeneurUncheckedCreateWithoutAgentsInput>
  }

  export type TeneurUpdateWithWhereUniqueWithoutAgentsInput = {
    where: TeneurWhereUniqueInput
    data: XOR<TeneurUpdateWithoutAgentsInput, TeneurUncheckedUpdateWithoutAgentsInput>
  }

  export type TeneurUpdateManyWithWhereWithoutAgentsInput = {
    where: TeneurScalarWhereInput
    data: XOR<TeneurUpdateManyMutationInput, TeneurUncheckedUpdateManyWithoutAgentsInput>
  }

  export type TeneurScalarWhereInput = {
    AND?: TeneurScalarWhereInput | TeneurScalarWhereInput[]
    OR?: TeneurScalarWhereInput[]
    NOT?: TeneurScalarWhereInput | TeneurScalarWhereInput[]
    id?: IntFilter<"Teneur"> | number
    valeur?: FloatFilter<"Teneur"> | number
    agentId?: IntFilter<"Teneur"> | number
    createdAt?: DateTimeFilter<"Teneur"> | Date | string
    updatedAt?: DateTimeFilter<"Teneur"> | Date | string
  }

  export type DeviseUpsertWithWhereUniqueWithoutAgentInput = {
    where: DeviseWhereUniqueInput
    update: XOR<DeviseUpdateWithoutAgentInput, DeviseUncheckedUpdateWithoutAgentInput>
    create: XOR<DeviseCreateWithoutAgentInput, DeviseUncheckedCreateWithoutAgentInput>
  }

  export type DeviseUpdateWithWhereUniqueWithoutAgentInput = {
    where: DeviseWhereUniqueInput
    data: XOR<DeviseUpdateWithoutAgentInput, DeviseUncheckedUpdateWithoutAgentInput>
  }

  export type DeviseUpdateManyWithWhereWithoutAgentInput = {
    where: DeviseScalarWhereInput
    data: XOR<DeviseUpdateManyMutationInput, DeviseUncheckedUpdateManyWithoutAgentInput>
  }

  export type DeviseScalarWhereInput = {
    AND?: DeviseScalarWhereInput | DeviseScalarWhereInput[]
    OR?: DeviseScalarWhereInput[]
    NOT?: DeviseScalarWhereInput | DeviseScalarWhereInput[]
    id?: IntFilter<"Devise"> | number
    nom?: StringFilter<"Devise"> | string
    code?: StringFilter<"Devise"> | string
    symbole?: StringFilter<"Devise"> | string
    tauxDEchange?: IntFilter<"Devise"> | number
    agentId?: IntFilter<"Devise"> | number
    createdAt?: DateTimeFilter<"Devise"> | Date | string
    updatedAt?: DateTimeFilter<"Devise"> | Date | string
  }

  export type PanierUpsertWithWhereUniqueWithoutAgentInput = {
    where: PanierWhereUniqueInput
    update: XOR<PanierUpdateWithoutAgentInput, PanierUncheckedUpdateWithoutAgentInput>
    create: XOR<PanierCreateWithoutAgentInput, PanierUncheckedCreateWithoutAgentInput>
  }

  export type PanierUpdateWithWhereUniqueWithoutAgentInput = {
    where: PanierWhereUniqueInput
    data: XOR<PanierUpdateWithoutAgentInput, PanierUncheckedUpdateWithoutAgentInput>
  }

  export type PanierUpdateManyWithWhereWithoutAgentInput = {
    where: PanierScalarWhereInput
    data: XOR<PanierUpdateManyMutationInput, PanierUncheckedUpdateManyWithoutAgentInput>
  }

  export type PanierScalarWhereInput = {
    AND?: PanierScalarWhereInput | PanierScalarWhereInput[]
    OR?: PanierScalarWhereInput[]
    NOT?: PanierScalarWhereInput | PanierScalarWhereInput[]
    id?: IntFilter<"Panier"> | number
    agentId?: IntNullableFilter<"Panier"> | number | null
    clientId?: IntNullableFilter<"Panier"> | number | null
    statut?: EnumstatutPanierFilter<"Panier"> | $Enums.statutPanier
    createdAt?: DateTimeFilter<"Panier"> | Date | string
    updatedAt?: DateTimeFilter<"Panier"> | Date | string
  }

  export type CaisseUpsertWithWhereUniqueWithoutAgentInput = {
    where: CaisseWhereUniqueInput
    update: XOR<CaisseUpdateWithoutAgentInput, CaisseUncheckedUpdateWithoutAgentInput>
    create: XOR<CaisseCreateWithoutAgentInput, CaisseUncheckedCreateWithoutAgentInput>
  }

  export type CaisseUpdateWithWhereUniqueWithoutAgentInput = {
    where: CaisseWhereUniqueInput
    data: XOR<CaisseUpdateWithoutAgentInput, CaisseUncheckedUpdateWithoutAgentInput>
  }

  export type CaisseUpdateManyWithWhereWithoutAgentInput = {
    where: CaisseScalarWhereInput
    data: XOR<CaisseUpdateManyMutationInput, CaisseUncheckedUpdateManyWithoutAgentInput>
  }

  export type MouvementCaisseUpsertWithWhereUniqueWithoutAgentInput = {
    where: MouvementCaisseWhereUniqueInput
    update: XOR<MouvementCaisseUpdateWithoutAgentInput, MouvementCaisseUncheckedUpdateWithoutAgentInput>
    create: XOR<MouvementCaisseCreateWithoutAgentInput, MouvementCaisseUncheckedCreateWithoutAgentInput>
  }

  export type MouvementCaisseUpdateWithWhereUniqueWithoutAgentInput = {
    where: MouvementCaisseWhereUniqueInput
    data: XOR<MouvementCaisseUpdateWithoutAgentInput, MouvementCaisseUncheckedUpdateWithoutAgentInput>
  }

  export type MouvementCaisseUpdateManyWithWhereWithoutAgentInput = {
    where: MouvementCaisseScalarWhereInput
    data: XOR<MouvementCaisseUpdateManyMutationInput, MouvementCaisseUncheckedUpdateManyWithoutAgentInput>
  }

  export type MouvementCaisseScalarWhereInput = {
    AND?: MouvementCaisseScalarWhereInput | MouvementCaisseScalarWhereInput[]
    OR?: MouvementCaisseScalarWhereInput[]
    NOT?: MouvementCaisseScalarWhereInput | MouvementCaisseScalarWhereInput[]
    id?: IntFilter<"MouvementCaisse"> | number
    caisseId?: IntFilter<"MouvementCaisse"> | number
    referenceExterne?: StringNullableFilter<"MouvementCaisse"> | string | null
    type_mouvement?: EnumTypeMouvementCaisseFilter<"MouvementCaisse"> | $Enums.TypeMouvementCaisse
    categorie?: EnumCategorieMouvementFilter<"MouvementCaisse"> | $Enums.CategorieMouvement
    moyen_paiement?: EnumModePaimentFilter<"MouvementCaisse"> | $Enums.ModePaiment
    montant?: FloatFilter<"MouvementCaisse"> | number
    description?: StringNullableFilter<"MouvementCaisse"> | string | null
    agentId?: IntFilter<"MouvementCaisse"> | number
    createdAt?: DateTimeFilter<"MouvementCaisse"> | Date | string
    updatedAt?: DateTimeFilter<"MouvementCaisse"> | Date | string
  }

  export type ClotureCaisseUpsertWithWhereUniqueWithoutAgentInput = {
    where: ClotureCaisseWhereUniqueInput
    update: XOR<ClotureCaisseUpdateWithoutAgentInput, ClotureCaisseUncheckedUpdateWithoutAgentInput>
    create: XOR<ClotureCaisseCreateWithoutAgentInput, ClotureCaisseUncheckedCreateWithoutAgentInput>
  }

  export type ClotureCaisseUpdateWithWhereUniqueWithoutAgentInput = {
    where: ClotureCaisseWhereUniqueInput
    data: XOR<ClotureCaisseUpdateWithoutAgentInput, ClotureCaisseUncheckedUpdateWithoutAgentInput>
  }

  export type ClotureCaisseUpdateManyWithWhereWithoutAgentInput = {
    where: ClotureCaisseScalarWhereInput
    data: XOR<ClotureCaisseUpdateManyMutationInput, ClotureCaisseUncheckedUpdateManyWithoutAgentInput>
  }

  export type FournisseurUpsertWithWhereUniqueWithoutAgentInput = {
    where: FournisseurWhereUniqueInput
    update: XOR<FournisseurUpdateWithoutAgentInput, FournisseurUncheckedUpdateWithoutAgentInput>
    create: XOR<FournisseurCreateWithoutAgentInput, FournisseurUncheckedCreateWithoutAgentInput>
  }

  export type FournisseurUpdateWithWhereUniqueWithoutAgentInput = {
    where: FournisseurWhereUniqueInput
    data: XOR<FournisseurUpdateWithoutAgentInput, FournisseurUncheckedUpdateWithoutAgentInput>
  }

  export type FournisseurUpdateManyWithWhereWithoutAgentInput = {
    where: FournisseurScalarWhereInput
    data: XOR<FournisseurUpdateManyMutationInput, FournisseurUncheckedUpdateManyWithoutAgentInput>
  }

  export type FournisseurScalarWhereInput = {
    AND?: FournisseurScalarWhereInput | FournisseurScalarWhereInput[]
    OR?: FournisseurScalarWhereInput[]
    NOT?: FournisseurScalarWhereInput | FournisseurScalarWhereInput[]
    id?: IntFilter<"Fournisseur"> | number
    nom?: StringFilter<"Fournisseur"> | string
    email?: StringFilter<"Fournisseur"> | string
    codePostale?: StringNullableFilter<"Fournisseur"> | string | null
    agentId?: IntFilter<"Fournisseur"> | number
    createdAt?: DateTimeFilter<"Fournisseur"> | Date | string
    updatedAt?: DateTimeFilter<"Fournisseur"> | Date | string
  }

  export type AdresseCreateWithoutClientInput = {
    ville?: string | null
    adresse: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    agent?: AgentCreateNestedOneWithoutAdressesInput
    entreprise?: EntrepriseCreateNestedOneWithoutAdresseInput
    fournisseur?: FournisseurCreateNestedOneWithoutAdressesInput
    reservations?: ReservationCreateNestedManyWithoutAdresseInput
    commandes?: CommandeCreateNestedManyWithoutAdresseInput
  }

  export type AdresseUncheckedCreateWithoutClientInput = {
    id?: number
    ville?: string | null
    adresse: string
    isActive?: boolean
    agentId?: number | null
    fournisseurId?: number | null
    entrepriseId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reservations?: ReservationUncheckedCreateNestedManyWithoutAdresseInput
    commandes?: CommandeUncheckedCreateNestedManyWithoutAdresseInput
  }

  export type AdresseCreateOrConnectWithoutClientInput = {
    where: AdresseWhereUniqueInput
    create: XOR<AdresseCreateWithoutClientInput, AdresseUncheckedCreateWithoutClientInput>
  }

  export type AdresseCreateManyClientInputEnvelope = {
    data: AdresseCreateManyClientInput | AdresseCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type ContactCreateWithoutClientInput = {
    tel: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    entreprise?: EntrepriseCreateNestedOneWithoutContactInput
    agent?: AgentCreateNestedOneWithoutContactsInput
    fournisseur?: FournisseurCreateNestedOneWithoutContactsInput
    reservations?: ReservationCreateNestedManyWithoutContactInput
    commandes?: CommandeCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutClientInput = {
    id?: number
    tel: string
    isActive?: boolean
    agentId?: number | null
    fournisseurId?: number | null
    entrepriseId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reservations?: ReservationUncheckedCreateNestedManyWithoutContactInput
    commandes?: CommandeUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutClientInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutClientInput, ContactUncheckedCreateWithoutClientInput>
  }

  export type ContactCreateManyClientInputEnvelope = {
    data: ContactCreateManyClientInput | ContactCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type VenteCreateWithoutClientInput = {
    statut?: $Enums.StatutVente
    typeAcheteur: $Enums.TypeClient
    enregistrerPar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    panier: PanierCreateNestedOneWithoutVentesInput
    agent?: AgentCreateNestedOneWithoutVentesInput
    fournisseur?: FournisseurCreateNestedOneWithoutVentesInput
    paiements?: PaiementCreateNestedManyWithoutVenteInput
  }

  export type VenteUncheckedCreateWithoutClientInput = {
    id?: number
    statut?: $Enums.StatutVente
    typeAcheteur: $Enums.TypeClient
    agentId?: number | null
    fournisseurId?: number | null
    panierId: number
    enregistrerPar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    paiements?: PaiementUncheckedCreateNestedManyWithoutVenteInput
  }

  export type VenteCreateOrConnectWithoutClientInput = {
    where: VenteWhereUniqueInput
    create: XOR<VenteCreateWithoutClientInput, VenteUncheckedCreateWithoutClientInput>
  }

  export type VenteCreateManyClientInputEnvelope = {
    data: VenteCreateManyClientInput | VenteCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type AchatCreateWithoutClientInput = {
    statut?: $Enums.StatutAchat
    createdAt?: Date | string
    updatedAt?: Date | string
    panier: PanierCreateNestedOneWithoutAchatsInput
    fournisseur: FournisseurCreateNestedOneWithoutAchatsInput
    agent: AgentCreateNestedOneWithoutAchatsInput
    paiements?: PaiementCreateNestedManyWithoutAchatInput
  }

  export type AchatUncheckedCreateWithoutClientInput = {
    id?: number
    statut?: $Enums.StatutAchat
    panierId: number
    fournisseurId: number
    agentId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    paiements?: PaiementUncheckedCreateNestedManyWithoutAchatInput
  }

  export type AchatCreateOrConnectWithoutClientInput = {
    where: AchatWhereUniqueInput
    create: XOR<AchatCreateWithoutClientInput, AchatUncheckedCreateWithoutClientInput>
  }

  export type AchatCreateManyClientInputEnvelope = {
    data: AchatCreateManyClientInput | AchatCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type PanierCreateWithoutClientInput = {
    statut?: $Enums.statutPanier
    createdAt?: Date | string
    updatedAt?: Date | string
    agent?: AgentCreateNestedOneWithoutPaniersInput
    detailPaniers?: DetailPanierCreateNestedManyWithoutPanierInput
    achats?: AchatCreateNestedManyWithoutPanierInput
    ventes?: VenteCreateNestedManyWithoutPanierInput
    reservations?: ReservationCreateNestedManyWithoutPanierInput
    commandes?: CommandeCreateNestedManyWithoutPanierInput
  }

  export type PanierUncheckedCreateWithoutClientInput = {
    id?: number
    agentId?: number | null
    statut?: $Enums.statutPanier
    createdAt?: Date | string
    updatedAt?: Date | string
    detailPaniers?: DetailPanierUncheckedCreateNestedManyWithoutPanierInput
    achats?: AchatUncheckedCreateNestedManyWithoutPanierInput
    ventes?: VenteUncheckedCreateNestedManyWithoutPanierInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutPanierInput
    commandes?: CommandeUncheckedCreateNestedManyWithoutPanierInput
  }

  export type PanierCreateOrConnectWithoutClientInput = {
    where: PanierWhereUniqueInput
    create: XOR<PanierCreateWithoutClientInput, PanierUncheckedCreateWithoutClientInput>
  }

  export type PanierCreateManyClientInputEnvelope = {
    data: PanierCreateManyClientInput | PanierCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type ReservationCreateWithoutClientInput = {
    dateLivraisonSouhaitee: Date | string
    adresseLivraison?: string | null
    statut?: $Enums.StatutReservation
    notes?: string | null
    typeClient?: $Enums.TypeClient
    nom?: string | null
    tel?: string | null
    enregistrerParId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    panier: PanierCreateNestedOneWithoutReservationsInput
    fournisseur?: FournisseurCreateNestedOneWithoutReservationsInput
    adresse?: AdresseCreateNestedOneWithoutReservationsInput
    contact?: ContactCreateNestedOneWithoutReservationsInput
  }

  export type ReservationUncheckedCreateWithoutClientInput = {
    id?: number
    dateLivraisonSouhaitee: Date | string
    adresseLivraison?: string | null
    statut?: $Enums.StatutReservation
    notes?: string | null
    typeClient?: $Enums.TypeClient
    panierId: number
    nom?: string | null
    tel?: string | null
    adresseId?: number | null
    contactId?: number | null
    enregistrerParId?: number | null
    fournisseurId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReservationCreateOrConnectWithoutClientInput = {
    where: ReservationWhereUniqueInput
    create: XOR<ReservationCreateWithoutClientInput, ReservationUncheckedCreateWithoutClientInput>
  }

  export type ReservationCreateManyClientInputEnvelope = {
    data: ReservationCreateManyClientInput | ReservationCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type CommandeCreateWithoutClientInput = {
    nom?: string | null
    tel?: string | null
    type_client?: $Enums.TypeClient
    commandeId?: number | null
    notes?: string | null
    dateLivraisonEffective?: Date | string | null
    adresseLivraison?: string | null
    enregistrerParId?: number | null
    statut?: $Enums.StatutCommande
    createdAt?: Date | string
    updatedAt?: Date | string
    Paiement?: PaiementCreateNestedManyWithoutCommandeInput
    panier: PanierCreateNestedOneWithoutCommandesInput
    fournisseur?: FournisseurCreateNestedOneWithoutCommandesInput
    adresse?: AdresseCreateNestedOneWithoutCommandesInput
    contact?: ContactCreateNestedOneWithoutCommandesInput
  }

  export type CommandeUncheckedCreateWithoutClientInput = {
    id?: number
    panierId: number
    nom?: string | null
    tel?: string | null
    type_client?: $Enums.TypeClient
    adresseId?: number | null
    contactId?: number | null
    fournisseurId?: number | null
    commandeId?: number | null
    notes?: string | null
    dateLivraisonEffective?: Date | string | null
    adresseLivraison?: string | null
    enregistrerParId?: number | null
    statut?: $Enums.StatutCommande
    createdAt?: Date | string
    updatedAt?: Date | string
    Paiement?: PaiementUncheckedCreateNestedManyWithoutCommandeInput
  }

  export type CommandeCreateOrConnectWithoutClientInput = {
    where: CommandeWhereUniqueInput
    create: XOR<CommandeCreateWithoutClientInput, CommandeUncheckedCreateWithoutClientInput>
  }

  export type CommandeCreateManyClientInputEnvelope = {
    data: CommandeCreateManyClientInput | CommandeCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type AdresseUpsertWithWhereUniqueWithoutClientInput = {
    where: AdresseWhereUniqueInput
    update: XOR<AdresseUpdateWithoutClientInput, AdresseUncheckedUpdateWithoutClientInput>
    create: XOR<AdresseCreateWithoutClientInput, AdresseUncheckedCreateWithoutClientInput>
  }

  export type AdresseUpdateWithWhereUniqueWithoutClientInput = {
    where: AdresseWhereUniqueInput
    data: XOR<AdresseUpdateWithoutClientInput, AdresseUncheckedUpdateWithoutClientInput>
  }

  export type AdresseUpdateManyWithWhereWithoutClientInput = {
    where: AdresseScalarWhereInput
    data: XOR<AdresseUpdateManyMutationInput, AdresseUncheckedUpdateManyWithoutClientInput>
  }

  export type ContactUpsertWithWhereUniqueWithoutClientInput = {
    where: ContactWhereUniqueInput
    update: XOR<ContactUpdateWithoutClientInput, ContactUncheckedUpdateWithoutClientInput>
    create: XOR<ContactCreateWithoutClientInput, ContactUncheckedCreateWithoutClientInput>
  }

  export type ContactUpdateWithWhereUniqueWithoutClientInput = {
    where: ContactWhereUniqueInput
    data: XOR<ContactUpdateWithoutClientInput, ContactUncheckedUpdateWithoutClientInput>
  }

  export type ContactUpdateManyWithWhereWithoutClientInput = {
    where: ContactScalarWhereInput
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyWithoutClientInput>
  }

  export type VenteUpsertWithWhereUniqueWithoutClientInput = {
    where: VenteWhereUniqueInput
    update: XOR<VenteUpdateWithoutClientInput, VenteUncheckedUpdateWithoutClientInput>
    create: XOR<VenteCreateWithoutClientInput, VenteUncheckedCreateWithoutClientInput>
  }

  export type VenteUpdateWithWhereUniqueWithoutClientInput = {
    where: VenteWhereUniqueInput
    data: XOR<VenteUpdateWithoutClientInput, VenteUncheckedUpdateWithoutClientInput>
  }

  export type VenteUpdateManyWithWhereWithoutClientInput = {
    where: VenteScalarWhereInput
    data: XOR<VenteUpdateManyMutationInput, VenteUncheckedUpdateManyWithoutClientInput>
  }

  export type AchatUpsertWithWhereUniqueWithoutClientInput = {
    where: AchatWhereUniqueInput
    update: XOR<AchatUpdateWithoutClientInput, AchatUncheckedUpdateWithoutClientInput>
    create: XOR<AchatCreateWithoutClientInput, AchatUncheckedCreateWithoutClientInput>
  }

  export type AchatUpdateWithWhereUniqueWithoutClientInput = {
    where: AchatWhereUniqueInput
    data: XOR<AchatUpdateWithoutClientInput, AchatUncheckedUpdateWithoutClientInput>
  }

  export type AchatUpdateManyWithWhereWithoutClientInput = {
    where: AchatScalarWhereInput
    data: XOR<AchatUpdateManyMutationInput, AchatUncheckedUpdateManyWithoutClientInput>
  }

  export type PanierUpsertWithWhereUniqueWithoutClientInput = {
    where: PanierWhereUniqueInput
    update: XOR<PanierUpdateWithoutClientInput, PanierUncheckedUpdateWithoutClientInput>
    create: XOR<PanierCreateWithoutClientInput, PanierUncheckedCreateWithoutClientInput>
  }

  export type PanierUpdateWithWhereUniqueWithoutClientInput = {
    where: PanierWhereUniqueInput
    data: XOR<PanierUpdateWithoutClientInput, PanierUncheckedUpdateWithoutClientInput>
  }

  export type PanierUpdateManyWithWhereWithoutClientInput = {
    where: PanierScalarWhereInput
    data: XOR<PanierUpdateManyMutationInput, PanierUncheckedUpdateManyWithoutClientInput>
  }

  export type ReservationUpsertWithWhereUniqueWithoutClientInput = {
    where: ReservationWhereUniqueInput
    update: XOR<ReservationUpdateWithoutClientInput, ReservationUncheckedUpdateWithoutClientInput>
    create: XOR<ReservationCreateWithoutClientInput, ReservationUncheckedCreateWithoutClientInput>
  }

  export type ReservationUpdateWithWhereUniqueWithoutClientInput = {
    where: ReservationWhereUniqueInput
    data: XOR<ReservationUpdateWithoutClientInput, ReservationUncheckedUpdateWithoutClientInput>
  }

  export type ReservationUpdateManyWithWhereWithoutClientInput = {
    where: ReservationScalarWhereInput
    data: XOR<ReservationUpdateManyMutationInput, ReservationUncheckedUpdateManyWithoutClientInput>
  }

  export type ReservationScalarWhereInput = {
    AND?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
    OR?: ReservationScalarWhereInput[]
    NOT?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
    id?: IntFilter<"Reservation"> | number
    dateLivraisonSouhaitee?: DateTimeFilter<"Reservation"> | Date | string
    adresseLivraison?: StringNullableFilter<"Reservation"> | string | null
    statut?: EnumStatutReservationFilter<"Reservation"> | $Enums.StatutReservation
    notes?: StringNullableFilter<"Reservation"> | string | null
    typeClient?: EnumTypeClientFilter<"Reservation"> | $Enums.TypeClient
    clientId?: IntNullableFilter<"Reservation"> | number | null
    panierId?: IntFilter<"Reservation"> | number
    nom?: StringNullableFilter<"Reservation"> | string | null
    tel?: StringNullableFilter<"Reservation"> | string | null
    adresseId?: IntNullableFilter<"Reservation"> | number | null
    contactId?: IntNullableFilter<"Reservation"> | number | null
    enregistrerParId?: IntNullableFilter<"Reservation"> | number | null
    fournisseurId?: IntNullableFilter<"Reservation"> | number | null
    createdAt?: DateTimeFilter<"Reservation"> | Date | string
    updatedAt?: DateTimeFilter<"Reservation"> | Date | string
  }

  export type CommandeUpsertWithWhereUniqueWithoutClientInput = {
    where: CommandeWhereUniqueInput
    update: XOR<CommandeUpdateWithoutClientInput, CommandeUncheckedUpdateWithoutClientInput>
    create: XOR<CommandeCreateWithoutClientInput, CommandeUncheckedCreateWithoutClientInput>
  }

  export type CommandeUpdateWithWhereUniqueWithoutClientInput = {
    where: CommandeWhereUniqueInput
    data: XOR<CommandeUpdateWithoutClientInput, CommandeUncheckedUpdateWithoutClientInput>
  }

  export type CommandeUpdateManyWithWhereWithoutClientInput = {
    where: CommandeScalarWhereInput
    data: XOR<CommandeUpdateManyMutationInput, CommandeUncheckedUpdateManyWithoutClientInput>
  }

  export type CommandeScalarWhereInput = {
    AND?: CommandeScalarWhereInput | CommandeScalarWhereInput[]
    OR?: CommandeScalarWhereInput[]
    NOT?: CommandeScalarWhereInput | CommandeScalarWhereInput[]
    id?: IntFilter<"Commande"> | number
    panierId?: IntFilter<"Commande"> | number
    clientId?: IntNullableFilter<"Commande"> | number | null
    nom?: StringNullableFilter<"Commande"> | string | null
    tel?: StringNullableFilter<"Commande"> | string | null
    type_client?: EnumTypeClientFilter<"Commande"> | $Enums.TypeClient
    adresseId?: IntNullableFilter<"Commande"> | number | null
    contactId?: IntNullableFilter<"Commande"> | number | null
    fournisseurId?: IntNullableFilter<"Commande"> | number | null
    commandeId?: IntNullableFilter<"Commande"> | number | null
    notes?: StringNullableFilter<"Commande"> | string | null
    dateLivraisonEffective?: DateTimeNullableFilter<"Commande"> | Date | string | null
    adresseLivraison?: StringNullableFilter<"Commande"> | string | null
    enregistrerParId?: IntNullableFilter<"Commande"> | number | null
    statut?: EnumStatutCommandeFilter<"Commande"> | $Enums.StatutCommande
    createdAt?: DateTimeFilter<"Commande"> | Date | string
    updatedAt?: DateTimeFilter<"Commande"> | Date | string
  }

  export type AgentCreateWithoutAdressesInput = {
    email: string
    nom: string
    postnom?: string | null
    nom_complet?: string | null
    sexe?: $Enums.Sexe | null
    role?: $Enums.Role
    poste?: $Enums.Poste | null
    picture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contacts?: ContactCreateNestedManyWithoutAgentInput
    produits?: ProduitCreateNestedManyWithoutAgentInput
    ventes?: VenteCreateNestedManyWithoutAgentInput
    achats?: AchatCreateNestedManyWithoutAgentInput
    teneurs?: TeneurCreateNestedManyWithoutAgentsInput
    devises?: DeviseCreateNestedManyWithoutAgentInput
    paniers?: PanierCreateNestedManyWithoutAgentInput
    caisses?: CaisseCreateNestedManyWithoutAgentInput
    mouvementCaisses?: MouvementCaisseCreateNestedManyWithoutAgentInput
    clotureCaisses?: ClotureCaisseCreateNestedManyWithoutAgentInput
    Fournisseur?: FournisseurCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateWithoutAdressesInput = {
    id?: number
    email: string
    nom: string
    postnom?: string | null
    nom_complet?: string | null
    sexe?: $Enums.Sexe | null
    role?: $Enums.Role
    poste?: $Enums.Poste | null
    picture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contacts?: ContactUncheckedCreateNestedManyWithoutAgentInput
    produits?: ProduitUncheckedCreateNestedManyWithoutAgentInput
    ventes?: VenteUncheckedCreateNestedManyWithoutAgentInput
    achats?: AchatUncheckedCreateNestedManyWithoutAgentInput
    teneurs?: TeneurUncheckedCreateNestedManyWithoutAgentsInput
    devises?: DeviseUncheckedCreateNestedManyWithoutAgentInput
    paniers?: PanierUncheckedCreateNestedManyWithoutAgentInput
    caisses?: CaisseUncheckedCreateNestedManyWithoutAgentInput
    mouvementCaisses?: MouvementCaisseUncheckedCreateNestedManyWithoutAgentInput
    clotureCaisses?: ClotureCaisseUncheckedCreateNestedManyWithoutAgentInput
    Fournisseur?: FournisseurUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentCreateOrConnectWithoutAdressesInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutAdressesInput, AgentUncheckedCreateWithoutAdressesInput>
  }

  export type EntrepriseCreateWithoutAdresseInput = {
    nom: string
    email: string
    encronyme: string
    codePostale: string
    site?: string | null
    description?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clotureCaisses?: ClotureCaisseCreateNestedManyWithoutEntrepriseInput
    Contact?: ContactCreateNestedManyWithoutEntrepriseInput
  }

  export type EntrepriseUncheckedCreateWithoutAdresseInput = {
    id?: number
    nom: string
    email: string
    encronyme: string
    codePostale: string
    site?: string | null
    description?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clotureCaisses?: ClotureCaisseUncheckedCreateNestedManyWithoutEntrepriseInput
    Contact?: ContactUncheckedCreateNestedManyWithoutEntrepriseInput
  }

  export type EntrepriseCreateOrConnectWithoutAdresseInput = {
    where: EntrepriseWhereUniqueInput
    create: XOR<EntrepriseCreateWithoutAdresseInput, EntrepriseUncheckedCreateWithoutAdresseInput>
  }

  export type FournisseurCreateWithoutAdressesInput = {
    nom: string
    email: string
    codePostale?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agent: AgentCreateNestedOneWithoutFournisseurInput
    ventes?: VenteCreateNestedManyWithoutFournisseurInput
    achats?: AchatCreateNestedManyWithoutFournisseurInput
    contacts?: ContactCreateNestedManyWithoutFournisseurInput
    reservations?: ReservationCreateNestedManyWithoutFournisseurInput
    commandes?: CommandeCreateNestedManyWithoutFournisseurInput
  }

  export type FournisseurUncheckedCreateWithoutAdressesInput = {
    id?: number
    nom: string
    email: string
    codePostale?: string | null
    agentId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    ventes?: VenteUncheckedCreateNestedManyWithoutFournisseurInput
    achats?: AchatUncheckedCreateNestedManyWithoutFournisseurInput
    contacts?: ContactUncheckedCreateNestedManyWithoutFournisseurInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutFournisseurInput
    commandes?: CommandeUncheckedCreateNestedManyWithoutFournisseurInput
  }

  export type FournisseurCreateOrConnectWithoutAdressesInput = {
    where: FournisseurWhereUniqueInput
    create: XOR<FournisseurCreateWithoutAdressesInput, FournisseurUncheckedCreateWithoutAdressesInput>
  }

  export type ClientCreateWithoutAdressesInput = {
    email: string
    nom: string
    postnom?: string | null
    nom_complet?: string | null
    sexe?: $Enums.Sexe | null
    picture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contacts?: ContactCreateNestedManyWithoutClientInput
    ventes?: VenteCreateNestedManyWithoutClientInput
    achats?: AchatCreateNestedManyWithoutClientInput
    paniers?: PanierCreateNestedManyWithoutClientInput
    reservations?: ReservationCreateNestedManyWithoutClientInput
    commandes?: CommandeCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutAdressesInput = {
    id?: number
    email: string
    nom: string
    postnom?: string | null
    nom_complet?: string | null
    sexe?: $Enums.Sexe | null
    picture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contacts?: ContactUncheckedCreateNestedManyWithoutClientInput
    ventes?: VenteUncheckedCreateNestedManyWithoutClientInput
    achats?: AchatUncheckedCreateNestedManyWithoutClientInput
    paniers?: PanierUncheckedCreateNestedManyWithoutClientInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutClientInput
    commandes?: CommandeUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutAdressesInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutAdressesInput, ClientUncheckedCreateWithoutAdressesInput>
  }

  export type ReservationCreateWithoutAdresseInput = {
    dateLivraisonSouhaitee: Date | string
    adresseLivraison?: string | null
    statut?: $Enums.StatutReservation
    notes?: string | null
    typeClient?: $Enums.TypeClient
    nom?: string | null
    tel?: string | null
    enregistrerParId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    panier: PanierCreateNestedOneWithoutReservationsInput
    fournisseur?: FournisseurCreateNestedOneWithoutReservationsInput
    contact?: ContactCreateNestedOneWithoutReservationsInput
    Client?: ClientCreateNestedOneWithoutReservationsInput
  }

  export type ReservationUncheckedCreateWithoutAdresseInput = {
    id?: number
    dateLivraisonSouhaitee: Date | string
    adresseLivraison?: string | null
    statut?: $Enums.StatutReservation
    notes?: string | null
    typeClient?: $Enums.TypeClient
    clientId?: number | null
    panierId: number
    nom?: string | null
    tel?: string | null
    contactId?: number | null
    enregistrerParId?: number | null
    fournisseurId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReservationCreateOrConnectWithoutAdresseInput = {
    where: ReservationWhereUniqueInput
    create: XOR<ReservationCreateWithoutAdresseInput, ReservationUncheckedCreateWithoutAdresseInput>
  }

  export type ReservationCreateManyAdresseInputEnvelope = {
    data: ReservationCreateManyAdresseInput | ReservationCreateManyAdresseInput[]
    skipDuplicates?: boolean
  }

  export type CommandeCreateWithoutAdresseInput = {
    nom?: string | null
    tel?: string | null
    type_client?: $Enums.TypeClient
    commandeId?: number | null
    notes?: string | null
    dateLivraisonEffective?: Date | string | null
    adresseLivraison?: string | null
    enregistrerParId?: number | null
    statut?: $Enums.StatutCommande
    createdAt?: Date | string
    updatedAt?: Date | string
    Paiement?: PaiementCreateNestedManyWithoutCommandeInput
    panier: PanierCreateNestedOneWithoutCommandesInput
    fournisseur?: FournisseurCreateNestedOneWithoutCommandesInput
    contact?: ContactCreateNestedOneWithoutCommandesInput
    Client?: ClientCreateNestedOneWithoutCommandesInput
  }

  export type CommandeUncheckedCreateWithoutAdresseInput = {
    id?: number
    panierId: number
    clientId?: number | null
    nom?: string | null
    tel?: string | null
    type_client?: $Enums.TypeClient
    contactId?: number | null
    fournisseurId?: number | null
    commandeId?: number | null
    notes?: string | null
    dateLivraisonEffective?: Date | string | null
    adresseLivraison?: string | null
    enregistrerParId?: number | null
    statut?: $Enums.StatutCommande
    createdAt?: Date | string
    updatedAt?: Date | string
    Paiement?: PaiementUncheckedCreateNestedManyWithoutCommandeInput
  }

  export type CommandeCreateOrConnectWithoutAdresseInput = {
    where: CommandeWhereUniqueInput
    create: XOR<CommandeCreateWithoutAdresseInput, CommandeUncheckedCreateWithoutAdresseInput>
  }

  export type CommandeCreateManyAdresseInputEnvelope = {
    data: CommandeCreateManyAdresseInput | CommandeCreateManyAdresseInput[]
    skipDuplicates?: boolean
  }

  export type AgentUpsertWithoutAdressesInput = {
    update: XOR<AgentUpdateWithoutAdressesInput, AgentUncheckedUpdateWithoutAdressesInput>
    create: XOR<AgentCreateWithoutAdressesInput, AgentUncheckedCreateWithoutAdressesInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutAdressesInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutAdressesInput, AgentUncheckedUpdateWithoutAdressesInput>
  }

  export type AgentUpdateWithoutAdressesInput = {
    email?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    postnom?: NullableStringFieldUpdateOperationsInput | string | null
    nom_complet?: NullableStringFieldUpdateOperationsInput | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    poste?: NullableEnumPosteFieldUpdateOperationsInput | $Enums.Poste | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactUpdateManyWithoutAgentNestedInput
    produits?: ProduitUpdateManyWithoutAgentNestedInput
    ventes?: VenteUpdateManyWithoutAgentNestedInput
    achats?: AchatUpdateManyWithoutAgentNestedInput
    teneurs?: TeneurUpdateManyWithoutAgentsNestedInput
    devises?: DeviseUpdateManyWithoutAgentNestedInput
    paniers?: PanierUpdateManyWithoutAgentNestedInput
    caisses?: CaisseUpdateManyWithoutAgentNestedInput
    mouvementCaisses?: MouvementCaisseUpdateManyWithoutAgentNestedInput
    clotureCaisses?: ClotureCaisseUpdateManyWithoutAgentNestedInput
    Fournisseur?: FournisseurUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateWithoutAdressesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    postnom?: NullableStringFieldUpdateOperationsInput | string | null
    nom_complet?: NullableStringFieldUpdateOperationsInput | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    poste?: NullableEnumPosteFieldUpdateOperationsInput | $Enums.Poste | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactUncheckedUpdateManyWithoutAgentNestedInput
    produits?: ProduitUncheckedUpdateManyWithoutAgentNestedInput
    ventes?: VenteUncheckedUpdateManyWithoutAgentNestedInput
    achats?: AchatUncheckedUpdateManyWithoutAgentNestedInput
    teneurs?: TeneurUncheckedUpdateManyWithoutAgentsNestedInput
    devises?: DeviseUncheckedUpdateManyWithoutAgentNestedInput
    paniers?: PanierUncheckedUpdateManyWithoutAgentNestedInput
    caisses?: CaisseUncheckedUpdateManyWithoutAgentNestedInput
    mouvementCaisses?: MouvementCaisseUncheckedUpdateManyWithoutAgentNestedInput
    clotureCaisses?: ClotureCaisseUncheckedUpdateManyWithoutAgentNestedInput
    Fournisseur?: FournisseurUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type EntrepriseUpsertWithoutAdresseInput = {
    update: XOR<EntrepriseUpdateWithoutAdresseInput, EntrepriseUncheckedUpdateWithoutAdresseInput>
    create: XOR<EntrepriseCreateWithoutAdresseInput, EntrepriseUncheckedCreateWithoutAdresseInput>
    where?: EntrepriseWhereInput
  }

  export type EntrepriseUpdateToOneWithWhereWithoutAdresseInput = {
    where?: EntrepriseWhereInput
    data: XOR<EntrepriseUpdateWithoutAdresseInput, EntrepriseUncheckedUpdateWithoutAdresseInput>
  }

  export type EntrepriseUpdateWithoutAdresseInput = {
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    encronyme?: StringFieldUpdateOperationsInput | string
    codePostale?: StringFieldUpdateOperationsInput | string
    site?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clotureCaisses?: ClotureCaisseUpdateManyWithoutEntrepriseNestedInput
    Contact?: ContactUpdateManyWithoutEntrepriseNestedInput
  }

  export type EntrepriseUncheckedUpdateWithoutAdresseInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    encronyme?: StringFieldUpdateOperationsInput | string
    codePostale?: StringFieldUpdateOperationsInput | string
    site?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clotureCaisses?: ClotureCaisseUncheckedUpdateManyWithoutEntrepriseNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutEntrepriseNestedInput
  }

  export type FournisseurUpsertWithoutAdressesInput = {
    update: XOR<FournisseurUpdateWithoutAdressesInput, FournisseurUncheckedUpdateWithoutAdressesInput>
    create: XOR<FournisseurCreateWithoutAdressesInput, FournisseurUncheckedCreateWithoutAdressesInput>
    where?: FournisseurWhereInput
  }

  export type FournisseurUpdateToOneWithWhereWithoutAdressesInput = {
    where?: FournisseurWhereInput
    data: XOR<FournisseurUpdateWithoutAdressesInput, FournisseurUncheckedUpdateWithoutAdressesInput>
  }

  export type FournisseurUpdateWithoutAdressesInput = {
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    codePostale?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUpdateOneRequiredWithoutFournisseurNestedInput
    ventes?: VenteUpdateManyWithoutFournisseurNestedInput
    achats?: AchatUpdateManyWithoutFournisseurNestedInput
    contacts?: ContactUpdateManyWithoutFournisseurNestedInput
    reservations?: ReservationUpdateManyWithoutFournisseurNestedInput
    commandes?: CommandeUpdateManyWithoutFournisseurNestedInput
  }

  export type FournisseurUncheckedUpdateWithoutAdressesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    codePostale?: NullableStringFieldUpdateOperationsInput | string | null
    agentId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ventes?: VenteUncheckedUpdateManyWithoutFournisseurNestedInput
    achats?: AchatUncheckedUpdateManyWithoutFournisseurNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutFournisseurNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutFournisseurNestedInput
    commandes?: CommandeUncheckedUpdateManyWithoutFournisseurNestedInput
  }

  export type ClientUpsertWithoutAdressesInput = {
    update: XOR<ClientUpdateWithoutAdressesInput, ClientUncheckedUpdateWithoutAdressesInput>
    create: XOR<ClientCreateWithoutAdressesInput, ClientUncheckedCreateWithoutAdressesInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutAdressesInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutAdressesInput, ClientUncheckedUpdateWithoutAdressesInput>
  }

  export type ClientUpdateWithoutAdressesInput = {
    email?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    postnom?: NullableStringFieldUpdateOperationsInput | string | null
    nom_complet?: NullableStringFieldUpdateOperationsInput | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactUpdateManyWithoutClientNestedInput
    ventes?: VenteUpdateManyWithoutClientNestedInput
    achats?: AchatUpdateManyWithoutClientNestedInput
    paniers?: PanierUpdateManyWithoutClientNestedInput
    reservations?: ReservationUpdateManyWithoutClientNestedInput
    commandes?: CommandeUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutAdressesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    postnom?: NullableStringFieldUpdateOperationsInput | string | null
    nom_complet?: NullableStringFieldUpdateOperationsInput | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactUncheckedUpdateManyWithoutClientNestedInput
    ventes?: VenteUncheckedUpdateManyWithoutClientNestedInput
    achats?: AchatUncheckedUpdateManyWithoutClientNestedInput
    paniers?: PanierUncheckedUpdateManyWithoutClientNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutClientNestedInput
    commandes?: CommandeUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ReservationUpsertWithWhereUniqueWithoutAdresseInput = {
    where: ReservationWhereUniqueInput
    update: XOR<ReservationUpdateWithoutAdresseInput, ReservationUncheckedUpdateWithoutAdresseInput>
    create: XOR<ReservationCreateWithoutAdresseInput, ReservationUncheckedCreateWithoutAdresseInput>
  }

  export type ReservationUpdateWithWhereUniqueWithoutAdresseInput = {
    where: ReservationWhereUniqueInput
    data: XOR<ReservationUpdateWithoutAdresseInput, ReservationUncheckedUpdateWithoutAdresseInput>
  }

  export type ReservationUpdateManyWithWhereWithoutAdresseInput = {
    where: ReservationScalarWhereInput
    data: XOR<ReservationUpdateManyMutationInput, ReservationUncheckedUpdateManyWithoutAdresseInput>
  }

  export type CommandeUpsertWithWhereUniqueWithoutAdresseInput = {
    where: CommandeWhereUniqueInput
    update: XOR<CommandeUpdateWithoutAdresseInput, CommandeUncheckedUpdateWithoutAdresseInput>
    create: XOR<CommandeCreateWithoutAdresseInput, CommandeUncheckedCreateWithoutAdresseInput>
  }

  export type CommandeUpdateWithWhereUniqueWithoutAdresseInput = {
    where: CommandeWhereUniqueInput
    data: XOR<CommandeUpdateWithoutAdresseInput, CommandeUncheckedUpdateWithoutAdresseInput>
  }

  export type CommandeUpdateManyWithWhereWithoutAdresseInput = {
    where: CommandeScalarWhereInput
    data: XOR<CommandeUpdateManyMutationInput, CommandeUncheckedUpdateManyWithoutAdresseInput>
  }

  export type EntrepriseCreateWithoutContactInput = {
    nom: string
    email: string
    encronyme: string
    codePostale: string
    site?: string | null
    description?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clotureCaisses?: ClotureCaisseCreateNestedManyWithoutEntrepriseInput
    Adresse?: AdresseCreateNestedManyWithoutEntrepriseInput
  }

  export type EntrepriseUncheckedCreateWithoutContactInput = {
    id?: number
    nom: string
    email: string
    encronyme: string
    codePostale: string
    site?: string | null
    description?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clotureCaisses?: ClotureCaisseUncheckedCreateNestedManyWithoutEntrepriseInput
    Adresse?: AdresseUncheckedCreateNestedManyWithoutEntrepriseInput
  }

  export type EntrepriseCreateOrConnectWithoutContactInput = {
    where: EntrepriseWhereUniqueInput
    create: XOR<EntrepriseCreateWithoutContactInput, EntrepriseUncheckedCreateWithoutContactInput>
  }

  export type ClientCreateWithoutContactsInput = {
    email: string
    nom: string
    postnom?: string | null
    nom_complet?: string | null
    sexe?: $Enums.Sexe | null
    picture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    adresses?: AdresseCreateNestedManyWithoutClientInput
    ventes?: VenteCreateNestedManyWithoutClientInput
    achats?: AchatCreateNestedManyWithoutClientInput
    paniers?: PanierCreateNestedManyWithoutClientInput
    reservations?: ReservationCreateNestedManyWithoutClientInput
    commandes?: CommandeCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutContactsInput = {
    id?: number
    email: string
    nom: string
    postnom?: string | null
    nom_complet?: string | null
    sexe?: $Enums.Sexe | null
    picture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    adresses?: AdresseUncheckedCreateNestedManyWithoutClientInput
    ventes?: VenteUncheckedCreateNestedManyWithoutClientInput
    achats?: AchatUncheckedCreateNestedManyWithoutClientInput
    paniers?: PanierUncheckedCreateNestedManyWithoutClientInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutClientInput
    commandes?: CommandeUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutContactsInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutContactsInput, ClientUncheckedCreateWithoutContactsInput>
  }

  export type AgentCreateWithoutContactsInput = {
    email: string
    nom: string
    postnom?: string | null
    nom_complet?: string | null
    sexe?: $Enums.Sexe | null
    role?: $Enums.Role
    poste?: $Enums.Poste | null
    picture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    adresses?: AdresseCreateNestedManyWithoutAgentInput
    produits?: ProduitCreateNestedManyWithoutAgentInput
    ventes?: VenteCreateNestedManyWithoutAgentInput
    achats?: AchatCreateNestedManyWithoutAgentInput
    teneurs?: TeneurCreateNestedManyWithoutAgentsInput
    devises?: DeviseCreateNestedManyWithoutAgentInput
    paniers?: PanierCreateNestedManyWithoutAgentInput
    caisses?: CaisseCreateNestedManyWithoutAgentInput
    mouvementCaisses?: MouvementCaisseCreateNestedManyWithoutAgentInput
    clotureCaisses?: ClotureCaisseCreateNestedManyWithoutAgentInput
    Fournisseur?: FournisseurCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateWithoutContactsInput = {
    id?: number
    email: string
    nom: string
    postnom?: string | null
    nom_complet?: string | null
    sexe?: $Enums.Sexe | null
    role?: $Enums.Role
    poste?: $Enums.Poste | null
    picture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    adresses?: AdresseUncheckedCreateNestedManyWithoutAgentInput
    produits?: ProduitUncheckedCreateNestedManyWithoutAgentInput
    ventes?: VenteUncheckedCreateNestedManyWithoutAgentInput
    achats?: AchatUncheckedCreateNestedManyWithoutAgentInput
    teneurs?: TeneurUncheckedCreateNestedManyWithoutAgentsInput
    devises?: DeviseUncheckedCreateNestedManyWithoutAgentInput
    paniers?: PanierUncheckedCreateNestedManyWithoutAgentInput
    caisses?: CaisseUncheckedCreateNestedManyWithoutAgentInput
    mouvementCaisses?: MouvementCaisseUncheckedCreateNestedManyWithoutAgentInput
    clotureCaisses?: ClotureCaisseUncheckedCreateNestedManyWithoutAgentInput
    Fournisseur?: FournisseurUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentCreateOrConnectWithoutContactsInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutContactsInput, AgentUncheckedCreateWithoutContactsInput>
  }

  export type FournisseurCreateWithoutContactsInput = {
    nom: string
    email: string
    codePostale?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agent: AgentCreateNestedOneWithoutFournisseurInput
    ventes?: VenteCreateNestedManyWithoutFournisseurInput
    achats?: AchatCreateNestedManyWithoutFournisseurInput
    adresses?: AdresseCreateNestedManyWithoutFournisseurInput
    reservations?: ReservationCreateNestedManyWithoutFournisseurInput
    commandes?: CommandeCreateNestedManyWithoutFournisseurInput
  }

  export type FournisseurUncheckedCreateWithoutContactsInput = {
    id?: number
    nom: string
    email: string
    codePostale?: string | null
    agentId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    ventes?: VenteUncheckedCreateNestedManyWithoutFournisseurInput
    achats?: AchatUncheckedCreateNestedManyWithoutFournisseurInput
    adresses?: AdresseUncheckedCreateNestedManyWithoutFournisseurInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutFournisseurInput
    commandes?: CommandeUncheckedCreateNestedManyWithoutFournisseurInput
  }

  export type FournisseurCreateOrConnectWithoutContactsInput = {
    where: FournisseurWhereUniqueInput
    create: XOR<FournisseurCreateWithoutContactsInput, FournisseurUncheckedCreateWithoutContactsInput>
  }

  export type ReservationCreateWithoutContactInput = {
    dateLivraisonSouhaitee: Date | string
    adresseLivraison?: string | null
    statut?: $Enums.StatutReservation
    notes?: string | null
    typeClient?: $Enums.TypeClient
    nom?: string | null
    tel?: string | null
    enregistrerParId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    panier: PanierCreateNestedOneWithoutReservationsInput
    fournisseur?: FournisseurCreateNestedOneWithoutReservationsInput
    adresse?: AdresseCreateNestedOneWithoutReservationsInput
    Client?: ClientCreateNestedOneWithoutReservationsInput
  }

  export type ReservationUncheckedCreateWithoutContactInput = {
    id?: number
    dateLivraisonSouhaitee: Date | string
    adresseLivraison?: string | null
    statut?: $Enums.StatutReservation
    notes?: string | null
    typeClient?: $Enums.TypeClient
    clientId?: number | null
    panierId: number
    nom?: string | null
    tel?: string | null
    adresseId?: number | null
    enregistrerParId?: number | null
    fournisseurId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReservationCreateOrConnectWithoutContactInput = {
    where: ReservationWhereUniqueInput
    create: XOR<ReservationCreateWithoutContactInput, ReservationUncheckedCreateWithoutContactInput>
  }

  export type ReservationCreateManyContactInputEnvelope = {
    data: ReservationCreateManyContactInput | ReservationCreateManyContactInput[]
    skipDuplicates?: boolean
  }

  export type CommandeCreateWithoutContactInput = {
    nom?: string | null
    tel?: string | null
    type_client?: $Enums.TypeClient
    commandeId?: number | null
    notes?: string | null
    dateLivraisonEffective?: Date | string | null
    adresseLivraison?: string | null
    enregistrerParId?: number | null
    statut?: $Enums.StatutCommande
    createdAt?: Date | string
    updatedAt?: Date | string
    Paiement?: PaiementCreateNestedManyWithoutCommandeInput
    panier: PanierCreateNestedOneWithoutCommandesInput
    fournisseur?: FournisseurCreateNestedOneWithoutCommandesInput
    adresse?: AdresseCreateNestedOneWithoutCommandesInput
    Client?: ClientCreateNestedOneWithoutCommandesInput
  }

  export type CommandeUncheckedCreateWithoutContactInput = {
    id?: number
    panierId: number
    clientId?: number | null
    nom?: string | null
    tel?: string | null
    type_client?: $Enums.TypeClient
    adresseId?: number | null
    fournisseurId?: number | null
    commandeId?: number | null
    notes?: string | null
    dateLivraisonEffective?: Date | string | null
    adresseLivraison?: string | null
    enregistrerParId?: number | null
    statut?: $Enums.StatutCommande
    createdAt?: Date | string
    updatedAt?: Date | string
    Paiement?: PaiementUncheckedCreateNestedManyWithoutCommandeInput
  }

  export type CommandeCreateOrConnectWithoutContactInput = {
    where: CommandeWhereUniqueInput
    create: XOR<CommandeCreateWithoutContactInput, CommandeUncheckedCreateWithoutContactInput>
  }

  export type CommandeCreateManyContactInputEnvelope = {
    data: CommandeCreateManyContactInput | CommandeCreateManyContactInput[]
    skipDuplicates?: boolean
  }

  export type EntrepriseUpsertWithoutContactInput = {
    update: XOR<EntrepriseUpdateWithoutContactInput, EntrepriseUncheckedUpdateWithoutContactInput>
    create: XOR<EntrepriseCreateWithoutContactInput, EntrepriseUncheckedCreateWithoutContactInput>
    where?: EntrepriseWhereInput
  }

  export type EntrepriseUpdateToOneWithWhereWithoutContactInput = {
    where?: EntrepriseWhereInput
    data: XOR<EntrepriseUpdateWithoutContactInput, EntrepriseUncheckedUpdateWithoutContactInput>
  }

  export type EntrepriseUpdateWithoutContactInput = {
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    encronyme?: StringFieldUpdateOperationsInput | string
    codePostale?: StringFieldUpdateOperationsInput | string
    site?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clotureCaisses?: ClotureCaisseUpdateManyWithoutEntrepriseNestedInput
    Adresse?: AdresseUpdateManyWithoutEntrepriseNestedInput
  }

  export type EntrepriseUncheckedUpdateWithoutContactInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    encronyme?: StringFieldUpdateOperationsInput | string
    codePostale?: StringFieldUpdateOperationsInput | string
    site?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clotureCaisses?: ClotureCaisseUncheckedUpdateManyWithoutEntrepriseNestedInput
    Adresse?: AdresseUncheckedUpdateManyWithoutEntrepriseNestedInput
  }

  export type ClientUpsertWithoutContactsInput = {
    update: XOR<ClientUpdateWithoutContactsInput, ClientUncheckedUpdateWithoutContactsInput>
    create: XOR<ClientCreateWithoutContactsInput, ClientUncheckedCreateWithoutContactsInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutContactsInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutContactsInput, ClientUncheckedUpdateWithoutContactsInput>
  }

  export type ClientUpdateWithoutContactsInput = {
    email?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    postnom?: NullableStringFieldUpdateOperationsInput | string | null
    nom_complet?: NullableStringFieldUpdateOperationsInput | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adresses?: AdresseUpdateManyWithoutClientNestedInput
    ventes?: VenteUpdateManyWithoutClientNestedInput
    achats?: AchatUpdateManyWithoutClientNestedInput
    paniers?: PanierUpdateManyWithoutClientNestedInput
    reservations?: ReservationUpdateManyWithoutClientNestedInput
    commandes?: CommandeUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutContactsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    postnom?: NullableStringFieldUpdateOperationsInput | string | null
    nom_complet?: NullableStringFieldUpdateOperationsInput | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adresses?: AdresseUncheckedUpdateManyWithoutClientNestedInput
    ventes?: VenteUncheckedUpdateManyWithoutClientNestedInput
    achats?: AchatUncheckedUpdateManyWithoutClientNestedInput
    paniers?: PanierUncheckedUpdateManyWithoutClientNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutClientNestedInput
    commandes?: CommandeUncheckedUpdateManyWithoutClientNestedInput
  }

  export type AgentUpsertWithoutContactsInput = {
    update: XOR<AgentUpdateWithoutContactsInput, AgentUncheckedUpdateWithoutContactsInput>
    create: XOR<AgentCreateWithoutContactsInput, AgentUncheckedCreateWithoutContactsInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutContactsInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutContactsInput, AgentUncheckedUpdateWithoutContactsInput>
  }

  export type AgentUpdateWithoutContactsInput = {
    email?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    postnom?: NullableStringFieldUpdateOperationsInput | string | null
    nom_complet?: NullableStringFieldUpdateOperationsInput | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    poste?: NullableEnumPosteFieldUpdateOperationsInput | $Enums.Poste | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adresses?: AdresseUpdateManyWithoutAgentNestedInput
    produits?: ProduitUpdateManyWithoutAgentNestedInput
    ventes?: VenteUpdateManyWithoutAgentNestedInput
    achats?: AchatUpdateManyWithoutAgentNestedInput
    teneurs?: TeneurUpdateManyWithoutAgentsNestedInput
    devises?: DeviseUpdateManyWithoutAgentNestedInput
    paniers?: PanierUpdateManyWithoutAgentNestedInput
    caisses?: CaisseUpdateManyWithoutAgentNestedInput
    mouvementCaisses?: MouvementCaisseUpdateManyWithoutAgentNestedInput
    clotureCaisses?: ClotureCaisseUpdateManyWithoutAgentNestedInput
    Fournisseur?: FournisseurUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateWithoutContactsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    postnom?: NullableStringFieldUpdateOperationsInput | string | null
    nom_complet?: NullableStringFieldUpdateOperationsInput | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    poste?: NullableEnumPosteFieldUpdateOperationsInput | $Enums.Poste | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adresses?: AdresseUncheckedUpdateManyWithoutAgentNestedInput
    produits?: ProduitUncheckedUpdateManyWithoutAgentNestedInput
    ventes?: VenteUncheckedUpdateManyWithoutAgentNestedInput
    achats?: AchatUncheckedUpdateManyWithoutAgentNestedInput
    teneurs?: TeneurUncheckedUpdateManyWithoutAgentsNestedInput
    devises?: DeviseUncheckedUpdateManyWithoutAgentNestedInput
    paniers?: PanierUncheckedUpdateManyWithoutAgentNestedInput
    caisses?: CaisseUncheckedUpdateManyWithoutAgentNestedInput
    mouvementCaisses?: MouvementCaisseUncheckedUpdateManyWithoutAgentNestedInput
    clotureCaisses?: ClotureCaisseUncheckedUpdateManyWithoutAgentNestedInput
    Fournisseur?: FournisseurUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type FournisseurUpsertWithoutContactsInput = {
    update: XOR<FournisseurUpdateWithoutContactsInput, FournisseurUncheckedUpdateWithoutContactsInput>
    create: XOR<FournisseurCreateWithoutContactsInput, FournisseurUncheckedCreateWithoutContactsInput>
    where?: FournisseurWhereInput
  }

  export type FournisseurUpdateToOneWithWhereWithoutContactsInput = {
    where?: FournisseurWhereInput
    data: XOR<FournisseurUpdateWithoutContactsInput, FournisseurUncheckedUpdateWithoutContactsInput>
  }

  export type FournisseurUpdateWithoutContactsInput = {
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    codePostale?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUpdateOneRequiredWithoutFournisseurNestedInput
    ventes?: VenteUpdateManyWithoutFournisseurNestedInput
    achats?: AchatUpdateManyWithoutFournisseurNestedInput
    adresses?: AdresseUpdateManyWithoutFournisseurNestedInput
    reservations?: ReservationUpdateManyWithoutFournisseurNestedInput
    commandes?: CommandeUpdateManyWithoutFournisseurNestedInput
  }

  export type FournisseurUncheckedUpdateWithoutContactsInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    codePostale?: NullableStringFieldUpdateOperationsInput | string | null
    agentId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ventes?: VenteUncheckedUpdateManyWithoutFournisseurNestedInput
    achats?: AchatUncheckedUpdateManyWithoutFournisseurNestedInput
    adresses?: AdresseUncheckedUpdateManyWithoutFournisseurNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutFournisseurNestedInput
    commandes?: CommandeUncheckedUpdateManyWithoutFournisseurNestedInput
  }

  export type ReservationUpsertWithWhereUniqueWithoutContactInput = {
    where: ReservationWhereUniqueInput
    update: XOR<ReservationUpdateWithoutContactInput, ReservationUncheckedUpdateWithoutContactInput>
    create: XOR<ReservationCreateWithoutContactInput, ReservationUncheckedCreateWithoutContactInput>
  }

  export type ReservationUpdateWithWhereUniqueWithoutContactInput = {
    where: ReservationWhereUniqueInput
    data: XOR<ReservationUpdateWithoutContactInput, ReservationUncheckedUpdateWithoutContactInput>
  }

  export type ReservationUpdateManyWithWhereWithoutContactInput = {
    where: ReservationScalarWhereInput
    data: XOR<ReservationUpdateManyMutationInput, ReservationUncheckedUpdateManyWithoutContactInput>
  }

  export type CommandeUpsertWithWhereUniqueWithoutContactInput = {
    where: CommandeWhereUniqueInput
    update: XOR<CommandeUpdateWithoutContactInput, CommandeUncheckedUpdateWithoutContactInput>
    create: XOR<CommandeCreateWithoutContactInput, CommandeUncheckedCreateWithoutContactInput>
  }

  export type CommandeUpdateWithWhereUniqueWithoutContactInput = {
    where: CommandeWhereUniqueInput
    data: XOR<CommandeUpdateWithoutContactInput, CommandeUncheckedUpdateWithoutContactInput>
  }

  export type CommandeUpdateManyWithWhereWithoutContactInput = {
    where: CommandeScalarWhereInput
    data: XOR<CommandeUpdateManyMutationInput, CommandeUncheckedUpdateManyWithoutContactInput>
  }

  export type AgentCreateWithoutFournisseurInput = {
    email: string
    nom: string
    postnom?: string | null
    nom_complet?: string | null
    sexe?: $Enums.Sexe | null
    role?: $Enums.Role
    poste?: $Enums.Poste | null
    picture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    adresses?: AdresseCreateNestedManyWithoutAgentInput
    contacts?: ContactCreateNestedManyWithoutAgentInput
    produits?: ProduitCreateNestedManyWithoutAgentInput
    ventes?: VenteCreateNestedManyWithoutAgentInput
    achats?: AchatCreateNestedManyWithoutAgentInput
    teneurs?: TeneurCreateNestedManyWithoutAgentsInput
    devises?: DeviseCreateNestedManyWithoutAgentInput
    paniers?: PanierCreateNestedManyWithoutAgentInput
    caisses?: CaisseCreateNestedManyWithoutAgentInput
    mouvementCaisses?: MouvementCaisseCreateNestedManyWithoutAgentInput
    clotureCaisses?: ClotureCaisseCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateWithoutFournisseurInput = {
    id?: number
    email: string
    nom: string
    postnom?: string | null
    nom_complet?: string | null
    sexe?: $Enums.Sexe | null
    role?: $Enums.Role
    poste?: $Enums.Poste | null
    picture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    adresses?: AdresseUncheckedCreateNestedManyWithoutAgentInput
    contacts?: ContactUncheckedCreateNestedManyWithoutAgentInput
    produits?: ProduitUncheckedCreateNestedManyWithoutAgentInput
    ventes?: VenteUncheckedCreateNestedManyWithoutAgentInput
    achats?: AchatUncheckedCreateNestedManyWithoutAgentInput
    teneurs?: TeneurUncheckedCreateNestedManyWithoutAgentsInput
    devises?: DeviseUncheckedCreateNestedManyWithoutAgentInput
    paniers?: PanierUncheckedCreateNestedManyWithoutAgentInput
    caisses?: CaisseUncheckedCreateNestedManyWithoutAgentInput
    mouvementCaisses?: MouvementCaisseUncheckedCreateNestedManyWithoutAgentInput
    clotureCaisses?: ClotureCaisseUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentCreateOrConnectWithoutFournisseurInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutFournisseurInput, AgentUncheckedCreateWithoutFournisseurInput>
  }

  export type VenteCreateWithoutFournisseurInput = {
    statut?: $Enums.StatutVente
    typeAcheteur: $Enums.TypeClient
    enregistrerPar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    panier: PanierCreateNestedOneWithoutVentesInput
    agent?: AgentCreateNestedOneWithoutVentesInput
    client?: ClientCreateNestedOneWithoutVentesInput
    paiements?: PaiementCreateNestedManyWithoutVenteInput
  }

  export type VenteUncheckedCreateWithoutFournisseurInput = {
    id?: number
    statut?: $Enums.StatutVente
    typeAcheteur: $Enums.TypeClient
    clientId?: number | null
    agentId?: number | null
    panierId: number
    enregistrerPar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    paiements?: PaiementUncheckedCreateNestedManyWithoutVenteInput
  }

  export type VenteCreateOrConnectWithoutFournisseurInput = {
    where: VenteWhereUniqueInput
    create: XOR<VenteCreateWithoutFournisseurInput, VenteUncheckedCreateWithoutFournisseurInput>
  }

  export type VenteCreateManyFournisseurInputEnvelope = {
    data: VenteCreateManyFournisseurInput | VenteCreateManyFournisseurInput[]
    skipDuplicates?: boolean
  }

  export type AchatCreateWithoutFournisseurInput = {
    statut?: $Enums.StatutAchat
    createdAt?: Date | string
    updatedAt?: Date | string
    panier: PanierCreateNestedOneWithoutAchatsInput
    agent: AgentCreateNestedOneWithoutAchatsInput
    Client?: ClientCreateNestedOneWithoutAchatsInput
    paiements?: PaiementCreateNestedManyWithoutAchatInput
  }

  export type AchatUncheckedCreateWithoutFournisseurInput = {
    id?: number
    statut?: $Enums.StatutAchat
    panierId: number
    agentId: number
    clientId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    paiements?: PaiementUncheckedCreateNestedManyWithoutAchatInput
  }

  export type AchatCreateOrConnectWithoutFournisseurInput = {
    where: AchatWhereUniqueInput
    create: XOR<AchatCreateWithoutFournisseurInput, AchatUncheckedCreateWithoutFournisseurInput>
  }

  export type AchatCreateManyFournisseurInputEnvelope = {
    data: AchatCreateManyFournisseurInput | AchatCreateManyFournisseurInput[]
    skipDuplicates?: boolean
  }

  export type AdresseCreateWithoutFournisseurInput = {
    ville?: string | null
    adresse: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    agent?: AgentCreateNestedOneWithoutAdressesInput
    entreprise?: EntrepriseCreateNestedOneWithoutAdresseInput
    client?: ClientCreateNestedOneWithoutAdressesInput
    reservations?: ReservationCreateNestedManyWithoutAdresseInput
    commandes?: CommandeCreateNestedManyWithoutAdresseInput
  }

  export type AdresseUncheckedCreateWithoutFournisseurInput = {
    id?: number
    ville?: string | null
    adresse: string
    isActive?: boolean
    agentId?: number | null
    clientId?: number | null
    entrepriseId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reservations?: ReservationUncheckedCreateNestedManyWithoutAdresseInput
    commandes?: CommandeUncheckedCreateNestedManyWithoutAdresseInput
  }

  export type AdresseCreateOrConnectWithoutFournisseurInput = {
    where: AdresseWhereUniqueInput
    create: XOR<AdresseCreateWithoutFournisseurInput, AdresseUncheckedCreateWithoutFournisseurInput>
  }

  export type AdresseCreateManyFournisseurInputEnvelope = {
    data: AdresseCreateManyFournisseurInput | AdresseCreateManyFournisseurInput[]
    skipDuplicates?: boolean
  }

  export type ContactCreateWithoutFournisseurInput = {
    tel: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    entreprise?: EntrepriseCreateNestedOneWithoutContactInput
    client?: ClientCreateNestedOneWithoutContactsInput
    agent?: AgentCreateNestedOneWithoutContactsInput
    reservations?: ReservationCreateNestedManyWithoutContactInput
    commandes?: CommandeCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutFournisseurInput = {
    id?: number
    tel: string
    isActive?: boolean
    agentId?: number | null
    clientId?: number | null
    entrepriseId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reservations?: ReservationUncheckedCreateNestedManyWithoutContactInput
    commandes?: CommandeUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutFournisseurInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutFournisseurInput, ContactUncheckedCreateWithoutFournisseurInput>
  }

  export type ContactCreateManyFournisseurInputEnvelope = {
    data: ContactCreateManyFournisseurInput | ContactCreateManyFournisseurInput[]
    skipDuplicates?: boolean
  }

  export type ReservationCreateWithoutFournisseurInput = {
    dateLivraisonSouhaitee: Date | string
    adresseLivraison?: string | null
    statut?: $Enums.StatutReservation
    notes?: string | null
    typeClient?: $Enums.TypeClient
    nom?: string | null
    tel?: string | null
    enregistrerParId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    panier: PanierCreateNestedOneWithoutReservationsInput
    adresse?: AdresseCreateNestedOneWithoutReservationsInput
    contact?: ContactCreateNestedOneWithoutReservationsInput
    Client?: ClientCreateNestedOneWithoutReservationsInput
  }

  export type ReservationUncheckedCreateWithoutFournisseurInput = {
    id?: number
    dateLivraisonSouhaitee: Date | string
    adresseLivraison?: string | null
    statut?: $Enums.StatutReservation
    notes?: string | null
    typeClient?: $Enums.TypeClient
    clientId?: number | null
    panierId: number
    nom?: string | null
    tel?: string | null
    adresseId?: number | null
    contactId?: number | null
    enregistrerParId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReservationCreateOrConnectWithoutFournisseurInput = {
    where: ReservationWhereUniqueInput
    create: XOR<ReservationCreateWithoutFournisseurInput, ReservationUncheckedCreateWithoutFournisseurInput>
  }

  export type ReservationCreateManyFournisseurInputEnvelope = {
    data: ReservationCreateManyFournisseurInput | ReservationCreateManyFournisseurInput[]
    skipDuplicates?: boolean
  }

  export type CommandeCreateWithoutFournisseurInput = {
    nom?: string | null
    tel?: string | null
    type_client?: $Enums.TypeClient
    commandeId?: number | null
    notes?: string | null
    dateLivraisonEffective?: Date | string | null
    adresseLivraison?: string | null
    enregistrerParId?: number | null
    statut?: $Enums.StatutCommande
    createdAt?: Date | string
    updatedAt?: Date | string
    Paiement?: PaiementCreateNestedManyWithoutCommandeInput
    panier: PanierCreateNestedOneWithoutCommandesInput
    adresse?: AdresseCreateNestedOneWithoutCommandesInput
    contact?: ContactCreateNestedOneWithoutCommandesInput
    Client?: ClientCreateNestedOneWithoutCommandesInput
  }

  export type CommandeUncheckedCreateWithoutFournisseurInput = {
    id?: number
    panierId: number
    clientId?: number | null
    nom?: string | null
    tel?: string | null
    type_client?: $Enums.TypeClient
    adresseId?: number | null
    contactId?: number | null
    commandeId?: number | null
    notes?: string | null
    dateLivraisonEffective?: Date | string | null
    adresseLivraison?: string | null
    enregistrerParId?: number | null
    statut?: $Enums.StatutCommande
    createdAt?: Date | string
    updatedAt?: Date | string
    Paiement?: PaiementUncheckedCreateNestedManyWithoutCommandeInput
  }

  export type CommandeCreateOrConnectWithoutFournisseurInput = {
    where: CommandeWhereUniqueInput
    create: XOR<CommandeCreateWithoutFournisseurInput, CommandeUncheckedCreateWithoutFournisseurInput>
  }

  export type CommandeCreateManyFournisseurInputEnvelope = {
    data: CommandeCreateManyFournisseurInput | CommandeCreateManyFournisseurInput[]
    skipDuplicates?: boolean
  }

  export type AgentUpsertWithoutFournisseurInput = {
    update: XOR<AgentUpdateWithoutFournisseurInput, AgentUncheckedUpdateWithoutFournisseurInput>
    create: XOR<AgentCreateWithoutFournisseurInput, AgentUncheckedCreateWithoutFournisseurInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutFournisseurInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutFournisseurInput, AgentUncheckedUpdateWithoutFournisseurInput>
  }

  export type AgentUpdateWithoutFournisseurInput = {
    email?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    postnom?: NullableStringFieldUpdateOperationsInput | string | null
    nom_complet?: NullableStringFieldUpdateOperationsInput | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    poste?: NullableEnumPosteFieldUpdateOperationsInput | $Enums.Poste | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adresses?: AdresseUpdateManyWithoutAgentNestedInput
    contacts?: ContactUpdateManyWithoutAgentNestedInput
    produits?: ProduitUpdateManyWithoutAgentNestedInput
    ventes?: VenteUpdateManyWithoutAgentNestedInput
    achats?: AchatUpdateManyWithoutAgentNestedInput
    teneurs?: TeneurUpdateManyWithoutAgentsNestedInput
    devises?: DeviseUpdateManyWithoutAgentNestedInput
    paniers?: PanierUpdateManyWithoutAgentNestedInput
    caisses?: CaisseUpdateManyWithoutAgentNestedInput
    mouvementCaisses?: MouvementCaisseUpdateManyWithoutAgentNestedInput
    clotureCaisses?: ClotureCaisseUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateWithoutFournisseurInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    postnom?: NullableStringFieldUpdateOperationsInput | string | null
    nom_complet?: NullableStringFieldUpdateOperationsInput | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    poste?: NullableEnumPosteFieldUpdateOperationsInput | $Enums.Poste | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adresses?: AdresseUncheckedUpdateManyWithoutAgentNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutAgentNestedInput
    produits?: ProduitUncheckedUpdateManyWithoutAgentNestedInput
    ventes?: VenteUncheckedUpdateManyWithoutAgentNestedInput
    achats?: AchatUncheckedUpdateManyWithoutAgentNestedInput
    teneurs?: TeneurUncheckedUpdateManyWithoutAgentsNestedInput
    devises?: DeviseUncheckedUpdateManyWithoutAgentNestedInput
    paniers?: PanierUncheckedUpdateManyWithoutAgentNestedInput
    caisses?: CaisseUncheckedUpdateManyWithoutAgentNestedInput
    mouvementCaisses?: MouvementCaisseUncheckedUpdateManyWithoutAgentNestedInput
    clotureCaisses?: ClotureCaisseUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type VenteUpsertWithWhereUniqueWithoutFournisseurInput = {
    where: VenteWhereUniqueInput
    update: XOR<VenteUpdateWithoutFournisseurInput, VenteUncheckedUpdateWithoutFournisseurInput>
    create: XOR<VenteCreateWithoutFournisseurInput, VenteUncheckedCreateWithoutFournisseurInput>
  }

  export type VenteUpdateWithWhereUniqueWithoutFournisseurInput = {
    where: VenteWhereUniqueInput
    data: XOR<VenteUpdateWithoutFournisseurInput, VenteUncheckedUpdateWithoutFournisseurInput>
  }

  export type VenteUpdateManyWithWhereWithoutFournisseurInput = {
    where: VenteScalarWhereInput
    data: XOR<VenteUpdateManyMutationInput, VenteUncheckedUpdateManyWithoutFournisseurInput>
  }

  export type AchatUpsertWithWhereUniqueWithoutFournisseurInput = {
    where: AchatWhereUniqueInput
    update: XOR<AchatUpdateWithoutFournisseurInput, AchatUncheckedUpdateWithoutFournisseurInput>
    create: XOR<AchatCreateWithoutFournisseurInput, AchatUncheckedCreateWithoutFournisseurInput>
  }

  export type AchatUpdateWithWhereUniqueWithoutFournisseurInput = {
    where: AchatWhereUniqueInput
    data: XOR<AchatUpdateWithoutFournisseurInput, AchatUncheckedUpdateWithoutFournisseurInput>
  }

  export type AchatUpdateManyWithWhereWithoutFournisseurInput = {
    where: AchatScalarWhereInput
    data: XOR<AchatUpdateManyMutationInput, AchatUncheckedUpdateManyWithoutFournisseurInput>
  }

  export type AdresseUpsertWithWhereUniqueWithoutFournisseurInput = {
    where: AdresseWhereUniqueInput
    update: XOR<AdresseUpdateWithoutFournisseurInput, AdresseUncheckedUpdateWithoutFournisseurInput>
    create: XOR<AdresseCreateWithoutFournisseurInput, AdresseUncheckedCreateWithoutFournisseurInput>
  }

  export type AdresseUpdateWithWhereUniqueWithoutFournisseurInput = {
    where: AdresseWhereUniqueInput
    data: XOR<AdresseUpdateWithoutFournisseurInput, AdresseUncheckedUpdateWithoutFournisseurInput>
  }

  export type AdresseUpdateManyWithWhereWithoutFournisseurInput = {
    where: AdresseScalarWhereInput
    data: XOR<AdresseUpdateManyMutationInput, AdresseUncheckedUpdateManyWithoutFournisseurInput>
  }

  export type ContactUpsertWithWhereUniqueWithoutFournisseurInput = {
    where: ContactWhereUniqueInput
    update: XOR<ContactUpdateWithoutFournisseurInput, ContactUncheckedUpdateWithoutFournisseurInput>
    create: XOR<ContactCreateWithoutFournisseurInput, ContactUncheckedCreateWithoutFournisseurInput>
  }

  export type ContactUpdateWithWhereUniqueWithoutFournisseurInput = {
    where: ContactWhereUniqueInput
    data: XOR<ContactUpdateWithoutFournisseurInput, ContactUncheckedUpdateWithoutFournisseurInput>
  }

  export type ContactUpdateManyWithWhereWithoutFournisseurInput = {
    where: ContactScalarWhereInput
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyWithoutFournisseurInput>
  }

  export type ReservationUpsertWithWhereUniqueWithoutFournisseurInput = {
    where: ReservationWhereUniqueInput
    update: XOR<ReservationUpdateWithoutFournisseurInput, ReservationUncheckedUpdateWithoutFournisseurInput>
    create: XOR<ReservationCreateWithoutFournisseurInput, ReservationUncheckedCreateWithoutFournisseurInput>
  }

  export type ReservationUpdateWithWhereUniqueWithoutFournisseurInput = {
    where: ReservationWhereUniqueInput
    data: XOR<ReservationUpdateWithoutFournisseurInput, ReservationUncheckedUpdateWithoutFournisseurInput>
  }

  export type ReservationUpdateManyWithWhereWithoutFournisseurInput = {
    where: ReservationScalarWhereInput
    data: XOR<ReservationUpdateManyMutationInput, ReservationUncheckedUpdateManyWithoutFournisseurInput>
  }

  export type CommandeUpsertWithWhereUniqueWithoutFournisseurInput = {
    where: CommandeWhereUniqueInput
    update: XOR<CommandeUpdateWithoutFournisseurInput, CommandeUncheckedUpdateWithoutFournisseurInput>
    create: XOR<CommandeCreateWithoutFournisseurInput, CommandeUncheckedCreateWithoutFournisseurInput>
  }

  export type CommandeUpdateWithWhereUniqueWithoutFournisseurInput = {
    where: CommandeWhereUniqueInput
    data: XOR<CommandeUpdateWithoutFournisseurInput, CommandeUncheckedUpdateWithoutFournisseurInput>
  }

  export type CommandeUpdateManyWithWhereWithoutFournisseurInput = {
    where: CommandeScalarWhereInput
    data: XOR<CommandeUpdateManyMutationInput, CommandeUncheckedUpdateManyWithoutFournisseurInput>
  }

  export type DetailPanierCreateWithoutProduitInput = {
    qtte: number
    modePaiement: $Enums.ModePaiment
    prixUnitaire: number
    prixTotalHT: number
    prixTotalTTC: number
    createdAt?: Date | string
    updatedAt?: Date | string
    devise: DeviseCreateNestedOneWithoutDetailPanierInput
    panier: PanierCreateNestedOneWithoutDetailPaniersInput
  }

  export type DetailPanierUncheckedCreateWithoutProduitInput = {
    id?: number
    qtte: number
    modePaiement: $Enums.ModePaiment
    prixUnitaire: number
    prixTotalHT: number
    prixTotalTTC: number
    panierId: number
    deviseId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DetailPanierCreateOrConnectWithoutProduitInput = {
    where: DetailPanierWhereUniqueInput
    create: XOR<DetailPanierCreateWithoutProduitInput, DetailPanierUncheckedCreateWithoutProduitInput>
  }

  export type DetailPanierCreateManyProduitInputEnvelope = {
    data: DetailPanierCreateManyProduitInput | DetailPanierCreateManyProduitInput[]
    skipDuplicates?: boolean
  }

  export type AgentCreateWithoutProduitsInput = {
    email: string
    nom: string
    postnom?: string | null
    nom_complet?: string | null
    sexe?: $Enums.Sexe | null
    role?: $Enums.Role
    poste?: $Enums.Poste | null
    picture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    adresses?: AdresseCreateNestedManyWithoutAgentInput
    contacts?: ContactCreateNestedManyWithoutAgentInput
    ventes?: VenteCreateNestedManyWithoutAgentInput
    achats?: AchatCreateNestedManyWithoutAgentInput
    teneurs?: TeneurCreateNestedManyWithoutAgentsInput
    devises?: DeviseCreateNestedManyWithoutAgentInput
    paniers?: PanierCreateNestedManyWithoutAgentInput
    caisses?: CaisseCreateNestedManyWithoutAgentInput
    mouvementCaisses?: MouvementCaisseCreateNestedManyWithoutAgentInput
    clotureCaisses?: ClotureCaisseCreateNestedManyWithoutAgentInput
    Fournisseur?: FournisseurCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateWithoutProduitsInput = {
    id?: number
    email: string
    nom: string
    postnom?: string | null
    nom_complet?: string | null
    sexe?: $Enums.Sexe | null
    role?: $Enums.Role
    poste?: $Enums.Poste | null
    picture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    adresses?: AdresseUncheckedCreateNestedManyWithoutAgentInput
    contacts?: ContactUncheckedCreateNestedManyWithoutAgentInput
    ventes?: VenteUncheckedCreateNestedManyWithoutAgentInput
    achats?: AchatUncheckedCreateNestedManyWithoutAgentInput
    teneurs?: TeneurUncheckedCreateNestedManyWithoutAgentsInput
    devises?: DeviseUncheckedCreateNestedManyWithoutAgentInput
    paniers?: PanierUncheckedCreateNestedManyWithoutAgentInput
    caisses?: CaisseUncheckedCreateNestedManyWithoutAgentInput
    mouvementCaisses?: MouvementCaisseUncheckedCreateNestedManyWithoutAgentInput
    clotureCaisses?: ClotureCaisseUncheckedCreateNestedManyWithoutAgentInput
    Fournisseur?: FournisseurUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentCreateOrConnectWithoutProduitsInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutProduitsInput, AgentUncheckedCreateWithoutProduitsInput>
  }

  export type DeviseCreateWithoutProduitsInput = {
    nom: string
    code: string
    symbole: string
    tauxDEchange: number
    createdAt?: Date | string
    updatedAt?: Date | string
    agent: AgentCreateNestedOneWithoutDevisesInput
    paiements?: PaiementCreateNestedManyWithoutDeviseInput
    caisses?: CaisseCreateNestedManyWithoutDeviseInput
    DetailPanier?: DetailPanierCreateNestedManyWithoutDeviseInput
  }

  export type DeviseUncheckedCreateWithoutProduitsInput = {
    id?: number
    nom: string
    code: string
    symbole: string
    tauxDEchange: number
    agentId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    paiements?: PaiementUncheckedCreateNestedManyWithoutDeviseInput
    caisses?: CaisseUncheckedCreateNestedManyWithoutDeviseInput
    DetailPanier?: DetailPanierUncheckedCreateNestedManyWithoutDeviseInput
  }

  export type DeviseCreateOrConnectWithoutProduitsInput = {
    where: DeviseWhereUniqueInput
    create: XOR<DeviseCreateWithoutProduitsInput, DeviseUncheckedCreateWithoutProduitsInput>
  }

  export type TeneurCreateWithoutProduitsInput = {
    valeur: number
    createdAt?: Date | string
    updatedAt?: Date | string
    agents: AgentCreateNestedOneWithoutTeneursInput
  }

  export type TeneurUncheckedCreateWithoutProduitsInput = {
    id?: number
    valeur: number
    agentId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeneurCreateOrConnectWithoutProduitsInput = {
    where: TeneurWhereUniqueInput
    create: XOR<TeneurCreateWithoutProduitsInput, TeneurUncheckedCreateWithoutProduitsInput>
  }

  export type DetailPanierUpsertWithWhereUniqueWithoutProduitInput = {
    where: DetailPanierWhereUniqueInput
    update: XOR<DetailPanierUpdateWithoutProduitInput, DetailPanierUncheckedUpdateWithoutProduitInput>
    create: XOR<DetailPanierCreateWithoutProduitInput, DetailPanierUncheckedCreateWithoutProduitInput>
  }

  export type DetailPanierUpdateWithWhereUniqueWithoutProduitInput = {
    where: DetailPanierWhereUniqueInput
    data: XOR<DetailPanierUpdateWithoutProduitInput, DetailPanierUncheckedUpdateWithoutProduitInput>
  }

  export type DetailPanierUpdateManyWithWhereWithoutProduitInput = {
    where: DetailPanierScalarWhereInput
    data: XOR<DetailPanierUpdateManyMutationInput, DetailPanierUncheckedUpdateManyWithoutProduitInput>
  }

  export type AgentUpsertWithoutProduitsInput = {
    update: XOR<AgentUpdateWithoutProduitsInput, AgentUncheckedUpdateWithoutProduitsInput>
    create: XOR<AgentCreateWithoutProduitsInput, AgentUncheckedCreateWithoutProduitsInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutProduitsInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutProduitsInput, AgentUncheckedUpdateWithoutProduitsInput>
  }

  export type AgentUpdateWithoutProduitsInput = {
    email?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    postnom?: NullableStringFieldUpdateOperationsInput | string | null
    nom_complet?: NullableStringFieldUpdateOperationsInput | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    poste?: NullableEnumPosteFieldUpdateOperationsInput | $Enums.Poste | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adresses?: AdresseUpdateManyWithoutAgentNestedInput
    contacts?: ContactUpdateManyWithoutAgentNestedInput
    ventes?: VenteUpdateManyWithoutAgentNestedInput
    achats?: AchatUpdateManyWithoutAgentNestedInput
    teneurs?: TeneurUpdateManyWithoutAgentsNestedInput
    devises?: DeviseUpdateManyWithoutAgentNestedInput
    paniers?: PanierUpdateManyWithoutAgentNestedInput
    caisses?: CaisseUpdateManyWithoutAgentNestedInput
    mouvementCaisses?: MouvementCaisseUpdateManyWithoutAgentNestedInput
    clotureCaisses?: ClotureCaisseUpdateManyWithoutAgentNestedInput
    Fournisseur?: FournisseurUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateWithoutProduitsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    postnom?: NullableStringFieldUpdateOperationsInput | string | null
    nom_complet?: NullableStringFieldUpdateOperationsInput | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    poste?: NullableEnumPosteFieldUpdateOperationsInput | $Enums.Poste | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adresses?: AdresseUncheckedUpdateManyWithoutAgentNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutAgentNestedInput
    ventes?: VenteUncheckedUpdateManyWithoutAgentNestedInput
    achats?: AchatUncheckedUpdateManyWithoutAgentNestedInput
    teneurs?: TeneurUncheckedUpdateManyWithoutAgentsNestedInput
    devises?: DeviseUncheckedUpdateManyWithoutAgentNestedInput
    paniers?: PanierUncheckedUpdateManyWithoutAgentNestedInput
    caisses?: CaisseUncheckedUpdateManyWithoutAgentNestedInput
    mouvementCaisses?: MouvementCaisseUncheckedUpdateManyWithoutAgentNestedInput
    clotureCaisses?: ClotureCaisseUncheckedUpdateManyWithoutAgentNestedInput
    Fournisseur?: FournisseurUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type DeviseUpsertWithoutProduitsInput = {
    update: XOR<DeviseUpdateWithoutProduitsInput, DeviseUncheckedUpdateWithoutProduitsInput>
    create: XOR<DeviseCreateWithoutProduitsInput, DeviseUncheckedCreateWithoutProduitsInput>
    where?: DeviseWhereInput
  }

  export type DeviseUpdateToOneWithWhereWithoutProduitsInput = {
    where?: DeviseWhereInput
    data: XOR<DeviseUpdateWithoutProduitsInput, DeviseUncheckedUpdateWithoutProduitsInput>
  }

  export type DeviseUpdateWithoutProduitsInput = {
    nom?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    symbole?: StringFieldUpdateOperationsInput | string
    tauxDEchange?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUpdateOneRequiredWithoutDevisesNestedInput
    paiements?: PaiementUpdateManyWithoutDeviseNestedInput
    caisses?: CaisseUpdateManyWithoutDeviseNestedInput
    DetailPanier?: DetailPanierUpdateManyWithoutDeviseNestedInput
  }

  export type DeviseUncheckedUpdateWithoutProduitsInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    symbole?: StringFieldUpdateOperationsInput | string
    tauxDEchange?: IntFieldUpdateOperationsInput | number
    agentId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paiements?: PaiementUncheckedUpdateManyWithoutDeviseNestedInput
    caisses?: CaisseUncheckedUpdateManyWithoutDeviseNestedInput
    DetailPanier?: DetailPanierUncheckedUpdateManyWithoutDeviseNestedInput
  }

  export type TeneurUpsertWithoutProduitsInput = {
    update: XOR<TeneurUpdateWithoutProduitsInput, TeneurUncheckedUpdateWithoutProduitsInput>
    create: XOR<TeneurCreateWithoutProduitsInput, TeneurUncheckedCreateWithoutProduitsInput>
    where?: TeneurWhereInput
  }

  export type TeneurUpdateToOneWithWhereWithoutProduitsInput = {
    where?: TeneurWhereInput
    data: XOR<TeneurUpdateWithoutProduitsInput, TeneurUncheckedUpdateWithoutProduitsInput>
  }

  export type TeneurUpdateWithoutProduitsInput = {
    valeur?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agents?: AgentUpdateOneRequiredWithoutTeneursNestedInput
  }

  export type TeneurUncheckedUpdateWithoutProduitsInput = {
    id?: IntFieldUpdateOperationsInput | number
    valeur?: FloatFieldUpdateOperationsInput | number
    agentId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VenteCreateWithoutPaiementsInput = {
    statut?: $Enums.StatutVente
    typeAcheteur: $Enums.TypeClient
    enregistrerPar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    panier: PanierCreateNestedOneWithoutVentesInput
    agent?: AgentCreateNestedOneWithoutVentesInput
    fournisseur?: FournisseurCreateNestedOneWithoutVentesInput
    client?: ClientCreateNestedOneWithoutVentesInput
  }

  export type VenteUncheckedCreateWithoutPaiementsInput = {
    id?: number
    statut?: $Enums.StatutVente
    typeAcheteur: $Enums.TypeClient
    clientId?: number | null
    agentId?: number | null
    fournisseurId?: number | null
    panierId: number
    enregistrerPar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VenteCreateOrConnectWithoutPaiementsInput = {
    where: VenteWhereUniqueInput
    create: XOR<VenteCreateWithoutPaiementsInput, VenteUncheckedCreateWithoutPaiementsInput>
  }

  export type AchatCreateWithoutPaiementsInput = {
    statut?: $Enums.StatutAchat
    createdAt?: Date | string
    updatedAt?: Date | string
    panier: PanierCreateNestedOneWithoutAchatsInput
    fournisseur: FournisseurCreateNestedOneWithoutAchatsInput
    agent: AgentCreateNestedOneWithoutAchatsInput
    Client?: ClientCreateNestedOneWithoutAchatsInput
  }

  export type AchatUncheckedCreateWithoutPaiementsInput = {
    id?: number
    statut?: $Enums.StatutAchat
    panierId: number
    fournisseurId: number
    agentId: number
    clientId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AchatCreateOrConnectWithoutPaiementsInput = {
    where: AchatWhereUniqueInput
    create: XOR<AchatCreateWithoutPaiementsInput, AchatUncheckedCreateWithoutPaiementsInput>
  }

  export type CommandeCreateWithoutPaiementInput = {
    nom?: string | null
    tel?: string | null
    type_client?: $Enums.TypeClient
    commandeId?: number | null
    notes?: string | null
    dateLivraisonEffective?: Date | string | null
    adresseLivraison?: string | null
    enregistrerParId?: number | null
    statut?: $Enums.StatutCommande
    createdAt?: Date | string
    updatedAt?: Date | string
    panier: PanierCreateNestedOneWithoutCommandesInput
    fournisseur?: FournisseurCreateNestedOneWithoutCommandesInput
    adresse?: AdresseCreateNestedOneWithoutCommandesInput
    contact?: ContactCreateNestedOneWithoutCommandesInput
    Client?: ClientCreateNestedOneWithoutCommandesInput
  }

  export type CommandeUncheckedCreateWithoutPaiementInput = {
    id?: number
    panierId: number
    clientId?: number | null
    nom?: string | null
    tel?: string | null
    type_client?: $Enums.TypeClient
    adresseId?: number | null
    contactId?: number | null
    fournisseurId?: number | null
    commandeId?: number | null
    notes?: string | null
    dateLivraisonEffective?: Date | string | null
    adresseLivraison?: string | null
    enregistrerParId?: number | null
    statut?: $Enums.StatutCommande
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommandeCreateOrConnectWithoutPaiementInput = {
    where: CommandeWhereUniqueInput
    create: XOR<CommandeCreateWithoutPaiementInput, CommandeUncheckedCreateWithoutPaiementInput>
  }

  export type CaisseCreateWithoutPaiementsInput = {
    nom: string
    description?: string | null
    soldeActuel?: number | null
    statut?: $Enums.StatutCaisse
    createdAt?: Date | string
    updatedAt?: Date | string
    devise: DeviseCreateNestedOneWithoutCaissesInput
    agent: AgentCreateNestedOneWithoutCaissesInput
    mouvementCaisses?: MouvementCaisseCreateNestedManyWithoutCaisseInput
  }

  export type CaisseUncheckedCreateWithoutPaiementsInput = {
    id?: number
    nom: string
    description?: string | null
    soldeActuel?: number | null
    deviseId: number
    agentId: number
    statut?: $Enums.StatutCaisse
    createdAt?: Date | string
    updatedAt?: Date | string
    mouvementCaisses?: MouvementCaisseUncheckedCreateNestedManyWithoutCaisseInput
  }

  export type CaisseCreateOrConnectWithoutPaiementsInput = {
    where: CaisseWhereUniqueInput
    create: XOR<CaisseCreateWithoutPaiementsInput, CaisseUncheckedCreateWithoutPaiementsInput>
  }

  export type DeviseCreateWithoutPaiementsInput = {
    nom: string
    code: string
    symbole: string
    tauxDEchange: number
    createdAt?: Date | string
    updatedAt?: Date | string
    agent: AgentCreateNestedOneWithoutDevisesInput
    produits?: ProduitCreateNestedManyWithoutDeviseInput
    caisses?: CaisseCreateNestedManyWithoutDeviseInput
    DetailPanier?: DetailPanierCreateNestedManyWithoutDeviseInput
  }

  export type DeviseUncheckedCreateWithoutPaiementsInput = {
    id?: number
    nom: string
    code: string
    symbole: string
    tauxDEchange: number
    agentId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    produits?: ProduitUncheckedCreateNestedManyWithoutDeviseInput
    caisses?: CaisseUncheckedCreateNestedManyWithoutDeviseInput
    DetailPanier?: DetailPanierUncheckedCreateNestedManyWithoutDeviseInput
  }

  export type DeviseCreateOrConnectWithoutPaiementsInput = {
    where: DeviseWhereUniqueInput
    create: XOR<DeviseCreateWithoutPaiementsInput, DeviseUncheckedCreateWithoutPaiementsInput>
  }

  export type VenteUpsertWithoutPaiementsInput = {
    update: XOR<VenteUpdateWithoutPaiementsInput, VenteUncheckedUpdateWithoutPaiementsInput>
    create: XOR<VenteCreateWithoutPaiementsInput, VenteUncheckedCreateWithoutPaiementsInput>
    where?: VenteWhereInput
  }

  export type VenteUpdateToOneWithWhereWithoutPaiementsInput = {
    where?: VenteWhereInput
    data: XOR<VenteUpdateWithoutPaiementsInput, VenteUncheckedUpdateWithoutPaiementsInput>
  }

  export type VenteUpdateWithoutPaiementsInput = {
    statut?: EnumStatutVenteFieldUpdateOperationsInput | $Enums.StatutVente
    typeAcheteur?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    enregistrerPar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    panier?: PanierUpdateOneRequiredWithoutVentesNestedInput
    agent?: AgentUpdateOneWithoutVentesNestedInput
    fournisseur?: FournisseurUpdateOneWithoutVentesNestedInput
    client?: ClientUpdateOneWithoutVentesNestedInput
  }

  export type VenteUncheckedUpdateWithoutPaiementsInput = {
    id?: IntFieldUpdateOperationsInput | number
    statut?: EnumStatutVenteFieldUpdateOperationsInput | $Enums.StatutVente
    typeAcheteur?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    agentId?: NullableIntFieldUpdateOperationsInput | number | null
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    panierId?: IntFieldUpdateOperationsInput | number
    enregistrerPar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchatUpsertWithoutPaiementsInput = {
    update: XOR<AchatUpdateWithoutPaiementsInput, AchatUncheckedUpdateWithoutPaiementsInput>
    create: XOR<AchatCreateWithoutPaiementsInput, AchatUncheckedCreateWithoutPaiementsInput>
    where?: AchatWhereInput
  }

  export type AchatUpdateToOneWithWhereWithoutPaiementsInput = {
    where?: AchatWhereInput
    data: XOR<AchatUpdateWithoutPaiementsInput, AchatUncheckedUpdateWithoutPaiementsInput>
  }

  export type AchatUpdateWithoutPaiementsInput = {
    statut?: EnumStatutAchatFieldUpdateOperationsInput | $Enums.StatutAchat
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    panier?: PanierUpdateOneRequiredWithoutAchatsNestedInput
    fournisseur?: FournisseurUpdateOneRequiredWithoutAchatsNestedInput
    agent?: AgentUpdateOneRequiredWithoutAchatsNestedInput
    Client?: ClientUpdateOneWithoutAchatsNestedInput
  }

  export type AchatUncheckedUpdateWithoutPaiementsInput = {
    id?: IntFieldUpdateOperationsInput | number
    statut?: EnumStatutAchatFieldUpdateOperationsInput | $Enums.StatutAchat
    panierId?: IntFieldUpdateOperationsInput | number
    fournisseurId?: IntFieldUpdateOperationsInput | number
    agentId?: IntFieldUpdateOperationsInput | number
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommandeUpsertWithoutPaiementInput = {
    update: XOR<CommandeUpdateWithoutPaiementInput, CommandeUncheckedUpdateWithoutPaiementInput>
    create: XOR<CommandeCreateWithoutPaiementInput, CommandeUncheckedCreateWithoutPaiementInput>
    where?: CommandeWhereInput
  }

  export type CommandeUpdateToOneWithWhereWithoutPaiementInput = {
    where?: CommandeWhereInput
    data: XOR<CommandeUpdateWithoutPaiementInput, CommandeUncheckedUpdateWithoutPaiementInput>
  }

  export type CommandeUpdateWithoutPaiementInput = {
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    type_client?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    commandeId?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    dateLivraisonEffective?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adresseLivraison?: NullableStringFieldUpdateOperationsInput | string | null
    enregistrerParId?: NullableIntFieldUpdateOperationsInput | number | null
    statut?: EnumStatutCommandeFieldUpdateOperationsInput | $Enums.StatutCommande
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    panier?: PanierUpdateOneRequiredWithoutCommandesNestedInput
    fournisseur?: FournisseurUpdateOneWithoutCommandesNestedInput
    adresse?: AdresseUpdateOneWithoutCommandesNestedInput
    contact?: ContactUpdateOneWithoutCommandesNestedInput
    Client?: ClientUpdateOneWithoutCommandesNestedInput
  }

  export type CommandeUncheckedUpdateWithoutPaiementInput = {
    id?: IntFieldUpdateOperationsInput | number
    panierId?: IntFieldUpdateOperationsInput | number
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    type_client?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    adresseId?: NullableIntFieldUpdateOperationsInput | number | null
    contactId?: NullableIntFieldUpdateOperationsInput | number | null
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    commandeId?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    dateLivraisonEffective?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adresseLivraison?: NullableStringFieldUpdateOperationsInput | string | null
    enregistrerParId?: NullableIntFieldUpdateOperationsInput | number | null
    statut?: EnumStatutCommandeFieldUpdateOperationsInput | $Enums.StatutCommande
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CaisseUpsertWithoutPaiementsInput = {
    update: XOR<CaisseUpdateWithoutPaiementsInput, CaisseUncheckedUpdateWithoutPaiementsInput>
    create: XOR<CaisseCreateWithoutPaiementsInput, CaisseUncheckedCreateWithoutPaiementsInput>
    where?: CaisseWhereInput
  }

  export type CaisseUpdateToOneWithWhereWithoutPaiementsInput = {
    where?: CaisseWhereInput
    data: XOR<CaisseUpdateWithoutPaiementsInput, CaisseUncheckedUpdateWithoutPaiementsInput>
  }

  export type CaisseUpdateWithoutPaiementsInput = {
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    soldeActuel?: NullableFloatFieldUpdateOperationsInput | number | null
    statut?: EnumStatutCaisseFieldUpdateOperationsInput | $Enums.StatutCaisse
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    devise?: DeviseUpdateOneRequiredWithoutCaissesNestedInput
    agent?: AgentUpdateOneRequiredWithoutCaissesNestedInput
    mouvementCaisses?: MouvementCaisseUpdateManyWithoutCaisseNestedInput
  }

  export type CaisseUncheckedUpdateWithoutPaiementsInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    soldeActuel?: NullableFloatFieldUpdateOperationsInput | number | null
    deviseId?: IntFieldUpdateOperationsInput | number
    agentId?: IntFieldUpdateOperationsInput | number
    statut?: EnumStatutCaisseFieldUpdateOperationsInput | $Enums.StatutCaisse
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mouvementCaisses?: MouvementCaisseUncheckedUpdateManyWithoutCaisseNestedInput
  }

  export type DeviseUpsertWithoutPaiementsInput = {
    update: XOR<DeviseUpdateWithoutPaiementsInput, DeviseUncheckedUpdateWithoutPaiementsInput>
    create: XOR<DeviseCreateWithoutPaiementsInput, DeviseUncheckedCreateWithoutPaiementsInput>
    where?: DeviseWhereInput
  }

  export type DeviseUpdateToOneWithWhereWithoutPaiementsInput = {
    where?: DeviseWhereInput
    data: XOR<DeviseUpdateWithoutPaiementsInput, DeviseUncheckedUpdateWithoutPaiementsInput>
  }

  export type DeviseUpdateWithoutPaiementsInput = {
    nom?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    symbole?: StringFieldUpdateOperationsInput | string
    tauxDEchange?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUpdateOneRequiredWithoutDevisesNestedInput
    produits?: ProduitUpdateManyWithoutDeviseNestedInput
    caisses?: CaisseUpdateManyWithoutDeviseNestedInput
    DetailPanier?: DetailPanierUpdateManyWithoutDeviseNestedInput
  }

  export type DeviseUncheckedUpdateWithoutPaiementsInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    symbole?: StringFieldUpdateOperationsInput | string
    tauxDEchange?: IntFieldUpdateOperationsInput | number
    agentId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    produits?: ProduitUncheckedUpdateManyWithoutDeviseNestedInput
    caisses?: CaisseUncheckedUpdateManyWithoutDeviseNestedInput
    DetailPanier?: DetailPanierUncheckedUpdateManyWithoutDeviseNestedInput
  }

  export type DeviseCreateWithoutCaissesInput = {
    nom: string
    code: string
    symbole: string
    tauxDEchange: number
    createdAt?: Date | string
    updatedAt?: Date | string
    agent: AgentCreateNestedOneWithoutDevisesInput
    produits?: ProduitCreateNestedManyWithoutDeviseInput
    paiements?: PaiementCreateNestedManyWithoutDeviseInput
    DetailPanier?: DetailPanierCreateNestedManyWithoutDeviseInput
  }

  export type DeviseUncheckedCreateWithoutCaissesInput = {
    id?: number
    nom: string
    code: string
    symbole: string
    tauxDEchange: number
    agentId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    produits?: ProduitUncheckedCreateNestedManyWithoutDeviseInput
    paiements?: PaiementUncheckedCreateNestedManyWithoutDeviseInput
    DetailPanier?: DetailPanierUncheckedCreateNestedManyWithoutDeviseInput
  }

  export type DeviseCreateOrConnectWithoutCaissesInput = {
    where: DeviseWhereUniqueInput
    create: XOR<DeviseCreateWithoutCaissesInput, DeviseUncheckedCreateWithoutCaissesInput>
  }

  export type AgentCreateWithoutCaissesInput = {
    email: string
    nom: string
    postnom?: string | null
    nom_complet?: string | null
    sexe?: $Enums.Sexe | null
    role?: $Enums.Role
    poste?: $Enums.Poste | null
    picture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    adresses?: AdresseCreateNestedManyWithoutAgentInput
    contacts?: ContactCreateNestedManyWithoutAgentInput
    produits?: ProduitCreateNestedManyWithoutAgentInput
    ventes?: VenteCreateNestedManyWithoutAgentInput
    achats?: AchatCreateNestedManyWithoutAgentInput
    teneurs?: TeneurCreateNestedManyWithoutAgentsInput
    devises?: DeviseCreateNestedManyWithoutAgentInput
    paniers?: PanierCreateNestedManyWithoutAgentInput
    mouvementCaisses?: MouvementCaisseCreateNestedManyWithoutAgentInput
    clotureCaisses?: ClotureCaisseCreateNestedManyWithoutAgentInput
    Fournisseur?: FournisseurCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateWithoutCaissesInput = {
    id?: number
    email: string
    nom: string
    postnom?: string | null
    nom_complet?: string | null
    sexe?: $Enums.Sexe | null
    role?: $Enums.Role
    poste?: $Enums.Poste | null
    picture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    adresses?: AdresseUncheckedCreateNestedManyWithoutAgentInput
    contacts?: ContactUncheckedCreateNestedManyWithoutAgentInput
    produits?: ProduitUncheckedCreateNestedManyWithoutAgentInput
    ventes?: VenteUncheckedCreateNestedManyWithoutAgentInput
    achats?: AchatUncheckedCreateNestedManyWithoutAgentInput
    teneurs?: TeneurUncheckedCreateNestedManyWithoutAgentsInput
    devises?: DeviseUncheckedCreateNestedManyWithoutAgentInput
    paniers?: PanierUncheckedCreateNestedManyWithoutAgentInput
    mouvementCaisses?: MouvementCaisseUncheckedCreateNestedManyWithoutAgentInput
    clotureCaisses?: ClotureCaisseUncheckedCreateNestedManyWithoutAgentInput
    Fournisseur?: FournisseurUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentCreateOrConnectWithoutCaissesInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutCaissesInput, AgentUncheckedCreateWithoutCaissesInput>
  }

  export type MouvementCaisseCreateWithoutCaisseInput = {
    referenceExterne?: string | null
    type_mouvement?: $Enums.TypeMouvementCaisse
    categorie?: $Enums.CategorieMouvement
    moyen_paiement: $Enums.ModePaiment
    montant: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agent: AgentCreateNestedOneWithoutMouvementCaissesInput
  }

  export type MouvementCaisseUncheckedCreateWithoutCaisseInput = {
    id?: number
    referenceExterne?: string | null
    type_mouvement?: $Enums.TypeMouvementCaisse
    categorie?: $Enums.CategorieMouvement
    moyen_paiement: $Enums.ModePaiment
    montant: number
    description?: string | null
    agentId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MouvementCaisseCreateOrConnectWithoutCaisseInput = {
    where: MouvementCaisseWhereUniqueInput
    create: XOR<MouvementCaisseCreateWithoutCaisseInput, MouvementCaisseUncheckedCreateWithoutCaisseInput>
  }

  export type MouvementCaisseCreateManyCaisseInputEnvelope = {
    data: MouvementCaisseCreateManyCaisseInput | MouvementCaisseCreateManyCaisseInput[]
    skipDuplicates?: boolean
  }

  export type PaiementCreateWithoutCaisseInput = {
    totalHT?: number | null
    totalTTC?: number | null
    modePaiement: $Enums.ModePaiment
    createdAt?: Date | string
    updatedAt?: Date | string
    vente?: VenteCreateNestedOneWithoutPaiementsInput
    achat?: AchatCreateNestedOneWithoutPaiementsInput
    commande?: CommandeCreateNestedOneWithoutPaiementInput
    devise: DeviseCreateNestedOneWithoutPaiementsInput
  }

  export type PaiementUncheckedCreateWithoutCaisseInput = {
    id?: number
    totalHT?: number | null
    totalTTC?: number | null
    modePaiement: $Enums.ModePaiment
    deviseId: number
    venteId?: number | null
    achatId?: number | null
    commandeId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaiementCreateOrConnectWithoutCaisseInput = {
    where: PaiementWhereUniqueInput
    create: XOR<PaiementCreateWithoutCaisseInput, PaiementUncheckedCreateWithoutCaisseInput>
  }

  export type PaiementCreateManyCaisseInputEnvelope = {
    data: PaiementCreateManyCaisseInput | PaiementCreateManyCaisseInput[]
    skipDuplicates?: boolean
  }

  export type DeviseUpsertWithoutCaissesInput = {
    update: XOR<DeviseUpdateWithoutCaissesInput, DeviseUncheckedUpdateWithoutCaissesInput>
    create: XOR<DeviseCreateWithoutCaissesInput, DeviseUncheckedCreateWithoutCaissesInput>
    where?: DeviseWhereInput
  }

  export type DeviseUpdateToOneWithWhereWithoutCaissesInput = {
    where?: DeviseWhereInput
    data: XOR<DeviseUpdateWithoutCaissesInput, DeviseUncheckedUpdateWithoutCaissesInput>
  }

  export type DeviseUpdateWithoutCaissesInput = {
    nom?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    symbole?: StringFieldUpdateOperationsInput | string
    tauxDEchange?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUpdateOneRequiredWithoutDevisesNestedInput
    produits?: ProduitUpdateManyWithoutDeviseNestedInput
    paiements?: PaiementUpdateManyWithoutDeviseNestedInput
    DetailPanier?: DetailPanierUpdateManyWithoutDeviseNestedInput
  }

  export type DeviseUncheckedUpdateWithoutCaissesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    symbole?: StringFieldUpdateOperationsInput | string
    tauxDEchange?: IntFieldUpdateOperationsInput | number
    agentId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    produits?: ProduitUncheckedUpdateManyWithoutDeviseNestedInput
    paiements?: PaiementUncheckedUpdateManyWithoutDeviseNestedInput
    DetailPanier?: DetailPanierUncheckedUpdateManyWithoutDeviseNestedInput
  }

  export type AgentUpsertWithoutCaissesInput = {
    update: XOR<AgentUpdateWithoutCaissesInput, AgentUncheckedUpdateWithoutCaissesInput>
    create: XOR<AgentCreateWithoutCaissesInput, AgentUncheckedCreateWithoutCaissesInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutCaissesInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutCaissesInput, AgentUncheckedUpdateWithoutCaissesInput>
  }

  export type AgentUpdateWithoutCaissesInput = {
    email?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    postnom?: NullableStringFieldUpdateOperationsInput | string | null
    nom_complet?: NullableStringFieldUpdateOperationsInput | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    poste?: NullableEnumPosteFieldUpdateOperationsInput | $Enums.Poste | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adresses?: AdresseUpdateManyWithoutAgentNestedInput
    contacts?: ContactUpdateManyWithoutAgentNestedInput
    produits?: ProduitUpdateManyWithoutAgentNestedInput
    ventes?: VenteUpdateManyWithoutAgentNestedInput
    achats?: AchatUpdateManyWithoutAgentNestedInput
    teneurs?: TeneurUpdateManyWithoutAgentsNestedInput
    devises?: DeviseUpdateManyWithoutAgentNestedInput
    paniers?: PanierUpdateManyWithoutAgentNestedInput
    mouvementCaisses?: MouvementCaisseUpdateManyWithoutAgentNestedInput
    clotureCaisses?: ClotureCaisseUpdateManyWithoutAgentNestedInput
    Fournisseur?: FournisseurUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateWithoutCaissesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    postnom?: NullableStringFieldUpdateOperationsInput | string | null
    nom_complet?: NullableStringFieldUpdateOperationsInput | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    poste?: NullableEnumPosteFieldUpdateOperationsInput | $Enums.Poste | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adresses?: AdresseUncheckedUpdateManyWithoutAgentNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutAgentNestedInput
    produits?: ProduitUncheckedUpdateManyWithoutAgentNestedInput
    ventes?: VenteUncheckedUpdateManyWithoutAgentNestedInput
    achats?: AchatUncheckedUpdateManyWithoutAgentNestedInput
    teneurs?: TeneurUncheckedUpdateManyWithoutAgentsNestedInput
    devises?: DeviseUncheckedUpdateManyWithoutAgentNestedInput
    paniers?: PanierUncheckedUpdateManyWithoutAgentNestedInput
    mouvementCaisses?: MouvementCaisseUncheckedUpdateManyWithoutAgentNestedInput
    clotureCaisses?: ClotureCaisseUncheckedUpdateManyWithoutAgentNestedInput
    Fournisseur?: FournisseurUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type MouvementCaisseUpsertWithWhereUniqueWithoutCaisseInput = {
    where: MouvementCaisseWhereUniqueInput
    update: XOR<MouvementCaisseUpdateWithoutCaisseInput, MouvementCaisseUncheckedUpdateWithoutCaisseInput>
    create: XOR<MouvementCaisseCreateWithoutCaisseInput, MouvementCaisseUncheckedCreateWithoutCaisseInput>
  }

  export type MouvementCaisseUpdateWithWhereUniqueWithoutCaisseInput = {
    where: MouvementCaisseWhereUniqueInput
    data: XOR<MouvementCaisseUpdateWithoutCaisseInput, MouvementCaisseUncheckedUpdateWithoutCaisseInput>
  }

  export type MouvementCaisseUpdateManyWithWhereWithoutCaisseInput = {
    where: MouvementCaisseScalarWhereInput
    data: XOR<MouvementCaisseUpdateManyMutationInput, MouvementCaisseUncheckedUpdateManyWithoutCaisseInput>
  }

  export type PaiementUpsertWithWhereUniqueWithoutCaisseInput = {
    where: PaiementWhereUniqueInput
    update: XOR<PaiementUpdateWithoutCaisseInput, PaiementUncheckedUpdateWithoutCaisseInput>
    create: XOR<PaiementCreateWithoutCaisseInput, PaiementUncheckedCreateWithoutCaisseInput>
  }

  export type PaiementUpdateWithWhereUniqueWithoutCaisseInput = {
    where: PaiementWhereUniqueInput
    data: XOR<PaiementUpdateWithoutCaisseInput, PaiementUncheckedUpdateWithoutCaisseInput>
  }

  export type PaiementUpdateManyWithWhereWithoutCaisseInput = {
    where: PaiementScalarWhereInput
    data: XOR<PaiementUpdateManyMutationInput, PaiementUncheckedUpdateManyWithoutCaisseInput>
  }

  export type PanierCreateWithoutVentesInput = {
    statut?: $Enums.statutPanier
    createdAt?: Date | string
    updatedAt?: Date | string
    agent?: AgentCreateNestedOneWithoutPaniersInput
    client?: ClientCreateNestedOneWithoutPaniersInput
    detailPaniers?: DetailPanierCreateNestedManyWithoutPanierInput
    achats?: AchatCreateNestedManyWithoutPanierInput
    reservations?: ReservationCreateNestedManyWithoutPanierInput
    commandes?: CommandeCreateNestedManyWithoutPanierInput
  }

  export type PanierUncheckedCreateWithoutVentesInput = {
    id?: number
    agentId?: number | null
    clientId?: number | null
    statut?: $Enums.statutPanier
    createdAt?: Date | string
    updatedAt?: Date | string
    detailPaniers?: DetailPanierUncheckedCreateNestedManyWithoutPanierInput
    achats?: AchatUncheckedCreateNestedManyWithoutPanierInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutPanierInput
    commandes?: CommandeUncheckedCreateNestedManyWithoutPanierInput
  }

  export type PanierCreateOrConnectWithoutVentesInput = {
    where: PanierWhereUniqueInput
    create: XOR<PanierCreateWithoutVentesInput, PanierUncheckedCreateWithoutVentesInput>
  }

  export type AgentCreateWithoutVentesInput = {
    email: string
    nom: string
    postnom?: string | null
    nom_complet?: string | null
    sexe?: $Enums.Sexe | null
    role?: $Enums.Role
    poste?: $Enums.Poste | null
    picture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    adresses?: AdresseCreateNestedManyWithoutAgentInput
    contacts?: ContactCreateNestedManyWithoutAgentInput
    produits?: ProduitCreateNestedManyWithoutAgentInput
    achats?: AchatCreateNestedManyWithoutAgentInput
    teneurs?: TeneurCreateNestedManyWithoutAgentsInput
    devises?: DeviseCreateNestedManyWithoutAgentInput
    paniers?: PanierCreateNestedManyWithoutAgentInput
    caisses?: CaisseCreateNestedManyWithoutAgentInput
    mouvementCaisses?: MouvementCaisseCreateNestedManyWithoutAgentInput
    clotureCaisses?: ClotureCaisseCreateNestedManyWithoutAgentInput
    Fournisseur?: FournisseurCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateWithoutVentesInput = {
    id?: number
    email: string
    nom: string
    postnom?: string | null
    nom_complet?: string | null
    sexe?: $Enums.Sexe | null
    role?: $Enums.Role
    poste?: $Enums.Poste | null
    picture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    adresses?: AdresseUncheckedCreateNestedManyWithoutAgentInput
    contacts?: ContactUncheckedCreateNestedManyWithoutAgentInput
    produits?: ProduitUncheckedCreateNestedManyWithoutAgentInput
    achats?: AchatUncheckedCreateNestedManyWithoutAgentInput
    teneurs?: TeneurUncheckedCreateNestedManyWithoutAgentsInput
    devises?: DeviseUncheckedCreateNestedManyWithoutAgentInput
    paniers?: PanierUncheckedCreateNestedManyWithoutAgentInput
    caisses?: CaisseUncheckedCreateNestedManyWithoutAgentInput
    mouvementCaisses?: MouvementCaisseUncheckedCreateNestedManyWithoutAgentInput
    clotureCaisses?: ClotureCaisseUncheckedCreateNestedManyWithoutAgentInput
    Fournisseur?: FournisseurUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentCreateOrConnectWithoutVentesInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutVentesInput, AgentUncheckedCreateWithoutVentesInput>
  }

  export type FournisseurCreateWithoutVentesInput = {
    nom: string
    email: string
    codePostale?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agent: AgentCreateNestedOneWithoutFournisseurInput
    achats?: AchatCreateNestedManyWithoutFournisseurInput
    adresses?: AdresseCreateNestedManyWithoutFournisseurInput
    contacts?: ContactCreateNestedManyWithoutFournisseurInput
    reservations?: ReservationCreateNestedManyWithoutFournisseurInput
    commandes?: CommandeCreateNestedManyWithoutFournisseurInput
  }

  export type FournisseurUncheckedCreateWithoutVentesInput = {
    id?: number
    nom: string
    email: string
    codePostale?: string | null
    agentId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    achats?: AchatUncheckedCreateNestedManyWithoutFournisseurInput
    adresses?: AdresseUncheckedCreateNestedManyWithoutFournisseurInput
    contacts?: ContactUncheckedCreateNestedManyWithoutFournisseurInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutFournisseurInput
    commandes?: CommandeUncheckedCreateNestedManyWithoutFournisseurInput
  }

  export type FournisseurCreateOrConnectWithoutVentesInput = {
    where: FournisseurWhereUniqueInput
    create: XOR<FournisseurCreateWithoutVentesInput, FournisseurUncheckedCreateWithoutVentesInput>
  }

  export type ClientCreateWithoutVentesInput = {
    email: string
    nom: string
    postnom?: string | null
    nom_complet?: string | null
    sexe?: $Enums.Sexe | null
    picture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    adresses?: AdresseCreateNestedManyWithoutClientInput
    contacts?: ContactCreateNestedManyWithoutClientInput
    achats?: AchatCreateNestedManyWithoutClientInput
    paniers?: PanierCreateNestedManyWithoutClientInput
    reservations?: ReservationCreateNestedManyWithoutClientInput
    commandes?: CommandeCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutVentesInput = {
    id?: number
    email: string
    nom: string
    postnom?: string | null
    nom_complet?: string | null
    sexe?: $Enums.Sexe | null
    picture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    adresses?: AdresseUncheckedCreateNestedManyWithoutClientInput
    contacts?: ContactUncheckedCreateNestedManyWithoutClientInput
    achats?: AchatUncheckedCreateNestedManyWithoutClientInput
    paniers?: PanierUncheckedCreateNestedManyWithoutClientInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutClientInput
    commandes?: CommandeUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutVentesInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutVentesInput, ClientUncheckedCreateWithoutVentesInput>
  }

  export type PaiementCreateWithoutVenteInput = {
    totalHT?: number | null
    totalTTC?: number | null
    modePaiement: $Enums.ModePaiment
    createdAt?: Date | string
    updatedAt?: Date | string
    achat?: AchatCreateNestedOneWithoutPaiementsInput
    commande?: CommandeCreateNestedOneWithoutPaiementInput
    caisse: CaisseCreateNestedOneWithoutPaiementsInput
    devise: DeviseCreateNestedOneWithoutPaiementsInput
  }

  export type PaiementUncheckedCreateWithoutVenteInput = {
    id?: number
    totalHT?: number | null
    totalTTC?: number | null
    modePaiement: $Enums.ModePaiment
    deviseId: number
    caisseId: number
    achatId?: number | null
    commandeId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaiementCreateOrConnectWithoutVenteInput = {
    where: PaiementWhereUniqueInput
    create: XOR<PaiementCreateWithoutVenteInput, PaiementUncheckedCreateWithoutVenteInput>
  }

  export type PaiementCreateManyVenteInputEnvelope = {
    data: PaiementCreateManyVenteInput | PaiementCreateManyVenteInput[]
    skipDuplicates?: boolean
  }

  export type PanierUpsertWithoutVentesInput = {
    update: XOR<PanierUpdateWithoutVentesInput, PanierUncheckedUpdateWithoutVentesInput>
    create: XOR<PanierCreateWithoutVentesInput, PanierUncheckedCreateWithoutVentesInput>
    where?: PanierWhereInput
  }

  export type PanierUpdateToOneWithWhereWithoutVentesInput = {
    where?: PanierWhereInput
    data: XOR<PanierUpdateWithoutVentesInput, PanierUncheckedUpdateWithoutVentesInput>
  }

  export type PanierUpdateWithoutVentesInput = {
    statut?: EnumstatutPanierFieldUpdateOperationsInput | $Enums.statutPanier
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUpdateOneWithoutPaniersNestedInput
    client?: ClientUpdateOneWithoutPaniersNestedInput
    detailPaniers?: DetailPanierUpdateManyWithoutPanierNestedInput
    achats?: AchatUpdateManyWithoutPanierNestedInput
    reservations?: ReservationUpdateManyWithoutPanierNestedInput
    commandes?: CommandeUpdateManyWithoutPanierNestedInput
  }

  export type PanierUncheckedUpdateWithoutVentesInput = {
    id?: IntFieldUpdateOperationsInput | number
    agentId?: NullableIntFieldUpdateOperationsInput | number | null
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    statut?: EnumstatutPanierFieldUpdateOperationsInput | $Enums.statutPanier
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    detailPaniers?: DetailPanierUncheckedUpdateManyWithoutPanierNestedInput
    achats?: AchatUncheckedUpdateManyWithoutPanierNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutPanierNestedInput
    commandes?: CommandeUncheckedUpdateManyWithoutPanierNestedInput
  }

  export type AgentUpsertWithoutVentesInput = {
    update: XOR<AgentUpdateWithoutVentesInput, AgentUncheckedUpdateWithoutVentesInput>
    create: XOR<AgentCreateWithoutVentesInput, AgentUncheckedCreateWithoutVentesInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutVentesInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutVentesInput, AgentUncheckedUpdateWithoutVentesInput>
  }

  export type AgentUpdateWithoutVentesInput = {
    email?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    postnom?: NullableStringFieldUpdateOperationsInput | string | null
    nom_complet?: NullableStringFieldUpdateOperationsInput | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    poste?: NullableEnumPosteFieldUpdateOperationsInput | $Enums.Poste | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adresses?: AdresseUpdateManyWithoutAgentNestedInput
    contacts?: ContactUpdateManyWithoutAgentNestedInput
    produits?: ProduitUpdateManyWithoutAgentNestedInput
    achats?: AchatUpdateManyWithoutAgentNestedInput
    teneurs?: TeneurUpdateManyWithoutAgentsNestedInput
    devises?: DeviseUpdateManyWithoutAgentNestedInput
    paniers?: PanierUpdateManyWithoutAgentNestedInput
    caisses?: CaisseUpdateManyWithoutAgentNestedInput
    mouvementCaisses?: MouvementCaisseUpdateManyWithoutAgentNestedInput
    clotureCaisses?: ClotureCaisseUpdateManyWithoutAgentNestedInput
    Fournisseur?: FournisseurUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateWithoutVentesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    postnom?: NullableStringFieldUpdateOperationsInput | string | null
    nom_complet?: NullableStringFieldUpdateOperationsInput | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    poste?: NullableEnumPosteFieldUpdateOperationsInput | $Enums.Poste | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adresses?: AdresseUncheckedUpdateManyWithoutAgentNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutAgentNestedInput
    produits?: ProduitUncheckedUpdateManyWithoutAgentNestedInput
    achats?: AchatUncheckedUpdateManyWithoutAgentNestedInput
    teneurs?: TeneurUncheckedUpdateManyWithoutAgentsNestedInput
    devises?: DeviseUncheckedUpdateManyWithoutAgentNestedInput
    paniers?: PanierUncheckedUpdateManyWithoutAgentNestedInput
    caisses?: CaisseUncheckedUpdateManyWithoutAgentNestedInput
    mouvementCaisses?: MouvementCaisseUncheckedUpdateManyWithoutAgentNestedInput
    clotureCaisses?: ClotureCaisseUncheckedUpdateManyWithoutAgentNestedInput
    Fournisseur?: FournisseurUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type FournisseurUpsertWithoutVentesInput = {
    update: XOR<FournisseurUpdateWithoutVentesInput, FournisseurUncheckedUpdateWithoutVentesInput>
    create: XOR<FournisseurCreateWithoutVentesInput, FournisseurUncheckedCreateWithoutVentesInput>
    where?: FournisseurWhereInput
  }

  export type FournisseurUpdateToOneWithWhereWithoutVentesInput = {
    where?: FournisseurWhereInput
    data: XOR<FournisseurUpdateWithoutVentesInput, FournisseurUncheckedUpdateWithoutVentesInput>
  }

  export type FournisseurUpdateWithoutVentesInput = {
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    codePostale?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUpdateOneRequiredWithoutFournisseurNestedInput
    achats?: AchatUpdateManyWithoutFournisseurNestedInput
    adresses?: AdresseUpdateManyWithoutFournisseurNestedInput
    contacts?: ContactUpdateManyWithoutFournisseurNestedInput
    reservations?: ReservationUpdateManyWithoutFournisseurNestedInput
    commandes?: CommandeUpdateManyWithoutFournisseurNestedInput
  }

  export type FournisseurUncheckedUpdateWithoutVentesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    codePostale?: NullableStringFieldUpdateOperationsInput | string | null
    agentId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    achats?: AchatUncheckedUpdateManyWithoutFournisseurNestedInput
    adresses?: AdresseUncheckedUpdateManyWithoutFournisseurNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutFournisseurNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutFournisseurNestedInput
    commandes?: CommandeUncheckedUpdateManyWithoutFournisseurNestedInput
  }

  export type ClientUpsertWithoutVentesInput = {
    update: XOR<ClientUpdateWithoutVentesInput, ClientUncheckedUpdateWithoutVentesInput>
    create: XOR<ClientCreateWithoutVentesInput, ClientUncheckedCreateWithoutVentesInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutVentesInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutVentesInput, ClientUncheckedUpdateWithoutVentesInput>
  }

  export type ClientUpdateWithoutVentesInput = {
    email?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    postnom?: NullableStringFieldUpdateOperationsInput | string | null
    nom_complet?: NullableStringFieldUpdateOperationsInput | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adresses?: AdresseUpdateManyWithoutClientNestedInput
    contacts?: ContactUpdateManyWithoutClientNestedInput
    achats?: AchatUpdateManyWithoutClientNestedInput
    paniers?: PanierUpdateManyWithoutClientNestedInput
    reservations?: ReservationUpdateManyWithoutClientNestedInput
    commandes?: CommandeUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutVentesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    postnom?: NullableStringFieldUpdateOperationsInput | string | null
    nom_complet?: NullableStringFieldUpdateOperationsInput | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adresses?: AdresseUncheckedUpdateManyWithoutClientNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutClientNestedInput
    achats?: AchatUncheckedUpdateManyWithoutClientNestedInput
    paniers?: PanierUncheckedUpdateManyWithoutClientNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutClientNestedInput
    commandes?: CommandeUncheckedUpdateManyWithoutClientNestedInput
  }

  export type PaiementUpsertWithWhereUniqueWithoutVenteInput = {
    where: PaiementWhereUniqueInput
    update: XOR<PaiementUpdateWithoutVenteInput, PaiementUncheckedUpdateWithoutVenteInput>
    create: XOR<PaiementCreateWithoutVenteInput, PaiementUncheckedCreateWithoutVenteInput>
  }

  export type PaiementUpdateWithWhereUniqueWithoutVenteInput = {
    where: PaiementWhereUniqueInput
    data: XOR<PaiementUpdateWithoutVenteInput, PaiementUncheckedUpdateWithoutVenteInput>
  }

  export type PaiementUpdateManyWithWhereWithoutVenteInput = {
    where: PaiementScalarWhereInput
    data: XOR<PaiementUpdateManyMutationInput, PaiementUncheckedUpdateManyWithoutVenteInput>
  }

  export type AgentCreateWithoutPaniersInput = {
    email: string
    nom: string
    postnom?: string | null
    nom_complet?: string | null
    sexe?: $Enums.Sexe | null
    role?: $Enums.Role
    poste?: $Enums.Poste | null
    picture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    adresses?: AdresseCreateNestedManyWithoutAgentInput
    contacts?: ContactCreateNestedManyWithoutAgentInput
    produits?: ProduitCreateNestedManyWithoutAgentInput
    ventes?: VenteCreateNestedManyWithoutAgentInput
    achats?: AchatCreateNestedManyWithoutAgentInput
    teneurs?: TeneurCreateNestedManyWithoutAgentsInput
    devises?: DeviseCreateNestedManyWithoutAgentInput
    caisses?: CaisseCreateNestedManyWithoutAgentInput
    mouvementCaisses?: MouvementCaisseCreateNestedManyWithoutAgentInput
    clotureCaisses?: ClotureCaisseCreateNestedManyWithoutAgentInput
    Fournisseur?: FournisseurCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateWithoutPaniersInput = {
    id?: number
    email: string
    nom: string
    postnom?: string | null
    nom_complet?: string | null
    sexe?: $Enums.Sexe | null
    role?: $Enums.Role
    poste?: $Enums.Poste | null
    picture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    adresses?: AdresseUncheckedCreateNestedManyWithoutAgentInput
    contacts?: ContactUncheckedCreateNestedManyWithoutAgentInput
    produits?: ProduitUncheckedCreateNestedManyWithoutAgentInput
    ventes?: VenteUncheckedCreateNestedManyWithoutAgentInput
    achats?: AchatUncheckedCreateNestedManyWithoutAgentInput
    teneurs?: TeneurUncheckedCreateNestedManyWithoutAgentsInput
    devises?: DeviseUncheckedCreateNestedManyWithoutAgentInput
    caisses?: CaisseUncheckedCreateNestedManyWithoutAgentInput
    mouvementCaisses?: MouvementCaisseUncheckedCreateNestedManyWithoutAgentInput
    clotureCaisses?: ClotureCaisseUncheckedCreateNestedManyWithoutAgentInput
    Fournisseur?: FournisseurUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentCreateOrConnectWithoutPaniersInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutPaniersInput, AgentUncheckedCreateWithoutPaniersInput>
  }

  export type ClientCreateWithoutPaniersInput = {
    email: string
    nom: string
    postnom?: string | null
    nom_complet?: string | null
    sexe?: $Enums.Sexe | null
    picture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    adresses?: AdresseCreateNestedManyWithoutClientInput
    contacts?: ContactCreateNestedManyWithoutClientInput
    ventes?: VenteCreateNestedManyWithoutClientInput
    achats?: AchatCreateNestedManyWithoutClientInput
    reservations?: ReservationCreateNestedManyWithoutClientInput
    commandes?: CommandeCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutPaniersInput = {
    id?: number
    email: string
    nom: string
    postnom?: string | null
    nom_complet?: string | null
    sexe?: $Enums.Sexe | null
    picture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    adresses?: AdresseUncheckedCreateNestedManyWithoutClientInput
    contacts?: ContactUncheckedCreateNestedManyWithoutClientInput
    ventes?: VenteUncheckedCreateNestedManyWithoutClientInput
    achats?: AchatUncheckedCreateNestedManyWithoutClientInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutClientInput
    commandes?: CommandeUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutPaniersInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutPaniersInput, ClientUncheckedCreateWithoutPaniersInput>
  }

  export type DetailPanierCreateWithoutPanierInput = {
    qtte: number
    modePaiement: $Enums.ModePaiment
    prixUnitaire: number
    prixTotalHT: number
    prixTotalTTC: number
    createdAt?: Date | string
    updatedAt?: Date | string
    devise: DeviseCreateNestedOneWithoutDetailPanierInput
    produit: ProduitCreateNestedOneWithoutDetailsPaniersInput
  }

  export type DetailPanierUncheckedCreateWithoutPanierInput = {
    id?: number
    produitId: number
    qtte: number
    modePaiement: $Enums.ModePaiment
    prixUnitaire: number
    prixTotalHT: number
    prixTotalTTC: number
    deviseId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DetailPanierCreateOrConnectWithoutPanierInput = {
    where: DetailPanierWhereUniqueInput
    create: XOR<DetailPanierCreateWithoutPanierInput, DetailPanierUncheckedCreateWithoutPanierInput>
  }

  export type DetailPanierCreateManyPanierInputEnvelope = {
    data: DetailPanierCreateManyPanierInput | DetailPanierCreateManyPanierInput[]
    skipDuplicates?: boolean
  }

  export type AchatCreateWithoutPanierInput = {
    statut?: $Enums.StatutAchat
    createdAt?: Date | string
    updatedAt?: Date | string
    fournisseur: FournisseurCreateNestedOneWithoutAchatsInput
    agent: AgentCreateNestedOneWithoutAchatsInput
    Client?: ClientCreateNestedOneWithoutAchatsInput
    paiements?: PaiementCreateNestedManyWithoutAchatInput
  }

  export type AchatUncheckedCreateWithoutPanierInput = {
    id?: number
    statut?: $Enums.StatutAchat
    fournisseurId: number
    agentId: number
    clientId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    paiements?: PaiementUncheckedCreateNestedManyWithoutAchatInput
  }

  export type AchatCreateOrConnectWithoutPanierInput = {
    where: AchatWhereUniqueInput
    create: XOR<AchatCreateWithoutPanierInput, AchatUncheckedCreateWithoutPanierInput>
  }

  export type AchatCreateManyPanierInputEnvelope = {
    data: AchatCreateManyPanierInput | AchatCreateManyPanierInput[]
    skipDuplicates?: boolean
  }

  export type VenteCreateWithoutPanierInput = {
    statut?: $Enums.StatutVente
    typeAcheteur: $Enums.TypeClient
    enregistrerPar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agent?: AgentCreateNestedOneWithoutVentesInput
    fournisseur?: FournisseurCreateNestedOneWithoutVentesInput
    client?: ClientCreateNestedOneWithoutVentesInput
    paiements?: PaiementCreateNestedManyWithoutVenteInput
  }

  export type VenteUncheckedCreateWithoutPanierInput = {
    id?: number
    statut?: $Enums.StatutVente
    typeAcheteur: $Enums.TypeClient
    clientId?: number | null
    agentId?: number | null
    fournisseurId?: number | null
    enregistrerPar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    paiements?: PaiementUncheckedCreateNestedManyWithoutVenteInput
  }

  export type VenteCreateOrConnectWithoutPanierInput = {
    where: VenteWhereUniqueInput
    create: XOR<VenteCreateWithoutPanierInput, VenteUncheckedCreateWithoutPanierInput>
  }

  export type VenteCreateManyPanierInputEnvelope = {
    data: VenteCreateManyPanierInput | VenteCreateManyPanierInput[]
    skipDuplicates?: boolean
  }

  export type ReservationCreateWithoutPanierInput = {
    dateLivraisonSouhaitee: Date | string
    adresseLivraison?: string | null
    statut?: $Enums.StatutReservation
    notes?: string | null
    typeClient?: $Enums.TypeClient
    nom?: string | null
    tel?: string | null
    enregistrerParId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    fournisseur?: FournisseurCreateNestedOneWithoutReservationsInput
    adresse?: AdresseCreateNestedOneWithoutReservationsInput
    contact?: ContactCreateNestedOneWithoutReservationsInput
    Client?: ClientCreateNestedOneWithoutReservationsInput
  }

  export type ReservationUncheckedCreateWithoutPanierInput = {
    id?: number
    dateLivraisonSouhaitee: Date | string
    adresseLivraison?: string | null
    statut?: $Enums.StatutReservation
    notes?: string | null
    typeClient?: $Enums.TypeClient
    clientId?: number | null
    nom?: string | null
    tel?: string | null
    adresseId?: number | null
    contactId?: number | null
    enregistrerParId?: number | null
    fournisseurId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReservationCreateOrConnectWithoutPanierInput = {
    where: ReservationWhereUniqueInput
    create: XOR<ReservationCreateWithoutPanierInput, ReservationUncheckedCreateWithoutPanierInput>
  }

  export type ReservationCreateManyPanierInputEnvelope = {
    data: ReservationCreateManyPanierInput | ReservationCreateManyPanierInput[]
    skipDuplicates?: boolean
  }

  export type CommandeCreateWithoutPanierInput = {
    nom?: string | null
    tel?: string | null
    type_client?: $Enums.TypeClient
    commandeId?: number | null
    notes?: string | null
    dateLivraisonEffective?: Date | string | null
    adresseLivraison?: string | null
    enregistrerParId?: number | null
    statut?: $Enums.StatutCommande
    createdAt?: Date | string
    updatedAt?: Date | string
    Paiement?: PaiementCreateNestedManyWithoutCommandeInput
    fournisseur?: FournisseurCreateNestedOneWithoutCommandesInput
    adresse?: AdresseCreateNestedOneWithoutCommandesInput
    contact?: ContactCreateNestedOneWithoutCommandesInput
    Client?: ClientCreateNestedOneWithoutCommandesInput
  }

  export type CommandeUncheckedCreateWithoutPanierInput = {
    id?: number
    clientId?: number | null
    nom?: string | null
    tel?: string | null
    type_client?: $Enums.TypeClient
    adresseId?: number | null
    contactId?: number | null
    fournisseurId?: number | null
    commandeId?: number | null
    notes?: string | null
    dateLivraisonEffective?: Date | string | null
    adresseLivraison?: string | null
    enregistrerParId?: number | null
    statut?: $Enums.StatutCommande
    createdAt?: Date | string
    updatedAt?: Date | string
    Paiement?: PaiementUncheckedCreateNestedManyWithoutCommandeInput
  }

  export type CommandeCreateOrConnectWithoutPanierInput = {
    where: CommandeWhereUniqueInput
    create: XOR<CommandeCreateWithoutPanierInput, CommandeUncheckedCreateWithoutPanierInput>
  }

  export type CommandeCreateManyPanierInputEnvelope = {
    data: CommandeCreateManyPanierInput | CommandeCreateManyPanierInput[]
    skipDuplicates?: boolean
  }

  export type AgentUpsertWithoutPaniersInput = {
    update: XOR<AgentUpdateWithoutPaniersInput, AgentUncheckedUpdateWithoutPaniersInput>
    create: XOR<AgentCreateWithoutPaniersInput, AgentUncheckedCreateWithoutPaniersInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutPaniersInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutPaniersInput, AgentUncheckedUpdateWithoutPaniersInput>
  }

  export type AgentUpdateWithoutPaniersInput = {
    email?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    postnom?: NullableStringFieldUpdateOperationsInput | string | null
    nom_complet?: NullableStringFieldUpdateOperationsInput | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    poste?: NullableEnumPosteFieldUpdateOperationsInput | $Enums.Poste | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adresses?: AdresseUpdateManyWithoutAgentNestedInput
    contacts?: ContactUpdateManyWithoutAgentNestedInput
    produits?: ProduitUpdateManyWithoutAgentNestedInput
    ventes?: VenteUpdateManyWithoutAgentNestedInput
    achats?: AchatUpdateManyWithoutAgentNestedInput
    teneurs?: TeneurUpdateManyWithoutAgentsNestedInput
    devises?: DeviseUpdateManyWithoutAgentNestedInput
    caisses?: CaisseUpdateManyWithoutAgentNestedInput
    mouvementCaisses?: MouvementCaisseUpdateManyWithoutAgentNestedInput
    clotureCaisses?: ClotureCaisseUpdateManyWithoutAgentNestedInput
    Fournisseur?: FournisseurUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateWithoutPaniersInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    postnom?: NullableStringFieldUpdateOperationsInput | string | null
    nom_complet?: NullableStringFieldUpdateOperationsInput | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    poste?: NullableEnumPosteFieldUpdateOperationsInput | $Enums.Poste | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adresses?: AdresseUncheckedUpdateManyWithoutAgentNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutAgentNestedInput
    produits?: ProduitUncheckedUpdateManyWithoutAgentNestedInput
    ventes?: VenteUncheckedUpdateManyWithoutAgentNestedInput
    achats?: AchatUncheckedUpdateManyWithoutAgentNestedInput
    teneurs?: TeneurUncheckedUpdateManyWithoutAgentsNestedInput
    devises?: DeviseUncheckedUpdateManyWithoutAgentNestedInput
    caisses?: CaisseUncheckedUpdateManyWithoutAgentNestedInput
    mouvementCaisses?: MouvementCaisseUncheckedUpdateManyWithoutAgentNestedInput
    clotureCaisses?: ClotureCaisseUncheckedUpdateManyWithoutAgentNestedInput
    Fournisseur?: FournisseurUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type ClientUpsertWithoutPaniersInput = {
    update: XOR<ClientUpdateWithoutPaniersInput, ClientUncheckedUpdateWithoutPaniersInput>
    create: XOR<ClientCreateWithoutPaniersInput, ClientUncheckedCreateWithoutPaniersInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutPaniersInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutPaniersInput, ClientUncheckedUpdateWithoutPaniersInput>
  }

  export type ClientUpdateWithoutPaniersInput = {
    email?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    postnom?: NullableStringFieldUpdateOperationsInput | string | null
    nom_complet?: NullableStringFieldUpdateOperationsInput | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adresses?: AdresseUpdateManyWithoutClientNestedInput
    contacts?: ContactUpdateManyWithoutClientNestedInput
    ventes?: VenteUpdateManyWithoutClientNestedInput
    achats?: AchatUpdateManyWithoutClientNestedInput
    reservations?: ReservationUpdateManyWithoutClientNestedInput
    commandes?: CommandeUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutPaniersInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    postnom?: NullableStringFieldUpdateOperationsInput | string | null
    nom_complet?: NullableStringFieldUpdateOperationsInput | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adresses?: AdresseUncheckedUpdateManyWithoutClientNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutClientNestedInput
    ventes?: VenteUncheckedUpdateManyWithoutClientNestedInput
    achats?: AchatUncheckedUpdateManyWithoutClientNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutClientNestedInput
    commandes?: CommandeUncheckedUpdateManyWithoutClientNestedInput
  }

  export type DetailPanierUpsertWithWhereUniqueWithoutPanierInput = {
    where: DetailPanierWhereUniqueInput
    update: XOR<DetailPanierUpdateWithoutPanierInput, DetailPanierUncheckedUpdateWithoutPanierInput>
    create: XOR<DetailPanierCreateWithoutPanierInput, DetailPanierUncheckedCreateWithoutPanierInput>
  }

  export type DetailPanierUpdateWithWhereUniqueWithoutPanierInput = {
    where: DetailPanierWhereUniqueInput
    data: XOR<DetailPanierUpdateWithoutPanierInput, DetailPanierUncheckedUpdateWithoutPanierInput>
  }

  export type DetailPanierUpdateManyWithWhereWithoutPanierInput = {
    where: DetailPanierScalarWhereInput
    data: XOR<DetailPanierUpdateManyMutationInput, DetailPanierUncheckedUpdateManyWithoutPanierInput>
  }

  export type AchatUpsertWithWhereUniqueWithoutPanierInput = {
    where: AchatWhereUniqueInput
    update: XOR<AchatUpdateWithoutPanierInput, AchatUncheckedUpdateWithoutPanierInput>
    create: XOR<AchatCreateWithoutPanierInput, AchatUncheckedCreateWithoutPanierInput>
  }

  export type AchatUpdateWithWhereUniqueWithoutPanierInput = {
    where: AchatWhereUniqueInput
    data: XOR<AchatUpdateWithoutPanierInput, AchatUncheckedUpdateWithoutPanierInput>
  }

  export type AchatUpdateManyWithWhereWithoutPanierInput = {
    where: AchatScalarWhereInput
    data: XOR<AchatUpdateManyMutationInput, AchatUncheckedUpdateManyWithoutPanierInput>
  }

  export type VenteUpsertWithWhereUniqueWithoutPanierInput = {
    where: VenteWhereUniqueInput
    update: XOR<VenteUpdateWithoutPanierInput, VenteUncheckedUpdateWithoutPanierInput>
    create: XOR<VenteCreateWithoutPanierInput, VenteUncheckedCreateWithoutPanierInput>
  }

  export type VenteUpdateWithWhereUniqueWithoutPanierInput = {
    where: VenteWhereUniqueInput
    data: XOR<VenteUpdateWithoutPanierInput, VenteUncheckedUpdateWithoutPanierInput>
  }

  export type VenteUpdateManyWithWhereWithoutPanierInput = {
    where: VenteScalarWhereInput
    data: XOR<VenteUpdateManyMutationInput, VenteUncheckedUpdateManyWithoutPanierInput>
  }

  export type ReservationUpsertWithWhereUniqueWithoutPanierInput = {
    where: ReservationWhereUniqueInput
    update: XOR<ReservationUpdateWithoutPanierInput, ReservationUncheckedUpdateWithoutPanierInput>
    create: XOR<ReservationCreateWithoutPanierInput, ReservationUncheckedCreateWithoutPanierInput>
  }

  export type ReservationUpdateWithWhereUniqueWithoutPanierInput = {
    where: ReservationWhereUniqueInput
    data: XOR<ReservationUpdateWithoutPanierInput, ReservationUncheckedUpdateWithoutPanierInput>
  }

  export type ReservationUpdateManyWithWhereWithoutPanierInput = {
    where: ReservationScalarWhereInput
    data: XOR<ReservationUpdateManyMutationInput, ReservationUncheckedUpdateManyWithoutPanierInput>
  }

  export type CommandeUpsertWithWhereUniqueWithoutPanierInput = {
    where: CommandeWhereUniqueInput
    update: XOR<CommandeUpdateWithoutPanierInput, CommandeUncheckedUpdateWithoutPanierInput>
    create: XOR<CommandeCreateWithoutPanierInput, CommandeUncheckedCreateWithoutPanierInput>
  }

  export type CommandeUpdateWithWhereUniqueWithoutPanierInput = {
    where: CommandeWhereUniqueInput
    data: XOR<CommandeUpdateWithoutPanierInput, CommandeUncheckedUpdateWithoutPanierInput>
  }

  export type CommandeUpdateManyWithWhereWithoutPanierInput = {
    where: CommandeScalarWhereInput
    data: XOR<CommandeUpdateManyMutationInput, CommandeUncheckedUpdateManyWithoutPanierInput>
  }

  export type DeviseCreateWithoutDetailPanierInput = {
    nom: string
    code: string
    symbole: string
    tauxDEchange: number
    createdAt?: Date | string
    updatedAt?: Date | string
    agent: AgentCreateNestedOneWithoutDevisesInput
    produits?: ProduitCreateNestedManyWithoutDeviseInput
    paiements?: PaiementCreateNestedManyWithoutDeviseInput
    caisses?: CaisseCreateNestedManyWithoutDeviseInput
  }

  export type DeviseUncheckedCreateWithoutDetailPanierInput = {
    id?: number
    nom: string
    code: string
    symbole: string
    tauxDEchange: number
    agentId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    produits?: ProduitUncheckedCreateNestedManyWithoutDeviseInput
    paiements?: PaiementUncheckedCreateNestedManyWithoutDeviseInput
    caisses?: CaisseUncheckedCreateNestedManyWithoutDeviseInput
  }

  export type DeviseCreateOrConnectWithoutDetailPanierInput = {
    where: DeviseWhereUniqueInput
    create: XOR<DeviseCreateWithoutDetailPanierInput, DeviseUncheckedCreateWithoutDetailPanierInput>
  }

  export type ProduitCreateWithoutDetailsPaniersInput = {
    designation: string
    prixUnitaire: number
    qtteDisponible?: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agent: AgentCreateNestedOneWithoutProduitsInput
    devise: DeviseCreateNestedOneWithoutProduitsInput
    teneur: TeneurCreateNestedOneWithoutProduitsInput
  }

  export type ProduitUncheckedCreateWithoutDetailsPaniersInput = {
    id?: number
    designation: string
    prixUnitaire: number
    qtteDisponible?: number
    description?: string | null
    deviseId: number
    teneurId: number
    agentId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProduitCreateOrConnectWithoutDetailsPaniersInput = {
    where: ProduitWhereUniqueInput
    create: XOR<ProduitCreateWithoutDetailsPaniersInput, ProduitUncheckedCreateWithoutDetailsPaniersInput>
  }

  export type PanierCreateWithoutDetailPaniersInput = {
    statut?: $Enums.statutPanier
    createdAt?: Date | string
    updatedAt?: Date | string
    agent?: AgentCreateNestedOneWithoutPaniersInput
    client?: ClientCreateNestedOneWithoutPaniersInput
    achats?: AchatCreateNestedManyWithoutPanierInput
    ventes?: VenteCreateNestedManyWithoutPanierInput
    reservations?: ReservationCreateNestedManyWithoutPanierInput
    commandes?: CommandeCreateNestedManyWithoutPanierInput
  }

  export type PanierUncheckedCreateWithoutDetailPaniersInput = {
    id?: number
    agentId?: number | null
    clientId?: number | null
    statut?: $Enums.statutPanier
    createdAt?: Date | string
    updatedAt?: Date | string
    achats?: AchatUncheckedCreateNestedManyWithoutPanierInput
    ventes?: VenteUncheckedCreateNestedManyWithoutPanierInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutPanierInput
    commandes?: CommandeUncheckedCreateNestedManyWithoutPanierInput
  }

  export type PanierCreateOrConnectWithoutDetailPaniersInput = {
    where: PanierWhereUniqueInput
    create: XOR<PanierCreateWithoutDetailPaniersInput, PanierUncheckedCreateWithoutDetailPaniersInput>
  }

  export type DeviseUpsertWithoutDetailPanierInput = {
    update: XOR<DeviseUpdateWithoutDetailPanierInput, DeviseUncheckedUpdateWithoutDetailPanierInput>
    create: XOR<DeviseCreateWithoutDetailPanierInput, DeviseUncheckedCreateWithoutDetailPanierInput>
    where?: DeviseWhereInput
  }

  export type DeviseUpdateToOneWithWhereWithoutDetailPanierInput = {
    where?: DeviseWhereInput
    data: XOR<DeviseUpdateWithoutDetailPanierInput, DeviseUncheckedUpdateWithoutDetailPanierInput>
  }

  export type DeviseUpdateWithoutDetailPanierInput = {
    nom?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    symbole?: StringFieldUpdateOperationsInput | string
    tauxDEchange?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUpdateOneRequiredWithoutDevisesNestedInput
    produits?: ProduitUpdateManyWithoutDeviseNestedInput
    paiements?: PaiementUpdateManyWithoutDeviseNestedInput
    caisses?: CaisseUpdateManyWithoutDeviseNestedInput
  }

  export type DeviseUncheckedUpdateWithoutDetailPanierInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    symbole?: StringFieldUpdateOperationsInput | string
    tauxDEchange?: IntFieldUpdateOperationsInput | number
    agentId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    produits?: ProduitUncheckedUpdateManyWithoutDeviseNestedInput
    paiements?: PaiementUncheckedUpdateManyWithoutDeviseNestedInput
    caisses?: CaisseUncheckedUpdateManyWithoutDeviseNestedInput
  }

  export type ProduitUpsertWithoutDetailsPaniersInput = {
    update: XOR<ProduitUpdateWithoutDetailsPaniersInput, ProduitUncheckedUpdateWithoutDetailsPaniersInput>
    create: XOR<ProduitCreateWithoutDetailsPaniersInput, ProduitUncheckedCreateWithoutDetailsPaniersInput>
    where?: ProduitWhereInput
  }

  export type ProduitUpdateToOneWithWhereWithoutDetailsPaniersInput = {
    where?: ProduitWhereInput
    data: XOR<ProduitUpdateWithoutDetailsPaniersInput, ProduitUncheckedUpdateWithoutDetailsPaniersInput>
  }

  export type ProduitUpdateWithoutDetailsPaniersInput = {
    designation?: StringFieldUpdateOperationsInput | string
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    qtteDisponible?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUpdateOneRequiredWithoutProduitsNestedInput
    devise?: DeviseUpdateOneRequiredWithoutProduitsNestedInput
    teneur?: TeneurUpdateOneRequiredWithoutProduitsNestedInput
  }

  export type ProduitUncheckedUpdateWithoutDetailsPaniersInput = {
    id?: IntFieldUpdateOperationsInput | number
    designation?: StringFieldUpdateOperationsInput | string
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    qtteDisponible?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    deviseId?: IntFieldUpdateOperationsInput | number
    teneurId?: IntFieldUpdateOperationsInput | number
    agentId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PanierUpsertWithoutDetailPaniersInput = {
    update: XOR<PanierUpdateWithoutDetailPaniersInput, PanierUncheckedUpdateWithoutDetailPaniersInput>
    create: XOR<PanierCreateWithoutDetailPaniersInput, PanierUncheckedCreateWithoutDetailPaniersInput>
    where?: PanierWhereInput
  }

  export type PanierUpdateToOneWithWhereWithoutDetailPaniersInput = {
    where?: PanierWhereInput
    data: XOR<PanierUpdateWithoutDetailPaniersInput, PanierUncheckedUpdateWithoutDetailPaniersInput>
  }

  export type PanierUpdateWithoutDetailPaniersInput = {
    statut?: EnumstatutPanierFieldUpdateOperationsInput | $Enums.statutPanier
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUpdateOneWithoutPaniersNestedInput
    client?: ClientUpdateOneWithoutPaniersNestedInput
    achats?: AchatUpdateManyWithoutPanierNestedInput
    ventes?: VenteUpdateManyWithoutPanierNestedInput
    reservations?: ReservationUpdateManyWithoutPanierNestedInput
    commandes?: CommandeUpdateManyWithoutPanierNestedInput
  }

  export type PanierUncheckedUpdateWithoutDetailPaniersInput = {
    id?: IntFieldUpdateOperationsInput | number
    agentId?: NullableIntFieldUpdateOperationsInput | number | null
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    statut?: EnumstatutPanierFieldUpdateOperationsInput | $Enums.statutPanier
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    achats?: AchatUncheckedUpdateManyWithoutPanierNestedInput
    ventes?: VenteUncheckedUpdateManyWithoutPanierNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutPanierNestedInput
    commandes?: CommandeUncheckedUpdateManyWithoutPanierNestedInput
  }

  export type PanierCreateWithoutAchatsInput = {
    statut?: $Enums.statutPanier
    createdAt?: Date | string
    updatedAt?: Date | string
    agent?: AgentCreateNestedOneWithoutPaniersInput
    client?: ClientCreateNestedOneWithoutPaniersInput
    detailPaniers?: DetailPanierCreateNestedManyWithoutPanierInput
    ventes?: VenteCreateNestedManyWithoutPanierInput
    reservations?: ReservationCreateNestedManyWithoutPanierInput
    commandes?: CommandeCreateNestedManyWithoutPanierInput
  }

  export type PanierUncheckedCreateWithoutAchatsInput = {
    id?: number
    agentId?: number | null
    clientId?: number | null
    statut?: $Enums.statutPanier
    createdAt?: Date | string
    updatedAt?: Date | string
    detailPaniers?: DetailPanierUncheckedCreateNestedManyWithoutPanierInput
    ventes?: VenteUncheckedCreateNestedManyWithoutPanierInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutPanierInput
    commandes?: CommandeUncheckedCreateNestedManyWithoutPanierInput
  }

  export type PanierCreateOrConnectWithoutAchatsInput = {
    where: PanierWhereUniqueInput
    create: XOR<PanierCreateWithoutAchatsInput, PanierUncheckedCreateWithoutAchatsInput>
  }

  export type FournisseurCreateWithoutAchatsInput = {
    nom: string
    email: string
    codePostale?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agent: AgentCreateNestedOneWithoutFournisseurInput
    ventes?: VenteCreateNestedManyWithoutFournisseurInput
    adresses?: AdresseCreateNestedManyWithoutFournisseurInput
    contacts?: ContactCreateNestedManyWithoutFournisseurInput
    reservations?: ReservationCreateNestedManyWithoutFournisseurInput
    commandes?: CommandeCreateNestedManyWithoutFournisseurInput
  }

  export type FournisseurUncheckedCreateWithoutAchatsInput = {
    id?: number
    nom: string
    email: string
    codePostale?: string | null
    agentId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    ventes?: VenteUncheckedCreateNestedManyWithoutFournisseurInput
    adresses?: AdresseUncheckedCreateNestedManyWithoutFournisseurInput
    contacts?: ContactUncheckedCreateNestedManyWithoutFournisseurInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutFournisseurInput
    commandes?: CommandeUncheckedCreateNestedManyWithoutFournisseurInput
  }

  export type FournisseurCreateOrConnectWithoutAchatsInput = {
    where: FournisseurWhereUniqueInput
    create: XOR<FournisseurCreateWithoutAchatsInput, FournisseurUncheckedCreateWithoutAchatsInput>
  }

  export type AgentCreateWithoutAchatsInput = {
    email: string
    nom: string
    postnom?: string | null
    nom_complet?: string | null
    sexe?: $Enums.Sexe | null
    role?: $Enums.Role
    poste?: $Enums.Poste | null
    picture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    adresses?: AdresseCreateNestedManyWithoutAgentInput
    contacts?: ContactCreateNestedManyWithoutAgentInput
    produits?: ProduitCreateNestedManyWithoutAgentInput
    ventes?: VenteCreateNestedManyWithoutAgentInput
    teneurs?: TeneurCreateNestedManyWithoutAgentsInput
    devises?: DeviseCreateNestedManyWithoutAgentInput
    paniers?: PanierCreateNestedManyWithoutAgentInput
    caisses?: CaisseCreateNestedManyWithoutAgentInput
    mouvementCaisses?: MouvementCaisseCreateNestedManyWithoutAgentInput
    clotureCaisses?: ClotureCaisseCreateNestedManyWithoutAgentInput
    Fournisseur?: FournisseurCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateWithoutAchatsInput = {
    id?: number
    email: string
    nom: string
    postnom?: string | null
    nom_complet?: string | null
    sexe?: $Enums.Sexe | null
    role?: $Enums.Role
    poste?: $Enums.Poste | null
    picture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    adresses?: AdresseUncheckedCreateNestedManyWithoutAgentInput
    contacts?: ContactUncheckedCreateNestedManyWithoutAgentInput
    produits?: ProduitUncheckedCreateNestedManyWithoutAgentInput
    ventes?: VenteUncheckedCreateNestedManyWithoutAgentInput
    teneurs?: TeneurUncheckedCreateNestedManyWithoutAgentsInput
    devises?: DeviseUncheckedCreateNestedManyWithoutAgentInput
    paniers?: PanierUncheckedCreateNestedManyWithoutAgentInput
    caisses?: CaisseUncheckedCreateNestedManyWithoutAgentInput
    mouvementCaisses?: MouvementCaisseUncheckedCreateNestedManyWithoutAgentInput
    clotureCaisses?: ClotureCaisseUncheckedCreateNestedManyWithoutAgentInput
    Fournisseur?: FournisseurUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentCreateOrConnectWithoutAchatsInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutAchatsInput, AgentUncheckedCreateWithoutAchatsInput>
  }

  export type ClientCreateWithoutAchatsInput = {
    email: string
    nom: string
    postnom?: string | null
    nom_complet?: string | null
    sexe?: $Enums.Sexe | null
    picture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    adresses?: AdresseCreateNestedManyWithoutClientInput
    contacts?: ContactCreateNestedManyWithoutClientInput
    ventes?: VenteCreateNestedManyWithoutClientInput
    paniers?: PanierCreateNestedManyWithoutClientInput
    reservations?: ReservationCreateNestedManyWithoutClientInput
    commandes?: CommandeCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutAchatsInput = {
    id?: number
    email: string
    nom: string
    postnom?: string | null
    nom_complet?: string | null
    sexe?: $Enums.Sexe | null
    picture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    adresses?: AdresseUncheckedCreateNestedManyWithoutClientInput
    contacts?: ContactUncheckedCreateNestedManyWithoutClientInput
    ventes?: VenteUncheckedCreateNestedManyWithoutClientInput
    paniers?: PanierUncheckedCreateNestedManyWithoutClientInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutClientInput
    commandes?: CommandeUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutAchatsInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutAchatsInput, ClientUncheckedCreateWithoutAchatsInput>
  }

  export type PaiementCreateWithoutAchatInput = {
    totalHT?: number | null
    totalTTC?: number | null
    modePaiement: $Enums.ModePaiment
    createdAt?: Date | string
    updatedAt?: Date | string
    vente?: VenteCreateNestedOneWithoutPaiementsInput
    commande?: CommandeCreateNestedOneWithoutPaiementInput
    caisse: CaisseCreateNestedOneWithoutPaiementsInput
    devise: DeviseCreateNestedOneWithoutPaiementsInput
  }

  export type PaiementUncheckedCreateWithoutAchatInput = {
    id?: number
    totalHT?: number | null
    totalTTC?: number | null
    modePaiement: $Enums.ModePaiment
    deviseId: number
    caisseId: number
    venteId?: number | null
    commandeId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaiementCreateOrConnectWithoutAchatInput = {
    where: PaiementWhereUniqueInput
    create: XOR<PaiementCreateWithoutAchatInput, PaiementUncheckedCreateWithoutAchatInput>
  }

  export type PaiementCreateManyAchatInputEnvelope = {
    data: PaiementCreateManyAchatInput | PaiementCreateManyAchatInput[]
    skipDuplicates?: boolean
  }

  export type PanierUpsertWithoutAchatsInput = {
    update: XOR<PanierUpdateWithoutAchatsInput, PanierUncheckedUpdateWithoutAchatsInput>
    create: XOR<PanierCreateWithoutAchatsInput, PanierUncheckedCreateWithoutAchatsInput>
    where?: PanierWhereInput
  }

  export type PanierUpdateToOneWithWhereWithoutAchatsInput = {
    where?: PanierWhereInput
    data: XOR<PanierUpdateWithoutAchatsInput, PanierUncheckedUpdateWithoutAchatsInput>
  }

  export type PanierUpdateWithoutAchatsInput = {
    statut?: EnumstatutPanierFieldUpdateOperationsInput | $Enums.statutPanier
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUpdateOneWithoutPaniersNestedInput
    client?: ClientUpdateOneWithoutPaniersNestedInput
    detailPaniers?: DetailPanierUpdateManyWithoutPanierNestedInput
    ventes?: VenteUpdateManyWithoutPanierNestedInput
    reservations?: ReservationUpdateManyWithoutPanierNestedInput
    commandes?: CommandeUpdateManyWithoutPanierNestedInput
  }

  export type PanierUncheckedUpdateWithoutAchatsInput = {
    id?: IntFieldUpdateOperationsInput | number
    agentId?: NullableIntFieldUpdateOperationsInput | number | null
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    statut?: EnumstatutPanierFieldUpdateOperationsInput | $Enums.statutPanier
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    detailPaniers?: DetailPanierUncheckedUpdateManyWithoutPanierNestedInput
    ventes?: VenteUncheckedUpdateManyWithoutPanierNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutPanierNestedInput
    commandes?: CommandeUncheckedUpdateManyWithoutPanierNestedInput
  }

  export type FournisseurUpsertWithoutAchatsInput = {
    update: XOR<FournisseurUpdateWithoutAchatsInput, FournisseurUncheckedUpdateWithoutAchatsInput>
    create: XOR<FournisseurCreateWithoutAchatsInput, FournisseurUncheckedCreateWithoutAchatsInput>
    where?: FournisseurWhereInput
  }

  export type FournisseurUpdateToOneWithWhereWithoutAchatsInput = {
    where?: FournisseurWhereInput
    data: XOR<FournisseurUpdateWithoutAchatsInput, FournisseurUncheckedUpdateWithoutAchatsInput>
  }

  export type FournisseurUpdateWithoutAchatsInput = {
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    codePostale?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUpdateOneRequiredWithoutFournisseurNestedInput
    ventes?: VenteUpdateManyWithoutFournisseurNestedInput
    adresses?: AdresseUpdateManyWithoutFournisseurNestedInput
    contacts?: ContactUpdateManyWithoutFournisseurNestedInput
    reservations?: ReservationUpdateManyWithoutFournisseurNestedInput
    commandes?: CommandeUpdateManyWithoutFournisseurNestedInput
  }

  export type FournisseurUncheckedUpdateWithoutAchatsInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    codePostale?: NullableStringFieldUpdateOperationsInput | string | null
    agentId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ventes?: VenteUncheckedUpdateManyWithoutFournisseurNestedInput
    adresses?: AdresseUncheckedUpdateManyWithoutFournisseurNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutFournisseurNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutFournisseurNestedInput
    commandes?: CommandeUncheckedUpdateManyWithoutFournisseurNestedInput
  }

  export type AgentUpsertWithoutAchatsInput = {
    update: XOR<AgentUpdateWithoutAchatsInput, AgentUncheckedUpdateWithoutAchatsInput>
    create: XOR<AgentCreateWithoutAchatsInput, AgentUncheckedCreateWithoutAchatsInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutAchatsInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutAchatsInput, AgentUncheckedUpdateWithoutAchatsInput>
  }

  export type AgentUpdateWithoutAchatsInput = {
    email?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    postnom?: NullableStringFieldUpdateOperationsInput | string | null
    nom_complet?: NullableStringFieldUpdateOperationsInput | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    poste?: NullableEnumPosteFieldUpdateOperationsInput | $Enums.Poste | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adresses?: AdresseUpdateManyWithoutAgentNestedInput
    contacts?: ContactUpdateManyWithoutAgentNestedInput
    produits?: ProduitUpdateManyWithoutAgentNestedInput
    ventes?: VenteUpdateManyWithoutAgentNestedInput
    teneurs?: TeneurUpdateManyWithoutAgentsNestedInput
    devises?: DeviseUpdateManyWithoutAgentNestedInput
    paniers?: PanierUpdateManyWithoutAgentNestedInput
    caisses?: CaisseUpdateManyWithoutAgentNestedInput
    mouvementCaisses?: MouvementCaisseUpdateManyWithoutAgentNestedInput
    clotureCaisses?: ClotureCaisseUpdateManyWithoutAgentNestedInput
    Fournisseur?: FournisseurUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateWithoutAchatsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    postnom?: NullableStringFieldUpdateOperationsInput | string | null
    nom_complet?: NullableStringFieldUpdateOperationsInput | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    poste?: NullableEnumPosteFieldUpdateOperationsInput | $Enums.Poste | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adresses?: AdresseUncheckedUpdateManyWithoutAgentNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutAgentNestedInput
    produits?: ProduitUncheckedUpdateManyWithoutAgentNestedInput
    ventes?: VenteUncheckedUpdateManyWithoutAgentNestedInput
    teneurs?: TeneurUncheckedUpdateManyWithoutAgentsNestedInput
    devises?: DeviseUncheckedUpdateManyWithoutAgentNestedInput
    paniers?: PanierUncheckedUpdateManyWithoutAgentNestedInput
    caisses?: CaisseUncheckedUpdateManyWithoutAgentNestedInput
    mouvementCaisses?: MouvementCaisseUncheckedUpdateManyWithoutAgentNestedInput
    clotureCaisses?: ClotureCaisseUncheckedUpdateManyWithoutAgentNestedInput
    Fournisseur?: FournisseurUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type ClientUpsertWithoutAchatsInput = {
    update: XOR<ClientUpdateWithoutAchatsInput, ClientUncheckedUpdateWithoutAchatsInput>
    create: XOR<ClientCreateWithoutAchatsInput, ClientUncheckedCreateWithoutAchatsInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutAchatsInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutAchatsInput, ClientUncheckedUpdateWithoutAchatsInput>
  }

  export type ClientUpdateWithoutAchatsInput = {
    email?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    postnom?: NullableStringFieldUpdateOperationsInput | string | null
    nom_complet?: NullableStringFieldUpdateOperationsInput | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adresses?: AdresseUpdateManyWithoutClientNestedInput
    contacts?: ContactUpdateManyWithoutClientNestedInput
    ventes?: VenteUpdateManyWithoutClientNestedInput
    paniers?: PanierUpdateManyWithoutClientNestedInput
    reservations?: ReservationUpdateManyWithoutClientNestedInput
    commandes?: CommandeUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutAchatsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    postnom?: NullableStringFieldUpdateOperationsInput | string | null
    nom_complet?: NullableStringFieldUpdateOperationsInput | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adresses?: AdresseUncheckedUpdateManyWithoutClientNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutClientNestedInput
    ventes?: VenteUncheckedUpdateManyWithoutClientNestedInput
    paniers?: PanierUncheckedUpdateManyWithoutClientNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutClientNestedInput
    commandes?: CommandeUncheckedUpdateManyWithoutClientNestedInput
  }

  export type PaiementUpsertWithWhereUniqueWithoutAchatInput = {
    where: PaiementWhereUniqueInput
    update: XOR<PaiementUpdateWithoutAchatInput, PaiementUncheckedUpdateWithoutAchatInput>
    create: XOR<PaiementCreateWithoutAchatInput, PaiementUncheckedCreateWithoutAchatInput>
  }

  export type PaiementUpdateWithWhereUniqueWithoutAchatInput = {
    where: PaiementWhereUniqueInput
    data: XOR<PaiementUpdateWithoutAchatInput, PaiementUncheckedUpdateWithoutAchatInput>
  }

  export type PaiementUpdateManyWithWhereWithoutAchatInput = {
    where: PaiementScalarWhereInput
    data: XOR<PaiementUpdateManyMutationInput, PaiementUncheckedUpdateManyWithoutAchatInput>
  }

  export type PanierCreateWithoutReservationsInput = {
    statut?: $Enums.statutPanier
    createdAt?: Date | string
    updatedAt?: Date | string
    agent?: AgentCreateNestedOneWithoutPaniersInput
    client?: ClientCreateNestedOneWithoutPaniersInput
    detailPaniers?: DetailPanierCreateNestedManyWithoutPanierInput
    achats?: AchatCreateNestedManyWithoutPanierInput
    ventes?: VenteCreateNestedManyWithoutPanierInput
    commandes?: CommandeCreateNestedManyWithoutPanierInput
  }

  export type PanierUncheckedCreateWithoutReservationsInput = {
    id?: number
    agentId?: number | null
    clientId?: number | null
    statut?: $Enums.statutPanier
    createdAt?: Date | string
    updatedAt?: Date | string
    detailPaniers?: DetailPanierUncheckedCreateNestedManyWithoutPanierInput
    achats?: AchatUncheckedCreateNestedManyWithoutPanierInput
    ventes?: VenteUncheckedCreateNestedManyWithoutPanierInput
    commandes?: CommandeUncheckedCreateNestedManyWithoutPanierInput
  }

  export type PanierCreateOrConnectWithoutReservationsInput = {
    where: PanierWhereUniqueInput
    create: XOR<PanierCreateWithoutReservationsInput, PanierUncheckedCreateWithoutReservationsInput>
  }

  export type FournisseurCreateWithoutReservationsInput = {
    nom: string
    email: string
    codePostale?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agent: AgentCreateNestedOneWithoutFournisseurInput
    ventes?: VenteCreateNestedManyWithoutFournisseurInput
    achats?: AchatCreateNestedManyWithoutFournisseurInput
    adresses?: AdresseCreateNestedManyWithoutFournisseurInput
    contacts?: ContactCreateNestedManyWithoutFournisseurInput
    commandes?: CommandeCreateNestedManyWithoutFournisseurInput
  }

  export type FournisseurUncheckedCreateWithoutReservationsInput = {
    id?: number
    nom: string
    email: string
    codePostale?: string | null
    agentId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    ventes?: VenteUncheckedCreateNestedManyWithoutFournisseurInput
    achats?: AchatUncheckedCreateNestedManyWithoutFournisseurInput
    adresses?: AdresseUncheckedCreateNestedManyWithoutFournisseurInput
    contacts?: ContactUncheckedCreateNestedManyWithoutFournisseurInput
    commandes?: CommandeUncheckedCreateNestedManyWithoutFournisseurInput
  }

  export type FournisseurCreateOrConnectWithoutReservationsInput = {
    where: FournisseurWhereUniqueInput
    create: XOR<FournisseurCreateWithoutReservationsInput, FournisseurUncheckedCreateWithoutReservationsInput>
  }

  export type AdresseCreateWithoutReservationsInput = {
    ville?: string | null
    adresse: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    agent?: AgentCreateNestedOneWithoutAdressesInput
    entreprise?: EntrepriseCreateNestedOneWithoutAdresseInput
    fournisseur?: FournisseurCreateNestedOneWithoutAdressesInput
    client?: ClientCreateNestedOneWithoutAdressesInput
    commandes?: CommandeCreateNestedManyWithoutAdresseInput
  }

  export type AdresseUncheckedCreateWithoutReservationsInput = {
    id?: number
    ville?: string | null
    adresse: string
    isActive?: boolean
    agentId?: number | null
    fournisseurId?: number | null
    clientId?: number | null
    entrepriseId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    commandes?: CommandeUncheckedCreateNestedManyWithoutAdresseInput
  }

  export type AdresseCreateOrConnectWithoutReservationsInput = {
    where: AdresseWhereUniqueInput
    create: XOR<AdresseCreateWithoutReservationsInput, AdresseUncheckedCreateWithoutReservationsInput>
  }

  export type ContactCreateWithoutReservationsInput = {
    tel: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    entreprise?: EntrepriseCreateNestedOneWithoutContactInput
    client?: ClientCreateNestedOneWithoutContactsInput
    agent?: AgentCreateNestedOneWithoutContactsInput
    fournisseur?: FournisseurCreateNestedOneWithoutContactsInput
    commandes?: CommandeCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutReservationsInput = {
    id?: number
    tel: string
    isActive?: boolean
    agentId?: number | null
    fournisseurId?: number | null
    clientId?: number | null
    entrepriseId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    commandes?: CommandeUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutReservationsInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutReservationsInput, ContactUncheckedCreateWithoutReservationsInput>
  }

  export type ClientCreateWithoutReservationsInput = {
    email: string
    nom: string
    postnom?: string | null
    nom_complet?: string | null
    sexe?: $Enums.Sexe | null
    picture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    adresses?: AdresseCreateNestedManyWithoutClientInput
    contacts?: ContactCreateNestedManyWithoutClientInput
    ventes?: VenteCreateNestedManyWithoutClientInput
    achats?: AchatCreateNestedManyWithoutClientInput
    paniers?: PanierCreateNestedManyWithoutClientInput
    commandes?: CommandeCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutReservationsInput = {
    id?: number
    email: string
    nom: string
    postnom?: string | null
    nom_complet?: string | null
    sexe?: $Enums.Sexe | null
    picture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    adresses?: AdresseUncheckedCreateNestedManyWithoutClientInput
    contacts?: ContactUncheckedCreateNestedManyWithoutClientInput
    ventes?: VenteUncheckedCreateNestedManyWithoutClientInput
    achats?: AchatUncheckedCreateNestedManyWithoutClientInput
    paniers?: PanierUncheckedCreateNestedManyWithoutClientInput
    commandes?: CommandeUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutReservationsInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutReservationsInput, ClientUncheckedCreateWithoutReservationsInput>
  }

  export type PanierUpsertWithoutReservationsInput = {
    update: XOR<PanierUpdateWithoutReservationsInput, PanierUncheckedUpdateWithoutReservationsInput>
    create: XOR<PanierCreateWithoutReservationsInput, PanierUncheckedCreateWithoutReservationsInput>
    where?: PanierWhereInput
  }

  export type PanierUpdateToOneWithWhereWithoutReservationsInput = {
    where?: PanierWhereInput
    data: XOR<PanierUpdateWithoutReservationsInput, PanierUncheckedUpdateWithoutReservationsInput>
  }

  export type PanierUpdateWithoutReservationsInput = {
    statut?: EnumstatutPanierFieldUpdateOperationsInput | $Enums.statutPanier
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUpdateOneWithoutPaniersNestedInput
    client?: ClientUpdateOneWithoutPaniersNestedInput
    detailPaniers?: DetailPanierUpdateManyWithoutPanierNestedInput
    achats?: AchatUpdateManyWithoutPanierNestedInput
    ventes?: VenteUpdateManyWithoutPanierNestedInput
    commandes?: CommandeUpdateManyWithoutPanierNestedInput
  }

  export type PanierUncheckedUpdateWithoutReservationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    agentId?: NullableIntFieldUpdateOperationsInput | number | null
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    statut?: EnumstatutPanierFieldUpdateOperationsInput | $Enums.statutPanier
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    detailPaniers?: DetailPanierUncheckedUpdateManyWithoutPanierNestedInput
    achats?: AchatUncheckedUpdateManyWithoutPanierNestedInput
    ventes?: VenteUncheckedUpdateManyWithoutPanierNestedInput
    commandes?: CommandeUncheckedUpdateManyWithoutPanierNestedInput
  }

  export type FournisseurUpsertWithoutReservationsInput = {
    update: XOR<FournisseurUpdateWithoutReservationsInput, FournisseurUncheckedUpdateWithoutReservationsInput>
    create: XOR<FournisseurCreateWithoutReservationsInput, FournisseurUncheckedCreateWithoutReservationsInput>
    where?: FournisseurWhereInput
  }

  export type FournisseurUpdateToOneWithWhereWithoutReservationsInput = {
    where?: FournisseurWhereInput
    data: XOR<FournisseurUpdateWithoutReservationsInput, FournisseurUncheckedUpdateWithoutReservationsInput>
  }

  export type FournisseurUpdateWithoutReservationsInput = {
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    codePostale?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUpdateOneRequiredWithoutFournisseurNestedInput
    ventes?: VenteUpdateManyWithoutFournisseurNestedInput
    achats?: AchatUpdateManyWithoutFournisseurNestedInput
    adresses?: AdresseUpdateManyWithoutFournisseurNestedInput
    contacts?: ContactUpdateManyWithoutFournisseurNestedInput
    commandes?: CommandeUpdateManyWithoutFournisseurNestedInput
  }

  export type FournisseurUncheckedUpdateWithoutReservationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    codePostale?: NullableStringFieldUpdateOperationsInput | string | null
    agentId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ventes?: VenteUncheckedUpdateManyWithoutFournisseurNestedInput
    achats?: AchatUncheckedUpdateManyWithoutFournisseurNestedInput
    adresses?: AdresseUncheckedUpdateManyWithoutFournisseurNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutFournisseurNestedInput
    commandes?: CommandeUncheckedUpdateManyWithoutFournisseurNestedInput
  }

  export type AdresseUpsertWithoutReservationsInput = {
    update: XOR<AdresseUpdateWithoutReservationsInput, AdresseUncheckedUpdateWithoutReservationsInput>
    create: XOR<AdresseCreateWithoutReservationsInput, AdresseUncheckedCreateWithoutReservationsInput>
    where?: AdresseWhereInput
  }

  export type AdresseUpdateToOneWithWhereWithoutReservationsInput = {
    where?: AdresseWhereInput
    data: XOR<AdresseUpdateWithoutReservationsInput, AdresseUncheckedUpdateWithoutReservationsInput>
  }

  export type AdresseUpdateWithoutReservationsInput = {
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUpdateOneWithoutAdressesNestedInput
    entreprise?: EntrepriseUpdateOneWithoutAdresseNestedInput
    fournisseur?: FournisseurUpdateOneWithoutAdressesNestedInput
    client?: ClientUpdateOneWithoutAdressesNestedInput
    commandes?: CommandeUpdateManyWithoutAdresseNestedInput
  }

  export type AdresseUncheckedUpdateWithoutReservationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    agentId?: NullableIntFieldUpdateOperationsInput | number | null
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    entrepriseId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commandes?: CommandeUncheckedUpdateManyWithoutAdresseNestedInput
  }

  export type ContactUpsertWithoutReservationsInput = {
    update: XOR<ContactUpdateWithoutReservationsInput, ContactUncheckedUpdateWithoutReservationsInput>
    create: XOR<ContactCreateWithoutReservationsInput, ContactUncheckedCreateWithoutReservationsInput>
    where?: ContactWhereInput
  }

  export type ContactUpdateToOneWithWhereWithoutReservationsInput = {
    where?: ContactWhereInput
    data: XOR<ContactUpdateWithoutReservationsInput, ContactUncheckedUpdateWithoutReservationsInput>
  }

  export type ContactUpdateWithoutReservationsInput = {
    tel?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entreprise?: EntrepriseUpdateOneWithoutContactNestedInput
    client?: ClientUpdateOneWithoutContactsNestedInput
    agent?: AgentUpdateOneWithoutContactsNestedInput
    fournisseur?: FournisseurUpdateOneWithoutContactsNestedInput
    commandes?: CommandeUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutReservationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    tel?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    agentId?: NullableIntFieldUpdateOperationsInput | number | null
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    entrepriseId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commandes?: CommandeUncheckedUpdateManyWithoutContactNestedInput
  }

  export type ClientUpsertWithoutReservationsInput = {
    update: XOR<ClientUpdateWithoutReservationsInput, ClientUncheckedUpdateWithoutReservationsInput>
    create: XOR<ClientCreateWithoutReservationsInput, ClientUncheckedCreateWithoutReservationsInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutReservationsInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutReservationsInput, ClientUncheckedUpdateWithoutReservationsInput>
  }

  export type ClientUpdateWithoutReservationsInput = {
    email?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    postnom?: NullableStringFieldUpdateOperationsInput | string | null
    nom_complet?: NullableStringFieldUpdateOperationsInput | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adresses?: AdresseUpdateManyWithoutClientNestedInput
    contacts?: ContactUpdateManyWithoutClientNestedInput
    ventes?: VenteUpdateManyWithoutClientNestedInput
    achats?: AchatUpdateManyWithoutClientNestedInput
    paniers?: PanierUpdateManyWithoutClientNestedInput
    commandes?: CommandeUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutReservationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    postnom?: NullableStringFieldUpdateOperationsInput | string | null
    nom_complet?: NullableStringFieldUpdateOperationsInput | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adresses?: AdresseUncheckedUpdateManyWithoutClientNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutClientNestedInput
    ventes?: VenteUncheckedUpdateManyWithoutClientNestedInput
    achats?: AchatUncheckedUpdateManyWithoutClientNestedInput
    paniers?: PanierUncheckedUpdateManyWithoutClientNestedInput
    commandes?: CommandeUncheckedUpdateManyWithoutClientNestedInput
  }

  export type PaiementCreateWithoutCommandeInput = {
    totalHT?: number | null
    totalTTC?: number | null
    modePaiement: $Enums.ModePaiment
    createdAt?: Date | string
    updatedAt?: Date | string
    vente?: VenteCreateNestedOneWithoutPaiementsInput
    achat?: AchatCreateNestedOneWithoutPaiementsInput
    caisse: CaisseCreateNestedOneWithoutPaiementsInput
    devise: DeviseCreateNestedOneWithoutPaiementsInput
  }

  export type PaiementUncheckedCreateWithoutCommandeInput = {
    id?: number
    totalHT?: number | null
    totalTTC?: number | null
    modePaiement: $Enums.ModePaiment
    deviseId: number
    caisseId: number
    venteId?: number | null
    achatId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaiementCreateOrConnectWithoutCommandeInput = {
    where: PaiementWhereUniqueInput
    create: XOR<PaiementCreateWithoutCommandeInput, PaiementUncheckedCreateWithoutCommandeInput>
  }

  export type PaiementCreateManyCommandeInputEnvelope = {
    data: PaiementCreateManyCommandeInput | PaiementCreateManyCommandeInput[]
    skipDuplicates?: boolean
  }

  export type PanierCreateWithoutCommandesInput = {
    statut?: $Enums.statutPanier
    createdAt?: Date | string
    updatedAt?: Date | string
    agent?: AgentCreateNestedOneWithoutPaniersInput
    client?: ClientCreateNestedOneWithoutPaniersInput
    detailPaniers?: DetailPanierCreateNestedManyWithoutPanierInput
    achats?: AchatCreateNestedManyWithoutPanierInput
    ventes?: VenteCreateNestedManyWithoutPanierInput
    reservations?: ReservationCreateNestedManyWithoutPanierInput
  }

  export type PanierUncheckedCreateWithoutCommandesInput = {
    id?: number
    agentId?: number | null
    clientId?: number | null
    statut?: $Enums.statutPanier
    createdAt?: Date | string
    updatedAt?: Date | string
    detailPaniers?: DetailPanierUncheckedCreateNestedManyWithoutPanierInput
    achats?: AchatUncheckedCreateNestedManyWithoutPanierInput
    ventes?: VenteUncheckedCreateNestedManyWithoutPanierInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutPanierInput
  }

  export type PanierCreateOrConnectWithoutCommandesInput = {
    where: PanierWhereUniqueInput
    create: XOR<PanierCreateWithoutCommandesInput, PanierUncheckedCreateWithoutCommandesInput>
  }

  export type FournisseurCreateWithoutCommandesInput = {
    nom: string
    email: string
    codePostale?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agent: AgentCreateNestedOneWithoutFournisseurInput
    ventes?: VenteCreateNestedManyWithoutFournisseurInput
    achats?: AchatCreateNestedManyWithoutFournisseurInput
    adresses?: AdresseCreateNestedManyWithoutFournisseurInput
    contacts?: ContactCreateNestedManyWithoutFournisseurInput
    reservations?: ReservationCreateNestedManyWithoutFournisseurInput
  }

  export type FournisseurUncheckedCreateWithoutCommandesInput = {
    id?: number
    nom: string
    email: string
    codePostale?: string | null
    agentId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    ventes?: VenteUncheckedCreateNestedManyWithoutFournisseurInput
    achats?: AchatUncheckedCreateNestedManyWithoutFournisseurInput
    adresses?: AdresseUncheckedCreateNestedManyWithoutFournisseurInput
    contacts?: ContactUncheckedCreateNestedManyWithoutFournisseurInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutFournisseurInput
  }

  export type FournisseurCreateOrConnectWithoutCommandesInput = {
    where: FournisseurWhereUniqueInput
    create: XOR<FournisseurCreateWithoutCommandesInput, FournisseurUncheckedCreateWithoutCommandesInput>
  }

  export type AdresseCreateWithoutCommandesInput = {
    ville?: string | null
    adresse: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    agent?: AgentCreateNestedOneWithoutAdressesInput
    entreprise?: EntrepriseCreateNestedOneWithoutAdresseInput
    fournisseur?: FournisseurCreateNestedOneWithoutAdressesInput
    client?: ClientCreateNestedOneWithoutAdressesInput
    reservations?: ReservationCreateNestedManyWithoutAdresseInput
  }

  export type AdresseUncheckedCreateWithoutCommandesInput = {
    id?: number
    ville?: string | null
    adresse: string
    isActive?: boolean
    agentId?: number | null
    fournisseurId?: number | null
    clientId?: number | null
    entrepriseId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reservations?: ReservationUncheckedCreateNestedManyWithoutAdresseInput
  }

  export type AdresseCreateOrConnectWithoutCommandesInput = {
    where: AdresseWhereUniqueInput
    create: XOR<AdresseCreateWithoutCommandesInput, AdresseUncheckedCreateWithoutCommandesInput>
  }

  export type ContactCreateWithoutCommandesInput = {
    tel: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    entreprise?: EntrepriseCreateNestedOneWithoutContactInput
    client?: ClientCreateNestedOneWithoutContactsInput
    agent?: AgentCreateNestedOneWithoutContactsInput
    fournisseur?: FournisseurCreateNestedOneWithoutContactsInput
    reservations?: ReservationCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutCommandesInput = {
    id?: number
    tel: string
    isActive?: boolean
    agentId?: number | null
    fournisseurId?: number | null
    clientId?: number | null
    entrepriseId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reservations?: ReservationUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutCommandesInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutCommandesInput, ContactUncheckedCreateWithoutCommandesInput>
  }

  export type ClientCreateWithoutCommandesInput = {
    email: string
    nom: string
    postnom?: string | null
    nom_complet?: string | null
    sexe?: $Enums.Sexe | null
    picture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    adresses?: AdresseCreateNestedManyWithoutClientInput
    contacts?: ContactCreateNestedManyWithoutClientInput
    ventes?: VenteCreateNestedManyWithoutClientInput
    achats?: AchatCreateNestedManyWithoutClientInput
    paniers?: PanierCreateNestedManyWithoutClientInput
    reservations?: ReservationCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutCommandesInput = {
    id?: number
    email: string
    nom: string
    postnom?: string | null
    nom_complet?: string | null
    sexe?: $Enums.Sexe | null
    picture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    adresses?: AdresseUncheckedCreateNestedManyWithoutClientInput
    contacts?: ContactUncheckedCreateNestedManyWithoutClientInput
    ventes?: VenteUncheckedCreateNestedManyWithoutClientInput
    achats?: AchatUncheckedCreateNestedManyWithoutClientInput
    paniers?: PanierUncheckedCreateNestedManyWithoutClientInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutCommandesInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutCommandesInput, ClientUncheckedCreateWithoutCommandesInput>
  }

  export type PaiementUpsertWithWhereUniqueWithoutCommandeInput = {
    where: PaiementWhereUniqueInput
    update: XOR<PaiementUpdateWithoutCommandeInput, PaiementUncheckedUpdateWithoutCommandeInput>
    create: XOR<PaiementCreateWithoutCommandeInput, PaiementUncheckedCreateWithoutCommandeInput>
  }

  export type PaiementUpdateWithWhereUniqueWithoutCommandeInput = {
    where: PaiementWhereUniqueInput
    data: XOR<PaiementUpdateWithoutCommandeInput, PaiementUncheckedUpdateWithoutCommandeInput>
  }

  export type PaiementUpdateManyWithWhereWithoutCommandeInput = {
    where: PaiementScalarWhereInput
    data: XOR<PaiementUpdateManyMutationInput, PaiementUncheckedUpdateManyWithoutCommandeInput>
  }

  export type PanierUpsertWithoutCommandesInput = {
    update: XOR<PanierUpdateWithoutCommandesInput, PanierUncheckedUpdateWithoutCommandesInput>
    create: XOR<PanierCreateWithoutCommandesInput, PanierUncheckedCreateWithoutCommandesInput>
    where?: PanierWhereInput
  }

  export type PanierUpdateToOneWithWhereWithoutCommandesInput = {
    where?: PanierWhereInput
    data: XOR<PanierUpdateWithoutCommandesInput, PanierUncheckedUpdateWithoutCommandesInput>
  }

  export type PanierUpdateWithoutCommandesInput = {
    statut?: EnumstatutPanierFieldUpdateOperationsInput | $Enums.statutPanier
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUpdateOneWithoutPaniersNestedInput
    client?: ClientUpdateOneWithoutPaniersNestedInput
    detailPaniers?: DetailPanierUpdateManyWithoutPanierNestedInput
    achats?: AchatUpdateManyWithoutPanierNestedInput
    ventes?: VenteUpdateManyWithoutPanierNestedInput
    reservations?: ReservationUpdateManyWithoutPanierNestedInput
  }

  export type PanierUncheckedUpdateWithoutCommandesInput = {
    id?: IntFieldUpdateOperationsInput | number
    agentId?: NullableIntFieldUpdateOperationsInput | number | null
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    statut?: EnumstatutPanierFieldUpdateOperationsInput | $Enums.statutPanier
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    detailPaniers?: DetailPanierUncheckedUpdateManyWithoutPanierNestedInput
    achats?: AchatUncheckedUpdateManyWithoutPanierNestedInput
    ventes?: VenteUncheckedUpdateManyWithoutPanierNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutPanierNestedInput
  }

  export type FournisseurUpsertWithoutCommandesInput = {
    update: XOR<FournisseurUpdateWithoutCommandesInput, FournisseurUncheckedUpdateWithoutCommandesInput>
    create: XOR<FournisseurCreateWithoutCommandesInput, FournisseurUncheckedCreateWithoutCommandesInput>
    where?: FournisseurWhereInput
  }

  export type FournisseurUpdateToOneWithWhereWithoutCommandesInput = {
    where?: FournisseurWhereInput
    data: XOR<FournisseurUpdateWithoutCommandesInput, FournisseurUncheckedUpdateWithoutCommandesInput>
  }

  export type FournisseurUpdateWithoutCommandesInput = {
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    codePostale?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUpdateOneRequiredWithoutFournisseurNestedInput
    ventes?: VenteUpdateManyWithoutFournisseurNestedInput
    achats?: AchatUpdateManyWithoutFournisseurNestedInput
    adresses?: AdresseUpdateManyWithoutFournisseurNestedInput
    contacts?: ContactUpdateManyWithoutFournisseurNestedInput
    reservations?: ReservationUpdateManyWithoutFournisseurNestedInput
  }

  export type FournisseurUncheckedUpdateWithoutCommandesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    codePostale?: NullableStringFieldUpdateOperationsInput | string | null
    agentId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ventes?: VenteUncheckedUpdateManyWithoutFournisseurNestedInput
    achats?: AchatUncheckedUpdateManyWithoutFournisseurNestedInput
    adresses?: AdresseUncheckedUpdateManyWithoutFournisseurNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutFournisseurNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutFournisseurNestedInput
  }

  export type AdresseUpsertWithoutCommandesInput = {
    update: XOR<AdresseUpdateWithoutCommandesInput, AdresseUncheckedUpdateWithoutCommandesInput>
    create: XOR<AdresseCreateWithoutCommandesInput, AdresseUncheckedCreateWithoutCommandesInput>
    where?: AdresseWhereInput
  }

  export type AdresseUpdateToOneWithWhereWithoutCommandesInput = {
    where?: AdresseWhereInput
    data: XOR<AdresseUpdateWithoutCommandesInput, AdresseUncheckedUpdateWithoutCommandesInput>
  }

  export type AdresseUpdateWithoutCommandesInput = {
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUpdateOneWithoutAdressesNestedInput
    entreprise?: EntrepriseUpdateOneWithoutAdresseNestedInput
    fournisseur?: FournisseurUpdateOneWithoutAdressesNestedInput
    client?: ClientUpdateOneWithoutAdressesNestedInput
    reservations?: ReservationUpdateManyWithoutAdresseNestedInput
  }

  export type AdresseUncheckedUpdateWithoutCommandesInput = {
    id?: IntFieldUpdateOperationsInput | number
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    agentId?: NullableIntFieldUpdateOperationsInput | number | null
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    entrepriseId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reservations?: ReservationUncheckedUpdateManyWithoutAdresseNestedInput
  }

  export type ContactUpsertWithoutCommandesInput = {
    update: XOR<ContactUpdateWithoutCommandesInput, ContactUncheckedUpdateWithoutCommandesInput>
    create: XOR<ContactCreateWithoutCommandesInput, ContactUncheckedCreateWithoutCommandesInput>
    where?: ContactWhereInput
  }

  export type ContactUpdateToOneWithWhereWithoutCommandesInput = {
    where?: ContactWhereInput
    data: XOR<ContactUpdateWithoutCommandesInput, ContactUncheckedUpdateWithoutCommandesInput>
  }

  export type ContactUpdateWithoutCommandesInput = {
    tel?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entreprise?: EntrepriseUpdateOneWithoutContactNestedInput
    client?: ClientUpdateOneWithoutContactsNestedInput
    agent?: AgentUpdateOneWithoutContactsNestedInput
    fournisseur?: FournisseurUpdateOneWithoutContactsNestedInput
    reservations?: ReservationUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutCommandesInput = {
    id?: IntFieldUpdateOperationsInput | number
    tel?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    agentId?: NullableIntFieldUpdateOperationsInput | number | null
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    entrepriseId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reservations?: ReservationUncheckedUpdateManyWithoutContactNestedInput
  }

  export type ClientUpsertWithoutCommandesInput = {
    update: XOR<ClientUpdateWithoutCommandesInput, ClientUncheckedUpdateWithoutCommandesInput>
    create: XOR<ClientCreateWithoutCommandesInput, ClientUncheckedCreateWithoutCommandesInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutCommandesInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutCommandesInput, ClientUncheckedUpdateWithoutCommandesInput>
  }

  export type ClientUpdateWithoutCommandesInput = {
    email?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    postnom?: NullableStringFieldUpdateOperationsInput | string | null
    nom_complet?: NullableStringFieldUpdateOperationsInput | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adresses?: AdresseUpdateManyWithoutClientNestedInput
    contacts?: ContactUpdateManyWithoutClientNestedInput
    ventes?: VenteUpdateManyWithoutClientNestedInput
    achats?: AchatUpdateManyWithoutClientNestedInput
    paniers?: PanierUpdateManyWithoutClientNestedInput
    reservations?: ReservationUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutCommandesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    postnom?: NullableStringFieldUpdateOperationsInput | string | null
    nom_complet?: NullableStringFieldUpdateOperationsInput | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adresses?: AdresseUncheckedUpdateManyWithoutClientNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutClientNestedInput
    ventes?: VenteUncheckedUpdateManyWithoutClientNestedInput
    achats?: AchatUncheckedUpdateManyWithoutClientNestedInput
    paniers?: PanierUncheckedUpdateManyWithoutClientNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutClientNestedInput
  }

  export type AgentCreateWithoutClotureCaissesInput = {
    email: string
    nom: string
    postnom?: string | null
    nom_complet?: string | null
    sexe?: $Enums.Sexe | null
    role?: $Enums.Role
    poste?: $Enums.Poste | null
    picture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    adresses?: AdresseCreateNestedManyWithoutAgentInput
    contacts?: ContactCreateNestedManyWithoutAgentInput
    produits?: ProduitCreateNestedManyWithoutAgentInput
    ventes?: VenteCreateNestedManyWithoutAgentInput
    achats?: AchatCreateNestedManyWithoutAgentInput
    teneurs?: TeneurCreateNestedManyWithoutAgentsInput
    devises?: DeviseCreateNestedManyWithoutAgentInput
    paniers?: PanierCreateNestedManyWithoutAgentInput
    caisses?: CaisseCreateNestedManyWithoutAgentInput
    mouvementCaisses?: MouvementCaisseCreateNestedManyWithoutAgentInput
    Fournisseur?: FournisseurCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateWithoutClotureCaissesInput = {
    id?: number
    email: string
    nom: string
    postnom?: string | null
    nom_complet?: string | null
    sexe?: $Enums.Sexe | null
    role?: $Enums.Role
    poste?: $Enums.Poste | null
    picture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    adresses?: AdresseUncheckedCreateNestedManyWithoutAgentInput
    contacts?: ContactUncheckedCreateNestedManyWithoutAgentInput
    produits?: ProduitUncheckedCreateNestedManyWithoutAgentInput
    ventes?: VenteUncheckedCreateNestedManyWithoutAgentInput
    achats?: AchatUncheckedCreateNestedManyWithoutAgentInput
    teneurs?: TeneurUncheckedCreateNestedManyWithoutAgentsInput
    devises?: DeviseUncheckedCreateNestedManyWithoutAgentInput
    paniers?: PanierUncheckedCreateNestedManyWithoutAgentInput
    caisses?: CaisseUncheckedCreateNestedManyWithoutAgentInput
    mouvementCaisses?: MouvementCaisseUncheckedCreateNestedManyWithoutAgentInput
    Fournisseur?: FournisseurUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentCreateOrConnectWithoutClotureCaissesInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutClotureCaissesInput, AgentUncheckedCreateWithoutClotureCaissesInput>
  }

  export type EntrepriseCreateWithoutClotureCaissesInput = {
    nom: string
    email: string
    encronyme: string
    codePostale: string
    site?: string | null
    description?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Adresse?: AdresseCreateNestedManyWithoutEntrepriseInput
    Contact?: ContactCreateNestedManyWithoutEntrepriseInput
  }

  export type EntrepriseUncheckedCreateWithoutClotureCaissesInput = {
    id?: number
    nom: string
    email: string
    encronyme: string
    codePostale: string
    site?: string | null
    description?: string | null
    logo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Adresse?: AdresseUncheckedCreateNestedManyWithoutEntrepriseInput
    Contact?: ContactUncheckedCreateNestedManyWithoutEntrepriseInput
  }

  export type EntrepriseCreateOrConnectWithoutClotureCaissesInput = {
    where: EntrepriseWhereUniqueInput
    create: XOR<EntrepriseCreateWithoutClotureCaissesInput, EntrepriseUncheckedCreateWithoutClotureCaissesInput>
  }

  export type AgentUpsertWithoutClotureCaissesInput = {
    update: XOR<AgentUpdateWithoutClotureCaissesInput, AgentUncheckedUpdateWithoutClotureCaissesInput>
    create: XOR<AgentCreateWithoutClotureCaissesInput, AgentUncheckedCreateWithoutClotureCaissesInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutClotureCaissesInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutClotureCaissesInput, AgentUncheckedUpdateWithoutClotureCaissesInput>
  }

  export type AgentUpdateWithoutClotureCaissesInput = {
    email?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    postnom?: NullableStringFieldUpdateOperationsInput | string | null
    nom_complet?: NullableStringFieldUpdateOperationsInput | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    poste?: NullableEnumPosteFieldUpdateOperationsInput | $Enums.Poste | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adresses?: AdresseUpdateManyWithoutAgentNestedInput
    contacts?: ContactUpdateManyWithoutAgentNestedInput
    produits?: ProduitUpdateManyWithoutAgentNestedInput
    ventes?: VenteUpdateManyWithoutAgentNestedInput
    achats?: AchatUpdateManyWithoutAgentNestedInput
    teneurs?: TeneurUpdateManyWithoutAgentsNestedInput
    devises?: DeviseUpdateManyWithoutAgentNestedInput
    paniers?: PanierUpdateManyWithoutAgentNestedInput
    caisses?: CaisseUpdateManyWithoutAgentNestedInput
    mouvementCaisses?: MouvementCaisseUpdateManyWithoutAgentNestedInput
    Fournisseur?: FournisseurUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateWithoutClotureCaissesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    postnom?: NullableStringFieldUpdateOperationsInput | string | null
    nom_complet?: NullableStringFieldUpdateOperationsInput | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    poste?: NullableEnumPosteFieldUpdateOperationsInput | $Enums.Poste | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adresses?: AdresseUncheckedUpdateManyWithoutAgentNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutAgentNestedInput
    produits?: ProduitUncheckedUpdateManyWithoutAgentNestedInput
    ventes?: VenteUncheckedUpdateManyWithoutAgentNestedInput
    achats?: AchatUncheckedUpdateManyWithoutAgentNestedInput
    teneurs?: TeneurUncheckedUpdateManyWithoutAgentsNestedInput
    devises?: DeviseUncheckedUpdateManyWithoutAgentNestedInput
    paniers?: PanierUncheckedUpdateManyWithoutAgentNestedInput
    caisses?: CaisseUncheckedUpdateManyWithoutAgentNestedInput
    mouvementCaisses?: MouvementCaisseUncheckedUpdateManyWithoutAgentNestedInput
    Fournisseur?: FournisseurUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type EntrepriseUpsertWithoutClotureCaissesInput = {
    update: XOR<EntrepriseUpdateWithoutClotureCaissesInput, EntrepriseUncheckedUpdateWithoutClotureCaissesInput>
    create: XOR<EntrepriseCreateWithoutClotureCaissesInput, EntrepriseUncheckedCreateWithoutClotureCaissesInput>
    where?: EntrepriseWhereInput
  }

  export type EntrepriseUpdateToOneWithWhereWithoutClotureCaissesInput = {
    where?: EntrepriseWhereInput
    data: XOR<EntrepriseUpdateWithoutClotureCaissesInput, EntrepriseUncheckedUpdateWithoutClotureCaissesInput>
  }

  export type EntrepriseUpdateWithoutClotureCaissesInput = {
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    encronyme?: StringFieldUpdateOperationsInput | string
    codePostale?: StringFieldUpdateOperationsInput | string
    site?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Adresse?: AdresseUpdateManyWithoutEntrepriseNestedInput
    Contact?: ContactUpdateManyWithoutEntrepriseNestedInput
  }

  export type EntrepriseUncheckedUpdateWithoutClotureCaissesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    encronyme?: StringFieldUpdateOperationsInput | string
    codePostale?: StringFieldUpdateOperationsInput | string
    site?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Adresse?: AdresseUncheckedUpdateManyWithoutEntrepriseNestedInput
    Contact?: ContactUncheckedUpdateManyWithoutEntrepriseNestedInput
  }

  export type CaisseCreateWithoutMouvementCaissesInput = {
    nom: string
    description?: string | null
    soldeActuel?: number | null
    statut?: $Enums.StatutCaisse
    createdAt?: Date | string
    updatedAt?: Date | string
    devise: DeviseCreateNestedOneWithoutCaissesInput
    agent: AgentCreateNestedOneWithoutCaissesInput
    paiements?: PaiementCreateNestedManyWithoutCaisseInput
  }

  export type CaisseUncheckedCreateWithoutMouvementCaissesInput = {
    id?: number
    nom: string
    description?: string | null
    soldeActuel?: number | null
    deviseId: number
    agentId: number
    statut?: $Enums.StatutCaisse
    createdAt?: Date | string
    updatedAt?: Date | string
    paiements?: PaiementUncheckedCreateNestedManyWithoutCaisseInput
  }

  export type CaisseCreateOrConnectWithoutMouvementCaissesInput = {
    where: CaisseWhereUniqueInput
    create: XOR<CaisseCreateWithoutMouvementCaissesInput, CaisseUncheckedCreateWithoutMouvementCaissesInput>
  }

  export type AgentCreateWithoutMouvementCaissesInput = {
    email: string
    nom: string
    postnom?: string | null
    nom_complet?: string | null
    sexe?: $Enums.Sexe | null
    role?: $Enums.Role
    poste?: $Enums.Poste | null
    picture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    adresses?: AdresseCreateNestedManyWithoutAgentInput
    contacts?: ContactCreateNestedManyWithoutAgentInput
    produits?: ProduitCreateNestedManyWithoutAgentInput
    ventes?: VenteCreateNestedManyWithoutAgentInput
    achats?: AchatCreateNestedManyWithoutAgentInput
    teneurs?: TeneurCreateNestedManyWithoutAgentsInput
    devises?: DeviseCreateNestedManyWithoutAgentInput
    paniers?: PanierCreateNestedManyWithoutAgentInput
    caisses?: CaisseCreateNestedManyWithoutAgentInput
    clotureCaisses?: ClotureCaisseCreateNestedManyWithoutAgentInput
    Fournisseur?: FournisseurCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateWithoutMouvementCaissesInput = {
    id?: number
    email: string
    nom: string
    postnom?: string | null
    nom_complet?: string | null
    sexe?: $Enums.Sexe | null
    role?: $Enums.Role
    poste?: $Enums.Poste | null
    picture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    adresses?: AdresseUncheckedCreateNestedManyWithoutAgentInput
    contacts?: ContactUncheckedCreateNestedManyWithoutAgentInput
    produits?: ProduitUncheckedCreateNestedManyWithoutAgentInput
    ventes?: VenteUncheckedCreateNestedManyWithoutAgentInput
    achats?: AchatUncheckedCreateNestedManyWithoutAgentInput
    teneurs?: TeneurUncheckedCreateNestedManyWithoutAgentsInput
    devises?: DeviseUncheckedCreateNestedManyWithoutAgentInput
    paniers?: PanierUncheckedCreateNestedManyWithoutAgentInput
    caisses?: CaisseUncheckedCreateNestedManyWithoutAgentInput
    clotureCaisses?: ClotureCaisseUncheckedCreateNestedManyWithoutAgentInput
    Fournisseur?: FournisseurUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentCreateOrConnectWithoutMouvementCaissesInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutMouvementCaissesInput, AgentUncheckedCreateWithoutMouvementCaissesInput>
  }

  export type CaisseUpsertWithoutMouvementCaissesInput = {
    update: XOR<CaisseUpdateWithoutMouvementCaissesInput, CaisseUncheckedUpdateWithoutMouvementCaissesInput>
    create: XOR<CaisseCreateWithoutMouvementCaissesInput, CaisseUncheckedCreateWithoutMouvementCaissesInput>
    where?: CaisseWhereInput
  }

  export type CaisseUpdateToOneWithWhereWithoutMouvementCaissesInput = {
    where?: CaisseWhereInput
    data: XOR<CaisseUpdateWithoutMouvementCaissesInput, CaisseUncheckedUpdateWithoutMouvementCaissesInput>
  }

  export type CaisseUpdateWithoutMouvementCaissesInput = {
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    soldeActuel?: NullableFloatFieldUpdateOperationsInput | number | null
    statut?: EnumStatutCaisseFieldUpdateOperationsInput | $Enums.StatutCaisse
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    devise?: DeviseUpdateOneRequiredWithoutCaissesNestedInput
    agent?: AgentUpdateOneRequiredWithoutCaissesNestedInput
    paiements?: PaiementUpdateManyWithoutCaisseNestedInput
  }

  export type CaisseUncheckedUpdateWithoutMouvementCaissesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    soldeActuel?: NullableFloatFieldUpdateOperationsInput | number | null
    deviseId?: IntFieldUpdateOperationsInput | number
    agentId?: IntFieldUpdateOperationsInput | number
    statut?: EnumStatutCaisseFieldUpdateOperationsInput | $Enums.StatutCaisse
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paiements?: PaiementUncheckedUpdateManyWithoutCaisseNestedInput
  }

  export type AgentUpsertWithoutMouvementCaissesInput = {
    update: XOR<AgentUpdateWithoutMouvementCaissesInput, AgentUncheckedUpdateWithoutMouvementCaissesInput>
    create: XOR<AgentCreateWithoutMouvementCaissesInput, AgentUncheckedCreateWithoutMouvementCaissesInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutMouvementCaissesInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutMouvementCaissesInput, AgentUncheckedUpdateWithoutMouvementCaissesInput>
  }

  export type AgentUpdateWithoutMouvementCaissesInput = {
    email?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    postnom?: NullableStringFieldUpdateOperationsInput | string | null
    nom_complet?: NullableStringFieldUpdateOperationsInput | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    poste?: NullableEnumPosteFieldUpdateOperationsInput | $Enums.Poste | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adresses?: AdresseUpdateManyWithoutAgentNestedInput
    contacts?: ContactUpdateManyWithoutAgentNestedInput
    produits?: ProduitUpdateManyWithoutAgentNestedInput
    ventes?: VenteUpdateManyWithoutAgentNestedInput
    achats?: AchatUpdateManyWithoutAgentNestedInput
    teneurs?: TeneurUpdateManyWithoutAgentsNestedInput
    devises?: DeviseUpdateManyWithoutAgentNestedInput
    paniers?: PanierUpdateManyWithoutAgentNestedInput
    caisses?: CaisseUpdateManyWithoutAgentNestedInput
    clotureCaisses?: ClotureCaisseUpdateManyWithoutAgentNestedInput
    Fournisseur?: FournisseurUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateWithoutMouvementCaissesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    postnom?: NullableStringFieldUpdateOperationsInput | string | null
    nom_complet?: NullableStringFieldUpdateOperationsInput | string | null
    sexe?: NullableEnumSexeFieldUpdateOperationsInput | $Enums.Sexe | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    poste?: NullableEnumPosteFieldUpdateOperationsInput | $Enums.Poste | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adresses?: AdresseUncheckedUpdateManyWithoutAgentNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutAgentNestedInput
    produits?: ProduitUncheckedUpdateManyWithoutAgentNestedInput
    ventes?: VenteUncheckedUpdateManyWithoutAgentNestedInput
    achats?: AchatUncheckedUpdateManyWithoutAgentNestedInput
    teneurs?: TeneurUncheckedUpdateManyWithoutAgentsNestedInput
    devises?: DeviseUncheckedUpdateManyWithoutAgentNestedInput
    paniers?: PanierUncheckedUpdateManyWithoutAgentNestedInput
    caisses?: CaisseUncheckedUpdateManyWithoutAgentNestedInput
    clotureCaisses?: ClotureCaisseUncheckedUpdateManyWithoutAgentNestedInput
    Fournisseur?: FournisseurUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type ProduitCreateManyTeneurInput = {
    id?: number
    designation: string
    prixUnitaire: number
    qtteDisponible?: number
    description?: string | null
    deviseId: number
    agentId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProduitUpdateWithoutTeneurInput = {
    designation?: StringFieldUpdateOperationsInput | string
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    qtteDisponible?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    detailsPaniers?: DetailPanierUpdateManyWithoutProduitNestedInput
    agent?: AgentUpdateOneRequiredWithoutProduitsNestedInput
    devise?: DeviseUpdateOneRequiredWithoutProduitsNestedInput
  }

  export type ProduitUncheckedUpdateWithoutTeneurInput = {
    id?: IntFieldUpdateOperationsInput | number
    designation?: StringFieldUpdateOperationsInput | string
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    qtteDisponible?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    deviseId?: IntFieldUpdateOperationsInput | number
    agentId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    detailsPaniers?: DetailPanierUncheckedUpdateManyWithoutProduitNestedInput
  }

  export type ProduitUncheckedUpdateManyWithoutTeneurInput = {
    id?: IntFieldUpdateOperationsInput | number
    designation?: StringFieldUpdateOperationsInput | string
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    qtteDisponible?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    deviseId?: IntFieldUpdateOperationsInput | number
    agentId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProduitCreateManyDeviseInput = {
    id?: number
    designation: string
    prixUnitaire: number
    qtteDisponible?: number
    description?: string | null
    teneurId: number
    agentId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaiementCreateManyDeviseInput = {
    id?: number
    totalHT?: number | null
    totalTTC?: number | null
    modePaiement: $Enums.ModePaiment
    caisseId: number
    venteId?: number | null
    achatId?: number | null
    commandeId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CaisseCreateManyDeviseInput = {
    id?: number
    nom: string
    description?: string | null
    soldeActuel?: number | null
    agentId: number
    statut?: $Enums.StatutCaisse
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DetailPanierCreateManyDeviseInput = {
    id?: number
    produitId: number
    qtte: number
    modePaiement: $Enums.ModePaiment
    prixUnitaire: number
    prixTotalHT: number
    prixTotalTTC: number
    panierId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProduitUpdateWithoutDeviseInput = {
    designation?: StringFieldUpdateOperationsInput | string
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    qtteDisponible?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    detailsPaniers?: DetailPanierUpdateManyWithoutProduitNestedInput
    agent?: AgentUpdateOneRequiredWithoutProduitsNestedInput
    teneur?: TeneurUpdateOneRequiredWithoutProduitsNestedInput
  }

  export type ProduitUncheckedUpdateWithoutDeviseInput = {
    id?: IntFieldUpdateOperationsInput | number
    designation?: StringFieldUpdateOperationsInput | string
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    qtteDisponible?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    teneurId?: IntFieldUpdateOperationsInput | number
    agentId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    detailsPaniers?: DetailPanierUncheckedUpdateManyWithoutProduitNestedInput
  }

  export type ProduitUncheckedUpdateManyWithoutDeviseInput = {
    id?: IntFieldUpdateOperationsInput | number
    designation?: StringFieldUpdateOperationsInput | string
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    qtteDisponible?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    teneurId?: IntFieldUpdateOperationsInput | number
    agentId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaiementUpdateWithoutDeviseInput = {
    totalHT?: NullableFloatFieldUpdateOperationsInput | number | null
    totalTTC?: NullableFloatFieldUpdateOperationsInput | number | null
    modePaiement?: EnumModePaimentFieldUpdateOperationsInput | $Enums.ModePaiment
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vente?: VenteUpdateOneWithoutPaiementsNestedInput
    achat?: AchatUpdateOneWithoutPaiementsNestedInput
    commande?: CommandeUpdateOneWithoutPaiementNestedInput
    caisse?: CaisseUpdateOneRequiredWithoutPaiementsNestedInput
  }

  export type PaiementUncheckedUpdateWithoutDeviseInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalHT?: NullableFloatFieldUpdateOperationsInput | number | null
    totalTTC?: NullableFloatFieldUpdateOperationsInput | number | null
    modePaiement?: EnumModePaimentFieldUpdateOperationsInput | $Enums.ModePaiment
    caisseId?: IntFieldUpdateOperationsInput | number
    venteId?: NullableIntFieldUpdateOperationsInput | number | null
    achatId?: NullableIntFieldUpdateOperationsInput | number | null
    commandeId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaiementUncheckedUpdateManyWithoutDeviseInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalHT?: NullableFloatFieldUpdateOperationsInput | number | null
    totalTTC?: NullableFloatFieldUpdateOperationsInput | number | null
    modePaiement?: EnumModePaimentFieldUpdateOperationsInput | $Enums.ModePaiment
    caisseId?: IntFieldUpdateOperationsInput | number
    venteId?: NullableIntFieldUpdateOperationsInput | number | null
    achatId?: NullableIntFieldUpdateOperationsInput | number | null
    commandeId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CaisseUpdateWithoutDeviseInput = {
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    soldeActuel?: NullableFloatFieldUpdateOperationsInput | number | null
    statut?: EnumStatutCaisseFieldUpdateOperationsInput | $Enums.StatutCaisse
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUpdateOneRequiredWithoutCaissesNestedInput
    mouvementCaisses?: MouvementCaisseUpdateManyWithoutCaisseNestedInput
    paiements?: PaiementUpdateManyWithoutCaisseNestedInput
  }

  export type CaisseUncheckedUpdateWithoutDeviseInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    soldeActuel?: NullableFloatFieldUpdateOperationsInput | number | null
    agentId?: IntFieldUpdateOperationsInput | number
    statut?: EnumStatutCaisseFieldUpdateOperationsInput | $Enums.StatutCaisse
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mouvementCaisses?: MouvementCaisseUncheckedUpdateManyWithoutCaisseNestedInput
    paiements?: PaiementUncheckedUpdateManyWithoutCaisseNestedInput
  }

  export type CaisseUncheckedUpdateManyWithoutDeviseInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    soldeActuel?: NullableFloatFieldUpdateOperationsInput | number | null
    agentId?: IntFieldUpdateOperationsInput | number
    statut?: EnumStatutCaisseFieldUpdateOperationsInput | $Enums.StatutCaisse
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DetailPanierUpdateWithoutDeviseInput = {
    qtte?: IntFieldUpdateOperationsInput | number
    modePaiement?: EnumModePaimentFieldUpdateOperationsInput | $Enums.ModePaiment
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    prixTotalHT?: FloatFieldUpdateOperationsInput | number
    prixTotalTTC?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    produit?: ProduitUpdateOneRequiredWithoutDetailsPaniersNestedInput
    panier?: PanierUpdateOneRequiredWithoutDetailPaniersNestedInput
  }

  export type DetailPanierUncheckedUpdateWithoutDeviseInput = {
    id?: IntFieldUpdateOperationsInput | number
    produitId?: IntFieldUpdateOperationsInput | number
    qtte?: IntFieldUpdateOperationsInput | number
    modePaiement?: EnumModePaimentFieldUpdateOperationsInput | $Enums.ModePaiment
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    prixTotalHT?: FloatFieldUpdateOperationsInput | number
    prixTotalTTC?: FloatFieldUpdateOperationsInput | number
    panierId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DetailPanierUncheckedUpdateManyWithoutDeviseInput = {
    id?: IntFieldUpdateOperationsInput | number
    produitId?: IntFieldUpdateOperationsInput | number
    qtte?: IntFieldUpdateOperationsInput | number
    modePaiement?: EnumModePaimentFieldUpdateOperationsInput | $Enums.ModePaiment
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    prixTotalHT?: FloatFieldUpdateOperationsInput | number
    prixTotalTTC?: FloatFieldUpdateOperationsInput | number
    panierId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClotureCaisseCreateManyEntrepriseInput = {
    id?: number
    dateCloture?: Date | string
    agentId: number
    updatedAt?: Date | string
    notes?: string | null
    createdAt?: Date | string
  }

  export type AdresseCreateManyEntrepriseInput = {
    id?: number
    ville?: string | null
    adresse: string
    isActive?: boolean
    agentId?: number | null
    fournisseurId?: number | null
    clientId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactCreateManyEntrepriseInput = {
    id?: number
    tel: string
    isActive?: boolean
    agentId?: number | null
    fournisseurId?: number | null
    clientId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClotureCaisseUpdateWithoutEntrepriseInput = {
    dateCloture?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUpdateOneRequiredWithoutClotureCaissesNestedInput
  }

  export type ClotureCaisseUncheckedUpdateWithoutEntrepriseInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateCloture?: DateTimeFieldUpdateOperationsInput | Date | string
    agentId?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClotureCaisseUncheckedUpdateManyWithoutEntrepriseInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateCloture?: DateTimeFieldUpdateOperationsInput | Date | string
    agentId?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdresseUpdateWithoutEntrepriseInput = {
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUpdateOneWithoutAdressesNestedInput
    fournisseur?: FournisseurUpdateOneWithoutAdressesNestedInput
    client?: ClientUpdateOneWithoutAdressesNestedInput
    reservations?: ReservationUpdateManyWithoutAdresseNestedInput
    commandes?: CommandeUpdateManyWithoutAdresseNestedInput
  }

  export type AdresseUncheckedUpdateWithoutEntrepriseInput = {
    id?: IntFieldUpdateOperationsInput | number
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    agentId?: NullableIntFieldUpdateOperationsInput | number | null
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reservations?: ReservationUncheckedUpdateManyWithoutAdresseNestedInput
    commandes?: CommandeUncheckedUpdateManyWithoutAdresseNestedInput
  }

  export type AdresseUncheckedUpdateManyWithoutEntrepriseInput = {
    id?: IntFieldUpdateOperationsInput | number
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    agentId?: NullableIntFieldUpdateOperationsInput | number | null
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUpdateWithoutEntrepriseInput = {
    tel?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneWithoutContactsNestedInput
    agent?: AgentUpdateOneWithoutContactsNestedInput
    fournisseur?: FournisseurUpdateOneWithoutContactsNestedInput
    reservations?: ReservationUpdateManyWithoutContactNestedInput
    commandes?: CommandeUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutEntrepriseInput = {
    id?: IntFieldUpdateOperationsInput | number
    tel?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    agentId?: NullableIntFieldUpdateOperationsInput | number | null
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reservations?: ReservationUncheckedUpdateManyWithoutContactNestedInput
    commandes?: CommandeUncheckedUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateManyWithoutEntrepriseInput = {
    id?: IntFieldUpdateOperationsInput | number
    tel?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    agentId?: NullableIntFieldUpdateOperationsInput | number | null
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdresseCreateManyAgentInput = {
    id?: number
    ville?: string | null
    adresse: string
    isActive?: boolean
    fournisseurId?: number | null
    clientId?: number | null
    entrepriseId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactCreateManyAgentInput = {
    id?: number
    tel: string
    isActive?: boolean
    fournisseurId?: number | null
    clientId?: number | null
    entrepriseId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProduitCreateManyAgentInput = {
    id?: number
    designation: string
    prixUnitaire: number
    qtteDisponible?: number
    description?: string | null
    deviseId: number
    teneurId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VenteCreateManyAgentInput = {
    id?: number
    statut?: $Enums.StatutVente
    typeAcheteur: $Enums.TypeClient
    clientId?: number | null
    fournisseurId?: number | null
    panierId: number
    enregistrerPar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AchatCreateManyAgentInput = {
    id?: number
    statut?: $Enums.StatutAchat
    panierId: number
    fournisseurId: number
    clientId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeneurCreateManyAgentsInput = {
    id?: number
    valeur: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeviseCreateManyAgentInput = {
    id?: number
    nom: string
    code: string
    symbole: string
    tauxDEchange: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PanierCreateManyAgentInput = {
    id?: number
    clientId?: number | null
    statut?: $Enums.statutPanier
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CaisseCreateManyAgentInput = {
    id?: number
    nom: string
    description?: string | null
    soldeActuel?: number | null
    deviseId: number
    statut?: $Enums.StatutCaisse
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MouvementCaisseCreateManyAgentInput = {
    id?: number
    caisseId: number
    referenceExterne?: string | null
    type_mouvement?: $Enums.TypeMouvementCaisse
    categorie?: $Enums.CategorieMouvement
    moyen_paiement: $Enums.ModePaiment
    montant: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClotureCaisseCreateManyAgentInput = {
    id?: number
    dateCloture?: Date | string
    entrepriseId?: number | null
    updatedAt?: Date | string
    notes?: string | null
    createdAt?: Date | string
  }

  export type FournisseurCreateManyAgentInput = {
    id?: number
    nom: string
    email: string
    codePostale?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdresseUpdateWithoutAgentInput = {
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entreprise?: EntrepriseUpdateOneWithoutAdresseNestedInput
    fournisseur?: FournisseurUpdateOneWithoutAdressesNestedInput
    client?: ClientUpdateOneWithoutAdressesNestedInput
    reservations?: ReservationUpdateManyWithoutAdresseNestedInput
    commandes?: CommandeUpdateManyWithoutAdresseNestedInput
  }

  export type AdresseUncheckedUpdateWithoutAgentInput = {
    id?: IntFieldUpdateOperationsInput | number
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    entrepriseId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reservations?: ReservationUncheckedUpdateManyWithoutAdresseNestedInput
    commandes?: CommandeUncheckedUpdateManyWithoutAdresseNestedInput
  }

  export type AdresseUncheckedUpdateManyWithoutAgentInput = {
    id?: IntFieldUpdateOperationsInput | number
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    entrepriseId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUpdateWithoutAgentInput = {
    tel?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entreprise?: EntrepriseUpdateOneWithoutContactNestedInput
    client?: ClientUpdateOneWithoutContactsNestedInput
    fournisseur?: FournisseurUpdateOneWithoutContactsNestedInput
    reservations?: ReservationUpdateManyWithoutContactNestedInput
    commandes?: CommandeUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutAgentInput = {
    id?: IntFieldUpdateOperationsInput | number
    tel?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    entrepriseId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reservations?: ReservationUncheckedUpdateManyWithoutContactNestedInput
    commandes?: CommandeUncheckedUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateManyWithoutAgentInput = {
    id?: IntFieldUpdateOperationsInput | number
    tel?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    entrepriseId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProduitUpdateWithoutAgentInput = {
    designation?: StringFieldUpdateOperationsInput | string
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    qtteDisponible?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    detailsPaniers?: DetailPanierUpdateManyWithoutProduitNestedInput
    devise?: DeviseUpdateOneRequiredWithoutProduitsNestedInput
    teneur?: TeneurUpdateOneRequiredWithoutProduitsNestedInput
  }

  export type ProduitUncheckedUpdateWithoutAgentInput = {
    id?: IntFieldUpdateOperationsInput | number
    designation?: StringFieldUpdateOperationsInput | string
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    qtteDisponible?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    deviseId?: IntFieldUpdateOperationsInput | number
    teneurId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    detailsPaniers?: DetailPanierUncheckedUpdateManyWithoutProduitNestedInput
  }

  export type ProduitUncheckedUpdateManyWithoutAgentInput = {
    id?: IntFieldUpdateOperationsInput | number
    designation?: StringFieldUpdateOperationsInput | string
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    qtteDisponible?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    deviseId?: IntFieldUpdateOperationsInput | number
    teneurId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VenteUpdateWithoutAgentInput = {
    statut?: EnumStatutVenteFieldUpdateOperationsInput | $Enums.StatutVente
    typeAcheteur?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    enregistrerPar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    panier?: PanierUpdateOneRequiredWithoutVentesNestedInput
    fournisseur?: FournisseurUpdateOneWithoutVentesNestedInput
    client?: ClientUpdateOneWithoutVentesNestedInput
    paiements?: PaiementUpdateManyWithoutVenteNestedInput
  }

  export type VenteUncheckedUpdateWithoutAgentInput = {
    id?: IntFieldUpdateOperationsInput | number
    statut?: EnumStatutVenteFieldUpdateOperationsInput | $Enums.StatutVente
    typeAcheteur?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    panierId?: IntFieldUpdateOperationsInput | number
    enregistrerPar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paiements?: PaiementUncheckedUpdateManyWithoutVenteNestedInput
  }

  export type VenteUncheckedUpdateManyWithoutAgentInput = {
    id?: IntFieldUpdateOperationsInput | number
    statut?: EnumStatutVenteFieldUpdateOperationsInput | $Enums.StatutVente
    typeAcheteur?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    panierId?: IntFieldUpdateOperationsInput | number
    enregistrerPar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchatUpdateWithoutAgentInput = {
    statut?: EnumStatutAchatFieldUpdateOperationsInput | $Enums.StatutAchat
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    panier?: PanierUpdateOneRequiredWithoutAchatsNestedInput
    fournisseur?: FournisseurUpdateOneRequiredWithoutAchatsNestedInput
    Client?: ClientUpdateOneWithoutAchatsNestedInput
    paiements?: PaiementUpdateManyWithoutAchatNestedInput
  }

  export type AchatUncheckedUpdateWithoutAgentInput = {
    id?: IntFieldUpdateOperationsInput | number
    statut?: EnumStatutAchatFieldUpdateOperationsInput | $Enums.StatutAchat
    panierId?: IntFieldUpdateOperationsInput | number
    fournisseurId?: IntFieldUpdateOperationsInput | number
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paiements?: PaiementUncheckedUpdateManyWithoutAchatNestedInput
  }

  export type AchatUncheckedUpdateManyWithoutAgentInput = {
    id?: IntFieldUpdateOperationsInput | number
    statut?: EnumStatutAchatFieldUpdateOperationsInput | $Enums.StatutAchat
    panierId?: IntFieldUpdateOperationsInput | number
    fournisseurId?: IntFieldUpdateOperationsInput | number
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeneurUpdateWithoutAgentsInput = {
    valeur?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    produits?: ProduitUpdateManyWithoutTeneurNestedInput
  }

  export type TeneurUncheckedUpdateWithoutAgentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    valeur?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    produits?: ProduitUncheckedUpdateManyWithoutTeneurNestedInput
  }

  export type TeneurUncheckedUpdateManyWithoutAgentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    valeur?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviseUpdateWithoutAgentInput = {
    nom?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    symbole?: StringFieldUpdateOperationsInput | string
    tauxDEchange?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    produits?: ProduitUpdateManyWithoutDeviseNestedInput
    paiements?: PaiementUpdateManyWithoutDeviseNestedInput
    caisses?: CaisseUpdateManyWithoutDeviseNestedInput
    DetailPanier?: DetailPanierUpdateManyWithoutDeviseNestedInput
  }

  export type DeviseUncheckedUpdateWithoutAgentInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    symbole?: StringFieldUpdateOperationsInput | string
    tauxDEchange?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    produits?: ProduitUncheckedUpdateManyWithoutDeviseNestedInput
    paiements?: PaiementUncheckedUpdateManyWithoutDeviseNestedInput
    caisses?: CaisseUncheckedUpdateManyWithoutDeviseNestedInput
    DetailPanier?: DetailPanierUncheckedUpdateManyWithoutDeviseNestedInput
  }

  export type DeviseUncheckedUpdateManyWithoutAgentInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    symbole?: StringFieldUpdateOperationsInput | string
    tauxDEchange?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PanierUpdateWithoutAgentInput = {
    statut?: EnumstatutPanierFieldUpdateOperationsInput | $Enums.statutPanier
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneWithoutPaniersNestedInput
    detailPaniers?: DetailPanierUpdateManyWithoutPanierNestedInput
    achats?: AchatUpdateManyWithoutPanierNestedInput
    ventes?: VenteUpdateManyWithoutPanierNestedInput
    reservations?: ReservationUpdateManyWithoutPanierNestedInput
    commandes?: CommandeUpdateManyWithoutPanierNestedInput
  }

  export type PanierUncheckedUpdateWithoutAgentInput = {
    id?: IntFieldUpdateOperationsInput | number
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    statut?: EnumstatutPanierFieldUpdateOperationsInput | $Enums.statutPanier
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    detailPaniers?: DetailPanierUncheckedUpdateManyWithoutPanierNestedInput
    achats?: AchatUncheckedUpdateManyWithoutPanierNestedInput
    ventes?: VenteUncheckedUpdateManyWithoutPanierNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutPanierNestedInput
    commandes?: CommandeUncheckedUpdateManyWithoutPanierNestedInput
  }

  export type PanierUncheckedUpdateManyWithoutAgentInput = {
    id?: IntFieldUpdateOperationsInput | number
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    statut?: EnumstatutPanierFieldUpdateOperationsInput | $Enums.statutPanier
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CaisseUpdateWithoutAgentInput = {
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    soldeActuel?: NullableFloatFieldUpdateOperationsInput | number | null
    statut?: EnumStatutCaisseFieldUpdateOperationsInput | $Enums.StatutCaisse
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    devise?: DeviseUpdateOneRequiredWithoutCaissesNestedInput
    mouvementCaisses?: MouvementCaisseUpdateManyWithoutCaisseNestedInput
    paiements?: PaiementUpdateManyWithoutCaisseNestedInput
  }

  export type CaisseUncheckedUpdateWithoutAgentInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    soldeActuel?: NullableFloatFieldUpdateOperationsInput | number | null
    deviseId?: IntFieldUpdateOperationsInput | number
    statut?: EnumStatutCaisseFieldUpdateOperationsInput | $Enums.StatutCaisse
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mouvementCaisses?: MouvementCaisseUncheckedUpdateManyWithoutCaisseNestedInput
    paiements?: PaiementUncheckedUpdateManyWithoutCaisseNestedInput
  }

  export type CaisseUncheckedUpdateManyWithoutAgentInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    soldeActuel?: NullableFloatFieldUpdateOperationsInput | number | null
    deviseId?: IntFieldUpdateOperationsInput | number
    statut?: EnumStatutCaisseFieldUpdateOperationsInput | $Enums.StatutCaisse
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MouvementCaisseUpdateWithoutAgentInput = {
    referenceExterne?: NullableStringFieldUpdateOperationsInput | string | null
    type_mouvement?: EnumTypeMouvementCaisseFieldUpdateOperationsInput | $Enums.TypeMouvementCaisse
    categorie?: EnumCategorieMouvementFieldUpdateOperationsInput | $Enums.CategorieMouvement
    moyen_paiement?: EnumModePaimentFieldUpdateOperationsInput | $Enums.ModePaiment
    montant?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    caisse?: CaisseUpdateOneRequiredWithoutMouvementCaissesNestedInput
  }

  export type MouvementCaisseUncheckedUpdateWithoutAgentInput = {
    id?: IntFieldUpdateOperationsInput | number
    caisseId?: IntFieldUpdateOperationsInput | number
    referenceExterne?: NullableStringFieldUpdateOperationsInput | string | null
    type_mouvement?: EnumTypeMouvementCaisseFieldUpdateOperationsInput | $Enums.TypeMouvementCaisse
    categorie?: EnumCategorieMouvementFieldUpdateOperationsInput | $Enums.CategorieMouvement
    moyen_paiement?: EnumModePaimentFieldUpdateOperationsInput | $Enums.ModePaiment
    montant?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MouvementCaisseUncheckedUpdateManyWithoutAgentInput = {
    id?: IntFieldUpdateOperationsInput | number
    caisseId?: IntFieldUpdateOperationsInput | number
    referenceExterne?: NullableStringFieldUpdateOperationsInput | string | null
    type_mouvement?: EnumTypeMouvementCaisseFieldUpdateOperationsInput | $Enums.TypeMouvementCaisse
    categorie?: EnumCategorieMouvementFieldUpdateOperationsInput | $Enums.CategorieMouvement
    moyen_paiement?: EnumModePaimentFieldUpdateOperationsInput | $Enums.ModePaiment
    montant?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClotureCaisseUpdateWithoutAgentInput = {
    dateCloture?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entreprise?: EntrepriseUpdateOneWithoutClotureCaissesNestedInput
  }

  export type ClotureCaisseUncheckedUpdateWithoutAgentInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateCloture?: DateTimeFieldUpdateOperationsInput | Date | string
    entrepriseId?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClotureCaisseUncheckedUpdateManyWithoutAgentInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateCloture?: DateTimeFieldUpdateOperationsInput | Date | string
    entrepriseId?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FournisseurUpdateWithoutAgentInput = {
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    codePostale?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ventes?: VenteUpdateManyWithoutFournisseurNestedInput
    achats?: AchatUpdateManyWithoutFournisseurNestedInput
    adresses?: AdresseUpdateManyWithoutFournisseurNestedInput
    contacts?: ContactUpdateManyWithoutFournisseurNestedInput
    reservations?: ReservationUpdateManyWithoutFournisseurNestedInput
    commandes?: CommandeUpdateManyWithoutFournisseurNestedInput
  }

  export type FournisseurUncheckedUpdateWithoutAgentInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    codePostale?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ventes?: VenteUncheckedUpdateManyWithoutFournisseurNestedInput
    achats?: AchatUncheckedUpdateManyWithoutFournisseurNestedInput
    adresses?: AdresseUncheckedUpdateManyWithoutFournisseurNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutFournisseurNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutFournisseurNestedInput
    commandes?: CommandeUncheckedUpdateManyWithoutFournisseurNestedInput
  }

  export type FournisseurUncheckedUpdateManyWithoutAgentInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    codePostale?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdresseCreateManyClientInput = {
    id?: number
    ville?: string | null
    adresse: string
    isActive?: boolean
    agentId?: number | null
    fournisseurId?: number | null
    entrepriseId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactCreateManyClientInput = {
    id?: number
    tel: string
    isActive?: boolean
    agentId?: number | null
    fournisseurId?: number | null
    entrepriseId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VenteCreateManyClientInput = {
    id?: number
    statut?: $Enums.StatutVente
    typeAcheteur: $Enums.TypeClient
    agentId?: number | null
    fournisseurId?: number | null
    panierId: number
    enregistrerPar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AchatCreateManyClientInput = {
    id?: number
    statut?: $Enums.StatutAchat
    panierId: number
    fournisseurId: number
    agentId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PanierCreateManyClientInput = {
    id?: number
    agentId?: number | null
    statut?: $Enums.statutPanier
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReservationCreateManyClientInput = {
    id?: number
    dateLivraisonSouhaitee: Date | string
    adresseLivraison?: string | null
    statut?: $Enums.StatutReservation
    notes?: string | null
    typeClient?: $Enums.TypeClient
    panierId: number
    nom?: string | null
    tel?: string | null
    adresseId?: number | null
    contactId?: number | null
    enregistrerParId?: number | null
    fournisseurId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommandeCreateManyClientInput = {
    id?: number
    panierId: number
    nom?: string | null
    tel?: string | null
    type_client?: $Enums.TypeClient
    adresseId?: number | null
    contactId?: number | null
    fournisseurId?: number | null
    commandeId?: number | null
    notes?: string | null
    dateLivraisonEffective?: Date | string | null
    adresseLivraison?: string | null
    enregistrerParId?: number | null
    statut?: $Enums.StatutCommande
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdresseUpdateWithoutClientInput = {
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUpdateOneWithoutAdressesNestedInput
    entreprise?: EntrepriseUpdateOneWithoutAdresseNestedInput
    fournisseur?: FournisseurUpdateOneWithoutAdressesNestedInput
    reservations?: ReservationUpdateManyWithoutAdresseNestedInput
    commandes?: CommandeUpdateManyWithoutAdresseNestedInput
  }

  export type AdresseUncheckedUpdateWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    agentId?: NullableIntFieldUpdateOperationsInput | number | null
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    entrepriseId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reservations?: ReservationUncheckedUpdateManyWithoutAdresseNestedInput
    commandes?: CommandeUncheckedUpdateManyWithoutAdresseNestedInput
  }

  export type AdresseUncheckedUpdateManyWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    agentId?: NullableIntFieldUpdateOperationsInput | number | null
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    entrepriseId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUpdateWithoutClientInput = {
    tel?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entreprise?: EntrepriseUpdateOneWithoutContactNestedInput
    agent?: AgentUpdateOneWithoutContactsNestedInput
    fournisseur?: FournisseurUpdateOneWithoutContactsNestedInput
    reservations?: ReservationUpdateManyWithoutContactNestedInput
    commandes?: CommandeUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    tel?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    agentId?: NullableIntFieldUpdateOperationsInput | number | null
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    entrepriseId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reservations?: ReservationUncheckedUpdateManyWithoutContactNestedInput
    commandes?: CommandeUncheckedUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateManyWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    tel?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    agentId?: NullableIntFieldUpdateOperationsInput | number | null
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    entrepriseId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VenteUpdateWithoutClientInput = {
    statut?: EnumStatutVenteFieldUpdateOperationsInput | $Enums.StatutVente
    typeAcheteur?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    enregistrerPar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    panier?: PanierUpdateOneRequiredWithoutVentesNestedInput
    agent?: AgentUpdateOneWithoutVentesNestedInput
    fournisseur?: FournisseurUpdateOneWithoutVentesNestedInput
    paiements?: PaiementUpdateManyWithoutVenteNestedInput
  }

  export type VenteUncheckedUpdateWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    statut?: EnumStatutVenteFieldUpdateOperationsInput | $Enums.StatutVente
    typeAcheteur?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    agentId?: NullableIntFieldUpdateOperationsInput | number | null
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    panierId?: IntFieldUpdateOperationsInput | number
    enregistrerPar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paiements?: PaiementUncheckedUpdateManyWithoutVenteNestedInput
  }

  export type VenteUncheckedUpdateManyWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    statut?: EnumStatutVenteFieldUpdateOperationsInput | $Enums.StatutVente
    typeAcheteur?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    agentId?: NullableIntFieldUpdateOperationsInput | number | null
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    panierId?: IntFieldUpdateOperationsInput | number
    enregistrerPar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchatUpdateWithoutClientInput = {
    statut?: EnumStatutAchatFieldUpdateOperationsInput | $Enums.StatutAchat
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    panier?: PanierUpdateOneRequiredWithoutAchatsNestedInput
    fournisseur?: FournisseurUpdateOneRequiredWithoutAchatsNestedInput
    agent?: AgentUpdateOneRequiredWithoutAchatsNestedInput
    paiements?: PaiementUpdateManyWithoutAchatNestedInput
  }

  export type AchatUncheckedUpdateWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    statut?: EnumStatutAchatFieldUpdateOperationsInput | $Enums.StatutAchat
    panierId?: IntFieldUpdateOperationsInput | number
    fournisseurId?: IntFieldUpdateOperationsInput | number
    agentId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paiements?: PaiementUncheckedUpdateManyWithoutAchatNestedInput
  }

  export type AchatUncheckedUpdateManyWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    statut?: EnumStatutAchatFieldUpdateOperationsInput | $Enums.StatutAchat
    panierId?: IntFieldUpdateOperationsInput | number
    fournisseurId?: IntFieldUpdateOperationsInput | number
    agentId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PanierUpdateWithoutClientInput = {
    statut?: EnumstatutPanierFieldUpdateOperationsInput | $Enums.statutPanier
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUpdateOneWithoutPaniersNestedInput
    detailPaniers?: DetailPanierUpdateManyWithoutPanierNestedInput
    achats?: AchatUpdateManyWithoutPanierNestedInput
    ventes?: VenteUpdateManyWithoutPanierNestedInput
    reservations?: ReservationUpdateManyWithoutPanierNestedInput
    commandes?: CommandeUpdateManyWithoutPanierNestedInput
  }

  export type PanierUncheckedUpdateWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    agentId?: NullableIntFieldUpdateOperationsInput | number | null
    statut?: EnumstatutPanierFieldUpdateOperationsInput | $Enums.statutPanier
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    detailPaniers?: DetailPanierUncheckedUpdateManyWithoutPanierNestedInput
    achats?: AchatUncheckedUpdateManyWithoutPanierNestedInput
    ventes?: VenteUncheckedUpdateManyWithoutPanierNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutPanierNestedInput
    commandes?: CommandeUncheckedUpdateManyWithoutPanierNestedInput
  }

  export type PanierUncheckedUpdateManyWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    agentId?: NullableIntFieldUpdateOperationsInput | number | null
    statut?: EnumstatutPanierFieldUpdateOperationsInput | $Enums.statutPanier
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReservationUpdateWithoutClientInput = {
    dateLivraisonSouhaitee?: DateTimeFieldUpdateOperationsInput | Date | string
    adresseLivraison?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: EnumStatutReservationFieldUpdateOperationsInput | $Enums.StatutReservation
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    typeClient?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    enregistrerParId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    panier?: PanierUpdateOneRequiredWithoutReservationsNestedInput
    fournisseur?: FournisseurUpdateOneWithoutReservationsNestedInput
    adresse?: AdresseUpdateOneWithoutReservationsNestedInput
    contact?: ContactUpdateOneWithoutReservationsNestedInput
  }

  export type ReservationUncheckedUpdateWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateLivraisonSouhaitee?: DateTimeFieldUpdateOperationsInput | Date | string
    adresseLivraison?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: EnumStatutReservationFieldUpdateOperationsInput | $Enums.StatutReservation
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    typeClient?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    panierId?: IntFieldUpdateOperationsInput | number
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    adresseId?: NullableIntFieldUpdateOperationsInput | number | null
    contactId?: NullableIntFieldUpdateOperationsInput | number | null
    enregistrerParId?: NullableIntFieldUpdateOperationsInput | number | null
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReservationUncheckedUpdateManyWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateLivraisonSouhaitee?: DateTimeFieldUpdateOperationsInput | Date | string
    adresseLivraison?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: EnumStatutReservationFieldUpdateOperationsInput | $Enums.StatutReservation
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    typeClient?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    panierId?: IntFieldUpdateOperationsInput | number
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    adresseId?: NullableIntFieldUpdateOperationsInput | number | null
    contactId?: NullableIntFieldUpdateOperationsInput | number | null
    enregistrerParId?: NullableIntFieldUpdateOperationsInput | number | null
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommandeUpdateWithoutClientInput = {
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    type_client?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    commandeId?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    dateLivraisonEffective?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adresseLivraison?: NullableStringFieldUpdateOperationsInput | string | null
    enregistrerParId?: NullableIntFieldUpdateOperationsInput | number | null
    statut?: EnumStatutCommandeFieldUpdateOperationsInput | $Enums.StatutCommande
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Paiement?: PaiementUpdateManyWithoutCommandeNestedInput
    panier?: PanierUpdateOneRequiredWithoutCommandesNestedInput
    fournisseur?: FournisseurUpdateOneWithoutCommandesNestedInput
    adresse?: AdresseUpdateOneWithoutCommandesNestedInput
    contact?: ContactUpdateOneWithoutCommandesNestedInput
  }

  export type CommandeUncheckedUpdateWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    panierId?: IntFieldUpdateOperationsInput | number
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    type_client?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    adresseId?: NullableIntFieldUpdateOperationsInput | number | null
    contactId?: NullableIntFieldUpdateOperationsInput | number | null
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    commandeId?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    dateLivraisonEffective?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adresseLivraison?: NullableStringFieldUpdateOperationsInput | string | null
    enregistrerParId?: NullableIntFieldUpdateOperationsInput | number | null
    statut?: EnumStatutCommandeFieldUpdateOperationsInput | $Enums.StatutCommande
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Paiement?: PaiementUncheckedUpdateManyWithoutCommandeNestedInput
  }

  export type CommandeUncheckedUpdateManyWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    panierId?: IntFieldUpdateOperationsInput | number
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    type_client?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    adresseId?: NullableIntFieldUpdateOperationsInput | number | null
    contactId?: NullableIntFieldUpdateOperationsInput | number | null
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    commandeId?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    dateLivraisonEffective?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adresseLivraison?: NullableStringFieldUpdateOperationsInput | string | null
    enregistrerParId?: NullableIntFieldUpdateOperationsInput | number | null
    statut?: EnumStatutCommandeFieldUpdateOperationsInput | $Enums.StatutCommande
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReservationCreateManyAdresseInput = {
    id?: number
    dateLivraisonSouhaitee: Date | string
    adresseLivraison?: string | null
    statut?: $Enums.StatutReservation
    notes?: string | null
    typeClient?: $Enums.TypeClient
    clientId?: number | null
    panierId: number
    nom?: string | null
    tel?: string | null
    contactId?: number | null
    enregistrerParId?: number | null
    fournisseurId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommandeCreateManyAdresseInput = {
    id?: number
    panierId: number
    clientId?: number | null
    nom?: string | null
    tel?: string | null
    type_client?: $Enums.TypeClient
    contactId?: number | null
    fournisseurId?: number | null
    commandeId?: number | null
    notes?: string | null
    dateLivraisonEffective?: Date | string | null
    adresseLivraison?: string | null
    enregistrerParId?: number | null
    statut?: $Enums.StatutCommande
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReservationUpdateWithoutAdresseInput = {
    dateLivraisonSouhaitee?: DateTimeFieldUpdateOperationsInput | Date | string
    adresseLivraison?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: EnumStatutReservationFieldUpdateOperationsInput | $Enums.StatutReservation
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    typeClient?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    enregistrerParId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    panier?: PanierUpdateOneRequiredWithoutReservationsNestedInput
    fournisseur?: FournisseurUpdateOneWithoutReservationsNestedInput
    contact?: ContactUpdateOneWithoutReservationsNestedInput
    Client?: ClientUpdateOneWithoutReservationsNestedInput
  }

  export type ReservationUncheckedUpdateWithoutAdresseInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateLivraisonSouhaitee?: DateTimeFieldUpdateOperationsInput | Date | string
    adresseLivraison?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: EnumStatutReservationFieldUpdateOperationsInput | $Enums.StatutReservation
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    typeClient?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    panierId?: IntFieldUpdateOperationsInput | number
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableIntFieldUpdateOperationsInput | number | null
    enregistrerParId?: NullableIntFieldUpdateOperationsInput | number | null
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReservationUncheckedUpdateManyWithoutAdresseInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateLivraisonSouhaitee?: DateTimeFieldUpdateOperationsInput | Date | string
    adresseLivraison?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: EnumStatutReservationFieldUpdateOperationsInput | $Enums.StatutReservation
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    typeClient?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    panierId?: IntFieldUpdateOperationsInput | number
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableIntFieldUpdateOperationsInput | number | null
    enregistrerParId?: NullableIntFieldUpdateOperationsInput | number | null
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommandeUpdateWithoutAdresseInput = {
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    type_client?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    commandeId?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    dateLivraisonEffective?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adresseLivraison?: NullableStringFieldUpdateOperationsInput | string | null
    enregistrerParId?: NullableIntFieldUpdateOperationsInput | number | null
    statut?: EnumStatutCommandeFieldUpdateOperationsInput | $Enums.StatutCommande
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Paiement?: PaiementUpdateManyWithoutCommandeNestedInput
    panier?: PanierUpdateOneRequiredWithoutCommandesNestedInput
    fournisseur?: FournisseurUpdateOneWithoutCommandesNestedInput
    contact?: ContactUpdateOneWithoutCommandesNestedInput
    Client?: ClientUpdateOneWithoutCommandesNestedInput
  }

  export type CommandeUncheckedUpdateWithoutAdresseInput = {
    id?: IntFieldUpdateOperationsInput | number
    panierId?: IntFieldUpdateOperationsInput | number
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    type_client?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    contactId?: NullableIntFieldUpdateOperationsInput | number | null
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    commandeId?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    dateLivraisonEffective?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adresseLivraison?: NullableStringFieldUpdateOperationsInput | string | null
    enregistrerParId?: NullableIntFieldUpdateOperationsInput | number | null
    statut?: EnumStatutCommandeFieldUpdateOperationsInput | $Enums.StatutCommande
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Paiement?: PaiementUncheckedUpdateManyWithoutCommandeNestedInput
  }

  export type CommandeUncheckedUpdateManyWithoutAdresseInput = {
    id?: IntFieldUpdateOperationsInput | number
    panierId?: IntFieldUpdateOperationsInput | number
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    type_client?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    contactId?: NullableIntFieldUpdateOperationsInput | number | null
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    commandeId?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    dateLivraisonEffective?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adresseLivraison?: NullableStringFieldUpdateOperationsInput | string | null
    enregistrerParId?: NullableIntFieldUpdateOperationsInput | number | null
    statut?: EnumStatutCommandeFieldUpdateOperationsInput | $Enums.StatutCommande
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReservationCreateManyContactInput = {
    id?: number
    dateLivraisonSouhaitee: Date | string
    adresseLivraison?: string | null
    statut?: $Enums.StatutReservation
    notes?: string | null
    typeClient?: $Enums.TypeClient
    clientId?: number | null
    panierId: number
    nom?: string | null
    tel?: string | null
    adresseId?: number | null
    enregistrerParId?: number | null
    fournisseurId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommandeCreateManyContactInput = {
    id?: number
    panierId: number
    clientId?: number | null
    nom?: string | null
    tel?: string | null
    type_client?: $Enums.TypeClient
    adresseId?: number | null
    fournisseurId?: number | null
    commandeId?: number | null
    notes?: string | null
    dateLivraisonEffective?: Date | string | null
    adresseLivraison?: string | null
    enregistrerParId?: number | null
    statut?: $Enums.StatutCommande
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReservationUpdateWithoutContactInput = {
    dateLivraisonSouhaitee?: DateTimeFieldUpdateOperationsInput | Date | string
    adresseLivraison?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: EnumStatutReservationFieldUpdateOperationsInput | $Enums.StatutReservation
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    typeClient?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    enregistrerParId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    panier?: PanierUpdateOneRequiredWithoutReservationsNestedInput
    fournisseur?: FournisseurUpdateOneWithoutReservationsNestedInput
    adresse?: AdresseUpdateOneWithoutReservationsNestedInput
    Client?: ClientUpdateOneWithoutReservationsNestedInput
  }

  export type ReservationUncheckedUpdateWithoutContactInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateLivraisonSouhaitee?: DateTimeFieldUpdateOperationsInput | Date | string
    adresseLivraison?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: EnumStatutReservationFieldUpdateOperationsInput | $Enums.StatutReservation
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    typeClient?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    panierId?: IntFieldUpdateOperationsInput | number
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    adresseId?: NullableIntFieldUpdateOperationsInput | number | null
    enregistrerParId?: NullableIntFieldUpdateOperationsInput | number | null
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReservationUncheckedUpdateManyWithoutContactInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateLivraisonSouhaitee?: DateTimeFieldUpdateOperationsInput | Date | string
    adresseLivraison?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: EnumStatutReservationFieldUpdateOperationsInput | $Enums.StatutReservation
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    typeClient?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    panierId?: IntFieldUpdateOperationsInput | number
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    adresseId?: NullableIntFieldUpdateOperationsInput | number | null
    enregistrerParId?: NullableIntFieldUpdateOperationsInput | number | null
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommandeUpdateWithoutContactInput = {
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    type_client?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    commandeId?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    dateLivraisonEffective?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adresseLivraison?: NullableStringFieldUpdateOperationsInput | string | null
    enregistrerParId?: NullableIntFieldUpdateOperationsInput | number | null
    statut?: EnumStatutCommandeFieldUpdateOperationsInput | $Enums.StatutCommande
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Paiement?: PaiementUpdateManyWithoutCommandeNestedInput
    panier?: PanierUpdateOneRequiredWithoutCommandesNestedInput
    fournisseur?: FournisseurUpdateOneWithoutCommandesNestedInput
    adresse?: AdresseUpdateOneWithoutCommandesNestedInput
    Client?: ClientUpdateOneWithoutCommandesNestedInput
  }

  export type CommandeUncheckedUpdateWithoutContactInput = {
    id?: IntFieldUpdateOperationsInput | number
    panierId?: IntFieldUpdateOperationsInput | number
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    type_client?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    adresseId?: NullableIntFieldUpdateOperationsInput | number | null
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    commandeId?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    dateLivraisonEffective?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adresseLivraison?: NullableStringFieldUpdateOperationsInput | string | null
    enregistrerParId?: NullableIntFieldUpdateOperationsInput | number | null
    statut?: EnumStatutCommandeFieldUpdateOperationsInput | $Enums.StatutCommande
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Paiement?: PaiementUncheckedUpdateManyWithoutCommandeNestedInput
  }

  export type CommandeUncheckedUpdateManyWithoutContactInput = {
    id?: IntFieldUpdateOperationsInput | number
    panierId?: IntFieldUpdateOperationsInput | number
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    type_client?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    adresseId?: NullableIntFieldUpdateOperationsInput | number | null
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    commandeId?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    dateLivraisonEffective?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adresseLivraison?: NullableStringFieldUpdateOperationsInput | string | null
    enregistrerParId?: NullableIntFieldUpdateOperationsInput | number | null
    statut?: EnumStatutCommandeFieldUpdateOperationsInput | $Enums.StatutCommande
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VenteCreateManyFournisseurInput = {
    id?: number
    statut?: $Enums.StatutVente
    typeAcheteur: $Enums.TypeClient
    clientId?: number | null
    agentId?: number | null
    panierId: number
    enregistrerPar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AchatCreateManyFournisseurInput = {
    id?: number
    statut?: $Enums.StatutAchat
    panierId: number
    agentId: number
    clientId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdresseCreateManyFournisseurInput = {
    id?: number
    ville?: string | null
    adresse: string
    isActive?: boolean
    agentId?: number | null
    clientId?: number | null
    entrepriseId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactCreateManyFournisseurInput = {
    id?: number
    tel: string
    isActive?: boolean
    agentId?: number | null
    clientId?: number | null
    entrepriseId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReservationCreateManyFournisseurInput = {
    id?: number
    dateLivraisonSouhaitee: Date | string
    adresseLivraison?: string | null
    statut?: $Enums.StatutReservation
    notes?: string | null
    typeClient?: $Enums.TypeClient
    clientId?: number | null
    panierId: number
    nom?: string | null
    tel?: string | null
    adresseId?: number | null
    contactId?: number | null
    enregistrerParId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommandeCreateManyFournisseurInput = {
    id?: number
    panierId: number
    clientId?: number | null
    nom?: string | null
    tel?: string | null
    type_client?: $Enums.TypeClient
    adresseId?: number | null
    contactId?: number | null
    commandeId?: number | null
    notes?: string | null
    dateLivraisonEffective?: Date | string | null
    adresseLivraison?: string | null
    enregistrerParId?: number | null
    statut?: $Enums.StatutCommande
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VenteUpdateWithoutFournisseurInput = {
    statut?: EnumStatutVenteFieldUpdateOperationsInput | $Enums.StatutVente
    typeAcheteur?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    enregistrerPar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    panier?: PanierUpdateOneRequiredWithoutVentesNestedInput
    agent?: AgentUpdateOneWithoutVentesNestedInput
    client?: ClientUpdateOneWithoutVentesNestedInput
    paiements?: PaiementUpdateManyWithoutVenteNestedInput
  }

  export type VenteUncheckedUpdateWithoutFournisseurInput = {
    id?: IntFieldUpdateOperationsInput | number
    statut?: EnumStatutVenteFieldUpdateOperationsInput | $Enums.StatutVente
    typeAcheteur?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    agentId?: NullableIntFieldUpdateOperationsInput | number | null
    panierId?: IntFieldUpdateOperationsInput | number
    enregistrerPar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paiements?: PaiementUncheckedUpdateManyWithoutVenteNestedInput
  }

  export type VenteUncheckedUpdateManyWithoutFournisseurInput = {
    id?: IntFieldUpdateOperationsInput | number
    statut?: EnumStatutVenteFieldUpdateOperationsInput | $Enums.StatutVente
    typeAcheteur?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    agentId?: NullableIntFieldUpdateOperationsInput | number | null
    panierId?: IntFieldUpdateOperationsInput | number
    enregistrerPar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchatUpdateWithoutFournisseurInput = {
    statut?: EnumStatutAchatFieldUpdateOperationsInput | $Enums.StatutAchat
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    panier?: PanierUpdateOneRequiredWithoutAchatsNestedInput
    agent?: AgentUpdateOneRequiredWithoutAchatsNestedInput
    Client?: ClientUpdateOneWithoutAchatsNestedInput
    paiements?: PaiementUpdateManyWithoutAchatNestedInput
  }

  export type AchatUncheckedUpdateWithoutFournisseurInput = {
    id?: IntFieldUpdateOperationsInput | number
    statut?: EnumStatutAchatFieldUpdateOperationsInput | $Enums.StatutAchat
    panierId?: IntFieldUpdateOperationsInput | number
    agentId?: IntFieldUpdateOperationsInput | number
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paiements?: PaiementUncheckedUpdateManyWithoutAchatNestedInput
  }

  export type AchatUncheckedUpdateManyWithoutFournisseurInput = {
    id?: IntFieldUpdateOperationsInput | number
    statut?: EnumStatutAchatFieldUpdateOperationsInput | $Enums.StatutAchat
    panierId?: IntFieldUpdateOperationsInput | number
    agentId?: IntFieldUpdateOperationsInput | number
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdresseUpdateWithoutFournisseurInput = {
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUpdateOneWithoutAdressesNestedInput
    entreprise?: EntrepriseUpdateOneWithoutAdresseNestedInput
    client?: ClientUpdateOneWithoutAdressesNestedInput
    reservations?: ReservationUpdateManyWithoutAdresseNestedInput
    commandes?: CommandeUpdateManyWithoutAdresseNestedInput
  }

  export type AdresseUncheckedUpdateWithoutFournisseurInput = {
    id?: IntFieldUpdateOperationsInput | number
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    agentId?: NullableIntFieldUpdateOperationsInput | number | null
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    entrepriseId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reservations?: ReservationUncheckedUpdateManyWithoutAdresseNestedInput
    commandes?: CommandeUncheckedUpdateManyWithoutAdresseNestedInput
  }

  export type AdresseUncheckedUpdateManyWithoutFournisseurInput = {
    id?: IntFieldUpdateOperationsInput | number
    ville?: NullableStringFieldUpdateOperationsInput | string | null
    adresse?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    agentId?: NullableIntFieldUpdateOperationsInput | number | null
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    entrepriseId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUpdateWithoutFournisseurInput = {
    tel?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entreprise?: EntrepriseUpdateOneWithoutContactNestedInput
    client?: ClientUpdateOneWithoutContactsNestedInput
    agent?: AgentUpdateOneWithoutContactsNestedInput
    reservations?: ReservationUpdateManyWithoutContactNestedInput
    commandes?: CommandeUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutFournisseurInput = {
    id?: IntFieldUpdateOperationsInput | number
    tel?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    agentId?: NullableIntFieldUpdateOperationsInput | number | null
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    entrepriseId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reservations?: ReservationUncheckedUpdateManyWithoutContactNestedInput
    commandes?: CommandeUncheckedUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateManyWithoutFournisseurInput = {
    id?: IntFieldUpdateOperationsInput | number
    tel?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    agentId?: NullableIntFieldUpdateOperationsInput | number | null
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    entrepriseId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReservationUpdateWithoutFournisseurInput = {
    dateLivraisonSouhaitee?: DateTimeFieldUpdateOperationsInput | Date | string
    adresseLivraison?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: EnumStatutReservationFieldUpdateOperationsInput | $Enums.StatutReservation
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    typeClient?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    enregistrerParId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    panier?: PanierUpdateOneRequiredWithoutReservationsNestedInput
    adresse?: AdresseUpdateOneWithoutReservationsNestedInput
    contact?: ContactUpdateOneWithoutReservationsNestedInput
    Client?: ClientUpdateOneWithoutReservationsNestedInput
  }

  export type ReservationUncheckedUpdateWithoutFournisseurInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateLivraisonSouhaitee?: DateTimeFieldUpdateOperationsInput | Date | string
    adresseLivraison?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: EnumStatutReservationFieldUpdateOperationsInput | $Enums.StatutReservation
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    typeClient?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    panierId?: IntFieldUpdateOperationsInput | number
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    adresseId?: NullableIntFieldUpdateOperationsInput | number | null
    contactId?: NullableIntFieldUpdateOperationsInput | number | null
    enregistrerParId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReservationUncheckedUpdateManyWithoutFournisseurInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateLivraisonSouhaitee?: DateTimeFieldUpdateOperationsInput | Date | string
    adresseLivraison?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: EnumStatutReservationFieldUpdateOperationsInput | $Enums.StatutReservation
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    typeClient?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    panierId?: IntFieldUpdateOperationsInput | number
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    adresseId?: NullableIntFieldUpdateOperationsInput | number | null
    contactId?: NullableIntFieldUpdateOperationsInput | number | null
    enregistrerParId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommandeUpdateWithoutFournisseurInput = {
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    type_client?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    commandeId?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    dateLivraisonEffective?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adresseLivraison?: NullableStringFieldUpdateOperationsInput | string | null
    enregistrerParId?: NullableIntFieldUpdateOperationsInput | number | null
    statut?: EnumStatutCommandeFieldUpdateOperationsInput | $Enums.StatutCommande
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Paiement?: PaiementUpdateManyWithoutCommandeNestedInput
    panier?: PanierUpdateOneRequiredWithoutCommandesNestedInput
    adresse?: AdresseUpdateOneWithoutCommandesNestedInput
    contact?: ContactUpdateOneWithoutCommandesNestedInput
    Client?: ClientUpdateOneWithoutCommandesNestedInput
  }

  export type CommandeUncheckedUpdateWithoutFournisseurInput = {
    id?: IntFieldUpdateOperationsInput | number
    panierId?: IntFieldUpdateOperationsInput | number
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    type_client?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    adresseId?: NullableIntFieldUpdateOperationsInput | number | null
    contactId?: NullableIntFieldUpdateOperationsInput | number | null
    commandeId?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    dateLivraisonEffective?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adresseLivraison?: NullableStringFieldUpdateOperationsInput | string | null
    enregistrerParId?: NullableIntFieldUpdateOperationsInput | number | null
    statut?: EnumStatutCommandeFieldUpdateOperationsInput | $Enums.StatutCommande
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Paiement?: PaiementUncheckedUpdateManyWithoutCommandeNestedInput
  }

  export type CommandeUncheckedUpdateManyWithoutFournisseurInput = {
    id?: IntFieldUpdateOperationsInput | number
    panierId?: IntFieldUpdateOperationsInput | number
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    type_client?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    adresseId?: NullableIntFieldUpdateOperationsInput | number | null
    contactId?: NullableIntFieldUpdateOperationsInput | number | null
    commandeId?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    dateLivraisonEffective?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adresseLivraison?: NullableStringFieldUpdateOperationsInput | string | null
    enregistrerParId?: NullableIntFieldUpdateOperationsInput | number | null
    statut?: EnumStatutCommandeFieldUpdateOperationsInput | $Enums.StatutCommande
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DetailPanierCreateManyProduitInput = {
    id?: number
    qtte: number
    modePaiement: $Enums.ModePaiment
    prixUnitaire: number
    prixTotalHT: number
    prixTotalTTC: number
    panierId: number
    deviseId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DetailPanierUpdateWithoutProduitInput = {
    qtte?: IntFieldUpdateOperationsInput | number
    modePaiement?: EnumModePaimentFieldUpdateOperationsInput | $Enums.ModePaiment
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    prixTotalHT?: FloatFieldUpdateOperationsInput | number
    prixTotalTTC?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    devise?: DeviseUpdateOneRequiredWithoutDetailPanierNestedInput
    panier?: PanierUpdateOneRequiredWithoutDetailPaniersNestedInput
  }

  export type DetailPanierUncheckedUpdateWithoutProduitInput = {
    id?: IntFieldUpdateOperationsInput | number
    qtte?: IntFieldUpdateOperationsInput | number
    modePaiement?: EnumModePaimentFieldUpdateOperationsInput | $Enums.ModePaiment
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    prixTotalHT?: FloatFieldUpdateOperationsInput | number
    prixTotalTTC?: FloatFieldUpdateOperationsInput | number
    panierId?: IntFieldUpdateOperationsInput | number
    deviseId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DetailPanierUncheckedUpdateManyWithoutProduitInput = {
    id?: IntFieldUpdateOperationsInput | number
    qtte?: IntFieldUpdateOperationsInput | number
    modePaiement?: EnumModePaimentFieldUpdateOperationsInput | $Enums.ModePaiment
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    prixTotalHT?: FloatFieldUpdateOperationsInput | number
    prixTotalTTC?: FloatFieldUpdateOperationsInput | number
    panierId?: IntFieldUpdateOperationsInput | number
    deviseId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MouvementCaisseCreateManyCaisseInput = {
    id?: number
    referenceExterne?: string | null
    type_mouvement?: $Enums.TypeMouvementCaisse
    categorie?: $Enums.CategorieMouvement
    moyen_paiement: $Enums.ModePaiment
    montant: number
    description?: string | null
    agentId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaiementCreateManyCaisseInput = {
    id?: number
    totalHT?: number | null
    totalTTC?: number | null
    modePaiement: $Enums.ModePaiment
    deviseId: number
    venteId?: number | null
    achatId?: number | null
    commandeId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MouvementCaisseUpdateWithoutCaisseInput = {
    referenceExterne?: NullableStringFieldUpdateOperationsInput | string | null
    type_mouvement?: EnumTypeMouvementCaisseFieldUpdateOperationsInput | $Enums.TypeMouvementCaisse
    categorie?: EnumCategorieMouvementFieldUpdateOperationsInput | $Enums.CategorieMouvement
    moyen_paiement?: EnumModePaimentFieldUpdateOperationsInput | $Enums.ModePaiment
    montant?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUpdateOneRequiredWithoutMouvementCaissesNestedInput
  }

  export type MouvementCaisseUncheckedUpdateWithoutCaisseInput = {
    id?: IntFieldUpdateOperationsInput | number
    referenceExterne?: NullableStringFieldUpdateOperationsInput | string | null
    type_mouvement?: EnumTypeMouvementCaisseFieldUpdateOperationsInput | $Enums.TypeMouvementCaisse
    categorie?: EnumCategorieMouvementFieldUpdateOperationsInput | $Enums.CategorieMouvement
    moyen_paiement?: EnumModePaimentFieldUpdateOperationsInput | $Enums.ModePaiment
    montant?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    agentId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MouvementCaisseUncheckedUpdateManyWithoutCaisseInput = {
    id?: IntFieldUpdateOperationsInput | number
    referenceExterne?: NullableStringFieldUpdateOperationsInput | string | null
    type_mouvement?: EnumTypeMouvementCaisseFieldUpdateOperationsInput | $Enums.TypeMouvementCaisse
    categorie?: EnumCategorieMouvementFieldUpdateOperationsInput | $Enums.CategorieMouvement
    moyen_paiement?: EnumModePaimentFieldUpdateOperationsInput | $Enums.ModePaiment
    montant?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    agentId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaiementUpdateWithoutCaisseInput = {
    totalHT?: NullableFloatFieldUpdateOperationsInput | number | null
    totalTTC?: NullableFloatFieldUpdateOperationsInput | number | null
    modePaiement?: EnumModePaimentFieldUpdateOperationsInput | $Enums.ModePaiment
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vente?: VenteUpdateOneWithoutPaiementsNestedInput
    achat?: AchatUpdateOneWithoutPaiementsNestedInput
    commande?: CommandeUpdateOneWithoutPaiementNestedInput
    devise?: DeviseUpdateOneRequiredWithoutPaiementsNestedInput
  }

  export type PaiementUncheckedUpdateWithoutCaisseInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalHT?: NullableFloatFieldUpdateOperationsInput | number | null
    totalTTC?: NullableFloatFieldUpdateOperationsInput | number | null
    modePaiement?: EnumModePaimentFieldUpdateOperationsInput | $Enums.ModePaiment
    deviseId?: IntFieldUpdateOperationsInput | number
    venteId?: NullableIntFieldUpdateOperationsInput | number | null
    achatId?: NullableIntFieldUpdateOperationsInput | number | null
    commandeId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaiementUncheckedUpdateManyWithoutCaisseInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalHT?: NullableFloatFieldUpdateOperationsInput | number | null
    totalTTC?: NullableFloatFieldUpdateOperationsInput | number | null
    modePaiement?: EnumModePaimentFieldUpdateOperationsInput | $Enums.ModePaiment
    deviseId?: IntFieldUpdateOperationsInput | number
    venteId?: NullableIntFieldUpdateOperationsInput | number | null
    achatId?: NullableIntFieldUpdateOperationsInput | number | null
    commandeId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaiementCreateManyVenteInput = {
    id?: number
    totalHT?: number | null
    totalTTC?: number | null
    modePaiement: $Enums.ModePaiment
    deviseId: number
    caisseId: number
    achatId?: number | null
    commandeId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaiementUpdateWithoutVenteInput = {
    totalHT?: NullableFloatFieldUpdateOperationsInput | number | null
    totalTTC?: NullableFloatFieldUpdateOperationsInput | number | null
    modePaiement?: EnumModePaimentFieldUpdateOperationsInput | $Enums.ModePaiment
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    achat?: AchatUpdateOneWithoutPaiementsNestedInput
    commande?: CommandeUpdateOneWithoutPaiementNestedInput
    caisse?: CaisseUpdateOneRequiredWithoutPaiementsNestedInput
    devise?: DeviseUpdateOneRequiredWithoutPaiementsNestedInput
  }

  export type PaiementUncheckedUpdateWithoutVenteInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalHT?: NullableFloatFieldUpdateOperationsInput | number | null
    totalTTC?: NullableFloatFieldUpdateOperationsInput | number | null
    modePaiement?: EnumModePaimentFieldUpdateOperationsInput | $Enums.ModePaiment
    deviseId?: IntFieldUpdateOperationsInput | number
    caisseId?: IntFieldUpdateOperationsInput | number
    achatId?: NullableIntFieldUpdateOperationsInput | number | null
    commandeId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaiementUncheckedUpdateManyWithoutVenteInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalHT?: NullableFloatFieldUpdateOperationsInput | number | null
    totalTTC?: NullableFloatFieldUpdateOperationsInput | number | null
    modePaiement?: EnumModePaimentFieldUpdateOperationsInput | $Enums.ModePaiment
    deviseId?: IntFieldUpdateOperationsInput | number
    caisseId?: IntFieldUpdateOperationsInput | number
    achatId?: NullableIntFieldUpdateOperationsInput | number | null
    commandeId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DetailPanierCreateManyPanierInput = {
    id?: number
    produitId: number
    qtte: number
    modePaiement: $Enums.ModePaiment
    prixUnitaire: number
    prixTotalHT: number
    prixTotalTTC: number
    deviseId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AchatCreateManyPanierInput = {
    id?: number
    statut?: $Enums.StatutAchat
    fournisseurId: number
    agentId: number
    clientId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VenteCreateManyPanierInput = {
    id?: number
    statut?: $Enums.StatutVente
    typeAcheteur: $Enums.TypeClient
    clientId?: number | null
    agentId?: number | null
    fournisseurId?: number | null
    enregistrerPar?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReservationCreateManyPanierInput = {
    id?: number
    dateLivraisonSouhaitee: Date | string
    adresseLivraison?: string | null
    statut?: $Enums.StatutReservation
    notes?: string | null
    typeClient?: $Enums.TypeClient
    clientId?: number | null
    nom?: string | null
    tel?: string | null
    adresseId?: number | null
    contactId?: number | null
    enregistrerParId?: number | null
    fournisseurId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommandeCreateManyPanierInput = {
    id?: number
    clientId?: number | null
    nom?: string | null
    tel?: string | null
    type_client?: $Enums.TypeClient
    adresseId?: number | null
    contactId?: number | null
    fournisseurId?: number | null
    commandeId?: number | null
    notes?: string | null
    dateLivraisonEffective?: Date | string | null
    adresseLivraison?: string | null
    enregistrerParId?: number | null
    statut?: $Enums.StatutCommande
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DetailPanierUpdateWithoutPanierInput = {
    qtte?: IntFieldUpdateOperationsInput | number
    modePaiement?: EnumModePaimentFieldUpdateOperationsInput | $Enums.ModePaiment
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    prixTotalHT?: FloatFieldUpdateOperationsInput | number
    prixTotalTTC?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    devise?: DeviseUpdateOneRequiredWithoutDetailPanierNestedInput
    produit?: ProduitUpdateOneRequiredWithoutDetailsPaniersNestedInput
  }

  export type DetailPanierUncheckedUpdateWithoutPanierInput = {
    id?: IntFieldUpdateOperationsInput | number
    produitId?: IntFieldUpdateOperationsInput | number
    qtte?: IntFieldUpdateOperationsInput | number
    modePaiement?: EnumModePaimentFieldUpdateOperationsInput | $Enums.ModePaiment
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    prixTotalHT?: FloatFieldUpdateOperationsInput | number
    prixTotalTTC?: FloatFieldUpdateOperationsInput | number
    deviseId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DetailPanierUncheckedUpdateManyWithoutPanierInput = {
    id?: IntFieldUpdateOperationsInput | number
    produitId?: IntFieldUpdateOperationsInput | number
    qtte?: IntFieldUpdateOperationsInput | number
    modePaiement?: EnumModePaimentFieldUpdateOperationsInput | $Enums.ModePaiment
    prixUnitaire?: FloatFieldUpdateOperationsInput | number
    prixTotalHT?: FloatFieldUpdateOperationsInput | number
    prixTotalTTC?: FloatFieldUpdateOperationsInput | number
    deviseId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchatUpdateWithoutPanierInput = {
    statut?: EnumStatutAchatFieldUpdateOperationsInput | $Enums.StatutAchat
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fournisseur?: FournisseurUpdateOneRequiredWithoutAchatsNestedInput
    agent?: AgentUpdateOneRequiredWithoutAchatsNestedInput
    Client?: ClientUpdateOneWithoutAchatsNestedInput
    paiements?: PaiementUpdateManyWithoutAchatNestedInput
  }

  export type AchatUncheckedUpdateWithoutPanierInput = {
    id?: IntFieldUpdateOperationsInput | number
    statut?: EnumStatutAchatFieldUpdateOperationsInput | $Enums.StatutAchat
    fournisseurId?: IntFieldUpdateOperationsInput | number
    agentId?: IntFieldUpdateOperationsInput | number
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paiements?: PaiementUncheckedUpdateManyWithoutAchatNestedInput
  }

  export type AchatUncheckedUpdateManyWithoutPanierInput = {
    id?: IntFieldUpdateOperationsInput | number
    statut?: EnumStatutAchatFieldUpdateOperationsInput | $Enums.StatutAchat
    fournisseurId?: IntFieldUpdateOperationsInput | number
    agentId?: IntFieldUpdateOperationsInput | number
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VenteUpdateWithoutPanierInput = {
    statut?: EnumStatutVenteFieldUpdateOperationsInput | $Enums.StatutVente
    typeAcheteur?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    enregistrerPar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUpdateOneWithoutVentesNestedInput
    fournisseur?: FournisseurUpdateOneWithoutVentesNestedInput
    client?: ClientUpdateOneWithoutVentesNestedInput
    paiements?: PaiementUpdateManyWithoutVenteNestedInput
  }

  export type VenteUncheckedUpdateWithoutPanierInput = {
    id?: IntFieldUpdateOperationsInput | number
    statut?: EnumStatutVenteFieldUpdateOperationsInput | $Enums.StatutVente
    typeAcheteur?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    agentId?: NullableIntFieldUpdateOperationsInput | number | null
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    enregistrerPar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paiements?: PaiementUncheckedUpdateManyWithoutVenteNestedInput
  }

  export type VenteUncheckedUpdateManyWithoutPanierInput = {
    id?: IntFieldUpdateOperationsInput | number
    statut?: EnumStatutVenteFieldUpdateOperationsInput | $Enums.StatutVente
    typeAcheteur?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    agentId?: NullableIntFieldUpdateOperationsInput | number | null
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    enregistrerPar?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReservationUpdateWithoutPanierInput = {
    dateLivraisonSouhaitee?: DateTimeFieldUpdateOperationsInput | Date | string
    adresseLivraison?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: EnumStatutReservationFieldUpdateOperationsInput | $Enums.StatutReservation
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    typeClient?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    enregistrerParId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fournisseur?: FournisseurUpdateOneWithoutReservationsNestedInput
    adresse?: AdresseUpdateOneWithoutReservationsNestedInput
    contact?: ContactUpdateOneWithoutReservationsNestedInput
    Client?: ClientUpdateOneWithoutReservationsNestedInput
  }

  export type ReservationUncheckedUpdateWithoutPanierInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateLivraisonSouhaitee?: DateTimeFieldUpdateOperationsInput | Date | string
    adresseLivraison?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: EnumStatutReservationFieldUpdateOperationsInput | $Enums.StatutReservation
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    typeClient?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    adresseId?: NullableIntFieldUpdateOperationsInput | number | null
    contactId?: NullableIntFieldUpdateOperationsInput | number | null
    enregistrerParId?: NullableIntFieldUpdateOperationsInput | number | null
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReservationUncheckedUpdateManyWithoutPanierInput = {
    id?: IntFieldUpdateOperationsInput | number
    dateLivraisonSouhaitee?: DateTimeFieldUpdateOperationsInput | Date | string
    adresseLivraison?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: EnumStatutReservationFieldUpdateOperationsInput | $Enums.StatutReservation
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    typeClient?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    adresseId?: NullableIntFieldUpdateOperationsInput | number | null
    contactId?: NullableIntFieldUpdateOperationsInput | number | null
    enregistrerParId?: NullableIntFieldUpdateOperationsInput | number | null
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommandeUpdateWithoutPanierInput = {
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    type_client?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    commandeId?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    dateLivraisonEffective?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adresseLivraison?: NullableStringFieldUpdateOperationsInput | string | null
    enregistrerParId?: NullableIntFieldUpdateOperationsInput | number | null
    statut?: EnumStatutCommandeFieldUpdateOperationsInput | $Enums.StatutCommande
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Paiement?: PaiementUpdateManyWithoutCommandeNestedInput
    fournisseur?: FournisseurUpdateOneWithoutCommandesNestedInput
    adresse?: AdresseUpdateOneWithoutCommandesNestedInput
    contact?: ContactUpdateOneWithoutCommandesNestedInput
    Client?: ClientUpdateOneWithoutCommandesNestedInput
  }

  export type CommandeUncheckedUpdateWithoutPanierInput = {
    id?: IntFieldUpdateOperationsInput | number
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    type_client?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    adresseId?: NullableIntFieldUpdateOperationsInput | number | null
    contactId?: NullableIntFieldUpdateOperationsInput | number | null
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    commandeId?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    dateLivraisonEffective?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adresseLivraison?: NullableStringFieldUpdateOperationsInput | string | null
    enregistrerParId?: NullableIntFieldUpdateOperationsInput | number | null
    statut?: EnumStatutCommandeFieldUpdateOperationsInput | $Enums.StatutCommande
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Paiement?: PaiementUncheckedUpdateManyWithoutCommandeNestedInput
  }

  export type CommandeUncheckedUpdateManyWithoutPanierInput = {
    id?: IntFieldUpdateOperationsInput | number
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    tel?: NullableStringFieldUpdateOperationsInput | string | null
    type_client?: EnumTypeClientFieldUpdateOperationsInput | $Enums.TypeClient
    adresseId?: NullableIntFieldUpdateOperationsInput | number | null
    contactId?: NullableIntFieldUpdateOperationsInput | number | null
    fournisseurId?: NullableIntFieldUpdateOperationsInput | number | null
    commandeId?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    dateLivraisonEffective?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adresseLivraison?: NullableStringFieldUpdateOperationsInput | string | null
    enregistrerParId?: NullableIntFieldUpdateOperationsInput | number | null
    statut?: EnumStatutCommandeFieldUpdateOperationsInput | $Enums.StatutCommande
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaiementCreateManyAchatInput = {
    id?: number
    totalHT?: number | null
    totalTTC?: number | null
    modePaiement: $Enums.ModePaiment
    deviseId: number
    caisseId: number
    venteId?: number | null
    commandeId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaiementUpdateWithoutAchatInput = {
    totalHT?: NullableFloatFieldUpdateOperationsInput | number | null
    totalTTC?: NullableFloatFieldUpdateOperationsInput | number | null
    modePaiement?: EnumModePaimentFieldUpdateOperationsInput | $Enums.ModePaiment
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vente?: VenteUpdateOneWithoutPaiementsNestedInput
    commande?: CommandeUpdateOneWithoutPaiementNestedInput
    caisse?: CaisseUpdateOneRequiredWithoutPaiementsNestedInput
    devise?: DeviseUpdateOneRequiredWithoutPaiementsNestedInput
  }

  export type PaiementUncheckedUpdateWithoutAchatInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalHT?: NullableFloatFieldUpdateOperationsInput | number | null
    totalTTC?: NullableFloatFieldUpdateOperationsInput | number | null
    modePaiement?: EnumModePaimentFieldUpdateOperationsInput | $Enums.ModePaiment
    deviseId?: IntFieldUpdateOperationsInput | number
    caisseId?: IntFieldUpdateOperationsInput | number
    venteId?: NullableIntFieldUpdateOperationsInput | number | null
    commandeId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaiementUncheckedUpdateManyWithoutAchatInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalHT?: NullableFloatFieldUpdateOperationsInput | number | null
    totalTTC?: NullableFloatFieldUpdateOperationsInput | number | null
    modePaiement?: EnumModePaimentFieldUpdateOperationsInput | $Enums.ModePaiment
    deviseId?: IntFieldUpdateOperationsInput | number
    caisseId?: IntFieldUpdateOperationsInput | number
    venteId?: NullableIntFieldUpdateOperationsInput | number | null
    commandeId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaiementCreateManyCommandeInput = {
    id?: number
    totalHT?: number | null
    totalTTC?: number | null
    modePaiement: $Enums.ModePaiment
    deviseId: number
    caisseId: number
    venteId?: number | null
    achatId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaiementUpdateWithoutCommandeInput = {
    totalHT?: NullableFloatFieldUpdateOperationsInput | number | null
    totalTTC?: NullableFloatFieldUpdateOperationsInput | number | null
    modePaiement?: EnumModePaimentFieldUpdateOperationsInput | $Enums.ModePaiment
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vente?: VenteUpdateOneWithoutPaiementsNestedInput
    achat?: AchatUpdateOneWithoutPaiementsNestedInput
    caisse?: CaisseUpdateOneRequiredWithoutPaiementsNestedInput
    devise?: DeviseUpdateOneRequiredWithoutPaiementsNestedInput
  }

  export type PaiementUncheckedUpdateWithoutCommandeInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalHT?: NullableFloatFieldUpdateOperationsInput | number | null
    totalTTC?: NullableFloatFieldUpdateOperationsInput | number | null
    modePaiement?: EnumModePaimentFieldUpdateOperationsInput | $Enums.ModePaiment
    deviseId?: IntFieldUpdateOperationsInput | number
    caisseId?: IntFieldUpdateOperationsInput | number
    venteId?: NullableIntFieldUpdateOperationsInput | number | null
    achatId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaiementUncheckedUpdateManyWithoutCommandeInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalHT?: NullableFloatFieldUpdateOperationsInput | number | null
    totalTTC?: NullableFloatFieldUpdateOperationsInput | number | null
    modePaiement?: EnumModePaimentFieldUpdateOperationsInput | $Enums.ModePaiment
    deviseId?: IntFieldUpdateOperationsInput | number
    caisseId?: IntFieldUpdateOperationsInput | number
    venteId?: NullableIntFieldUpdateOperationsInput | number | null
    achatId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}